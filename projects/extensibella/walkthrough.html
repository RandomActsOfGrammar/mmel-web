<html>
<head>
<title>Extensibella Walkthrough</title>
<link href="../style.css" rel="stylesheet" type="text/css">
<script src="../actions.js"></script>
<link rel="icon" href="images/favicon.png" type="image/x-icon">
</head>
<body class="extensibella">
<div id="header-logo">
<a href="index.html">
<img class="header-logo" src="images/Extensibella.png" alt="Extensibella logo">
</a>
</div>
<div class="section">
  <h1>Walkthrough</h1>
  <p>
    Extensibella is an interactive proof assistant that reasons about
    extensible languages built by separate modules.  Much of the
    reasoning will look familiar to those familiar
    with <a href="https://abella-prover.org">Abella</a>.
  </p>

  <p>
    This walkthrough of reasoning about an extensible language will
    use a language with three modules.  The <a href="#host">host
    language</a> is the simply-typed lambda calculus with numbers.
    There are two extensions to the host language, one
    adding <a href="#let">let bindings</a> and another
    adding <a href="#pair">pairs</a>.  The language is based on the
    language
    in <a href="https://dl.acm.org/doi/abs/10.1145/2837614.2837644">"Sound
    type-dependent syntactic language extension"</a>.  We will give
    <a href="../sterling/index.html">Sterling</a> specifications of
    the language about which we are reasoning.
  </p>
</div>

<div class="section" id="host">
  <h2>Host Language</h2>
  <p>
    Our host language is
    the <code class="sterling">walkthrough:host</code> module.  It
    defines syntax categories and constructors for terms
    (<code class="sterling">tm</code>) and types
    (<code class="sterling">ty</code>), as well as relations for
    evaluation and typing and rules defining them.
  </p>
  <a class="fold-link" href="javascript:void" id="togglehost.sos"
     onclick="toggleFile('host.sos')">[Shrink File]</a>
<pre class="code sterling" id="host.sos">
Module walkthrough:host

tm ::= var(string)
     | abs(string, ty, tm)
     | app(tm, tm)

Translation tm : [(string, ty)]

ty ::= arrowTy(ty, ty)
     | intTy

Translation ty :



Judgment eval : tm* tm
Judgment subst : string tm tm* tm
Judgment value : tm*

eval T1 T11
----------------------------- [E-App-Step1]
eval app(T1, T2) app(T11, T2)


value T1
eval T2 T21
----------------------------- [E-App-Step2]
eval app(T1, T2) app(T1, T21)


value T2
subst X T2 Body V
-------------------------------- [E-App-Subst]
eval app(abs(X, Ty, Body), T2) V



X != Y
----------------------- [S-Var-NEq]
subst X R var(Y) var(Y)


------------------ [S-Var-Eq]
subst X R var(X) R


X != Y
subst X R B S
------------------------------------- [S-Abs-NEq]
subst X R abs(Y, Ty, B) abs(Y, Ty, S)


------------------------------------- [S-Abs-Eq]
subst X R abs(X, Ty, B) abs(X, Ty, B)


subst X R T1 S1
subst X R T2 S2
--------------------------------- [S-App]
subst X R app(T1, T2) app(S1, S2)



------------------- [V-Abs]
value abs(X, Ty, T)



Judgment typeOf : [(string, ty)] tm* ty

lookup Ctx X Ty
-------------------- [T-Var]
typeOf Ctx var(X) Ty


typeOf (X, Ty1)::Ctx Body Ty2
---------------------------------------------- [T-Abs]
typeOf Ctx abs(X, Ty1, Body) arrowTy(Ty1, Ty2)


typeOf Ctx T1 arrowTy(Ty1, Ty2)
typeOf Ctx T2 Ty1
------------------------------- [T-App]
typeOf Ctx app(T1, T2) Ty2
</pre>

  <p>
    Once this module has been compiled for Extensibella using
    Sterling, we can load it in Extensibella to reason about it:
  </p>
  <pre class="code extensibella">
 < <b>Module walkthrough:host.</b> </pre>
  <p>
    We will show how we prove type preservation here.  Our proof of
    type preservation will rely on a property about substitution, that
    it maintains types:
  </p>
  <pre class="code extensibella">
subst_type_preservation : forall T Ctx X XTy Ty R S,
   typeOf ((X, XTy)::Ctx) T Ty -> subst X R T S -> typeOf [] R XTy -> typeOf Ctx S Ty </pre>
  <p>
    We omit the proof of this fact here, moving directly to type
    preservation.  We will prove type preservation by considering the
    rules for evaluating a term.  As new rules defining evaluation may
    be added by extensions, type preservation must be an extensible
    theorem.  This will require each extension to prove the property
    for the new rules it introduces.
  </p>
  <p>
    We state our type preservation property as if a term is typable
    with an empty typing context and it takes an evaluation step to
    <code>T'</code>, then <code>T'</code> has the same type.  We give
    each assumption a name we will use to refer to it in the proof.
    The clause <code class="extensibella">on Ev</code> declares we
    will prove the property by induction on the derivation of
    evaluation, and by considering the last rule by which the
    evaluation might have been derived:
  </p>
  <pre class="code extensibella">
 < <b>Extensible_Theorem</b>
     <b>type_preservation : forall T Ty T',</b>
       <b>Ty : typeOf [] T Ty -></b>
       <b>Ev : eval T T' -></b>
       <b>typeOf [] T' Ty</b>
     <b>on Ev.</b>
Subgoal 1:

Variables: Ty T2 T11 T1
IH : forall T Ty T', typeOf [] T Ty -> eval T T' * -> typeOf [] T' Ty
Ty : typeOf [] (app T1 T2) Ty
Ev : eval (app T1 T2) (app T11 T2) @
Ev1 : eval T1 T11 *
============================
 typeOf [] (app T11 T2) Ty </pre>
  <p>
    After declaring the property, we are immediately dropped into the
    case for the first rule, which here is
    the <code>E-App-Step1</code> rule.  Before going into how we prove
    this case, consider our induction scheme.  Note we have the
    inductive hypothesis in the context, using the
    name <code>IH</code>, in addition to the <code>Ty</code>
    and <code>Ev</code> assumptions from our declared property.  The
    second premise of <code>IH</code>, corresponding
    to <code>Ev</code> in our original statement, is marked with
    the <code>*</code> annotation, while the <code>Ev</code>
    assumption is marked with the <code>@</code> assumption.
    The <code>@</code> annotation denotes this is the size of
    derivation with which we started, while the <code>*</code>
    annotation denotes a smaller derivation.  Thus the inductive
    hypothesis can only be used with derivations marked as smaller.
    We get smaller derivations by case analysis on derivations
    annotated with <code>@</code> or <code>*</code>.  We see this
    in <code>Ev1</code>, coming from the top-level case analysis on
    the rules deriving <code>Ev</code>.
  </p>
  <p>
    In this case, for rule <code>E-App-Step1</code>, we evaluate the
    application by evaluating the first sub-term.  The evaluation of
    the sub-term is smaller, so we can use it with the inductive
    hypothesis, but first we need a relevant typing derivation.  The
    top-level case analysis on <code>Ev</code> filled in the primary
    component of <code>Ty</code>, so we can analyze the rules by which
    this may have been derived using
    the <code class="extensibella">case</code> tactic:
  </p>
  <pre class="code extensibella">
 < <b>Ty: case Ty.</b>
Subgoal 1:

Variables: Ty T2 T11 T1 Ty1
IH : forall T Ty T', typeOf [] T Ty -> eval T T' * -> typeOf [] T' Ty
Ev : eval (app T1 T2) (app T11 T2) @
Ev1 : eval T1 T11 *
Ty : typeOf [] T1 (arrowTy Ty1 Ty)
Ty1 : typeOf [] T2 Ty1
============================
 typeOf [] (app T11 T2) Ty </pre>
  <p>
    The case analysis gives us typing judgments for
    both <code>T1</code> and <code>T2</code>.  We can now use the
    <code class="extensibella">apply</code> tactic to use the
    inductive hypothesis to get a typing judgment for the result:
  </p>
  <pre class="code extensibella">
 < <b>apply IH to Ty Ev1.</b>
Subgoal 1:

Variables: Ty T2 T11 T1 Ty1
IH : forall T Ty T', typeOf [] T Ty -> eval T T' * -> typeOf [] T' Ty
Ev : eval (app T1 T2) (app T11 T2) @
Ev1 : eval T1 T11 *
Ty : typeOf [] T1 (arrowTy Ty1 Ty)
Ty1 : typeOf [] T2 Ty1
H1 : typeOf [] T11 (arrowTy Ty1 Ty)
============================
 typeOf [] (app T11 T2) Ty </pre>
  <p>
    The <code>T-App</code> rule now applies to <code>H1</code>
    and <code>Ty1</code>.  Extensibella will automatically apply this
    rule when we use the <code class="extensibella">search</code>
    tactic, finishing this case and moving to the next one:
  </p>
  <pre class="code extensibella">
 < <b>search.</b>
Subgoal 2:

Variables: Ty T21 T1 T2
IH : forall T Ty T', typeOf [] T Ty -> eval T T' * -> typeOf [] T' Ty
Ty : typeOf [] (app T1 T2) Ty
Ev : eval (app T1 T2) (app T1 T21) @
Ev1 : value T1
Ev2 : eval T2 T21 *
============================
 typeOf [] (app T1 T21) Ty </pre>
  <p>
    The next case, for rule <code>E-App-Step2</code>, is similar to
    the first case and can be completed with the following three
    commands (note if you are following along that each must be
    entered individually on the Extensibella command line):
  </p>
  <pre class="code extensibella">
<b>Ty: case Ty. apply IH to Ty1 Ev2. search.</b> </pre>
  <p>
    This brings us to the last case in the host language, that for
    the <code>E-App-Subst</code>:
  </p>
  <pre class="code extensibella">
Subgoal 3:

Variables: Ty T' T2 Body Ty1 X
IH : forall T Ty T', typeOf [] T Ty -> eval T T' * -> typeOf [] T' Ty
Ty : typeOf [] (app (abs X Ty1 Body) T2) Ty
Ev : eval (app (abs X Ty1 Body) T2) T' @
Ev1 : value T2
Ev2 : subst X T2 Body T'
============================
 typeOf [] T' Ty </pre>
  <p>
    We want to use the <code>subst_type_preservation</code> theorem we
    would have proven earlier.  To do so, we will need a derivation of
    typing for <code>Body</code>.  First, we analyze the derivation of
    typing again:
  </p>
  <pre class="code extensibella">
 < <b>Ty: case Ty.</b>
Subgoal 3:

Variables: Ty T' T2 Body Ty1 X Ty2
IH : forall T Ty T', typeOf [] T Ty -> eval T T' * -> typeOf [] T' Ty
Ev : eval (app (abs X Ty1 Body) T2) T' @
Ev1 : value T2
Ev2 : subst X T2 Body T'
Ty : typeOf [] (abs X Ty1 Body) (arrowTy Ty2 Ty)
Ty1 : typeOf [] T2 Ty2
============================
 typeOf [] T' Ty </pre>
  <p>
    This does not give us a derivation of typing for <code>Body</code>
    directly, but it gives us a derivation of typing for the full
    abstraction.  Analyzing this again gives us the typing derivation
    we need:
  </p>
  <pre class="code extensibella">
 < <b>Ty: case Ty.</b>
Subgoal 3:

Variables: Ty T' T2 Body X Ty2
IH : forall T Ty T', typeOf [] T Ty -> eval T T' * -> typeOf [] T' Ty
Ev : eval (app (abs X Ty2 Body) T2) T' @
Ev1 : value T2
Ev2 : subst X T2 Body T'
Ty1 : typeOf [] T2 Ty2
Ty : typeOf [(X, Ty2)] Body Ty
============================
 typeOf [] T' Ty </pre>
  <p>
    We can now use the <code class="extensibella">apply</code> tactic
    to apply the <code>subst_type_preservation</code> lemma:
  </p>
  <pre class="code extensibella">
 < <b>apply subst_type_preservation to Ty Ev2 Ty1.</b>
Subgoal 3:

Variables: Ty T' T2 Body X Ty2
IH : forall T Ty T', typeOf [] T Ty -> eval T T' * -> typeOf [] T' Ty
Ev : eval (app (abs X Ty2 Body) T2) T' @
Ev1 : value T2
Ev2 : subst X T2 Body T'
Ty1 : typeOf [] T2 Ty2
Ty : typeOf [(X, Ty2)] Body Ty
H1 : typeOf [] T' Ty
============================
 typeOf [] T' Ty </pre>
  <p>
    This gives us the exact same formula as our goal as an assumption.
    The <code>search</code> tactic will find this and solve the goal,
    and, as it is the last goal, the full proof as well.
  </p>
  <pre class="code extensibella">
 < <b>search.</b>
Proof completed. </pre>
  <p>
    In order to continue to prove properties for the extensions, the
    development for the host language must be saved in a file and
    compiled.
  </p>

</div>

<div class="section" id="let">
  <h3>Let Extension</h3>
  <p>
    Our first extension adds new form for terms,
    a <code>let</code>-binding, and defines the relations introduced
    by the host language for the new form.
  </p>

  <a class="fold-link" href="javascript:void" id="togglelet.sos"
     onclick="toggleFile('let.sos')">[Shrink File]</a>
<pre class="code sterling" id="let.sos">
Module walkthrough:let

Builds on walkthrough:host

tm ::= ...
     | let(string, tm, tm)


typeOf Ctx T1 Ty
----------------------------------------------------- [Trans-Let]
Ctx |{tm}- let(X, T1, T2) ~~> app(abs(X, Ty, T2), T1)



eval T1 T11
----------------------------------- [E-Let-Step]
eval let(X, T1, T2) let(X, T11, T2)


value T1
subst X T1 T2 V
--------------------- [E-Let-Subst]
eval let(X, T1, T2) V



X != Y
subst X R T1 S1
subst X R T2 S2
--------------------------------------- [S-Let-NEq]
subst X R let(Y, T1, T2) let(Y, S1, S2)


subst X R T1 S1
--------------------------------------- [S-Let-Eq]
subst X R let(X, T1, T2) let(X, S1, T2)



typeOf Ctx T1 Ty1
typeOf (X, Ty1)::Ctx T2 Ty2
----------------------------- [T-Let]
typeOf Ctx let(X, T1, T2) Ty2
</pre>

  <p>
    Once this module has been compiled for Extensibella using
    Sterling, we can load it in Extensibella to reason about it:
  </p>
  <pre class="code extensibella">
 < <b>Module walkthrough:let.</b> </pre>
  <p>
    This loads in the definition of the <code>walkthrough:let</code>
    module, including the definition of
    the <code>walkthrough:host</code> module on which it builds.
    Extensibella knows about this builds-on relation, so this
    reasoning module is required to prove the host language's
    properties for the new cases it introduces.  When it is ready to
    prove the type preservation property, it declares so with
    a <code class="extensibella">Prove</code> declaration:
  </p>
  <pre class="code extensibella">
 < <b>Prove walkthrough:host:type_preservation.</b>
Subgoal 7:

Variables: Ty T2 T11 X T1
IH : forall T Ty T', typeOf [] T Ty -> eval T T' * -> typeOf [] T' Ty
Ty : typeOf [] (let X T1 T2) Ty
Ev : eval (let X T1 T2) (let X T11 T2) @
Ev1 : eval T1 T11 *
============================
 typeOf [] (let X T11 T2) Ty </pre>
  <p>
    This drops us into the first case for when <code>Ev</code> is
    derived using a rule introduced by this extension, specifically
    the <code>E-Let-Step</code> rule.  This can be solved by a
    sequence of tactics similar to those for
    the <code>E-App-Step1</code> and <code>E-App-Step2</code> rules in
    the host language:
  </p>
  <pre class="code extensibella">
<b>Ty: case Ty. apply IH to Ty Ev1. search.</b> </pre>
  <p>
    This brings us to the case for the <code>E-Let-Subst</code>:
  </p>
  <pre class="code extensibella">
Subgoal 8:

Variables: Ty T' T2 T1 X
IH : forall T Ty T', typeOf [] T Ty -> eval T T' * -> typeOf [] T' Ty
Ty : typeOf [] (let X T1 T2) Ty
Ev : eval (let X T1 T2) T' @
Ev1 : value T1
Ev2 : subst X T1 T2 T'
============================
 typeOf [] T' Ty </pre>
  <p>
    This is similar to the case for the <code>E-App-Subst</code> rule
    from the host language and can be solved by a similar chain of
    tactics:
  </p>
  <pre class="code extensibella">
<b>Ty: case Ty. apply subst_type_preservation to Ty1 Ev2 Ty. search.</b> </pre>
</div>

</body>
</html>
