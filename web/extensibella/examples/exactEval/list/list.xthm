Module exactEval:list.

/********************************************************************
 Basic Projection Constraints
 ********************************************************************/
Prove_Constraint exactEval:host:proj_expr_unique.
%Proj-Nil
 case PrB. search.
%Proj-Cons
 case PrB. search.
%Proj-Head
 case PrB. search.
%Proj-Tail
 case PrB. search.
%Proj-Null
 case PrB. search.
%Proj-Index
 PrB: case PrB. apply fresh_name_unique_mems to PrA1 PrB _ _.
 apply fresh_name_unique_mems to PrA2 PrB1 _ _. search.
%Proj-Length
 PrB: case PrB. apply fresh_name_unique_mems to PrA1 PrB _ _.
 apply fresh_name_unique_mems to PrA2 PrB1 _ _. search.
Prove_Constraint exactEval:host:proj_expr_is.
%Proj-Nil
 case IsE. search 8.
%Proj-Cons
 case IsE. search 10.
%Proj-Head
 case IsE. search 7.
%Proj-Tail
 case IsE. search 7.
%Proj-Null
 case IsE. search 7.
%Proj-Index
 case IsE. apply fresh_name_is to _ Pr1. apply fresh_name_is to _ Pr2.
 search 20.
%Proj-Length
 case IsE. apply fresh_name_is to _ Pr1. apply fresh_name_is to _ Pr2.
 search 13.
Prove_Constraint exactEval:host:proj_expr_other.
%Proj-Nil
 search.
%Proj-Cons
 search.
%Proj-Head
 search.
%Proj-Tail
 search.
%Proj-Null
 search.
%Proj-Index
 apply fresh_name_exists to _ IsL' with Base = "I".
 apply fresh_name_exists to _ IsL' with Base = "L". search.
%Proj-Length
 apply fresh_name_exists to _ IsL' with Base = "L".
 apply fresh_name_exists to _ IsL' with Base = "Len". search.

Prove_Constraint exactEval:host:proj_stmt_unique.
%Proj-ListUpdate
 PrB: case PrB.
 assert forall X, mem X (L::L2) -> mem X (L::L1).
   intros M. M: case M. search. apply Rel21 to M. search.
 assert forall X, mem X (L::L1) -> mem X (L::L2).
   intros M. M: case M. search. apply Rel12 to M. search.
 apply fresh_name_unique_mems to PrA1 PrB _ _.
 apply fresh_name_unique_mems to PrA2 PrB1 _ _.
 apply fresh_name_unique_mems to PrA3 PrB2 _ _.
 apply fresh_name_unique_mems to PrA4 PrB3 _ _. search.
%Proj-ListForeach
 PrB: case PrB. apply fresh_name_unique_mems to PrA1 PrB _ _.
   intros M. M: case M. search. apply Rel21 to M. search.
   intros M. M: case M. search. apply Rel12 to M. search.
 search.
Prove_Constraint exactEval:host:proj_stmt_is.
%Proj-ListUpdate
 case IsS. apply fresh_name_is to _ Pr1.
 assert is_string "Hold". search 6.
 apply fresh_name_is to _ Pr2. apply fresh_name_is to _ Pr3.
 apply fresh_name_is to _ Pr4. search 30.
%Proj-ListForeach
 case IsS. apply fresh_name_is to _ Pr1. search 20.
Prove_Constraint exactEval:host:proj_stmt_other.
%Proj-ListUpdate
 case IsS. Is': assert is_list is_string (L1::L').
 apply fresh_name_exists to _ Is' with Base = "I".
 apply fresh_name_exists to _ Is' with Base = "Hold". search 6.
 apply fresh_name_exists to _ Is' with Base = "E".
 apply fresh_name_exists to _ Is' with Base = "C". search.
%Proj-ListForeach
 case IsS. Is': assert is_list is_string (X::L').
 apply fresh_name_exists to _ Is' with Base = "L". search.

Prove_Constraint exactEval:host:proj_fun_unique.
Prove_Constraint exactEval:host:proj_fun_is.

Prove_Constraint exactEval:host:proj_param_unique.
Prove_Constraint exactEval:host:proj_param_is.

Prove_Constraint exactEval:host:proj_program_unique.
Prove_Constraint exactEval:host:proj_program_is.

Prove_Constraint exactEval:host:proj_typ_unique.
%Proj-ListTy
 case PrB. search.
Prove_Constraint exactEval:host:proj_typ_is.
%Proj-ListTy
 case IsT. search 11.




/********************************************************************
 Decidable Equality
 ********************************************************************/
Add_Proj_Rel exactEval:host:is_expr,
             exactEval:host:is_args,
             exactEval:host:is_recFieldExprs,
             exactEval:host:is_stmt.

Prove_Ext_Ind exactEval:host:is_expr,
              exactEval:host:is_args,
              exactEval:host:is_recFieldExprs,
              exactEval:host:is_stmt.
%is_expr
 %nil
  search 10.
 %cons
  apply IH to R1. apply IH to R2. search 20.
 %head
  apply IH to R1. search 10.
 %tail
  apply IH to R1. search 10.
 %null
  apply IH to R1. search 10.
 %index
  apply IH to R1. apply IH to R2.
  apply fresh_name_exists to _ _ with Base = "I", Names = [].
  apply fresh_name_exists to _ _ with Base = "L", Names = [].
  search 20.
 %length
  apply IH to R1.
  apply fresh_name_exists to _ _ with Base = "L", Names = [].
  apply fresh_name_exists to _ _ with Base = "Len", Names = [].
  search 20.
%is_stmt
 %listUpdate
  apply IH to R2. apply IH to R3.
  FrI: apply fresh_name_exists to _ _ with Base = "I", Names = [S1].
  FrH: apply fresh_name_exists to _ _ with
         Base = "Hold", Names = [S1]. search 7.
  FrE: apply fresh_name_exists to _ _ with Base = "E", Names = [S1].
  FrC: apply fresh_name_exists to _ _ with Base = "C", Names = [S1].
  apply fresh_name_is to _ FrI. rename F to SaveI.
  apply fresh_name_is to _ FrH. search 7. rename F1 to Hold.
  apply fresh_name_is to _ FrE. rename F2 to SaveE.
  apply fresh_name_is to _ FrC. rename F3 to Copy.
  rename Expr1 to I. rename Expr to E.
  assert [] |{stmt}- listUpdate S1 I E ~~>
   scopeStmt
      (seq (declare intTy SaveI I)
      (seq (declare intTy SaveE E)
      (seq (assign SaveI (name SaveI))
      (seq (declare intTy Hold (exactEval:list:nil intTy))
      (seq (while (exactEval:host:and
                      (not (eq (name SaveI) (num 0)))
                      (not (null (name S1))))
                (seq (assign SaveI (minus (name SaveI) (num 1)))
                (seq (declare intTy Copy (name S1))
                (seq (recUpdate Copy ["tail"] (name Hold))
                (seq (assign Hold (name Copy))
                     (assign S1 (tail (name S1))))))))
      (seq (ifThenElse (null (name S1))
               (declare intTy Copy
                   (errorExpr (stringLit "Invalid update") intTy))
               noop)
      (seq (recUpdate S1 ["head"] (name SaveE))
           (while (not (null (name Hold)))
                (seq (declare intTy Copy (name Hold))
                (seq (recUpdate Copy ["tail"] (name S1))
                (seq (assign S1 (name Copy))
                     (assign Hold (tail (name Hold)))))))))))))).
  unfold. exists [],
   scopeStmt
      (seq (declare intTy SaveI I)
      (seq (declare intTy SaveE E)
      (seq (assign SaveI (name SaveI))
      (seq (declare intTy Hold (exactEval:list:nil intTy))
      (seq (while (exactEval:host:and
                      (not (eq (name SaveI) (num 0)))
                      (not (null (name S1))))
              (seq (assign SaveI (minus (name SaveI) (num 1)))
              (seq (declare intTy Copy (name S1))
              (seq (recUpdate Copy ["tail"] (name Hold))
              (seq (assign Hold (name Copy))
                   (assign S1 (tail (name S1))))))))
      (seq (ifThenElse (null (name S1))
              (declare intTy Copy
                  (errorExpr (stringLit "Invalid update") intTy))
              noop)
      (seq (recUpdate S1 ["head"] (name SaveE))
           (while (not (null (name Hold)))
              (seq (declare intTy Copy (name Hold))
              (seq (recUpdate Copy ["tail"] (name S1))
              (seq (assign S1 (name Copy))
                   (assign Hold (tail (name Hold)))))))))))))). split.
    %is_string S1
     search.
    %is_expr_P I
     search.
    %is_expr_P E
     search.
    %proj
     search.
    %is proj
     search 30.
 %listForeach
  apply IH to R2. apply IH3 to R3.
  Fr: apply fresh_name_exists to _ _ with Base = "L", Names = [S1].
  apply fresh_name_is to _ Fr. search 20.

Prove exactEval:host:is_args_nilArgs_or_consArgs.
Prove exactEval:host:is_recFieldExprs_nilRecFieldExprs_or_consRecFieldExprs.




/********************************************************************
 Variables
 ********************************************************************/
Prove exactEval:host:vars_unique.
%V-Nil
 case VarsB. search.
%V-Cons
 case IsE. VarsB: case VarsB. apply IH to _ VarsA1 VarsB.
 apply IH to _ VarsA2 VarsB1. apply append_unique to VarsA3 VarsB2.
 search.
%V-Head
 case IsE. VarsB: case VarsB. apply IH to _ VarsA1 VarsB. search.
%V-Tail
 case IsE. VarsB: case VarsB. apply IH to _ VarsA1 VarsB. search.
%V-Null
 case IsE. VarsB: case VarsB. apply IH to _ VarsA1 VarsB. search.
%V-Index
 case IsE. VarsB: case VarsB. apply IH to _ VarsA1 VarsB.
 apply IH to _ VarsA2 VarsB1. apply append_unique to VarsA3 VarsB2.
 search.
%V-Length
 case IsE. VarsB: case VarsB. apply IH to _ VarsA1 VarsB. search.

Prove exactEval:host:vars_is.
%V-Nil
 search.
%V-Cons
 case IsE. apply IH to _ V1. apply IH to _ V2.
 apply append_list_string_is to _ _ V3. search.
%V-Head
 case IsE. apply IH to _ V1. search.
%V-Tail
 case IsE. apply IH to _ V1. search.
%V-Null
 case IsE. apply IH to _ V1. search.
%V-Index
 case IsE. apply IH to _ V1. apply IH to _ V2.
 apply append_list_string_is to _ _ V3. search.
%V-Length
 case IsE. apply IH to _ V1. search.


Prove exactEval:host:vars_exist,
      exactEval:host:varsArgs_exist,
      exactEval:host:varsRecFields_exist.
%vars_exist
 %nil
  search.
 %cons
  V1: apply IH to IsE1. V2: apply IH to IsE2.
  IsV1: apply vars_is to _ V1. IsV2: apply vars_is to _ V2.
  apply append_list_string_total to IsV1 IsV2. search.
 %head
  apply IH to IsE1. search.
 %tail
  apply IH to IsE1. search.
 %null
  apply IH to IsE1. search.
 %index
  V1: apply IH to IsE1. V2: apply IH to IsE2.
  IsV1: apply vars_is to _ V1. IsV2: apply vars_is to _ V2.
  apply append_list_string_total to IsV1 IsV2. search.
 %length
  apply IH to IsE1. search.




/********************************************************************
 Statement Names
 ********************************************************************/
Prove exactEval:host:stmtNames_is,
      exactEval:host:stmtNames_isCtx,
      exactEval:host:exprNames_is.
%stmtNames_is
 %SN-ListUpdate-Ignore
  case IsS. apply IH_E to _ _ SN2. apply IH_E to _ _ SN3.
  apply append_list_string_is to _ _ SN4. search.
 %SN-ListUpdate-Take
  case IsS. apply IH_E to _ _ SN2. apply IH_E to _ _ SN3.
  apply append_list_string_is to _ _ SN4. search.
 %SN-ListForeach
  case IsS. apply IH_E to _ _ SN1. apply IH_S to _ _ SN2.
  apply append_list_string_is to _ _ SN3. search.
%stmtNames_isCtx
 %SN-ListUpdate-Ignore
  case IsS. apply IH_E to _ _ SN2. apply IH_E to _ _ SN3. search.
 %SN-ListUpdate-Take
  case IsS. search.
 %SN-ListForeach
  search.
%exprNames_is
 %EN-Nil
  search.
 %EN-Cons
  case IsE. apply IH_E to _ _ EN1. apply IH_E to _ _ EN2.
  apply append_list_string_is to _ _ EN3. search.
 %EN-Head
  case IsE. apply IH_E to _ _ EN1. search.
 %EN-Tail
  case IsE. apply IH_E to _ _ EN1. search.
 %EN-Null
  case IsE. apply IH_E to _ _ EN1. search.
 %EN-Index
  case IsE. apply IH_E to _ _ EN1. apply IH_E to _ _ EN2.
  apply append_list_string_is to _ _ EN3. search.
 %EN-Length
  case IsE. apply IH_E to _ _ EN1. search.


Prove exactEval:host:stmtNames_unique,
      exactEval:host:exprNames_unique.
%stmtNames_unique
 %SN-ListUpdate-Ignore
  case IsS. SNB: case SNB.
    %SN-ListUpdate-Ignore
     apply IH_E to _ _ SNA2 SNB1. apply IH_E to _ _ SNA3 SNB2.
     apply append_unique to SNA4 SNB3. search.
    %SN-ListUpdate-Take
     apply not_mems to SNB SNA1.
 %SN-ListUpdate-Take
  case IsS. SNB: case SNB.
    %SN-ListUpdate-Ignore
     apply not_mems to SNA1 SNB.
    %SN-ListUpdate-Take
     apply IH_E to _ _ SNA2 SNB1. apply IH_E to _ _ SNA3 SNB2.
     apply append_unique to SNA4 SNB3. search.
 %SN-ListForeach
  case IsS. SNB: case SNB. apply IH_E to _ _ SNA1 SNB.
  apply IH_S to _ _ SNA2 SNB1. apply append_unique to SNA3 SNB2.
  search.
%exprNames_unique
 %EN-Nil
  case ENB. search.
 %EN-Cons
  case IsE. ENB: case ENB. apply IH_E to _ _ ENA1 ENB.
  apply IH_E to _ _ ENA2 ENB1. apply append_unique to ENA3 ENB2.
  search.
 %EN-Head
  case IsE. ENB: case ENB. apply IH_E to _ _ ENA1 ENB. search.
 %EN-Tail
  case IsE. ENB: case ENB. apply IH_E to _ _ ENA1 ENB. search.
 %EN-Null
  case IsE. ENB: case ENB. apply IH_E to _ _ ENA1 ENB. search.
 %EN-Index
  case IsE. ENB: case ENB. apply IH_E to _ _ ENA1 ENB.
  apply IH_E to _ _ ENA2 ENB1. apply append_unique to ENA3 ENB2.
  search.
 %EN-Length
  case IsE. ENB: case ENB. apply IH_E to _ _ ENA1 ENB. search.


Prove exactEval:host:stmtNames_keep_older.
%SN-ListUpdate-Ignore
 search.
%SN-ListUpdate-Take
 search.
%SN-ListForeach
 search.


Prove exactEval:host:stmtNames_exists,
      exactEval:host:exprNames_exists,
      exactEval:host:argsNames_exists,
      exactEval:host:recFieldNames_exists.
%stmtNames_exists
 %listUpdate
  EN1: apply IH_E to IsS2 IsCtx. EN2: apply IH_E to IsS3 IsCtx.
  Is1: apply exprNames_is to _ _ EN1.
  Is2: apply exprNames_is to _ _ EN2.
  apply append_list_string_total to Is1 Is2.
  Or: apply mems_or_not_mems to IsCtx IsS1. M: case Or.
    %mems S1 (Scope::Ctx)
     search.
    %not_mems S1 (Scope::Ctx)
     search.
 %SN-ListForeach
  EN: apply IH_E to IsS2 IsCtx.
  SN: apply IH_S to IsS3 _ with Ctx = Scope::Ctx, Scope = [S1].
  Is1: apply exprNames_is to _ _ EN.
  Is2: apply stmtNames_is to _ _ SN.
  apply append_list_string_total to Is1 Is2. search.
%exprNames_exists
 %nil
  search.
 %cons
  EN1: apply IH_E to IsE1 IsCtx. EN2: apply IH_E to IsE2 IsCtx.
  Is1: apply exprNames_is to _ _ EN1.
  Is2: apply exprNames_is to _ _ EN2.
  apply append_list_string_total to Is1 Is2. search.
 %head
  apply IH_E to IsE1 IsCtx. search.
 %tail
  apply IH_E to IsE1 IsCtx. search.
 %null
  apply IH_E to IsE1 IsCtx. search.
 %index
  EN1: apply IH_E to IsE1 IsCtx. EN2: apply IH_E to IsE2 IsCtx.
  Is1: apply exprNames_is to _ _ EN1.
  Is2: apply exprNames_is to _ _ EN2.
  apply append_list_string_total to Is1 Is2. search.
 %length
  apply IH_E to IsE1 IsCtx. search.


Prove exactEval:host:stmtNames_not_in_ctx,
      exactEval:host:exprNames_not_in_ctx.
%stmtNames_not_in_ctx
 %SN-ListUpdate-Ignore
  case IsS. Or: apply mem_append to MemN SN4. M: case Or.
    %mem X NI
     apply IH_E to _ _ SN2 M MemsCtx.
    %mem X NE
     apply IH_E to _ _ SN3 M MemsCtx.
 %SN-ListUpdate-Take
  case IsS. MN: case MemN.
    %Mem-Here (X = L)
     apply not_mems to SN1 MemsCtx.
    %Mem-Later
     Or: apply mem_append to MN SN4. M: case Or.
       %mem X NI
        apply IH_E to _ _ SN2 M MemsCtx.
       %mem X NE
        apply IH_E to _ _ SN3 M MemsCtx.
 %SN-ListForeach
  case IsS. Or: apply mem_append to MemN SN3. M: case Or.
    %mem X NL
     apply IH_E to _ _ SN1 M MemsCtx.
    %mem X NB
     apply IH_S to _ _ SN2 M _.
%exprNames_not_in_ctx
 %EN-Nil
  case MemN.
 %EN-Cons
  case IsE. Or: apply mem_append to MemN EN3. M: case Or.
    %mem X N2
     apply IH_E to _ _ EN1 M MemsCtx.
    %mem X N3
     apply IH_E to _ _ EN2 M MemsCtx.
 %EN-Head
  case IsE. apply IH_E to _ _ EN1 MemN MemsCtx.
 %EN-Tail
  case IsE. apply IH_E to _ _ EN1 MemN MemsCtx.
 %EN-Null
  case IsE. apply IH_E to _ _ EN1 MemN MemsCtx.
 %EN-Index
  case IsE. Or: apply mem_append to MemN EN3. M: case Or.
    %mem X N2
     apply IH_E to _ _ EN1 M MemsCtx.
    %mem X N3
     apply IH_E to _ _ EN2 M MemsCtx.
 %EN-Length
  case IsE. apply IH_E to _ _ EN1 MemN MemsCtx.


Prove exactEval:host:stmtNames_relatedCtxs,
      exactEval:host:stmtNames_relatedCtxs_ctx_fwd,
      exactEval:host:stmtNames_relatedCtxs_ctx_back,
      exactEval:host:exprNames_relatedCtxs.
%stmtNames_relatedCtxs
 %SN-ListUpdate-Ignore
  Is': case IsS. EN1: apply IH_E to _ _ _ RelAB RelBA SN2.
  EN2: apply IH_E to _ _ _ RelAB RelBA SN3.
  Is1: apply exprNames_is to _ _ EN1.
  Is2: apply exprNames_is to _ _ EN2.
  Or: apply mems_or_not_mems to IsCtxB Is'. M: case Or.
    %mems L (ScopeB::CtxB)
     search.
    %not_mems L (ScopeB::CtxB)
     MB: apply RelAB to SN1. apply not_mems to M MB.
 %SN-ListUpdate-Take
  Is': case IsS. EN1: apply IH_E to _ _ _ RelAB RelBA SN2.
  EN2: apply IH_E to _ _ _ RelAB RelBA SN3.
  Is1: apply exprNames_is to _ _ EN1.
  Is2: apply exprNames_is to _ _ EN2.
  Or: apply mems_or_not_mems to IsCtxB Is'. M: case Or.
    %mems L (ScopeB::CtxB)
     MA: apply RelBA to M. apply not_mems to SN1 MA.
    %not_mems L (ScopeB::CtxB)
     search.
 %SN-ListForeach
  Is': case IsS. EN: apply IH_E to _ _ _ RelAB RelBA SN1.
  SN: apply IH_S to _ _ _ _ _ SN2 with
         ScopeB = [I], CtxB = ScopeB::CtxB.
    intros M. M: case M. search. apply RelBA to M. search.
    intros M. M: case M. search. apply RelAB to M. search.
  search.
%stmtNames_relatedCtxs_ctx_fwd
 %SN-ListUpdate-Ignore
  SNB: case SNB.
    %SN-ListUpdate-Ignore
     backchain RelAB.
    %SN-ListUpdate-Take
     backchain RelAB.
 %SN-ListUpdate-Take
  SNB: case SNB.
    %SN-ListUpdate-Ignore
     backchain RelAB.
    %SN-ListUpdate-Take
     backchain RelAB.
 %SN-ListForeach
  SNB: case SNB. backchain RelAB.
%stmtNames_relatedCtxs_ctx_back
 %SN-ListUpdate-Ignore
  SNB: case SNB.
    %SN-ListUpdate-Ignore
     backchain RelBA.
    %SN-ListUpdate-Take
     backchain RelBA.
 %SN-ListUpdate-Take
  SNB: case SNB.
    %SN-ListUpdate-Ignore
     backchain RelBA.
    %SN-ListUpdate-Take
     backchain RelBA.
 %SN-ListForeach
  SNB: case SNB. backchain RelBA.
%exprNames_relatedCtxs
 %EN-Nil
  search.
 %EN-Cons
  case IsE. apply IH_E to _ _ _ RelAB RelBA EN1.
  apply IH_E to _ _ _ RelAB RelBA EN2. search.
 %EN-Head
  case IsE. apply IH_E to _ _ _ RelAB RelBA EN1. search.
 %EN-Tail
  case IsE. apply IH_E to _ _ _ RelAB RelBA EN1. search.
 %EN-Null
  case IsE. apply IH_E to _ _ _ RelAB RelBA EN1. search.
 %EN-Index
  case IsE. apply IH_E to _ _ _ RelAB RelBA EN1.
  apply IH_E to _ _ _ RelAB RelBA EN2. search.
 %EN-Length
  case IsE. apply IH_E to _ _ _ RelAB RelBA EN1. search.


Prove exactEval:host:stmtNames_increaseCtxs,
      exactEval:host:stmtNames_increaseCtxs_ctxs,
      exactEval:host:exprNames_increaseCtxs.
%stmtNames_increaseCtxs
 %SN-ListUpdate-Ignore
  case IsS. SNB: case SNB.
    %SN-ListUpdate-Ignore
     Or: apply mem_append to M SNB3. M': case Or.
       %mem X NI1
        MI: apply IH_E to _ _ _ _ SNA2 SNB1 M'.
        apply mem_append_left to MI SNA4. search.
       %mem X NE1
        MN: apply IH_E to _ _ _ _ SNA3 SNB2 M'.
        apply mem_append_right to MN SNA4. search.
    %SN-ListUpdate-Take
     MB: apply RelAB to SNA1. apply not_mems to SNB MB.
 %SN-ListUpdate-Take
  case IsS. SNB: case SNB.
    %SN-ListUpdate-Ignore
     Or: apply mem_append to M SNB3. M': case Or.
       %mem X NI1
        MI: apply IH_E to _ _ _ _ SNA2 SNB1 M'.
        apply mem_append_left to MI SNA4. search.
       %mem X NE1
        MN: apply IH_E to _ _ _ _ SNA3 SNB2 M'.
        apply mem_append_right to MN SNA4. search.
    %SN-ListUpdate-Take
     M: case M.
       %Mem-Here
        search.
       %Mem-Later
        Or: apply mem_append to M SNB3. M': case Or.
          %mem X NI1
           MI: apply IH_E to _ _ _ _ SNA2 SNB1 M'.
           apply mem_append_left to MI SNA4. search.
          %mem X NI2
           MN: apply IH_E to _ _ _ _ SNA3 SNB2 M'.
           apply mem_append_right to MN SNA4. search.
 %SN-ListForeach
  case IsS. SNB: case SNB. Or: apply mem_append to M SNB2.
  M': case Or.
    %mem X NL1
     M'': apply IH_E to _ _ _ _ SNA1 SNB M'.
     apply mem_append_left to M'' SNA3. search.
    %mem X NB2
     M'': apply IH_S to _ _ _ _ SNA2 SNB1 M'.
       intros Mems. Mems: case Mems.
         %Mems-Here
          MX: case Mems. search. case MX.
         %Mems-Later
          apply RelAB to Mems. search.
     apply mem_append_right to M'' SNA3. search.
%stmtNames_increaseCtxs_ctxs
 %SN-ListUpdate-Ignore
  case IsS. SNB: case SNB.
    %SN-ListUpdate-Ignore
     backchain RelAB.
    %SN-ListUpdate-Take
     backchain RelAB.
 %SN-ListUpdate-Take
  case IsS. SNB: case SNB.
    %SN-ListUpdate-Ignore
     backchain RelAB.
    %SN-ListUpdate-Take
     backchain RelAB.
 %SN-ListForeach
  case SNB. backchain RelAB.
%exprNames_increaseCtxs
 %EN-Nil
  case ENB. case M.
 %EN-Cons
  case IsE. ENB: case ENB. Or: apply mem_append to M ENB2.
  M': case Or.
    %mem X N3
     M1: apply IH_E to _ _ _ _ ENA1 ENB M'.
     apply mem_append_left to M1 ENA3. search.
    %mem X N4
     M2: apply IH_E to _ _ _ _ ENA2 ENB1 M'.
     apply mem_append_right to M2 ENA3. search.
 %EN-Head
  case IsE. ENB: case ENB. apply IH_E to _ _ _ _ ENA1 ENB M. search.
 %EN-Tail
  case IsE. ENB: case ENB. apply IH_E to _ _ _ _ ENA1 ENB M. search.
 %EN-Null
  case IsE. ENB: case ENB. apply IH_E to _ _ _ _ ENA1 ENB M. search.
 %EN-Index
  case IsE. ENB: case ENB. Or: apply mem_append to M ENB2.
  M': case Or.
    %mem X N3
     M1: apply IH_E to _ _ _ _ ENA1 ENB M'.
     apply mem_append_left to M1 ENA3. search.
    %mem X N4
     M2: apply IH_E to _ _ _ _ ENA2 ENB1 M'.
     apply mem_append_right to M2 ENA3. search.
 %EN-Length
  case IsE. ENB: case ENB. apply IH_E to _ _ _ _ ENA1 ENB M. search.


Theorem exprNames_mem : forall Ctx X N,
  mems X Ctx -> exprNames Ctx (name X) N -> N = [].
intros M EN. EN: case EN.
  %EN-Name-Ignore
   search.
  %EN-Name-Take
   apply not_mems to EN M.

Prove_Constraint exactEval:host:proj_exprNames.
%Proj-Nil
 EN_P: case EN_P. EN_P: case EN_P. EN_P: case EN_P. EN_P: case EN_P1.
 case EN_P2. case M.
%Proj-Cons
 case IsE. EN: case EN. EN_P: case EN_P. EN_P: case EN_P.
 EN_P: case EN_P1. EN_P: case EN_P3. case EN_P. case EN_P5.
 case EN_P2. apply append_nil_right to EN_P6. clear EN_P6.
 apply exprNames_unique to _ _ EN EN_P1.
 apply exprNames_unique to _ _ EN1 EN_P3.
 apply append_unique to EN2 EN_P4. search.
%Proj-Head
 case IsE. EN: case EN. EN_P: case EN_P.
 apply exprNames_unique to _ _ EN EN_P. search.
%Proj-Tail
 case IsE. EN: case EN. EN_P: case EN_P.
 apply exprNames_unique to _ _ EN EN_P. search.
%Proj-Null
 case IsE. EN: case EN. EN_P: case EN_P.
 apply exprNames_unique to _ _ EN EN_P. search.
%Proj-Index
 case IsE. EN: case EN. EN_P: case EN_P. EN_P: case EN_P1.
 EN_P: case EN_P. EN_P: case EN_P. EN_P: case EN_P3. EN_P: case EN_P3.
 EN_P: case EN_P5. EN_P: case EN_P5. EN_P: case EN_P5. case EN_P5.
 case EN_P10. EN_P: case EN_P9. EN_P: case EN_P5. case EN_P5.
 case EN_P14. apply append_nil_right to EN_P11.
 apply append_nil_right to EN_P12. clear EN_P11 EN_P12.
 EN_P: case EN_P7. apply exprNames_mem to _ EN_P1.
 apply append_nil_right to EN_P2. clear EN_P1 EN_P2.
 apply exprNames_mem to _ EN_P13. case EN_P8. clear EN_P13.
 EN_P: case EN_P5. case EN_P2. apply exprNames_mem to _ EN_P1.
 case EN_P5. case EN_P9. clear EN_P1. EN_P: case EN_P7.
 EN_P: case EN_P1.
   %SN-Assign-Ignore
    clear EN_P1. EN_P: case EN_P7. apply exprNames_mem to _ EN_P1.
    case EN_P5. clear EN_P1. EN_P: case EN_P2.
      %SN-Assign-Ignore
       clear EN_P1. EN_P: case EN_P2. case EN_P2.
       apply exprNames_mem to _ EN_P1. case EN_P5. clear EN_P1.
       apply append_nil_right to EN_P6. clear EN_P6.
       Or: apply mem_append to M EN_P4. M': case Or.
         %mem X N1
          M2: apply exprNames_increaseCtxs to _ _ _ _ EN EN_P M'.
          apply mem_append_left to M2 EN2. search.
         %mem X N4
          apply fresh_name_is to _ Pr2.
          M3: apply exprNames_increaseCtxs to _ _ _ _ EN1 EN_P3 M'.
          apply mem_append_right to M3 EN2. search.
      %SN-Assign-Take
       NM: case EN_P1. NM': case NM1. NM'': case NM'. apply NM'' to _.
   %SN-Assign-Take
    NM: case EN_P1. NM': case NM1. NM'': case NM'. NM''': case NM''1.
    apply NM''' to _.
%Proj-Length
 case IsE. EN: case EN. EN_P: case EN_P. EN_P: case EN_P.
 EN_P: case EN_P. EN_P: case EN_P3. EN_P: case EN_P3. case EN_P3.
 case EN_P6. EN_P: case EN_P5. EN_P: case EN_P3. EN_P: case EN_P3.
 EN_P: case EN_P5. M': case EN_P3.
   %EN-Name-Ignore
    clear M'. case EN_P6. EN_P: case EN_P5.
      %SN-Assign-Ignore
       clear EN_P3. EN_P: case EN_P5. M': case EN_P3.
         %EN-Name-Ignore
          clear M'. case EN_P8. EN_P: case EN_P7.
            %SN-Assign-Ignore
             clear EN_P3. EN_P: case EN_P5. case EN_P5.
             EN_P: case EN_P3.
               %EN-Name-Ignore
                case EN_P6. apply append_nil_right to EN_P4.
                clear EN_P4 EN_P3. M': case EN_P1.
                  %EN-Name-Ignore
                   apply append_nil_right to EN_P2.
                   apply exprNames_increaseCtxs to
                      _ _ _ _ EN EN_P M. search.
                  %EN-Name-Take
                   NM: case M'. NM': case NM. apply NM' to _.
               %EN-Name-Take
                NM: case EN_P3. NM': case NM1. NM'': case NM'.
                apply NM'' to _.
            %SN-Assign-Take
             NM: case EN_P3. NM': case NM1. NM'': case NM'.
             apply NM'' to _.
         %EN-Name-Take
          NM: case M'. NM': case NM1. NM'': case NM'.
          NM''': case NM''1. apply NM''' to _.
      %SN-Assign-Take
       NM: case EN_P3. NM': case NM1. NM'': case NM'.
       NM''': case NM''1. apply NM''' to _.
   %EN-Name-Take
    NM: case M'. NM': case NM. NM'': case NM'1. apply NM'' to _.


Theorem mems_append_right[X] : forall A B C (X : X),
  A ++ B = C -> mems X B -> mems X C.
induction on 1. intros App M. App: case App.
  %nil
   search.
  %cons
   apply IH to App M. search.

Prove_Constraint exactEval:host:proj_stmtNames.
%Proj-ListUpdate
 case IsS. SN: case SN.
   %SN-ListUpdate-Ignore
    SN_P: case SN_P. SN_P: case SN_P. SN_PI: case SN_P.
    SN_P: case SN_P1. SN_PE: case SN_P. SN_P: case SN_P1.
    SN_P: case SN_P1. SN_P: case SN_P1. case SN_P1. case SN_P6.
    SN_P: case SN_P5. SN_P: case SN_P1. SN_P: case SN_P1.
    SN_P: case SN_P1. SN_P: case SN_P1. case SN_P11. SN_P: case SN_P9.
    SN_P: case SN_P9. SN_P: case SN_P7. SN_P: case SN_P11.
    SN_P: case SN_P11. SN_P: case SN_P14. SN_P: case SN_P16.
    SN_P: case SN_P5. SN_P: case SN_P5. SN_P: case SN_P5. case SN_P23.
    SN_P: case SN_P22. SN_P: case SN_P22. case SN_P22.
    SN_P: case SN_P20. SN_P: case SN_P22. SN_P: case SN_P22.
    SN_P: case SN_P22. SN_P: case SN_P26. SN_P: case SN_P26.
    SN_P: case SN_P28. SN_P: case SN_P30.
    Eq: assert N5 = [] /\
               Scope1::Ctx6 = [SaveE, SaveI]::Scope::Ctx.
      A: case SN_P.
        %SN-Assign-Ignore
         E: case A1. search. N: case E. N: case N. N: case N2.
         apply N2 to _.
        %SN-Assign-Take
         N: case A. N: case N. N: case N2. apply N2 to _.
    case Eq. case SN_P4. clear SN_P.
    Eq: assert N13 = [].
      E: case SN_P1. search. N: case E. N: case N. N: case N2.
      N: case N3. apply N3 to _.
    case Eq. case SN_P12. case SN_P10. clear SN_P1.
    Eq: assert CN = [].
      E: case SN_P9. search. N: case E. apply not_mems to N1 SN.
    case Eq. case SN_P8. clear SN_P9.
    Eq: assert N15 = [] /\
          Scope2::Ctx10 = []::[Hold, SaveE, SaveI]::Scope::Ctx.
      A: case SN_P7.
        %SN-Assign-Ignore
         E: case A1. case E1. E: case E. case E2. search.
         N: case E. N: case N1. N: case N1. N: case N3. N: case N4.
         apply N4 to _.
        %SN-Assign-Take
         N: case A. N: case N1. N: case N1. N: case N3. N: case N4.
         apply N4 to _.
    case Eq. case SN_P13. clear SN_P7.
    Eq: assert N17 = [].
      E: case SN_P11. search. N: case E. N: case N1.
      apply not_mems to N2 _.
    case Eq. case SN_P15. clear SN_P11.
    Eq: assert N19 = [] /\
               Ctx11 = [Copy]::[Hold, SaveE, SaveI]::Scope::Ctx.
      R: case SN_P14.
        %SN-RecUpdate-Ignore
         E: case R1. search. N: case E. N: case N1. N: case N1.
         apply N1 to _.
        %SN-RecUpdate-Take
         N: case R. N: case N. apply N to _.
    case Eq. case SN_P17. clear SN_P14.
    Eq: assert N21 = [] /\
               Ctx12 = [Copy]::[Hold, SaveE, SaveI]::Scope::Ctx.
      A: case SN_P16.
        %SN-Assign-Ignore
         E: case A1. search. N: case E. N: case N. apply N to _.
        %SN-Assign-Take
         N: case A. N: case N1. N: case N1. apply N1 to _.
    case Eq. case SN_P19. clear SN_P16.
    Eq: assert N9 = [] /\
               CtxB = [Copy]::[Hold, SaveE, SaveI]::Scope::Ctx.
      A: case SN_P18.
        %SN-Assign-Ignore
         E: case A1. E: case E. search. N: case E. N: case N1.
         apply not_mems to N2 _.
        %SN-Assign-Take
         N: case A. N: case N1. apply not_mems to N2 _.
    case Eq. case SN_P6. clear SN_P18.
    Eq: assert CN1 = [].
      E: case SN_P5. search. N: case E. apply not_mems to N1 _.
    case Eq. case SN_P24. case SN_P25. case SN_P21. clear SN_P5.
    Eq: assert N26 = [] /\
               Ctx2 = [Hold, SaveE, SaveI]::Scope::Ctx.
      R: case SN_P20.
        %SN-RecUpdate-Ignore
         E: case R1. search. N: case E. N: case N. N: case N2.
         apply N2 to _.
        %SN-RecUpdate-Take
         N: case R. apply not_mems to N1 _.
    case Eq. case SN_P23. clear SN_P20.
    Eq: assert CN2 = [].
      E: case SN_P22. search. N: case E. N: case N. apply N to _.
    case Eq. case SN_P27. clear SN_P22.
    Eq: assert N28 = [].
      E: case SN_P26. search. N: case E. N: case N1. N: case N1.
      apply N1 to _.
    case Eq. case SN_P29. clear SN_P26.
    Eq: assert N30 = [] /\
               Ctx16 = [Copy]::[Hold, SaveE, SaveI]::Scope::Ctx.
      R: case SN_P28.
        %SN-RecUpdate-Ignore
         E: case R1. search. N: case E. N: case N1.
         apply not_mems to N2 _.
        %SN-RecUpdate-Take
         N: case R. N: case N. apply N to _.
    case Eq. case SN_P31. clear SN_P28.
    Eq: assert N32 = [] /\
               Ctx17 = [Copy]::[Hold, SaveE, SaveI]::Scope::Ctx.
      A: case SN_P30.
        %SN-Assign-Ignore
         E: case A1. search. N: case E. N: case N. apply N to _.
        %SN-Assign-Take
         N: case A. N: case N1. apply not_mems to N2 _.
    case Eq. case SN_P33. clear SN_P30.
    Eq: assert N4 = [].
      A: case SN_P32.
        %SN-Assign-Ignore
         E: case A1. E: case E. search. N: case E. N: case N1.
         N: case N1. apply N1 to _.
        %SN-Assign-Take
         N: case A. N: case N1. N: case N1. apply N1 to _.
    case Eq. apply append_nil_right to SN_P3. clear SN_P3 SN_P32.
    Or: apply mem_append to M SN_P2. M': case Or.
      %mem X N2
       MI: apply exprNames_increaseCtxs to _ _ _ _ SN1 SN_PI M'.
       apply mem_append_left to MI SN3. search.
      %mem X N3
       apply fresh_name_is to _ Pr1.
       ME: apply exprNames_increaseCtxs to _ _ _ _ SN2 SN_PE M'.
       apply mem_append_right to ME SN3. search.
   %SN-ListUpdate-Take
    apply fresh_name_is to _ Pr1.
    apply fresh_name_is to _ Pr2. search 6.
    NotI: assert L = SaveI -> false.
      intros E. case E. apply fresh_name_not_mem to Pr1 _.
    NotHold: assert L = Hold -> false.
      intros E. case E. apply fresh_name_not_mem to Pr2 _.
    NotE: assert L = SaveE -> false.
      intros E. case E. apply fresh_name_not_mem to Pr3 _.
    NotCopy: assert L = Copy -> false.
      intros E. case E. apply fresh_name_not_mem to Pr4 _.
    SN_P: case SN_P. SN_P: case SN_P. SN_PI: case SN_P.
    SN_P: case SN_P1. SN_PE: case SN_P. SN_P: case SN_P1.
    SN_P: case SN_P1. SN_P: case SN_P1. case SN_P1. case SN_P6.
    SN_P: case SN_P5. SN_P: case SN_P1. SN_P: case SN_P1.
    SN_P: case SN_P1. SN_P: case SN_P1. case SN_P11. SN_P: case SN_P9.
    SN_P: case SN_P9. SN_P: case SN_P7. SN_P: case SN_P11.
    SN_P: case SN_P11. SN_P: case SN_P14. SN_P: case SN_P16.
    SN_P: case SN_P5. SN_P: case SN_P5. SN_P: case SN_P5. case SN_P23.
    SN_P: case SN_P22. SN_P: case SN_P22. case SN_P22.
    SN_P: case SN_P20. SN_P: case SN_P22. SN_P: case SN_P22.
    SN_P: case SN_P22. SN_P: case SN_P26. SN_P: case SN_P26.
    SN_P: case SN_P28. SN_P: case SN_P30.
    Eq: assert N6 = [] /\
               Scope1::Ctx6 = [SaveE, SaveI]::Scope::Ctx.
      A: case SN_P.
        %SN-Assign-Ignore
         E: case A1. search. N: case E. N: case N. N: case N2.
         apply N2 to _.
        %SN-Assign-Take
         N: case A. N: case N. N: case N2. apply N2 to _.
    case Eq. case SN_P4. clear SN_P.
    Eq: assert N14 = [].
      E: case SN_P1. search. N: case E. N: case N. N: case N2.
      N: case N3. apply N3 to _.
    case Eq. case SN_P12. case SN_P10. clear SN_P1.
    Eq: assert CN = [L].
      E: case SN_P9. M': case E. M': case M'. apply NotHold to _.
      M': case M'. apply NotE to _. M': case M'. apply NotI to _.
      case M'. apply not_mems to SN _. search.
    case Eq. App: case SN_P8. case App. clear SN_P9.
    Eq: assert N16 = [] /\
          Scope2::Ctx10 = []::[Hold, SaveE, SaveI]::Scope::Ctx.
      A: case SN_P7.
        %SN-Assign-Ignore
         E: case A1. case E1. E: case E. case E2. search.
         N: case E. N: case N1. N: case N1. N: case N3. N: case N4.
         apply N4 to _.
        %SN-Assign-Take
         N: case A. N: case N1. N: case N1. N: case N3. N: case N4.
         apply N4 to _.
    case Eq. case SN_P13. clear SN_P7.
    Eq: assert N18 = [L].
      E: case SN_P11. M': case E. case M'. M': case M'. M': case M'.
      apply NotHold to _. M': case M'. apply NotE to _. M': case M'.
      apply NotI to _. case M'. apply not_mems to SN _. search.
    case Eq. App: case SN_P15. case App. clear SN_P11.
    Eq: assert N20 = [] /\
               Ctx11 = [Copy]::[Hold, SaveE, SaveI]::Scope::Ctx.
      R: case SN_P14.
        %SN-RecUpdate-Ignore
         E: case R1. search. N: case E. N: case N1. N: case N1.
         apply N1 to _.
        %SN-RecUpdate-Take
         N: case R. N: case N. apply N to _.
    case Eq. case SN_P17. clear SN_P14.
    Eq: assert N22 = [] /\
               Ctx12 = [Copy]::[Hold, SaveE, SaveI]::Scope::Ctx.
      A: case SN_P16.
        %SN-Assign-Ignore
         E: case A1. search. N: case E. N: case N. apply N to _.
        %SN-Assign-Take
         N: case A. N: case N1. N: case N1. apply N1 to _.
    case Eq. case SN_P19. clear SN_P16.
    Eq: assert L1 = [L, L] /\
               CtxB = [Copy]::[Hold, SaveE, SaveI]::Scope::Ctx.
      A: case SN_P18.
        %SN-Assign-Ignore
         M': case A. M': case M'. apply NotCopy to _. case M'.
         M': case M'. M': case M'. apply NotHold to _. M': case M'.
         apply NotE to _. M': case M'. apply NotI to _. case M'.
         apply not_mems to _ M'.
        %SN-Assign-Take
         E: case A1. E: case E. M': case E. M': case M'.
         apply NotCopy to _. case M'. M': case M'. M': case M'.
         apply NotHold to _. M': case M'. apply NotE to _.
         M': case M'. apply NotI to _. case M'.
         apply not_mems to _ M'. search.
    case Eq. App: case SN_P6. App: case App. App: case App.
    App: case App. case App. clear SN_P18.
    Eq: assert CN1 = [L].
      E: case SN_P5. M': case E. M': case M'. apply NotHold to _.
      M': case M'. apply NotE to _. M': case M'. apply NotI to _.
      case M'. apply not_mems to _ M'. search.
    case Eq. App: case SN_P24. case App. App: case SN_P25. case App.
    App: case SN_P21. case App. clear SN_P5.
    Eq: assert N27 = [L] /\
               Ctx2 = [Hold, SaveE, SaveI]::Scope::Ctx.
      R: case SN_P20.
        %SN-RecUpdate-Ignore
         M': case R. M': case M'. apply NotHold to _. M': case M'.
         apply NotE to _. M': case M'. apply NotI to _. case M'.
         apply not_mems to _ M'.
        %SN-RecUpdate-Take
         E: case R1. search. N: case E. N: case N. N: case N2.
         apply N2 to _.
    case Eq. App: case SN_P23. case App. clear SN_P20.
    Eq: assert CN2 = [].
      E: case SN_P22. search. N: case E. N: case N. apply N to _.
    case Eq. case SN_P27. clear SN_P22.
    Eq: assert N29 = [].
      E: case SN_P26. search. N: case E. N: case N1. N: case N1.
      apply N1 to _.
    case Eq. case SN_P29. clear SN_P26.
    Eq: assert N31 = [L] /\
               Ctx16 = [Copy]::[Hold, SaveE, SaveI]::Scope::Ctx.
      R: case SN_P28.
        %SN-RecUpdate-Ignore
         E: case R1. M': case E. M': case M'. apply NotCopy to _.
         case M'. M': case M'. M': case M'. apply NotHold to _.
         M': case M'. apply NotE to _. M': case M'. apply NotI to _.
         case M'. apply not_mems to _ M'. search.
        %SN-RecUpdate-Take
         N: case R. N: case N. apply N to _.
    case Eq. App: case SN_P31. case App. clear SN_P28.
    Eq: assert N33 = [L] /\
               Ctx17 = [Copy]::[Hold, SaveE, SaveI]::Scope::Ctx.
      A: case SN_P30.
        %SN-Assign-Ignore
         M': case A. M': case M'. apply NotCopy to _. case M'.
         M': case M'. M': case M'. apply NotHold to _. M': case M'.
         apply NotE to _. M': case M'. apply NotI to _. case M'.
         apply not_mems to _ M'.
        %SN-Assign-Take
         E: case A1. search. N: case E. N: case N. apply N to _.
    case Eq. App: case SN_P33. case App. clear SN_P30.
    Eq: assert L13 = [].
      A: case SN_P32.
        %SN-Assign-Ignore
         E: case A1. E: case E. search. N: case E. N: case N1.
         N: case N1. apply N1 to _.
        %SN-Assign-Take
         N: case A. N: case N1. N: case N1. apply N1 to _.
    case Eq. clear SN_P32. Or: apply mem_append to M SN_P2.
    M': case Or.
      %mem X N2
       MI: apply exprNames_increaseCtxs to _ _ _ _ SN1 SN_PI M'.
       apply mem_append_left to MI SN3. search.
      %mem X N3
       Or: apply mem_append to M' SN_P3. M'': case Or.
         %mem X N4
          apply fresh_name_is to _ Pr1.
          ME: apply exprNames_increaseCtxs to _ _ _ _ SN2 SN_PE M''.
          apply mem_append_right to ME SN3. search.
         %mem X L's
          Eq: assert X = L.
           X: case M''. search. X: case X. search. X: case X. search.
           X: case X. search. X: case X. search. X: case X. search.
           X: case X. search. X: case X. search. case X.
          case Eq. search.
%Proj-ListForeach
 case IsS. apply fresh_name_is to _ Pr1. SN: case SN. SN_P: case SN_P.
 SN_P: case SN_P. SN_P: case SN_P. SN_P: case SN_P1. SN_P: case SN_P1.
 SN_P: case SN_P1. SN_P: case SN_P3. SN_P: case SN_P3.
 SN_P: case SN_P3. Eq: assert N1 = [].
   M': case SN_P3. search. NM: case M'. NM: case NM1. N: case NM1.
   apply N to _.
 case Eq. case SN_P6. clear SN_P3. Eq: assert CN = [].
   M': case SN_P1. search. NM: case M'. NM: case NM. apply NM to _.
 case Eq. case SN_P4. clear SN_P1. SN_P: case SN_P5.
 Eq: assert N5 = [] /\
            Ctx5 = [X1]::([SaveL]::(Scope::Ctx)).
   A: case SN_P1.
     %SN-Assign-Ignore
      A: case A1. MA: case A1. search. NM: case MA. NM: case NM1.
      NM': case NM1. apply NM' to _.
     %SN-Assign-Take
      NM: case A. NM: case NM1. NM': case NM1. apply NM' to _.
 case Eq. case SN_P4. Or: apply mem_append to M SN_P2. M': case Or.
   %mem X N2
    ML: apply exprNames_increaseCtxs to _ _ _ _ SN SN_P M'.
    apply mem_append_left to ML SN2. search.
   %mem X N3
    MB: apply stmtNames_increaseCtxs to _ _ _ _ SN1 SN_P3 M'.
      intros Ms. Ms: case Ms. M'': case Ms. search. case M''. search.
    apply mem_append_right to MB SN2. search.


Prove_Constraint exactEval:host:proj_stmtNames_names_forward.
%Proj-ListUpdate
 apply fresh_name_is to _ Pr1. apply fresh_name_is to _ Pr2. search 6.
 SN: case SN.
   %SN-ListUpdate-Ignore
    SN_P: case SN_P. search.
   %SN-ListUpdate-Take
    SN_P: case SN_P. search.
%Proj-ListForeach
 SN_P: case SN_P. SN: case SN. search.


Prove_Constraint exactEval:host:proj_stmtNames_names_backward.
%Proj-ListUpdate
 SN: case SN.
   %SN-ListUpdate-Ignore
    SN_P: case SN_P. search.
   %SN-ListUpdate-Take
    SN_P: case SN_P. search.
%Proj-ListForeach
 SN_P: case SN_P. SN: case SN. search.




/********************************************************************
 Typing
 ********************************************************************/
Prove exactEval:host:typeOf_isTy,
      exactEval:host:stmtOK_isCtx.
%typeOf_isTy
 %T-Nil
  case IsE. search.
 %T-Cons
  case IsE. apply IH to _ _ _ Ty1. search.
 %T-Head
  case IsE. Is: apply IH to _ _ _ Ty1. case Is. search.
 %T-Tail
  case IsE. apply IH to _ _ _ Ty1. search.
 %T-Null
  search.
 %T-Index
  case IsE. Is: apply IH to _ _ _ Ty1. case Is. search.
 %T-List
  search.
%stmtOK_isCtx
 %T-ListUpdate
  search.
 %T-ListForeach
  search.


Prove exactEval:host:stmtOK_keep_scopes.
%T-ListUpdate
 search.
%T-ListForeach
 search.


Prove exactEval:host:stmtOK_older_scopes_same.
%T-ListUpdate
 search.
%T-ListForeach
 search.


Prove exactEval:host:stmtOK_first_scope_lookup_same.
%T-ListUpdate
 search.
%T-ListForeach
 search.


Prove exactEval:host:typeOf_unique,
      exactEval:host:stmtOK_unique.
%typeOf_unique
 %T-Nil
  case TyB. search.
 %T-Cons
  case IsE. TyB: case TyB. apply IH_E to _ _ _ _ TyA1 TyB _. search.
 %T-Head
  case IsE. TyB: case TyB. apply IH_E to _ _ _ _ TyA1 TyB _. search.
 %T-Tail
  case IsE. TyB: case TyB. apply IH_E to _ _ _ _ TyA1 TyB _. search.
 %T-Null
  case IsE. TyB: case TyB. search.
 %T-Index
  case IsE. TyB: case TyB. apply IH_E to _ _ _ _ TyA1 TyB _. search.
 %T-List
  case TyB. search.
%stmtOK_unique
 %T-ListUpdate
  case TyB. search.
 %T-ListForeach
  TyB: case TyB. search.


Prove exactEval:host:paramTy_is.
Prove exactEval:host:getFunInfo_is.


Prove exactEval:host:paramTy_exists.
Prove exactEval:host:getFunInfo_exists.




/********************************************************************
 Evaluation
 ********************************************************************/
Theorem listIndex_is : forall L I V,
  is_value L -> listIndex L I V -> is_value V.
induction on 2. intros Is LI. LI: case LI.
  %LI-0
   case Is. apply lookup_is_value to _ LI. search.
  %LI-Step
   case Is. apply lookup_is_value to _ LI1. apply IH to _ LI2. search.


Theorem listLength_is : forall L I,
  is_value L -> listLength L I -> is_integer I.
induction on 2. intros Is LL. LL: case LL.
  %LL-Nil
   search.
  %LL-Cons
   case Is. apply lookup_is_value to _ LL1. apply IH to _ LL2.
   apply plus_integer_is_integer to _ _ LL3. search.


Theorem updateListIndex_is : forall L I V Out,
  is_value L -> is_value V -> updateListIndex L I V Out ->
  is_value Out.
induction on 3. intros IsL IsV ULI. ULI: case ULI.
  %ULI-0
   case IsL. apply replaceRecVal_is to _ _ ULI1. search.
  %ULI-Step
   case IsL. apply lookup_is_value to _ ULI2. apply IH to _ _ ULI3.
   apply replaceRecVal_is to _ _ ULI4. search.


Prove exactEval:host:evalExpr_isCtx,
      exactEval:host:evalExpr_isValue,
      exactEval:host:evalStmt_isCtx,
      exactEval:host:evalArgs_isCtx,
      exactEval:host:evalArgs_isValue,
      exactEval:host:evalRecFields_isCtx,
      exactEval:host:evalRecFields_isValue
with
  iterateList_isCtx : forall FE EE V X Body EE' O,
    IsV : is_value V ->
    IsX : is_string X ->
    IsBody : is_stmt Body ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    IL : iterateList FE EE V X Body EE' O ->
    is_list (is_list (is_pair is_string is_value)) EE'
  on IL as IH_IL.
%evalExpr_isCtx
 %E-Nil
  search.
 %E-Cons
  Is: case IsE. apply IH_C_E to _ _ _ Ev1. apply IH_C_E to _ _ _ Ev2.
  search.
 %E-Head
  Is: case IsE. apply IH_C_E to _ _ _ Ev1. search.
 %E-Tail
  Is: case IsE. apply IH_C_E to _ _ _ Ev1. search.
 %E-Null
  Is: case IsE. apply IH_C_E to _ _ _ Ev1. search.
 %E-Index
  Is: case IsE. apply IH_C_E to _ _ _ Ev1. apply IH_C_E to _ _ _ Ev2.
  search.
 %E-Length
  Is: case IsE. apply IH_C_E to _ _ _ Ev1. search.
%evalExpr_isValue
 %E-Nil
  case IsE. search 10.
 %E-Cons
  case IsE. apply IH_V_E to _ _ _ Ev1. apply IH_C_E to _ _ _ Ev1.
  apply IH_V_E to _ _ _ Ev2. search 20.
 %E-Head
  case IsE. Is: apply IH_V_E to _ _ _ Ev1. case Is.
  apply lookup_is_value to _ Ev2. search.
 %E-Tail
  case IsE. Is: apply IH_V_E to _ _ _ Ev1. case Is.
  apply lookup_is_value to _ Ev2. search.
 %E-Null
  case IsE. Is: apply IH_V_E to _ _ _ Ev1. case Is.
  apply lookup_is_value to _ Ev2. search.
 %E-Index
  case IsE. apply IH_V_E to _ _ _ Ev1. apply listIndex_is to _ Ev3.
  search.
 %E-Length
  case IsE. apply IH_V_E to _ _ _ Ev1. apply listLength_is to _ Ev2.
  search.
%evalStmt_isCtx
 %E-ListUpdate
  case IsS. apply IH_C_E to _ _ _ Ev1. apply IH_C_E to _ _ _ Ev2.
  apply IH_V_E to _ _ _ Ev2. apply lookupScopes_is to _ Ev3.
  apply updateListIndex_is to _ _ Ev4.
  apply replaceScopes_is to _ _ Ev5. search.
 %E-ListForeach
  case IsS. apply IH_C_E to _ _ _ Ev1. apply IH_V_E to _ _ _ Ev1.
  apply IH_IL to _ _ _ _ _ Ev2. search.
%iterateList_isCtx
 %IL-Nil
  search.
 %IL-Cons
  case IsV. apply lookup_is_value to _ IL2.
  IsEE3+: apply IH_C_S to _ _ _ IL3. case IsEE3+.
  apply lookup_is_value to _ IL4. apply IH_IL to _ _ _ _ _ IL5.
  search.


Prove exactEval:host:evalExpr_isOutput,
      exactEval:host:evalStmt_isOutput,
      exactEval:host:evalArgs_isOutput,
      exactEval:host:evalRecFields_isOutput
with
  iterateList_isOutput : forall FE EE V X Body EE' O,
    IsV : is_value V ->
    IsX : is_string X ->
    IsBody : is_stmt Body ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    IL : iterateList FE EE V X Body EE' O ->
    is_list is_value O
  on IL as IH_IL.
%evalExpr_isOutput
 %E-Nil
  search.
 %E-Cons
  case IsE. apply IH_E to _ _ _ Ev1.
  apply evalExpr_isCtx to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply append_values_is to _ _ Ev3. search.
 %E-Head
  case IsE. apply IH_E to _ _ _ Ev1. search.
 %E-Tail
  case IsE. apply IH_E to _ _ _ Ev1. search.
 %E-Null
  case IsE. apply IH_E to _ _ _ Ev1. search.
 %E-Index
  case IsE. apply IH_E to _ _ _ Ev1.
  apply evalExpr_isCtx to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply append_values_is to _ _ Ev4. search.
 %E-Length
  case IsE. apply IH_E to _ _ _ Ev1. search.
%evalStmt_isOutput
 %E-ListUpdate
  case IsS. apply IH_E to _ _ _ Ev1.
  apply evalExpr_isCtx to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply append_values_is to _ _ Ev6. search.
 %E-ListForeach
  case IsS. apply IH_E to _ _ _ Ev1.
  apply evalExpr_isValue to _ _ _ Ev1.
  apply evalExpr_isCtx to _ _ _ Ev1.
  apply IH_IL to _ _ _ _ _ Ev2.
  apply append_values_is to _ _ Ev3. search.
%iterateList_isOutput
 %IL-Nil
  search.
 %IL-Cons
  case IsV. apply lookup_is_value to _ IL2.
  IsEE3+: apply evalStmt_isCtx to _ _ _ IL3. case IsEE3+.
  apply IH_S to _ _ _ IL3. apply lookup_is_value to _ IL4.
  apply IH_IL to _ _ _ _ _ IL5. apply append_values_is to _ _ IL6.
  search.


Prove exactEval:host:paramName_is.
Prove exactEval:host:getFunEvalInfo_is.

Prove exactEval:host:evalProgram_isOutput.


Prove exactEval:host:evalExpr_names_same,
      exactEval:host:evalStmt_names_same,
      exactEval:host:evalArgs_names_same,
      exactEval:host:evalRecFields_names_same
with
  iterateList_names_same : forall FE EE V X Body EE' O,
    IsV : is_value V ->
    IsX : is_string X ->
    IsBody : is_stmt Body ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    IL : iterateList FE EE V X Body EE' O ->
    names_same EE EE'
  on IL as IH_IL.
%evalExpr_names_same
 %E-Nil
  backchain names_same_reflexive.
 %E-Cons
  case IsE. NS1: apply IH_E to _ _ _ Ev1.
  apply evalExpr_isCtx to _ _ _ Ev1. NS2: apply IH_E to _ _ _ Ev2.
  apply names_same_transitive to NS1 NS2. search.
 %E-Head
  case IsE. apply IH_E to _ _ _ Ev1. search.
 %E-Tail
  case IsE. apply IH_E to _ _ _ Ev1. search.
 %E-Null
  case IsE. apply IH_E to _ _ _ Ev1. search.
 %E-Index
  case IsE. NS1: apply IH_E to _ _ _ Ev1.
  apply evalExpr_isCtx to _ _ _ Ev1. NS2: apply IH_E to _ _ _ Ev2.
  apply names_same_transitive to NS1 NS2. search.
 %E-Length
  case IsE. apply IH_E to _ _ _ Ev1. search.
%evalStmt_names_same
 %E-ListUpdate
  case IsS. NS_I: apply IH_E to _ _ _ Ev1.
  apply evalExpr_isCtx to _ _ _ Ev1.
  NS_E: apply IH_E to _ _ _ Ev2. apply evalExpr_isCtx to _ _ _ Ev2.
  NS_R: apply replaceScopes_names_same to _ Ev5.
  NS': apply names_same_transitive to NS_I NS_E.
  NS: apply names_same_transitive to NS' NS_R. case NS. search.
 %E-ListForeach
  case IsS. NS1: apply IH_E to _ _ _ Ev1.
  apply evalExpr_isCtx to _ _ _ Ev1.
  apply evalExpr_isValue to _ _ _ Ev1.
  NS2: apply IH_IL to _ _ _ _ _ Ev2.
  NS: apply names_same_transitive to NS1 NS2. case NS. search.
%iterateList_names_same
 %IL-Nil
  backchain names_same_reflexive.
 %IL-Cons
  case IsV. apply lookup_is_value to _ IL2.
  NS1: apply IH_S to _ _ _ IL3.
  IsEE3+: apply evalStmt_isCtx to _ _ _ IL3. case IsEE3+.
  apply lookup_is_value to _ IL4. NS2: apply IH_IL to _ _ _ _ _ IL5.
  apply names_same_transitive to NS1 NS2. search.


Theorem listIndex_geq_0 : forall L I V,
  is_integer I -> listIndex L I V -> I >= 0.
induction on 2. intros IsI LI. LI: case LI.
  %LI-0
   search.
  %LI-Step
   apply minus_integer_is_integer to _ _ LI. G: apply IH to _ LI2.
   P: apply minus_plus_same_integer to _ _ LI.
   apply greatereq_integer__add_positive to _ _ P. search.

Theorem listIndex_unique : forall L I VA VB,
  listIndex L I VA -> listIndex L I VB -> VA = VB.
induction on 1. intros LIA LIB. LIA: case LIA.
  %LI-0
   LIB: case LIB.
     %LI-0
      apply lookup_unique to LIA LIB. search.
     %LI-Step
      compute LIB. G: apply listIndex_geq_0 to _ LIB2. G: case G.
      case G.
  %LI-Step
   LIB: case LIB.
     %LI-0
      compute LIA. G: apply listIndex_geq_0 to _ LIA2. G: case G.
      case G.
     %LI-Step
      apply minus_integer_unique to LIA LIB.
      apply lookup_unique to LIA1 LIB1. apply IH to LIA2 LIB2. search.


Theorem listLength_unique : forall L IA IB,
  listLength L IA -> listLength L IB -> IA = IB.
induction on 1. intros LLA LLB. LLA: case LLA.
  %LL-Nil
   LLB: case LLB.
     %LL-Nil
      search.
     %LL-Cons
      apply lookup_unique to LLA LLB.
  %LL-Cons
   LLB: case LLB.
     %LL-Nil
      apply lookup_unique to LLA LLB.
     %LL-Cons
      apply lookup_unique to LLA1 LLB1. apply IH to LLA2 LLB2.
      apply plus_integer_unique to LLA3 LLB3. search.


Theorem updateListIndex_geq_0 : forall L I V Out,
  is_integer I -> updateListIndex L I V Out -> I >= 0.
induction on 2. intros IsI ULI. ULI: case ULI.
  %ULI-0
   search.
  %ULI-Step
   apply minus_integer_is_integer to _ _ ULI1. G: apply IH to _ ULI3.
   P: apply minus_plus_same_integer to _ _ ULI1.
   apply greatereq_integer__add_positive to _ _ P. search.

Theorem updateListIndex_unique : forall L I V OutA OutB,
  updateListIndex L I V OutA -> updateListIndex L I V OutB ->
  OutA = OutB.
induction on 1. intros ULIA ULIB. ULIA: case ULIA.
  %ULI-0
   ULIB: case ULIB.
     %ULI-0
      apply replaceRecVal_unique to ULIA1 ULIB1. search.
     %ULI-Step
      compute ULIB1. G: apply updateListIndex_geq_0 to _ ULIB3.
      G: case G. case G.
  %ULI-Step
   ULIB: case ULIB.
     %ULI-0
      compute ULIA1. G: apply updateListIndex_geq_0 to _ ULIA3.
      G: case G. case G.
     %ULI-Step
      apply minus_integer_unique to ULIA1 ULIB1.
      apply lookup_unique to ULIA2 ULIB2. apply IH to ULIA3 ULIB3.
      apply replaceRecVal_unique to ULIA4 ULIB4. search.


Prove exactEval:host:evalExpr_newNameScopes,
      exactEval:host:evalExpr_newNameScopes_output,
      exactEval:host:evalExpr_newNameScopes_ctx,
      exactEval:host:evalStmt_newNameScopes_output,
      exactEval:host:evalStmt_newNameScopes,
      exactEval:host:evalArgs_newNameScopes,
      exactEval:host:evalArgs_newNameScopes_output,
      exactEval:host:evalArgs_newNameScopes_ctx,
      exactEval:host:evalRecFields_newNameScopes,
      exactEval:host:evalRecFields_newNameScopes_output,
      exactEval:host:evalRecFields_newNameScopes_ctx
with
  iterateList_newNameScopes_output :
    forall FE EE_A EE_B V X Body EE_A' EE_B' O_A O_B N Len,
      IsV : is_value V ->
      IsX : is_string X ->
      IsBody : is_stmt Body ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsA : is_list (is_list (is_pair is_string is_value)) EE_A ->
      IsB : is_list (is_list (is_pair is_string is_value)) EE_B ->
      ILA : iterateList FE EE_A V X Body EE_A' O_A ->
      ILB : iterateList FE EE_B V X Body EE_B' O_B ->
      NNS : newNameScopes N Len EE_A EE_B ->
      O_A = O_B
    on ILA as IH_O_IL,
  iterateList_newNameScopes :
    forall FE EE_A EE_B V X Body EE_A' EE_B' O_A O_B N Len,
      IsV : is_value V ->
      IsX : is_string X ->
      IsBody : is_stmt Body ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsA : is_list (is_list (is_pair is_string is_value)) EE_A ->
      IsB : is_list (is_list (is_pair is_string is_value)) EE_B ->
      ILA : iterateList FE EE_A V X Body EE_A' O_A ->
      ILB : iterateList FE EE_B V X Body EE_B' O_B ->
      NNS : newNameScopes N Len EE_A EE_B ->
      newNameScopes N Len EE_A' EE_B'
    on ILA as IH_C_IL.
%evalExpr_newNameScopes
 %E-Nil
  case EvB. search.
 %E-Cons
  case IsE. EvB: case EvB. apply IH_C_E to _ _ _ _ EvA1 EvB _.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB.
  apply IH_V_E to _ _ _ _ EvA1 EvB _.
  apply IH_V_E to _ _ _ _ EvA2 EvB1 _. search.
 %E-Head
  case IsE. EvB: case EvB. apply IH_V_E to _ _ _ _ EvA1 EvB _.
  apply lookup_unique to EvA2 EvB1. search.
 %E-Tail
  case IsE. EvB: case EvB. apply IH_V_E to _ _ _ _ EvA1 EvB _.
  apply lookup_unique to EvA2 EvB1. search.
 %E-Null
  case IsE. EvB: case EvB. apply IH_V_E to _ _ _ _ EvA1 EvB _.
  apply lookup_unique to EvA2 EvB1. search.
 %E-Index
  case IsE. EvB: case EvB. apply IH_C_E to _ _ _ _ EvA1 EvB _.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB.
  apply IH_V_E to _ _ _ _ EvA1 EvB _.
  apply IH_V_E to _ _ _ _ EvA2 EvB1 _.
  apply listIndex_unique to EvA3 EvB2. search.
 %E-Length
  case IsE. EvB: case EvB. apply IH_V_E to _ _ _ _ EvA1 EvB _.
  apply listLength_unique to EvA2 EvB1. search.
%evalExpr_newNameScopes_output
 %E-Nil
  case EvB. search.
 %E-Cons
  case IsE. EvB: case EvB. apply IH_C_E to _ _ _ _ EvA1 EvB _.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB.
  apply IH_O_E to _ _ _ _ EvA1 EvB _.
  apply IH_O_E to _ _ _ _ EvA2 EvB1 _.
  apply append_unique to EvA3 EvB2. search.
 %E-Head
  case IsE. EvB: case EvB. apply IH_O_E to _ _ _ _ EvA1 EvB _. search.
 %E-Tail
  case IsE. EvB: case EvB. apply IH_O_E to _ _ _ _ EvA1 EvB _. search.
 %E-Null
  case IsE. EvB: case EvB. apply IH_O_E to _ _ _ _ EvA1 EvB _. search.
 %E-Index
  case IsE. EvB: case EvB. apply IH_C_E to _ _ _ _ EvA1 EvB _.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB.
  apply IH_O_E to _ _ _ _ EvA1 EvB _.
  apply IH_O_E to _ _ _ _ EvA2 EvB1 _.
  apply append_unique to EvA4 EvB3. search.
 %E-Length
  case IsE. EvB: case EvB. apply IH_O_E to _ _ _ _ EvA1 EvB _. search.
%evalExpr_newNameScopes_ctx
 %E-Nil
  case IsE. EvB: case EvB. search.
 %E-Cons
  case IsE. EvB: case EvB. apply IH_C_E to _ _ _ _ EvA1 EvB _.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB.
  apply IH_C_E to _ _ _ _ EvA2 EvB1 _. search.
 %E-Head
  case IsE. EvB: case EvB. apply IH_C_E to _ _ _ _ EvA1 EvB _. search.
 %E-Tail
  case IsE. EvB: case EvB. apply IH_C_E to _ _ _ _ EvA1 EvB _. search.
 %E-Null-True
  case IsE. EvB: case EvB. apply IH_C_E to _ _ _ _ EvA1 EvB _. search.
 %E-Index
  case IsE. EvB: case EvB. apply IH_C_E to _ _ _ _ EvA1 EvB _.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB.
  apply IH_C_E to _ _ _ _ EvA2 EvB1 _. search.
 %E-Length
  case IsE. EvB: case EvB. apply IH_C_E to _ _ _ _ EvA1 EvB _. search.
%evalStmt_newNameScopes_output
 %E-ListUpdate
  case IsS. EvB: case EvB.
  apply IH_C_E to _ _ _ _ EvA1 EvB _.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB.
  apply IH_C_E to _ _ _ _ EvA2 EvB1 _.
  apply evalExpr_isCtx to _ _ _ EvA2.
  apply evalExpr_isCtx to _ _ _ EvB1.
  L: apply newNameScopes_lookupScopes to _ _ _ EvB2 with
        A = EE2. apply lookupScopes_unique to L EvA3.
  apply IH_O_E to _ _ _ _ EvA1 EvB _.
  apply IH_O_E to _ _ _ _ EvA2 EvB1 _.
  apply append_unique to EvA6 EvB5. search.
 %E-ListForeach
  case IsS. EvB: case EvB. apply IH_O_E to _ _ _ _ EvA1 EvB _.
  NNS': apply IH_C_E to _ _ _ _ EvA1 EvB _.
  apply evalExpr_isValue to _ _ _ EvA1.
  apply IH_V_E to _ _ _ _ EvA1 EvB _.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB.
  apply IH_O_IL to _ _ _ _ _ _ EvA2 EvB1 _.
  apply append_unique to EvA3 EvB2. search.
%evalStmt_newNameScopes
 %E-ListUpdate
  case IsS. EvB: case EvB.
  apply IH_C_E to _ _ _ _ EvA1 EvB _.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB.
  NNS': apply IH_C_E to _ _ _ _ EvA2 EvB1 _.
  apply evalExpr_isCtx to _ _ _ EvA2.
  apply evalExpr_isCtx to _ _ _ EvB1.
  L: apply newNameScopes_lookupScopes to _ _ _ EvB2 with
        A = EE2. apply lookupScopes_unique to L EvA3.
  apply IH_V_E to _ _ _ _ EvA1 EvB _.
  apply IH_V_E to _ _ _ _ EvA2 EvB1 _.
  apply updateListIndex_unique to EvA4 EvB3.
  apply evalExpr_isValue to _ _ _ EvA2.
  apply lookupScopes_is to _ EvA3.
  apply updateListIndex_is to _ _ EvA4.
  R: apply newNameScopes_replaceScopes to _ _ _ _ NNS' EvB4.
  apply replaceScopes_unique to R EvA5. search.
 %E-ListForeach
  case IsS. EvB: case EvB. NNS': apply IH_C_E to _ _ _ _ EvA1 EvB _.
  apply evalExpr_isValue to _ _ _ EvA1.
  apply IH_V_E to _ _ _ _ EvA1 EvB _.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB.
  NNS'': apply IH_C_IL to _ _ _ _ _ _ EvA2 EvB1 _. search.
%iterateList_newNameScopes_output
 %IL-Nil
  ILB: case ILB.
    %IL-Nil
     search.
    %IL-Cons
     apply lookup_unique to ILA1 ILB.
 %IL-Cons
  case IsV. ILB: case ILB.
    %IL-Nil
     apply lookup_unique to ILA1 ILB.
    %IL-Cons
     apply lookup_is_value to _ ILA2.
     apply lookup_unique to ILA2 ILB1.
     apply IH_O_S to _ _ _ _ ILA3 ILB2 _.
     IsEE1+: apply evalStmt_isCtx to _ _ _ ILA3. case IsEE1+.
     IsEE2+: apply evalStmt_isCtx to _ _ _ ILB2. case IsEE2+.
     NNS': apply IH_C_S to _ _ _ _ ILA3 ILB2 _.
     apply lookup_unique to ILA4 ILB3.
     apply lookup_is_value to _ ILA4. NNS': case NNS'.
       %end
        LenB: apply length_exists_list_pair_string_value to IsB.
        IsN2: apply length_is to LenB.
        P: apply plus_integer_total to _ IsN2 with N1 = 1.
        LenEE_B+: assert length ([(X, Hd1)]::EE_B) N3.
        LenEE2+: apply evalStmt_keep_scopes to _ _ _ ILB2 LenEE_B+.
        apply length_unique to LenEE2+ NNS'.
        LEq: apply newNameScopes_length to NNS LenB.
        L: apply lt_plus_one to P _.
        apply less_lesseq_flip_false to L LEq.
       %step
        apply IH_O_IL to _ _ _ _ _ _ ILA5 ILB4 NNS'.
        apply append_unique to ILA6 ILB5. search.
%iterateList_newNameScopes
 %IL-Nil
  ILB: case ILB.
    %IL-Nil
     search.
    %IL-Cons
     apply lookup_unique to ILA1 ILB.
 %IL-Cons
  case IsV. ILB: case ILB.
    %IL-Nil
     apply lookup_unique to ILA1 ILB.
    %IL-Cons
     apply lookup_is_value to _ ILA2.
     apply lookup_unique to ILA2 ILB1.
     IsEE1+: apply evalStmt_isCtx to _ _ _ ILA3. case IsEE1+.
     IsEE2+: apply evalStmt_isCtx to _ _ _ ILB2. case IsEE2+.
     NNS': apply IH_C_S to _ _ _ _ ILA3 ILB2 _.
     apply lookup_unique to ILA4 ILB3.
     apply lookup_is_value to _ ILA4. NNS': case NNS'.
       %end
        LenB: apply length_exists_list_pair_string_value to IsB.
        IsN2: apply length_is to LenB.
        P: apply plus_integer_total to _ IsN2 with N1 = 1.
        LenEE_B+: assert length ([(X, Hd1)]::EE_B) N3.
        LenEE2+: apply evalStmt_keep_scopes to _ _ _ ILB2 LenEE_B+.
        apply length_unique to LenEE2+ NNS'.
        LEq: apply newNameScopes_length to NNS LenB.
        L: apply lt_plus_one to P _.
        apply less_lesseq_flip_false to L LEq.
       %step
        apply IH_C_IL to _ _ _ _ _ _ ILA5 ILB4 NNS'. search.


Add_Ext_Size exactEval:host:evalExpr, exactEval:host:evalArgs,
             exactEval:host:evalRecFields, exactEval:host:evalStmt
        with iterateList FE EE V X Body EE' O.
Add_Proj_Rel exactEval:host:evalExpr, exactEval:host:evalArgs,
             exactEval:host:evalRecFields, exactEval:host:evalStmt
        with iterateList FE EE V X Body EE' O.


Prove exactEval:host:evalExpr_newNameScopes_exists_ES,
      exactEval:host:evalStmt_newNameScopes_exists_ES,
      exactEval:host:evalArgs_newNameScopes_exists_ES,
      exactEval:host:evalRecFields_newNameScopes_exists_ES
with
  iterateList_newNameScopes_exists_ES :
    forall FE EE_A EE_B V X Body EE_B' O N Len ES,
      IsV : is_value V ->
      IsX : is_string X ->
      IsBody : is_stmt Body ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsA : is_list (is_list (is_pair is_string is_value)) EE_A ->
      IsB : is_list (is_list (is_pair is_string is_value)) EE_B ->
      ILB : <iterateList {ES}> FE EE_B V X Body EE_B' O ES ->
      NNS : newNameScopes N Len EE_A EE_B ->
      exists EE_A', <iterateList {ES}> FE EE_A V X Body EE_A' O ES
    on ILB as IH_IL.
%evalExpr_newNameScopes_exists_ES
 %E-Nil
  search.
 %E-Cons
  case IsE. EvA1: apply IH_E to _ _ _ _ EvB3 NNS.
  EvB1': apply drop_ext_size_evalExpr to EvB3.
  EvA1': apply drop_ext_size_evalExpr to EvA1.
  NNS': apply evalExpr_newNameScopes_ctx to _ _ _ _ EvA1' EvB1' _.
  apply evalExpr_isCtx to _ _ _ EvB1'.
  apply evalExpr_isCtx to _ _ _ EvA1'.
  apply IH_E to _ _ _ _ EvB4 NNS'. search.
 %E-Head
  case IsE. apply IH_E to _ _ _ _ EvB2 NNS. search.
 %E-Tail
  case IsE. apply IH_E to _ _ _ _ EvB2 NNS. search.
 %E-Null
  case IsE. apply IH_E to _ _ _ _ EvB2 NNS. search.
 %E-Index
  case IsE. EvA1: apply IH_E to _ _ _ _ EvB3 NNS.
  EvB1': apply drop_ext_size_evalExpr to EvB3.
  EvA1': apply drop_ext_size_evalExpr to EvA1.
  NNS': apply evalExpr_newNameScopes_ctx to _ _ _ _ EvA1' EvB1' _.
  apply evalExpr_isCtx to _ _ _ EvB1'.
  apply evalExpr_isCtx to _ _ _ EvA1'.
  apply IH_E to _ _ _ _ EvB4 NNS'. search.
 %E-Length
  case IsE. apply IH_E to _ _ _ _ EvB2 NNS. search.
%evalStmt_newNameScopes_exists_ES
 %E-ListUpdate
  case IsS. EvA1: apply IH_E to _ _ IsA _ EvB3 _.
  EvB1': apply drop_ext_size_evalExpr to EvB3.
  EvA1': apply drop_ext_size_evalExpr to EvA1.
  apply evalExpr_isCtx to _ _ _ EvB1'.
  apply evalExpr_isCtx to _ _ _ EvA1'.
  NNS': apply evalExpr_newNameScopes_ctx to _ _ _ _ EvA1' EvB1' _.
  EvA2: apply IH_E to _ _ _ _ EvB4 NNS'.
  EvB2': apply drop_ext_size_evalExpr to EvB4.
  EvA2': apply drop_ext_size_evalExpr to EvA2.
  NNS'': apply evalExpr_newNameScopes_ctx to _ _ _ _ EvA2' EvB2' _.
  IsA': apply evalExpr_isCtx to _ _ _ EvA2'.
  apply evalExpr_isCtx to _ _ _ EvB2'.
  LA: apply newNameScopes_lookupScopes to IsA' _ _ EvB5.
  apply evalExpr_isValue to _ _ _ EvB2'.
  apply lookupScopes_is to _ EvB5.
  apply updateListIndex_is to _ _ EvB6.
  apply evalExpr_isCtx to _ _ _ EvB2'.
  apply newNameScopes_replaceScopes to _ _ _ _ NNS'' EvB7. search.
 %E-ListForeach
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  case IsS. EvA1: apply IH_E to _ _ _ _ EvB3 NNS'.
  EvB3': apply drop_ext_size_evalExpr to EvB3.
  EvA1': apply drop_ext_size_evalExpr to EvA1.
  NNS'': apply evalExpr_newNameScopes_ctx to _ _ _ _ EvA1' EvB3' NNS'.
  apply evalExpr_isValue to _ _ _ EvA1'.
  apply evalExpr_isCtx to _ _ _ EvA1'.
  apply evalExpr_isCtx to _ _ _ EvB3'.
  apply IH_IL to _ _ _ _ _ _ EvB4 NNS''. search.
%iterateList_newNameScopes_exists_ES
 %IL-Nil
  search.
 %IL-Cons
  case IsV. apply lookup_is_value to _ ILB3.
  ILA1: apply IH_S to _ _ _ _ ILB4 NNS.
  ILB5': apply drop_ext_size_evalStmt to ILB4.
  ILA1': apply drop_ext_size_evalStmt to ILA1.
  NNS': apply evalStmt_newNameScopes to _ _ _ _ ILA1' ILB5' _.
  IsEE1+: apply evalStmt_isCtx to _ _ _ ILB5'. case IsEE1+.
  IsEE_A': apply evalStmt_isCtx to _ _ _ ILA1'.
  apply lookup_is_value to _ ILB5. NNS': case NNS'.
    %end
     LenB: apply length_exists_list_pair_string_value to IsB.
     IsN5: apply length_is to LenB.
     P: apply plus_integer_total to _ IsN5 with N1 = 1.
     LenEE_B+: assert length ([(X, Hd)]::EE_B) N5.
     LenEE2+: apply evalStmt_keep_scopes to _ _ _ ILB5' LenEE_B+.
     apply length_unique to LenEE2+ NNS'.
     LEq: apply newNameScopes_length to NNS LenB.
     L: apply lt_plus_one to P _.
     apply less_lesseq_flip_false to L LEq.
    %step
     case IsEE_A'. apply IH_IL to _ _ _ _ _ _ ILB6 NNS'. search.


Prove exactEval:host:evalExpr_ctx_names,
      exactEval:host:evalStmt_ctx_names,
      exactEval:host:evalArgs_ctx_names,
      exactEval:host:evalRecFields_ctx_names
with
  iterateList_ctx_names : forall FE EE V X Body EE' O Ctx N Sc Ctx',
    IsV : is_value V ->
    IsX : is_string X ->
    IsBody : is_stmt Body ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    IsCtx : is_list (is_list is_string) Ctx ->
    Ctxs : ctx_names EE Ctx ->
    BN : stmtNames ([X]::Ctx) Body N (Sc::Ctx') ->
    IL : iterateList FE EE V X Body EE' O ->
    ctx_names EE' Ctx
  on IL as IH_IL.
%evalExpr_ctx_names
 %E-Nil
  search.
 %E-Cons
  case IsE. EN: case EN. C: apply IH_E to _ _ _ _ Ctxs EN Ev1.
  apply evalExpr_isCtx to _ _ _ Ev1. apply IH_E to _ _ _ _ C EN1 Ev2.
  search.
 %E-Head
  case IsE. EN: case EN. apply IH_E to _ _ _ _ Ctxs EN Ev1. search.
 %E-Tail
  case IsE. EN: case EN. apply IH_E to _ _ _ _ Ctxs EN Ev1. search.
 %E-Null
  case IsE. EN: case EN. apply IH_E to _ _ _ _ Ctxs EN Ev1. search.
 %E-Index
  case IsE. EN: case EN. C: apply IH_E to _ _ _ _ Ctxs EN Ev1.
  apply evalExpr_isCtx to _ _ _ Ev1. apply IH_E to _ _ _ _ C EN1 Ev2.
  search.
 %E-Length
  case IsE. EN: case EN. apply IH_E to _ _ _ _ Ctxs EN Ev1. search.
%evalStmt_ctx_names
 %E-ListUpdate
  case IsS. SN: case SN.
    %SN-ListUpdate-Ignore
     C: apply IH_E to _ _ _ _ Ctxs SN1 Ev1.
     apply evalExpr_isCtx to _ _ _ Ev1.
     C': apply IH_E to _ _ _ _ C SN2 Ev2.
     apply evalExpr_isCtx to _ _ _ Ev2.
     apply ctx_names_replaceScopes to _ _ C' Ev5. search.
    %SN-ListUpdate-Take
     C: apply IH_E to _ _ _ _ Ctxs SN1 Ev1.
     apply evalExpr_isCtx to _ _ _ Ev1.
     C': apply IH_E to _ _ _ _ C SN2 Ev2.
     apply evalExpr_isCtx to _ _ _ Ev2.
     apply ctx_names_replaceScopes to _ _ C' Ev5. search.
 %E-ListForeach
  case IsS. SN: case SN. M: apply stmtNames_keep_older to _ _ SN1.
  apply IH_E to _ _ _ _ _ SN Ev1. apply evalExpr_isCtx to _ _ _ Ev1.
  apply evalExpr_isValue to _ _ _ Ev1.
  apply IH_IL to _ _ _ _ _ _ _ SN1 Ev2. search.
%iterateList_ctx_names
 %IL-Nil
  search.
 %IL-Cons
  case IsV. apply lookup_is_value to _ IL2.
  apply lookup_is_value to _ IL4.
  apply stmtNames_keep_older to _ _ BN.
  assert ctx_names ([(X, Hd)]::EE) ([X]::Ctx).
    unfold.
      %mem EE -> mem Ctx
       intros M. M: case M. search. case M.
      %mem Ctx -> mem EE
       intros M. M: case M. search. case M.
      %rest
       search.
  Ctxs': apply IH_S to _ _ _ _ _ BN IL3. case Ctxs'.
  IsEE3+: apply evalStmt_isCtx to _ _ _ IL3. case IsEE3+.
  apply IH_IL to _ _ _ _ _ _ _ BN IL5. search.


Prove exactEval:host:evalExpr_newNameScopes_exists_back,
      exactEval:host:evalStmt_newNameScopes_exists_back,
      exactEval:host:evalArgs_newNameScopes_exists_back,
      exactEval:host:evalRecFields_newNameScopes_exists_back
with
  iterateList_newNameScopes_exists_back :
    forall FE EE_A EE_B V X Body Ctx EE_A' O N Len Ctx',
      IsV : is_value V ->
      IsX : is_string X ->
      IsBody : is_stmt Body ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsA : is_list (is_list (is_pair is_string is_value)) EE_A ->
      IsB : is_list (is_list (is_pair is_string is_value)) EE_B ->
      IsCtx : is_list (is_list is_string) Ctx ->
      %----------
      Ctxs : ctx_names EE_B Ctx ->
      BN : stmtNames ([X]::Ctx) Body [] Ctx' ->
      %----------
      ILA : iterateList FE EE_A V X Body EE_A' O ->
      NNS : newNameScopes N Len EE_A EE_B ->
      exists EE_B', iterateList FE EE_B V X Body EE_B' O
    on ILA as IH_IL.
%evalExpr_newNameScopes_exists_back
 %E-Nil
  search.
 %E-Cons
  case IsE. EN: case EN. case EN2.
  EvB1: apply IH_E to _ _ _ _ _ Ctxs EN EvA1 NNS.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB1.
  C: apply evalExpr_ctx_names to _ _ _ _ Ctxs EN EvB1.
  NNS': apply evalExpr_newNameScopes_ctx to _ _ _ _ EvA1 EvB1 NNS.
  apply IH_E to _ _ _ _ _ C EN1 EvA2 NNS'. search.
 %E-Head
  case IsE. EN: case EN. apply IH_E to _ _ _ _ _ Ctxs EN EvA1 NNS.
  search.
 %E-Tail
  case IsE. EN: case EN. apply IH_E to _ _ _ _ _ Ctxs EN EvA1 NNS.
  search.
 %E-Null
  case IsE. EN: case EN. apply IH_E to _ _ _ _ _ Ctxs EN EvA1 NNS.
  search.
 %E-Index
  case IsE. EN: case EN. case EN2.
  EvB1: apply IH_E to _ _ _ _ _ Ctxs EN EvA1 NNS.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB1.
  C: apply evalExpr_ctx_names to _ _ _ _ Ctxs EN EvB1.
  NNS': apply evalExpr_newNameScopes_ctx to _ _ _ _ EvA1 EvB1 NNS.
  apply IH_E to _ _ _ _ _ C EN1 EvA2 NNS'. search.
 %E-Length
  case IsE. EN: case EN. apply IH_E to _ _ _ _ _ Ctxs EN EvA1 NNS.
  search.
%evalStmt_newNameScopes_exists_back
 %E-ListUpdate
  case IsS. EN: case SN. case EN3.
  EvB1: apply IH_E to _ _ _ _ _ Ctxs EN1 EvA1 _.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB1.
  C: apply evalExpr_ctx_names to _ _ _ _ Ctxs EN1 EvB1.
  NNS': apply evalExpr_newNameScopes_ctx to _ _ _ _ EvA1 EvB1 _.
  EvB2: apply IH_E to _ _ _ _ _ C EN2 EvA2 NNS'.
  C': apply evalExpr_ctx_names to _ _ _ _ C EN2 EvB2.
  NNS'': apply evalExpr_newNameScopes_ctx to _ _ _ _ EvA2 EvB2 _.
  apply newNameScopes_ctx_names_lookupScopes to NNS'' _ EN EvA3.
  apply evalExpr_isValue to _ _ _ EvA2.
  apply evalExpr_isCtx to _ _ _ EvA2.
  apply lookupScopes_is to _ EvA3.
  apply updateListIndex_is to _ _ EvA4.
  apply evalExpr_isCtx to _ _ _ EvB2.
  apply newNameScopes_replaceScopes_back to _ _ _ _ C' EN NNS'' EvA5.
  search.
 %E-ListForeach
  case IsS. SN: case SN. case SN2.
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  EvB1: apply IH_E to _ _ _ _ _ _  SN EvA1 NNS'.
  NNS'': apply evalExpr_newNameScopes_ctx to _ _ _ _ EvA1 EvB1 _.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB1.
  apply evalExpr_isValue to _ _ _ EvA1.
  apply evalExpr_ctx_names to _ _ _ _ _ SN EvB1.
  apply IH_IL to _ _ _ _ _ _ _ _ SN1 EvA2 NNS''. search.
%iterateList_newNameScopes_exists_back
 %IL-Nil
  search.
 %IL-Cons
  case IsV. apply lookup_is_value to _ ILA2.
  apply lookup_is_value to _ ILA4.
  assert ctx_names ([(X, Hd)]::EE_B) ([X]::Ctx).
    unfold.
      %mem EE -> mem Ctx
       intros M. M: case M. search. case M.
      %mem Ctx -> mem EE
       intros M. M: case M. search. case M.
      %rest
       search.
  EvB: apply IH_S to _ _ _ _ _ _ BN ILA3 NNS.
  Ctxs': apply evalStmt_ctx_names to _ _ _ _ _ BN EvB.
  apply stmtNames_keep_older to _ _ BN. case Ctxs'.
  IsEE1+: apply evalStmt_isCtx to _ _ _ ILA3. case IsEE1+.
  IsAR+: apply evalStmt_isCtx to _ _ _ EvB. case IsAR+.
  NNS': apply evalStmt_newNameScopes to _ _ _ _ ILA3 EvB _.
  NNS': case NNS'.
    %end
     LenB: apply length_exists_list_pair_string_value to IsB.
     IsN2: apply length_is to LenB.
     P: apply plus_integer_total to _ IsN2 with N1 = 1.
     LenEE_B+: assert length ([(X, Hd)]::EE_B) N3.
     LenAR+: apply evalStmt_keep_scopes to _ _ _ EvB LenEE_B+.
     apply length_unique to LenAR+ NNS'.
     LEq: apply newNameScopes_length to NNS LenB.
     L: apply lt_plus_one to P _.
     apply less_lesseq_flip_false to L LEq.
    %step
     apply IH_IL to _ _ _ _ _ _ _ _ BN ILA5 NNS'. search.


Prove exactEval:host:evalExpr_scopes_same,
      exactEval:host:evalExpr_scopes_same_ctx,
      exactEval:host:evalStmt_scopes_same,
      exactEval:host:evalStmt_scopes_same_ctx,
      exactEval:host:evalArgs_scopes_same,
      exactEval:host:evalArgs_scopes_same_ctx,
      exactEval:host:evalRecFields_scopes_same,
      exactEval:host:evalRecFields_scopes_same_ctx
with
  iterateList_scopes_same :
    forall V X Body FE EE_A EE_A' OA EE_B EE_B' OB,
      IsV : is_value V ->
      IsX : is_string X ->
      IsBody : is_stmt Body ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsA : is_list (is_list (is_pair is_string is_value)) EE_A ->
      IsB : is_list (is_list (is_pair is_string is_value)) EE_B ->
      SS : scopes_same EE_A EE_B ->
      ILA : iterateList FE EE_A V X Body EE_A' OA ->
      ILB : iterateList FE EE_B V X Body EE_B' OB ->
      OA = OB
    on ILA as IH_IL,
  iterateList_scopes_same_ctx :
    forall V X Body FE EE_A EE_A' OA EE_B EE_B' OB,
      IsV : is_value V ->
      IsX : is_string X ->
      IsBody : is_stmt Body ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsA : is_list (is_list (is_pair is_string is_value)) EE_A ->
      IsB : is_list (is_list (is_pair is_string is_value)) EE_B ->
      SS : scopes_same EE_A EE_B ->
      ILA : iterateList FE EE_A V X Body EE_A' OA ->
      ILB : iterateList FE EE_B V X Body EE_B' OB ->
      scopes_same EE_A' EE_B'
    on ILA as IH_IL_C.
%evalExpr_scopes_same
 %E-Nil
  case EvB. search.
 %E-Cons
  case IsE. EvB: case EvB. apply IH_E to _ _ _ _ _ EvA1 EvB.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB.
  apply IH_E_C to _ _ _ _ _ EvA1 EvB.
  apply IH_E to _ _ _ _ _ EvA2 EvB1. apply append_unique to EvA3 EvB2.
  search.
 %E-Head
  case IsE. EvB: case EvB. apply IH_E to _ _ _ _ _ EvA1 EvB.
  apply lookup_unique to EvA2 EvB1. search.
 %E-Tail
  case IsE. EvB: case EvB. apply IH_E to _ _ _ _ _ EvA1 EvB.
  apply lookup_unique to EvA2 EvB1. search.
 %E-Null
  case IsE. EvB: case EvB. apply IH_E to _ _ _ _ _ EvA1 EvB.
  apply lookup_unique to EvA2 EvB1. search.
 %E-Index
  case IsE. EvB: case EvB. apply IH_E to _ _ _ _ _ EvA1 EvB.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB.
  apply IH_E_C to _ _ _ _ _ EvA1 EvB.
  apply IH_E to _ _ _ _ _ EvA2 EvB1.
  apply listIndex_unique to EvA3 EvB2.
  apply append_unique to EvA4 EvB3. search.
 %E-Length
  case IsE. EvB: case EvB. apply IH_E to _ _ _ _ _ EvA1 EvB.
  apply listLength_unique to EvA2 EvB1. search.
%evalExpr_scopes_same_ctx
 %E-Nil
  case EvB. search.
 %E-Cons
  case IsE. EvB: case EvB. apply IH_E_C to _ _ _ _ _ EvA1 EvB.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB.
  apply IH_E_C to _ _ _ _ _ EvA2 EvB1. search.
 %E-Head
  case IsE. EvB: case EvB. apply IH_E_C to _ _ _ _ _ EvA1 EvB. search.
 %E-Tail
  case IsE. EvB: case EvB. apply IH_E_C to _ _ _ _ _ EvA1 EvB. search.
 %E-Null
  case IsE. EvB: case EvB. apply IH_E_C to _ _ _ _ _ EvA1 EvB. search.
 %E-Index
  case IsE. EvB: case EvB. apply IH_E_C to _ _ _ _ _ EvA1 EvB.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB.
  apply IH_E_C to _ _ _ _ _ EvA2 EvB1. search.
 %E-Length
  case IsE. EvB: case EvB. apply IH_E_C to _ _ _ _ _ EvA1 EvB. search.
%evalStmt_scopes_same
 %E-ListUpdate
  case IsS. EvB: case EvB. apply IH_E to _ _ _ _ _ EvA1 EvB.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB.
  apply IH_E_C to _ _ _ _ _ EvA1 EvB.
  apply IH_E_C to _ _ _ _ _ EvA2 EvB1.
  apply evalExpr_isCtx to _ _ _ EvA2.
  apply evalExpr_isCtx to _ _ _ EvB1.
  apply scopes_same_lookupScopes to _ _ _ EvA3 EvB2.
  apply IH_E to _ _ _ _ _ EvA2 EvB1. apply append_unique to EvA6 EvB5.
  search.
 %E-ListForeach
  case IsS. EvB: case EvB. apply IH_E to _ _ _ _ _ EvA1 EvB.
  apply IH_E_C to _ _ _ _ _ EvA1 EvB.
  apply evalExpr_isValue to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB.
  apply IH_IL to _ _ _ _ _ _ _ EvA2 EvB1.
  apply append_unique to EvA3 EvB2. search.
%evalStmt_scopes_same_ctx
 %E-ListUpdate
  case IsS. EvB: case EvB. apply IH_E_C to _ _ _ _ _ EvA1 EvB.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB.
  apply IH_E_C to _ _ _ _ _ EvA2 EvB1.
  apply IH_E to _ _ _ _ _ EvA1 EvB.
  apply IH_E to _ _ _ _ _ EvA2 EvB1.
  apply evalExpr_isCtx to _ _ _ EvA2.
  apply evalExpr_isCtx to _ _ _ EvB1.
  apply scopes_same_lookupScopes to _ _ _ EvA3 EvB2.
  apply updateListIndex_unique to EvA4 EvB3.
  apply scopes_same_replaceScopes_scopes_same to _ _ _ _ EvA5 EvB4.
  search.
 %E-ListForeach
  case IsS. EvB: case EvB. apply IH_E to _ _ _ _ _ EvA1 EvB.
  apply IH_E_C to _ _ _ _ _ EvA1 EvB.
  apply evalExpr_isValue to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB.
  apply IH_IL_C to _ _ _ _ _ _ _ EvA2 EvB1. search.
%iterateList_scopes_same
 %IL-Nil
  ILB: case ILB.
    %IL-Nil
     search.
    %IL-Cons
     apply lookup_unique to ILA1 ILB.
 %IL-Cons
  case IsV. ILB: case ILB.
    %IL-Nil
     apply lookup_unique to ILA1 ILB.
    %IL-Cons
     apply lookup_unique to ILB1 ILA2.
     apply lookup_unique to ILB3 ILA4.
     apply lookup_is_value to _ ILB1. apply lookup_is_value to _ ILB3.
     apply IH_S to _ _ _ _ _ ILA3 ILB2.
     SS': apply IH_S_C to _ _ _ _ _ ILA3 ILB2. case SS'.
     IsEE1+: apply evalStmt_isCtx to _ _ _ ILA3. case IsEE1+.
     IsEE2+: apply evalStmt_isCtx to _ _ _ ILB2. case IsEE2+.
     apply IH_IL to _ _ _ _ _ _ _ ILA5 ILB4.
     apply append_unique to ILA6 ILB5. search.
%iterateList_scopes_same_ctx
 %IL-Nil
  ILB: case ILB.
    %IL-Nil
     search.
    %IL-Cons
     apply lookup_unique to ILA1 ILB.
 %IL-Cons
  case IsV. ILB: case ILB.
    %IL-Nil
     apply lookup_unique to ILA1 ILB.
    %IL-Cons
     apply lookup_unique to ILB1 ILA2.
     apply lookup_unique to ILB3 ILA4.
     apply lookup_is_value to _ ILB1. apply lookup_is_value to _ ILB3.
     SS': apply IH_S_C to _ _ _ _ _ ILA3 ILB2. case SS'.
     IsEE1+: apply evalStmt_isCtx to _ _ _ ILA3. case IsEE1+.
     IsEE2+: apply evalStmt_isCtx to _ _ _ ILB2. case IsEE2+.
     apply IH_IL_C to _ _ _ _ _ _ _ ILA5 ILB4. search.


Prove exactEval:host:evalExpr_scopes_same_exists,
      exactEval:host:evalStmt_scopes_same_exists,
      exactEval:host:evalArgs_scopes_same_exists,
      exactEval:host:evalRecFields_scopes_same_exists
with
  iterateList_scopes_same_exists :
    forall V X Body FE EE_A EE_A' O EE_B,
      IsV : is_value V ->
      IsX : is_string X ->
      IsBody : is_stmt Body ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsA : is_list (is_list (is_pair is_string is_value)) EE_A ->
      IsB : is_list (is_list (is_pair is_string is_value)) EE_B ->
      SS : scopes_same EE_A EE_B ->
      ILA : iterateList FE EE_A V X Body EE_A' O ->
      exists EE_B', iterateList FE EE_B V X Body EE_B' O
  on ILA as IH_IL.
%evalExpr_scopes_same_exists
 %E-Nil
  search.
 %E-Cons
  case IsE. EvB1: apply IH_E to _ _ _ _ SS EvA1.
  SS': apply evalExpr_scopes_same_ctx to _ _ _ _ _ EvA1 EvB1.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB1.
  EvB2: apply IH_E to _ _ _ _ SS' EvA2. search.
 %E-Head
  case IsE. EvB1: apply IH_E to _ _ _ _ SS EvA1. search.
 %E-Tail
  case IsE. EvB1: apply IH_E to _ _ _ _ SS EvA1. search.
 %E-Null
  case IsE. EvB1: apply IH_E to _ _ _ _ SS EvA1. search.
 %E-Index
  case IsE. EvB1: apply IH_E to _ _ _ _ SS EvA1.
  SS': apply evalExpr_scopes_same_ctx to _ _ _ _ _ EvA1 EvB1.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB1.
  EvB2: apply IH_E to _ _ _ _ SS' EvA2. search.
 %E-Length
  case IsE. EvB1: apply IH_E to _ _ _ _ SS EvA1. search.
%evalStmt_scopes_same_exists
 %E-ListUpdate
  case IsS. EvB1: apply IH_E to _ _ _ _ SS EvA1.
  SS': apply evalExpr_scopes_same_ctx to _ _ _ _ _ EvA1 EvB1.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB1.
  EvB2: apply IH_E to _ _ _ _ SS' EvA2.
  apply evalExpr_isCtx to _ _ _ EvA2.
  apply evalExpr_isCtx to _ _ _ EvB2.
  SS'': apply evalExpr_scopes_same_ctx to _ _ _ _ _ EvA2 EvB2.
  apply scopes_same_lookupScopes_exists to _ _ SS'' EvA3.
  apply scopes_same_replaceScopes_exists to _ _ _ SS'' EvA5.
  search.
 %E-ListForeach
  case IsS. EvB: apply IH_E to _ _ _ _ SS EvA1.
  SS': apply evalExpr_scopes_same_ctx to _ _ _ _ _ EvA1 EvB.
  apply evalExpr_isCtx to _ _ _ EvA1.
  apply evalExpr_isCtx to _ _ _ EvB.
  apply evalExpr_isValue to _ _ _ EvA1.
  apply IH_IL to _ _ _ _ _ _ SS' EvA2. search.
%iterateList_scopes_same_exists
 %IL-Nil
  search.
 %IL-Cons
  case IsV. apply lookup_is_value to _ ILA2.
  apply lookup_is_value to _ ILA4.
  SS': assert scopes_same ([(X, Hd)]::EE_A) ([(X, Hd)]::EE_B).
  EvB: apply IH_S to _ _ _ _ SS' ILA3.
  IsEE1+: apply evalStmt_isCtx to _ _ _ ILA3. case IsEE1+.
  IsB+: apply evalStmt_isCtx to _ _ _ EvB.
  SS+: apply evalStmt_scopes_same_ctx to _ _ _ _ _ ILA3 EvB.
  SS'': case SS+. case IsB+. apply IH_IL to _ _ _ _ _ _ SS''2 ILA5.
  search.


Theorem is_list_values_append_nil : forall L,
  is_list is_value L -> L ++ [] = L.
induction on 1. intros IsL. Is: case IsL.
  %nil
   search.
  %cons
   apply IH to Is1. search.

Theorem index_to_while : forall LV IV V FE Ctx I L,
  listIndex LV IV V -> (L = I -> false) -> is_integer IV ->
  exists Fields,
    <evalStmt {ES}> FE ([(I, intVal IV), (L, LV)]::Ctx)
       (while (greater (name I) (num 0))
          (seq (assign L (recFieldAccess (name L) "tail"))
               (assign I (minus (name I) (num 1)))))
       ([(I, intVal 0), (L, recVal Fields)]::Ctx) [] 0 /\
    lookup Fields "head" V.
induction on 1. intros LI NEqLI IsIV. LI: case LI.
  %LI-0
   exists Fields. split.
     %eval
      assert <evalExpr {ES}> FE
                ([(I, intVal 0), (L, recVal Fields)]::Ctx)
                (greater (name I) (num 0)) falseVal
                ([(I, intVal 0), (L, recVal Fields)]::Ctx) [] 0.
      search.
     %lookup Fields
      search.
  %LI-Step
   apply minus_integer_is_integer to _ _ LI.
   NEqIL: assert I = L -> false. intros E. case E. backchain NEqLI.
   assert <evalExpr {ES}> FE
                ([(I, intVal IV), (L, recVal Fields)]::Ctx)
                (greater (name I) (num 0)) trueVal
                ([(I, intVal IV), (L, recVal Fields)]::Ctx) [] 0.
        unfold.
        exists 0, 0, IV,
           ([(I, intVal IV), (L, recVal Fields)]::Ctx), [], 0, [].
        split.
          %0 + 0 = 0
           search.
          %eval (name I)
           search.
          %eval (num 0)
           search.
          %IV > 0
           GEq: apply listIndex_geq_0 to _ LI2.
           P: apply minus_plus_same_integer to _ _ LI.
           P': apply plus_integer_comm to _ _ P.
           L: apply lt_plus_one to P' _. LEq: case GEq.
           apply lesseq_less_integer_transitive to LEq L. search.
          %append output
           search.
   assert <evalStmt {ES}> FE
                ([]::[(I, intVal IV), (L, recVal Fields)]::Ctx)
                (assign L (recFieldAccess (name L) "tail"))
                ([]::[(L, Tl), (I, intVal IV)]::Ctx) [] 0.
        search 20.
   assert <evalStmt {ES}> FE
             ([]::[(L, Tl), (I, intVal IV)]::Ctx)
             (assign I (minus (name I) (num 1)))
             ([]::[(I, intVal I1), (L, Tl)]::Ctx) [] 0.
        search 20.
   apply IH to LI2 _ _ with Ctx = Ctx, FE = FE. search.

Theorem while_to_index : forall LV IV V FE Ctx Ctx' O I L Fields,
  evalStmt FE ([(I, intVal IV), (L, LV)]::Ctx)
     (while (greater (name I) (num 0))
        (seq (assign L (recFieldAccess (name L) "tail"))
             (assign I (minus (name I) (num 1))))) Ctx' O ->
  lookupScopes L Ctx' (recVal Fields) ->
  lookup Fields "head" V ->
  IV >= 0 -> %necessary for E-While-False case to get IV = 0
  is_integer IV -> %necessary for maintaining IV >= 0 for IH
  (L = I -> false) ->
  listIndex LV IV V /\ O = [] /\ exists Scope, Ctx' = Scope::Ctx.
induction on 1. intros Ev LkpL LkpHead GEqIV IsIV NEqLI.
NEqIL: assert I = L -> false. intros E. case E. backchain NEqLI.
Ev: case Ev.
  %E-While-True
   Ev: case Ev1. Ev: case Ev1. Ev: case Ev1. Ev: case Ev1.
   Ev: case Ev. case Ev9. Ev: case Ev. case Ev11. case Ev6. case Ev3.
   Ev: case Ev5. Ev: case Ev3. case Ev6. Ev: case Ev3. case Ev11.
   case Ev4. Eq: assert I1 = IV.
     LS: case Ev.
       %LS-FirstScope
        L: case LS. search. apply L to _.
       %LS-Later
        NL: case LS. apply NL to _.
   case Eq. clear Ev. Eq: assert LV = recVal Fields1.
     LS: case Ev1.
       %LS-FirstScope
        case LS.
       %LS-Later
        clear LS. LS: case LS1.
          %LS-FirstScope
           L: case LS. L': case L1. search. apply L' to _.
          %LS-Later
           NL: case LS. NL': case NL1. apply NL' to _.
   case Eq. clear Ev1.
   Eq: assert EE6 = []::[(L, V1), (I, intVal IV)]::Ctx.
     R: case Ev7.
       %RS-FirstScope
        case R.
       %RS-Later
        clear R. R: case R1.
          %RS-FirstScope
           RA: case R1.
             %RA-Remove
              apply NEqLI to _.
             %RA-Keep
              RA': case RA1.
                %RA-Remove
                 case RA'. search.
                %RA-Keep
                 apply RA' to _.
          %RS-Later
           NL: case R. NL': case NL1. apply NL' to _.
   case Eq. clear Ev7. Eq: assert I4 = IV.
     LS: case Ev3.
       %LS-FirstScope
        case LS.
       %LS-Later
        clear LS. LS: case LS1.
          %LS-FirstScope
           L: case LS.
             %Lkp-Here
              apply NEqIL to _.
             %Lkp-Later
              L': case L1.
                %Lkp-Here
                 search.
                %Lkp-Later
                 apply L' to _.
          %LS-Later
           NL: case LS. NL': case NL1. apply NL' to _.
   case Eq. clear Ev3.
   Eq: assert Scope::EE2 = []::[(I, intVal I3), (L, V1)]::Ctx.
     R: case Ev5.
       %RS-FirstScope
        case R.
       %RS-Later
        clear R. R: case R1.
          %RS-FirstScope
           RA: case R1.
             %RA-Remove
              apply NEqLI to _.
             %RA-Keep
              RA': case RA1.
                %RA-Remove
                 case RA'. search.
                %RA-Keep
                 apply RA' to _.
          %RS-Later
           NL: case R. NL': case NL1. apply NL' to _.
   case Eq. clear Ev5.
   apply minus_integer_is_integer to _ _ Ev9.
   P: apply minus_plus_same_integer to _ _ Ev9.
   P': apply plus_integer_comm to _ _ P.
   M: apply plus_minus_same_integer to _ _ P'.
   assert I3 >= 0.
     GEq1: apply greater_integer_step_greatereq to _ _ Ev10 _.
     Or: apply is_integer_related to _ _ with A = IV, B = 1.
     C: case Or.
       %IV = 1
        compute Ev9. search.
       %IV < 1
        LEq1: case GEq1. apply less_lesseq_flip_false to C LEq1.
       %IV > 1
        case C. LI3: apply minus_smaller_positive to Ev9 _.
        apply less_integer_lesseq to LI3. search.
   apply IH to Ev2 LkpL LkpHead _ _ _. search.
  %E-While-False
   Ev: case Ev. case Ev1. Ev: case Ev. Eq: assert I1 = IV.
     LS: case Ev.
       %LS-FirstScope
        L: case LS.
          %Lkp-Here
           search.
          %Lkp-Later
           apply L to _.
       %LS-Later
        NL: case LS. apply NL to _.
   case Eq. clear Ev. case Ev3. Eq: assert IV = 0.
     Or: apply greatereq_integer_greater_or_eq to GEqIV.
     C: case Or.
       %IV > 0
        L: case C. apply less_lesseq_flip_false to L Ev2.
       %IV = 0
        search.
   case Eq. Eq: assert LV = recVal Fields.
     LS: case LkpL.
       %LS-FirstScope
        L: case LS. L': case L1. search. apply L' to _.
       %LS-Later
        NL: case LS. NL': case NL1. apply NL' to _.
   case Eq. search.

Theorem length_to_while :
  forall LV StoreLen L Len CurrLen TotalLen FE Ctx,
    listLength LV CurrLen -> (L = Len -> false) ->
    CurrLen + StoreLen = TotalLen -> is_integer StoreLen ->
    is_integer CurrLen ->
    exists Fields,
      <evalStmt {ES}> FE ([(Len, intVal StoreLen), (L, LV)]::Ctx)
         (while (not (recFieldAccess (name L) "null"))
            (seq (assign L (recFieldAccess (name L) "tail"))
                 (assign Len (plus (name Len) (num 1)))))
         ([(Len, intVal TotalLen), (L, recVal Fields)]::Ctx) [] 0 /\
      lookup Fields "null" trueVal.
induction on 1. intros Len NEq P IsSLen IsCLen.
assert Len = L -> false. intros E. case E. backchain NEq.
Len: case Len.
  %LL-Nil
   case P. exists Fields. split.
     %evalStmt
      assert lookupScopes L
                ([(Len, intVal TotalLen), (L, recVal Fields)]::Ctx)
                (recVal Fields).
      assert <evalExpr {ES}> FE
                ([(Len, intVal TotalLen), (L, recVal Fields)]::Ctx)
                (not (recFieldAccess (name L) "null")) falseVal
                ([(Len, intVal TotalLen), (L, recVal Fields)]::Ctx)
                [] 0.
      search.
     %lookup
      search.
  %LL-Cons
   LSL: assert lookupScopes L
                 ([(Len, intVal StoreLen), (L, recVal Fields)]::Ctx)
                 (recVal Fields).
   EvC: assert <evalExpr {ES}> FE
                  ([(Len, intVal StoreLen), (L, recVal Fields)]::Ctx)
                  (not (recFieldAccess (name L) "null")) trueVal
                  ([(Len, intVal StoreLen), (L, recVal Fields)]::Ctx)
                  [] 0.
   EvL: assert
           <evalStmt {ES}> FE
               ([]::[(Len, intVal StoreLen), (L, recVal Fields)]::Ctx)
               (assign L (recFieldAccess (name L) "tail"))
               ([]::[(L, Tl), (Len, intVal StoreLen)]::Ctx) [] 0.
     search 20.
   P': apply plus_integer_total to _ IsSLen with N1 = 1.
   apply plus_integer_is_integer to _ _ P'.
   EvE: assert <evalStmt {ES}> FE
                  ([]::[(L, Tl), (Len, intVal StoreLen)]::Ctx)
                  (assign Len (plus (name Len) (num 1)))
                  ([]::[(Len, intVal N3), (L, Tl)]::Ctx) [] 0.
     apply plus_integer_comm to _ _ P'. search 20.
   IsI: apply plus_integer_is_integer_result to _ Len3. clear IsI1.
   assert I + N3 = TotalLen.
     OrigP': apply plus_integer_comm to _ _ P.
     AssocP: apply plus_integer_assoc to _ _ _ Len3 OrigP'.
     apply plus_integer_unique to P' AssocP. search.
   apply IH to Len2 NEq _ _ _ with
      TotalLen = TotalLen, StoreLen = N3, FE = FE, Ctx = Ctx.
   exists Fields1. search.

Theorem while_to_length :
  forall LV StoreLen L Len FE Ctx Ctx' FinalLen O,
    evalStmt FE ([(Len, intVal StoreLen), (L, LV)]::Ctx)
      (while (not (recFieldAccess (name L) "null"))
         (seq (assign L (recFieldAccess (name L) "tail"))
              (assign Len (plus (name Len) (num 1))))) Ctx' O ->
    lookupScopes Len Ctx' FinalLen -> is_integer StoreLen ->
    (L = Len -> false) ->
    exists Scope TotalLen CurrLen,
       O = [] /\ Ctx' = Scope::Ctx /\ FinalLen = intVal TotalLen /\
       listLength LV CurrLen /\ is_integer CurrLen /\
       CurrLen + StoreLen = TotalLen.
induction on 1. intros Ev LS IsSLen NEq. Ev: case Ev.
  %E-While-True
   Ev: case Ev. Ev: case Ev. Ev: case Ev. case Ev3.
   Eq: assert LV = recVal Fields.
     LS: case Ev.
       %LS-FirstScope
        L: case LS1. L': case L1. search. apply L' to _.
       %LS-Later
        NL: case LS1. NL': case NL1. apply NL' to _.
   case Eq. clear Ev. Ev: case Ev1. Ev: case Ev. Ev: case Ev.
   Ev: case Ev. case Ev3. Eq: assert Fields1 = Fields.
     LS': case Ev.
       %LS-FirstScope
        case LS'.
       %LS-Later
        clear LS'. LS': case LS'1.
          %LS-FirstScope
           L: case LS'. L': case L1. search. apply L' to _.
          %LS-Later
           NL: case LS'. NL': case NL1. apply NL' to _.
   case Eq. clear Ev.
   Eq: assert EE3 = []::[(L, V), (Len, intVal StoreLen)]::Ctx.
     RS: case Ev6.
       %RS-FirstScope
        case RS.
       %RS-Later
        clear RS. RS: case RS1.
          %RS-FirstScope
           RA: case RS1.
             %RA-Remove
              apply NEq to _.
             %RA-Keep
              clear RA. RA: case RA1.
                %RA-Remove
                 case RA. search.
                %RA-Keep
                 apply RA to _.
          %RS-Later
           NL: case RS. NL': case NL1. apply NL' to _.
   case Eq. clear Ev6. Ev: case Ev1. Ev: case Ev. case Ev3.
   Ev: case Ev. case Ev8. case Ev4. Eq: assert I1 = StoreLen.
     LS': case Ev.
       %LS-FirstScope
        case LS'.
       %LS-Later
        clear LS'. LS': case LS'1.
          %LS-FirstScope
           L: case LS'.
             %Lkp-Here
              apply NEq to _.
             %Lkp-Later
              L': case L1. search. apply L' to _.
          %LS-Later
           NL: case LS'. NL': case NL1. apply NL' to _.
   case Eq. clear Ev.
   Eq: assert []::[(Len, intVal I), (L, V)]::Ctx = Scope::EE2.
     R: case Ev1.
       %RS-FirstScope
        case R.
       %RS-Later
        clear R. R: case R1.
          %RS-FirstScope
           RA: case R1.
             %RA-Remove
              apply NEq to _.
             %RA-Keep
              RA': case RA1.
                %RA-Remove
                 case RA'. search.
                %RA-Keep
                 apply RA' to _.
          %RS-Later
           NL: case R. NL': case NL1. apply NL' to _.
   case Eq. clear Ev1. apply plus_integer_is_integer to _ _ Ev6.
   Sub: apply IH to Ev2 LS _ NEq.
   P: apply plus_integer_total to Sub1 _ with N2 = 1.
   apply plus_integer_is_integer to _ _ P.
   AssocP: apply plus_integer_assoc to _ _ _ Ev6 Sub2.
   P': apply plus_integer_comm to _ _ P.
   apply plus_integer_unique to P' AssocP.
   apply plus_integer_comm to _ _ AssocP1. search.
  %E-While-False
   Ev: case Ev. Ev: case Ev. Ev: case Ev.
   Eq: assert LV = recVal Fields.
     LS': case Ev.
       %LS-FirstScope
        L: case LS'. L': case L1. search. apply L' to _.
       %LS-Later
        NL: case LS'. NL': case NL1. apply NL' to _.
   case Eq. clear Ev. Eq: assert FinalLen = intVal StoreLen.
     LS: case LS.
       %LS-FirstScope
        L: case LS. search. apply L to _.
       %LS-Later
        NL: case LS. apply NL to _.
   case Eq. P: assert 0 + StoreLen = StoreLen. search.

Extensible_Theorem
  iterateList_dot_null : forall FE EE V X Body EE' O,
    IL : iterateList FE EE V X Body EE' O ->
    exists Fs, V = recVal Fs /\
              (lookup Fs "null" trueVal \/ lookup Fs "null" falseVal)
  on IL.
search. search.


Theorem iterateList_to_while : forall FE EE V X Body EE' O Names L,
  is_value V -> is_string X -> is_stmt Body ->
  is_list (is_pair is_string
          (is_pair is_string
          (is_pair is_value
          (is_pair (is_list is_string) is_stmt)))) FE ->
  is_list (is_list (is_pair is_string is_value)) EE ->
  iterateList FE EE V X Body EE' O ->
  names EE Names -> fresh_name "L" (X::Names) L ->
  exists V',
    evalStmt FE ([(L, V)]::EE)
      (while (not (null (name L)))
         (seq (declare intTy X (head (name L)))
         (seq (assign L (tail (name L)))
              Body))) ([(L, V')]::EE') O.
induction on 6. intros IsV IsX IsBody IsFE IsEE IL Names Fr.
Or: apply iterateList_dot_null to IL. clear Or. IL: case IL.
  %IL-Nil
   search 20.
  %IL-Cons
   case IsV. apply lookup_is_value to _ IL1.
   apply lookup_is_value to _ IL3.
   IsEE''+: apply evalStmt_isCtx to _ _ _ IL2. IsEE'': case IsEE''+.
   NS: apply evalStmt_names_same to _ _ _ IL2.
   Names'': apply names_exists to IsEE''1.
   IsN: apply names_is to _ Names''.
   Fr': apply fresh_name_exists to _ _ with Base = "L", Names = X::N.
   apply fresh_name_unique_mems to Fr Fr' _ _.
     %mem X::N -> mem X::Names
      intros M. M: case M. search.
      NS': apply names_same_symmetric to NS.
      apply names_same_names to NS' Names'' Names M. search.
     %mem X::Names -> mem X::N
      intros M. M: case M. search.
      apply names_same_names to NS Names Names'' M. search.
   EvSub: apply IH to _ _ _ _ _ IL4 Names'' Fr'.
   exists V'. unfold. exists [(F, recVal Fs)]::EE, [], Scope'.
   exists [(F, Tl)]::EE'', O2, O3, O2. split.
     %eval condition
      search.
     %eval body
      unfold. exists [(X, Hd)]::[(F, recVal Fs)]::EE, [], O2. split.
        %eval declare X
         search 20.
        %eval rest
         NEq: assert X = F -> false.
           intros E. case E. apply fresh_name_not_mem to Fr _.
         unfold. exists [(X, Hd)]::[(F, Tl)]::EE, [], O2. split.
           %eval assign
            search 10.
           %eval Body
            LenEE: apply length_exists_list_pair_string_value to IsEE.
            rename N1 to Len.
            NNS: assert newNameScopes [[(F, Tl)]] Len
                                      ([(F, Tl)]::EE) EE.
              unfold. exists 1, [F], Names. split. search. search.
              search. search. search. intros M MN. M: case M.
              apply fresh_name_not_mem to Fr _. case M.
            apply fresh_name_is to _ Fr.
            Ev: apply evalStmt_newNameScopes_exists to
                   _ _ _ _ IL2 NNS.
            NNS': apply evalStmt_newNameScopes to _ _ _ _ Ev IL2 _.
            NNS': case NNS'.
              %end
               Take: case NNS'2. case Take1. compute Take.
               Drop: case NNS'1. apply drop_is_integer to Drop1.
               apply plus_integer_unique_addend to _ _ _ Take Drop.
               Eq: assert L1 = Scope'::EE''.
                 D: case Drop1. search. apply drop_is_integer to D1.
                 P: assert 1 + -1 = 0.
                 apply plus_integer_unique_addend to _ _ _ P D.
                 GEq: apply drop_geq_0 to D1. LEq: case GEq. case LEq.
               case Eq. clear Take Drop Drop1.
               Len: case NNS'. apply length_is to Len.
               L: apply lt_plus_one to Len1 _.
               Len'': apply names_same_length to NS LenEE.
               apply length_unique to Len'' Len.
               apply less_integer_not_eq to L.
              %step
               NNS': case NNS'.
                 %end
                  Take: case NNS'2. case Take1. compute Take.
                  Drop: case NNS'1. apply drop_is_integer to Drop1.
                  apply plus_integer_unique_addend to _ _ _ Take Drop.
                  Eq: assert L1 = EE''.
                    D: case Drop1. search. P: assert 1 + -1 = 0.
                    apply drop_is_integer to D1.
                    apply plus_integer_unique_addend to _ _ _ D P.
                    GEq: apply drop_geq_0 to D1. LEq: case GEq.
                    case LEq.
                  case Eq. search.
                 %step
                  LenBR+: apply names_same_length to NS LenEE.
                  LenBR: case LenBR+. apply length_is to LenBR.
                  L: apply lt_plus_one to LenBR1 _.
                  LEq: apply newNameScopes_length to NNS' LenBR.
                  apply less_lesseq_flip_false to L LEq.
        %append output
         search.
        %append output
         search.
     %eval loop again
      search.
     %append first output
      search.
     %append rest output
      search.


Theorem while_to_iterateList :
  forall FE EE V X Body Scope' EE' O Names L Ctx Ctx',
    is_value V -> is_string X -> is_stmt Body ->
    is_list (is_pair is_string
            (is_pair is_string
            (is_pair is_value
            (is_pair (is_list is_string) is_stmt)))) FE ->
    is_list (is_list (is_pair is_string is_value)) EE ->
    is_list (is_list is_string) Ctx ->
    names EE Names -> fresh_name "L" (X::Names) L ->
    ctx_names EE Ctx ->
    stmtNames ([X]::Ctx) Body [] Ctx' ->
    evalStmt FE ([(L, V)]::EE)
      (while (not (null (name L)))
         (seq (declare intTy X (head (name L)))
         (seq (assign L (tail (name L)))
              Body))) (Scope'::EE') O ->
    iterateList FE EE V X Body EE' O.
induction on 11. intros IsV IsX IsBody IsFE IsEE IsCtx
                        Names Fr CN BN Ev. Ev: case Ev.
  %E-While-True
   Ev: case Ev. Ev: case Ev. Ev: case Ev.
   Eq: assert V = recVal Fields.
     L: case Ev.
       %LS-FirstScope
        L: case L.
          %Lkp-Here
           search.
          %Lkp-Later
           case L1.
       %LS-Later
        NL: case L. apply NL to _.
   case Eq. case Ev3. Ev: case Ev1. Ev: case Ev1. Ev: case Ev1.
   Ev: case Ev1. Eq: assert Fields1 = Fields.
     LS: case Ev1.
       %LS-FirstScope
        case LS.
       %LS-Later
        LS': case LS1.
          %LS-FirstScope
           L: case LS'.
             %Lkp-Here
              search.
             %Lkp-Later
              apply L to _.
          %LS-Later
           NL: case LS'. apply NL to _.
   case Eq. case Ev6. Ev: case Ev3. Ev: case Ev3. Ev: case Ev3.
   Ev: case Ev3. case Ev8. Eq: assert Fields2 = Fields.
     LS: case Ev3.
       %LS-FirstScope
        L: case LS.
          %Lkp-Here
           apply fresh_name_not_mem to Fr _.
          %Lkp-Later
           case L1.
       %LS-Later
        LS': case LS1.
          %LS-FirstScope
           L: case LS'.
             %Lkp-Here
              search.
             %Lkp-Later
              apply L to _.
          %LS-Later
           NL: case LS'. apply NL to _.
   case Eq. Eq: assert EE3 = [(X, V1)]::[(L, V2)]::EE.
     RS: case Ev9.
       %RS-FirstScope
        M: case RS. apply fresh_name_not_mem to Fr _. case M.
       %RS-Later
        RS': case RS1.
          %RS-FirstScope
           RA: case RS'1.
             %RA-Remove
              case RA. search.
             %RA-Keep
              apply RA to _.
          %RS-Later
           NL: case RS'. apply NL to _.
   case Eq. Len: apply length_exists_list_pair_string_value to IsEE.
   NNS: assert newNameScopes [[(L, V2)]] N ([(L, V2)]::EE) EE.
     unfold. exists 1, [L], Names. split. search. search. search.
     search. search. intros M MN. M: case M.
     apply fresh_name_not_mem to Fr _. case M.
   assert ctx_names ([(X, V1)]::EE) ([X]::Ctx).
     unfold.
       %mem EE -> mem Ctx
        intros M. M: case M. search. case M.
       %mem Ctx -> mem EE
        intros M. M: case M. search. case M.
       %rest
        search.
   apply fresh_name_is to _ Fr. IsR: apply lookupScopes_is to _ Ev.
   case IsR. apply lookup_is_value to _ Ev7.
   apply lookup_is_value to _ Ev10.
   EvB: apply evalStmt_newNameScopes_exists_back to
           _ _ _ _ _ _ BN Ev6 NNS.
   NNS': apply evalStmt_newNameScopes to _ _ _ _ Ev6 EvB NNS.
   NNS': case NNS'.
     %end
      Take: case NNS'2. case Take1. compute Take. Drop: case NNS'1.
      apply drop_is_integer to Drop1.
      apply plus_integer_unique_addend to _ _ _ Take Drop.
      Eq: assert EE4 = EE_B'.
        D: case Drop1. search. apply drop_is_integer to D1.
        P: assert 1 + -1 = 0.
        apply plus_integer_unique_addend to _ _ _ P D.
        GEq: apply drop_geq_0 to D1. LEq: case GEq. case LEq.
      case Eq. clear Take Drop Drop1.
      NS: apply evalStmt_names_same to _ _ _ EvB.
      LenEE'': apply names_same_length to NS Len.
      LenNNS: case NNS'. apply length_unique to LenEE'' LenNNS.
      apply length_is to LenEE''. L: apply lt_plus_one to LenNNS1 _.
      apply less_integer_not_eq to L.
     %step
      NNS': case NNS'.
        %end
         Take: case NNS'2. case Take1. compute Take. Drop: case NNS'1.
         apply drop_is_integer to Drop1.
         apply plus_integer_unique_addend to _ _ _ Take Drop.
         Eq: assert L1 = BR.
           D: case Drop1. search. apply drop_is_integer to D1.
           P: assert 1 + -1 = 0.
           apply plus_integer_unique_addend to _ _ _ P D.
           GEq: apply drop_geq_0 to D1. LEq: case GEq. case LEq.
         case Eq. clear Take Drop Drop1.
         CN': apply evalStmt_ctx_names to _ _ _ _ _ BN EvB.
         apply stmtNames_keep_older to _ _ BN. CN': case CN'.
         IsBR+: apply evalStmt_isCtx to _ _ _ EvB. IsBR: case IsBR+.
         NamesBR: apply names_exists to IsBR1.
         IsN4: apply names_is to _ NamesBR.
         Fr': apply fresh_name_exists to _ _ with
                 Base = "L", Names = X::N4.
         NS: apply evalStmt_names_same to _ _ _ EvB.
         apply fresh_name_unique_mems to Fr Fr' _ _.
           %mem X::N4 -> mem X::Names
            intros M. M: case M. search.
            NS': apply names_same_symmetric to NS.
            apply names_same_names to NS' NamesBR Names M. search.
           %mem X::Names -> mem X::N4
            intros M. M: case M. search.
            apply names_same_names to NS Names NamesBR M. search.
         apply IH to _ _ _ _ _ _ NamesBR Fr' CN'2 BN Ev2. search.
        %step
         NS: apply evalStmt_names_same to _ _ _ EvB.
         LenBR+: apply names_same_length to NS Len.
         LenBR: case LenBR+. apply length_is to LenBR.
         LEq: apply newNameScopes_length to NNS' LenBR.
         L: apply lt_plus_one to LenBR1 _.
         apply less_lesseq_flip_false to L LEq.
  %E-While-False
   Ev: case Ev. Ev: case Ev. Ev: case Ev.
   Eq: assert V = recVal Fields.
     LS: case Ev.
       %LS-FirstScope
        L: case LS.
          %Lkp-Here
           search.
          %Lkp-Later
           apply L to _.
       %LS-Later
        NL: case LS. apply NL to _.
   case Eq. search.


Theorem lookupScopes_replaceScopes_exists : forall L Key V V',
  is_list (is_list (is_pair is_string is_value)) L -> is_string Key ->
  lookupScopes Key L V -> exists R, replaceScopes Key V' L R.
induction on 3. intros IsL IsKey LS. LS: case LS.
  %LS-FirstScope
   Is: case IsL. RA: apply remove_all_exists to Is IsKey.
   M: apply lookup_mem to LS. search.
  %LS-Later
   case IsL. apply IH to _ _ LS1 with V' = V'. search.

Theorem replaceScopes_lookupScopes_same[Key, Item] :
  forall L (Key : Key) (V : Item) R,
    replaceScopes Key V L R -> lookupScopes Key R V.
induction on 1. intros RS. RS: case RS.
  %RS-FirstScope
   search.
  %RS-Later
   apply IH to RS1. search.

Theorem remove_all_twice[K, V] : forall (L : list (pair K V)) K RA RB,
  remove_all L K RA -> remove_all RA K RB -> RA = RB.
induction on 1. intros RA RB. RA: case RA.
  %RA-Nil
   case RB. search.
  %RA-Remove
   apply IH to RA RB. search.
  %RA-Keep
   RB: case RB.
     %RA-Remove
      apply RA to _.
     %RA-Keep
      apply IH to RA1 RB1. search.

Theorem replaceScopes_twice[Key, Item] :
  forall (L : list (list (pair string value))) K VA RA VB RB,
    replaceScopes K VA L RA -> replaceScopes K VB RA RB ->
    replaceScopes K VB L RB.
induction on 1. intros RSA RSB. RSA: case RSA.
  %RS-FirstScope
   RSB: case RSB.
     %RS-FirstScope
      RA: case RSB1.
        %RA-Remove
         apply remove_all_twice to RSA1 RA. search.
        %RA-Keep
         apply RA to _.
     %RS-Later
      N: case RSB. apply N to _.
  %RS-Later
   RSB: case RSB.
     %RS-FirstScope
      apply no_lookup_mem to RSA RSB.
     %RS-Later
      apply IH to RSA1 RSB1. search.

Theorem updateListIndex_is_integer : forall L I V L',
  updateListIndex L I V L' -> is_integer I.
induction on 1. intros ULI. ULI: case ULI.
  %ULI-0
   search.
  %ULI-Step
   IsI1: apply IH to ULI3.
   apply minus_integer_is_integer_result to _ ULI1. search.

Theorem updateListIndex_pos : forall L I V L',
  updateListIndex L I V L' -> I >= 0.
induction on 1. intros ULI.
IsI: apply updateListIndex_is_integer to ULI. ULI: case ULI.
  %ULI-0
   search.
  %ULI-Step
   GEq: apply IH to ULI3. P: apply minus_plus_same_integer to _ _ ULI1.
   IsI1: apply updateListIndex_is_integer to ULI3.
   P': apply plus_integer_comm to _ _ P. L: apply lt_plus_one to P' _.
   LEq: case GEq. L': apply lesseq_less_integer_transitive to LEq L.
   G: assert I > 0. apply greater_integer_greatereq to G. search.

Define listy : value -> prop by
listy (recVal Fields) := lookup Fields "null" trueVal;
listy (recVal Fields) :=
   exists Tl,
     lookup Fields "null" falseVal /\
     lookup Fields "tail" Tl /\ listy Tl.

%flip first list onto second, producing third
Define flipOnto : value -> value -> value -> prop by
flipOnto (recVal Fields) L L := lookup Fields "null" trueVal;
flipOnto (recVal Fields) L L' :=
  exists Fields' T,
    lookup Fields "null" falseVal /\
    lookup Fields "tail" T /\
    replaceRecVal "tail" L Fields Fields' /\
    flipOnto T (recVal Fields') L'.

Theorem lookup_replaceRecVal_exists : forall L F V V',
  lookup L F V -> exists R, replaceRecVal F V' L R.
induction on 1. intros L. L: case L.
  %Lkp-Here
   search.
  %Lkp-Later
   assert F = K -> false. intros E. case E. backchain L.
   apply IH to L1 with V' = V'. search.

Theorem replaceScopes_lookupScopes[Key, Item] :
  forall (X : Key) (V : Item) L R,
    replaceScopes X V L R -> lookupScopes X R V.
induction on 1. intros RS. RS: case RS.
  %RS-FirstScope
   search.
  %RS-Later
   apply IH to RS1. search.

Theorem replaceRecVal_lookup : forall L F V R,
  replaceRecVal F V L R -> lookup R F V.
induction on 1. intros R. R: case R.
  %RRV-Here
   search.
  %RRV-Later
   assert O = F -> false. intros E. case E. backchain R.
   apply IH to R1. search.

Theorem replaceRecVal_lookup_other : forall L F V R F' V',
  replaceRecVal F V L R -> lookup L F' V' -> (F = F' -> false) ->
  lookup R F' V'.
induction on 2. intros RRV L NEq. L: case L.
  %Lkp-Here
   RRV: case RRV.
     %RRV-Here
      apply NEq to _.
     %RRV-Later
      search.
  %Lkp-Later
   RRV: case RRV.
     %RRV-here
      search.
     %RRV-Later
      apply IH to RRV1 L1 _. search.

Theorem replaceRecVal_twice : forall A B C F V1 V2,
  replaceRecVal F V1 A B -> replaceRecVal F V2 B C ->
  replaceRecVal F V2 A C.
induction on 1. intros RAB RBC. RAB: case RAB.
  %RRV-Here
   RBC: case RBC.
     %RRV-Here
      search.
     %RRV-Later
      apply RBC to _.
  %RRV-Later
   RBC: case RBC.
     %RRV-Here
      apply RAB to _.
     %RRV-Later
      apply IH to RAB1 RBC1. search.

Theorem eval_update_loop2 :
  forall (Hold SaveI SaveE Copy L : string) V HFs HoldL LVal G FE,
    listy HoldL ->
    is_list (is_pair is_string
            (is_pair is_string
            (is_pair is_value
            (is_pair (is_list is_string) is_stmt)))) FE ->
    is_list (is_list (is_pair is_string is_value))
        ([(Hold, recVal HFs), (SaveI, intVal 0), (SaveE, V)]::G) ->
    lookup HFs "tail" HoldL -> lookup HFs "null" falseVal ->
    (Hold = SaveI -> false) -> (Hold = L -> false) ->
    (SaveI = SaveE -> false) -> (SaveI = L -> false) ->
    (Hold = SaveE -> false) -> (SaveE = L -> false) ->
    (Copy = Hold -> false) -> (Copy = L -> false) ->
    (SaveI = Copy -> false) -> (SaveE = Copy -> false) ->
    lookupScopes L ([(Hold, recVal HFs), (SaveI, intVal 0),
                     (SaveE, V)]::G) LVal ->
    exists G' LV HFs',
      <evalStmt {P}> FE
             ([(Hold, recVal HFs), (SaveI, intVal 0), (SaveE, V)]::G)
             (while (not (null (name Hold)))
                 (seq (declare intTy Copy (name Hold))
                 (seq (recUpdate Copy ["tail"] (name L))
                 (seq (assign L (name Copy))
                      (assign Hold (tail (name Hold)))))))
             ([(Hold, recVal HFs'), (SaveI, intVal 0),
               (SaveE, V)]::G') [] /\
      lookup HFs' "null" trueVal /\
      replaceScopes L LV G G' /\
      flipOnto (recVal HFs) LVal LV.
induction on 1. intros ListyH IsFE IsCtx LkpTl LkpNl NEqHI NEqHL NEqIE
                       NEqIL NEqHE NEqEL NEqCH NEqCL NEqIC NEqEC LS.
NamesCtx: apply names_exists to IsCtx. rename N to Names.
ListyH: case ListyH.
  %nil-esque
   EvCondA: assert <evalExpr {P}>
                     FE ([]::[(Hold, recVal HFs),
                              (SaveI, intVal 0), (SaveE, V)]::G)
                     (not (null (name Hold))) trueVal
                     ([]::[(Hold, recVal HFs),
                           (SaveI, intVal 0), (SaveE, V)]::G) [].
     unfold. unfold.
     exists Names, recFieldAccess (name Hold) "null", falseVal,
        []::[(Hold, recVal HFs), (SaveI, intVal 0), (SaveE, V)]::G,
        [], HFs. search.
   EvBody1: assert <evalStmt {P}> FE
                     ([]::[(Hold, recVal HFs),
                           (SaveI, intVal 0), (SaveE, V)]::G)
                     (declare intTy Copy (name Hold))
                     ([(Copy, recVal HFs)]::
                      [(Hold, recVal HFs), (SaveI, intVal 0),
                       (SaveE, V)]::G) [].
   RRVCopy: apply lookup_replaceRecVal_exists to LkpTl with V' = LVal.
   EvBody2: assert <evalStmt {P}> FE
                     ([(Copy, recVal HFs)]::
                      [(Hold, recVal HFs), (SaveI, intVal 0),
                       (SaveE, V)]::G)
                     (recUpdate Copy ["tail"] (name L))
                     ([(Copy, recVal R)]::
                      [(Hold, recVal HFs), (SaveI, intVal 0),
                       (SaveE, V)]::G) [].
   apply lookupScopes_is to _ LS.
   RS: apply lookupScopes_replaceScopes_exists to _ _ LS with
          V' = recVal R.
   EvBody3: assert <evalStmt {P}> FE
                     ([(Copy, recVal R)]::
                      [(Hold, recVal HFs), (SaveI, intVal 0),
                       (SaveE, V)]::G)
                     (assign L (name Copy))
                     ([(Copy, recVal R)]::R1) [].
   Eq: assert exists R',
         R1 = [(Hold, recVal HFs), (SaveI, intVal 0), (SaveE, V)]::R'.
     RS: case RS.
       %RS-FirstScope
        M: case RS. apply NEqHL to _. M: case M. apply NEqIL to _.
        M: case M. apply NEqEL to _. case M.
       %RS-Later
        search.
   case Eq. Is: case IsCtx. Is: case Is. Is: case Is. case Is3.
   apply replaceRecVal_is to _ _ RRVCopy.
   Is+: apply replaceScopes_is to _ _ RS. apply names_exists to Is+.
   EvBody4: assert <evalStmt {P}> FE
                     ([(Copy, recVal R)]::[(Hold, recVal HFs),
                         (SaveI, intVal 0), (SaveE, V)]::R')
                     (assign Hold (tail (name Hold)))
                     ([(Copy, recVal R)]::[(Hold, recVal Fields),
                         (SaveI, intVal 0), (SaveE, V)]::R') [].
     unfold. exists recVal Fields,
        [(Copy, recVal R)]::[(Hold, recVal HFs), (SaveI, intVal 0),
                             (SaveE, V)]::R'. split.
       %eval tail(Hold)
        unfold. exists Copy::N, recFieldAccess (name Hold) "tail",
                   recVal Fields,
                   [(Copy, recVal R)]::[(Hold, recVal HFs),
                              (SaveI, intVal 0), (SaveE, V)]::R', [],
                   HFs. split.
          %eval Hold
           search.
          %lookup tail
           search.
          %names
           search.
          %proj
           search.
          %eval proj
           search.
       %replaceScopes
        unfold. search.
        unfold. exists recVal HFs. split. search.
          unfold. unfold. intros E. case E. backchain NEqHI.
          unfold. intros E. case E. backchain NEqHE. search.
   IsV: apply lookup_is_value to _ LkpTl. case IsV.
   case Is+.
   apply names_exists to _ with
      L = [(Hold, recVal Fields), (SaveI, intVal 0), (SaveE, V)]::R'.
   EvCond2: assert <evalExpr {P}> FE
                      ([(Hold, recVal Fields), (SaveI, intVal 0),
                        (SaveE, V)]::R')
                      (not (null (name Hold))) falseVal
                      ([(Hold, recVal Fields), (SaveI, intVal 0),
                        (SaveE, V)]::R') [].
     unfold. unfold. exists N1, recFieldAccess (name Hold) "null",
                        trueVal, [(Hold, recVal Fields),
                           (SaveI, intVal 0), (SaveE, V)]::R', [],
                        Fields. split.
       %eval Hold
        search.
       %lookup null
        search.
       %names
        search.
       %proj
        search.
       %eval proj
        search.
   exists R', recVal R, Fields. split.
     %eval while
      search 7.
     %lookup null
      search.
     %replaceScopes
      RS: case RS.
        %RS-FirstScope
         apply NEqHL to _.
        %RS-Later
         search.
     %flipOnto
      search.
  %cons-esque
   EvCondA: assert <evalExpr {P}>
                     FE ([]::[(Hold, recVal HFs),
                              (SaveI, intVal 0), (SaveE, V)]::G)
                     (not (null (name Hold))) trueVal
                     ([]::[(Hold, recVal HFs),
                           (SaveI, intVal 0), (SaveE, V)]::G) [].
     unfold. unfold.
     exists Names, recFieldAccess (name Hold) "null", falseVal,
        []::[(Hold, recVal HFs), (SaveI, intVal 0), (SaveE, V)]::G,
        [], HFs. search.
   EvBody1: assert <evalStmt {P}> FE
                     ([]::[(Hold, recVal HFs),
                           (SaveI, intVal 0), (SaveE, V)]::G)
                     (declare intTy Copy (name Hold))
                     ([(Copy, recVal HFs)]::
                      [(Hold, recVal HFs), (SaveI, intVal 0),
                       (SaveE, V)]::G) [].
   RRVCopy: apply lookup_replaceRecVal_exists to LkpTl with V' = LVal.
   EvBody2: assert <evalStmt {P}> FE
                     ([(Copy, recVal HFs)]::
                      [(Hold, recVal HFs), (SaveI, intVal 0),
                       (SaveE, V)]::G)
                     (recUpdate Copy ["tail"] (name L))
                     ([(Copy, recVal R)]::
                      [(Hold, recVal HFs), (SaveI, intVal 0),
                       (SaveE, V)]::G) [].
   apply lookupScopes_is to _ LS.
   RS: apply lookupScopes_replaceScopes_exists to _ _ LS with
          V' = recVal R.
   EvBody3: assert <evalStmt {P}> FE
                     ([(Copy, recVal R)]::
                      [(Hold, recVal HFs), (SaveI, intVal 0),
                       (SaveE, V)]::G)
                     (assign L (name Copy))
                     ([(Copy, recVal R)]::R1) [].
   Eq: assert exists R',
         R1 = [(Hold, recVal HFs), (SaveI, intVal 0), (SaveE, V)]::R'.
     RS: case RS.
       %RS-FirstScope
        M: case RS. apply NEqHL to _. M: case M. apply NEqIL to _.
        M: case M. apply NEqEL to _. case M.
       %RS-Later
        search.
   case Eq. Is: case IsCtx. Is: case Is. Is: case Is. case Is3.
   apply replaceRecVal_is to _ _ RRVCopy.
   Is+: apply replaceScopes_is to _ _ RS. apply names_exists to Is+.
   EvBody4: assert <evalStmt {P}> FE
                     ([(Copy, recVal R)]::[(Hold, recVal HFs),
                         (SaveI, intVal 0), (SaveE, V)]::R')
                     (assign Hold (tail (name Hold)))
                     ([(Copy, recVal R)]::[(Hold, recVal Fields),
                         (SaveI, intVal 0), (SaveE, V)]::R') [].
     unfold. exists recVal Fields,
        [(Copy, recVal R)]::[(Hold, recVal HFs), (SaveI, intVal 0),
                             (SaveE, V)]::R'. split.
       %eval tail(Hold)
        unfold. exists Copy::N, recFieldAccess (name Hold) "tail",
                   recVal Fields,
                   [(Copy, recVal R)]::[(Hold, recVal HFs),
                              (SaveI, intVal 0), (SaveE, V)]::R', [],
                   HFs. split.
          %eval Hold
           search.
          %lookup tail
           search.
          %names
           search.
          %proj
           search.
          %eval proj
           search.
       %replaceScopes
        unfold. search.
        unfold. exists recVal HFs. split. search.
          unfold. unfold. intros E. case E. backchain NEqHI.
          unfold. intros E. case E. backchain NEqHE. search.
   IsV: apply lookup_is_value to _ LkpTl. case IsV.
   case Is+. LS': apply replaceScopes_lookupScopes to RS.
   LS'': assert lookupScopes L ([(Hold, recVal Fields),
                   (SaveI, intVal 0), (SaveE, V)]::R') (recVal R).
     LS': case LS'.
       %LS-FirstScope
        L: case LS'. apply NEqHL to _. L': case L1. L'': case L'1.
        apply NEqEL to _. case L''1.
       %LS-Later
        search.
   Sub: apply IH to ListyH2 IsFE _ ListyH1 ListyH NEqHI NEqHL
               NEqIE NEqIL NEqHE NEqEL NEqCH NEqCL NEqIC NEqEC LS''.
   exists G', LV, HFs'. split.
     %eval
      search 20.
     %lookup null
      search.
     %replaceScopes
      RS: case RS.
        %RS-FirstScope
         apply NEqHL to _.
        %RS-Later
         apply replaceScopes_twice to RS1 Sub2. search.
     %flipOnto
      search.

Theorem proj_listUpdate_eval :
  forall OldL I (Hold SaveI SaveE Copy L : string) HoldL V NewL G FE,
    updateListIndex OldL I V NewL ->
    (Hold = SaveI -> false) -> (Hold = L -> false) ->
    (SaveI = SaveE -> false) -> (SaveI = L -> false) ->
    (Hold = SaveE -> false) -> (SaveE = L -> false) ->
    (Copy = Hold -> false) -> (Copy = L -> false) ->
    (SaveI = Copy -> false) -> (SaveE = Copy -> false) ->
    listy HoldL ->
    I >= 0 ->
    is_list (is_pair is_string
            (is_pair is_string
            (is_pair is_value
            (is_pair (is_list is_string) is_stmt)))) FE ->
    is_list (is_list (is_pair is_string is_value))
       ([(Hold, HoldL), (SaveI, intVal I), (SaveE, V)]::G) ->
    is_string Copy ->
    lookupScopes L ([(Hold, HoldL), (SaveI, intVal I), (SaveE, V)]::G)
                 OldL ->
    exists G' LV HFs,
      <evalStmt {P}> FE
         ([(Hold, HoldL), (SaveI, intVal I), (SaveE, V)]::G)
         (seq (while (exactEval:host:and (not (eq (name SaveI) (num 0)))
                                       (not (null (name L))))
                   (seq (assign SaveI (minus (name SaveI) (num 1)))
                   (seq (declare intTy Copy (name L))
                   (seq (recUpdate Copy ["tail"] (name Hold))
                   (seq (assign Hold (name Copy))
                        (assign L (tail (name L))))))))
           (seq (ifThenElse (null (name L))
                    (declare intTy Copy
                        (errorExpr (stringLit "Invalid update") intTy))
                    noop)
           (seq (recUpdate L ["head"] (name SaveE))
                (while (not (null (name Hold)))
                     (seq (declare intTy Copy (name Hold))
                     (seq (recUpdate Copy ["tail"] (name L))
                     (seq (assign L (name Copy))
                          (assign Hold (tail (name Hold))))))))))
         ([(Hold, recVal HFs), (SaveI, intVal 0), (SaveE, V)]::G') [] /\
      lookup HFs "null" trueVal /\
      replaceScopes L LV G G' /\
      flipOnto HoldL NewL LV.
induction on 1. intros ULI NEqHI NEqHL NEqIE NEqIL NEqHE NEqEL NEqCH
                       NEqCL NEqIC NEqEC ListyH GEqI0 IsFE Is+ IsC LS.
ULI: case ULI.
  %ULI-0
   EvLoop1:
      assert <evalStmt {P}> FE
                 ([(Hold, HoldL), (SaveI, intVal 0),
                   (SaveE, V)]::G)
                 (while (exactEval:host:and
                            (not (eq (name SaveI) (num 0)))
                            (not (null (name L))))
                   (seq (assign SaveI (minus (name SaveI) (num 1)))
                   (seq (declare intTy Copy (name L))
                   (seq (recUpdate Copy ["tail"] (name Hold))
                   (seq (assign Hold (name Copy))
                        (assign L (tail (name L))))))))
                 ([(Hold, HoldL), (SaveI, intVal 0),
                       (SaveE, V)]::G) []. search 10.
   EvCheck:
      assert <evalStmt {P}> FE
                 ([(Hold, HoldL), (SaveI, intVal 0),
                       (SaveE, V)]::G)
                 (ifThenElse (null (name L))
                    (declare intTy Copy
                        (errorExpr (stringLit "Invalid update") intTy))
                    noop)
                 ([(Hold, HoldL), (SaveI, intVal 0),
                       (SaveE, V)]::G) [].
     Names: apply names_exists to Is+. search 10.
   EvMid: assert exists G',
             <evalStmt {P}> FE
               ([(Hold, HoldL), (SaveI, intVal 0),
                 (SaveE, V)]::G)
               (recUpdate L ["head"] (name SaveE))
               ([(Hold, HoldL), (SaveI, intVal 0),
                 (SaveE, V)]::G') [] /\
             replaceScopes L (recVal NewFields) G G'.
     IsL: apply lookupScopes_is to _ LS.
     RS: apply lookupScopes_replaceScopes_exists to _ _ LS with
           V' = recVal NewFields. RS: case RS (keep).
       %RS-FirstScope
        M: case RS1. apply NEqHL to _. M: case M. apply NEqIL to _.
        M: case M. apply NEqEL to _. case M.
       %RS-Later
        search 20.
   EvMid: case EvMid.
   ListyH': case ListyH (keep).
     %nil-esque
      exists G', recVal NewFields, Fields1. split.
        %eval
         unfold. exists ([(Hold, recVal Fields1),
                          (SaveI, intVal 0), (SaveE, V)]::G),
                        [], []. split.
           %loop 1
            search.
           %rest
            unfold. exists [(Hold, recVal Fields1),
                       (SaveI, intVal 0), (SaveE, V)]::G, [], [].
            split.
              %ifThenElse
               search.
              %rest
               unfold. exists [(Hold, recVal Fields1),
                          (SaveI, intVal 0), (SaveE, V)]::G', [], [].
               split.
                 %mid assign
                  search.
                 %loop 2
                  IsLV: apply lookupScopes_is to _ LS. case IsLV.
                  Is: case Is+. Is: case Is. Is: case Is2.
                  Is: case Is3. case Is3.
                  apply replaceRecVal_is to _ _ ULI1.
                  IsG': apply replaceScopes_is to _ _ EvMid1.
                  apply names_exists to IsG'.
                  assert (Hold::SaveI::SaveE::N) |{expr}-
                           null (name Hold) ~~>
                           recFieldAccess (name Hold) "null".
                  search 20.
                 %append output
                  search.
              %append output
               search.
        %append output
         search.
        %matchInt
         search.
        %replaceScopes
         search.
        %flipOnto
         search.
     %cons-esque
      LS': assert lookupScopes L ([(Hold, recVal Fields1),
                                   (SaveI, intVal 0), (SaveE, V)]::G')
                               (recVal NewFields).
        apply replaceScopes_lookupScopes_same to EvMid1. search.
      IsL: apply lookupScopes_is to _ LS.
      Is: case Is+. Is: case Is. Is: case Is2. Is: case Is3.
      Is: case Is3. EvMid': apply drop_proj_rel_evalStmt to EvMid.
      apply lookupScopes_is to _ LS.
      apply evalStmt_isCtx to _ _ _ EvMid'. search 10.
      EvLoop2:
         apply eval_update_loop2 to _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
            with Hold = Hold, SaveI = SaveI, SaveE = SaveE, L = L,
                 V = V, HoldL = Tl, LVal = recVal NewFields,
                 G = G', FE = FE, Copy = Copy.
      exists G'1, LV, HFs'. split.
        %eval
         unfold. exists ([(Hold, recVal Fields1), (SaveI, intVal 0),
                          (SaveE, V)]::G), [], []. split.
           %loop 1
            search.
           %rest
            unfold. exists [(Hold, recVal Fields1), (SaveI, intVal 0),
                            (SaveE, V)]::G, [], []. split.
              %ifThenElse
               search.
              %rest
               unfold. exists [(Hold, recVal Fields1),
                               (SaveI, intVal 0), (SaveE, V)]::G',
                              [], []. split.
                 %mid assign
                  search.
                 %loop 2
                  search.
                 %append output
                  search.
              %append output
               search.
        %append output
         search.
        %lookup null
         search.
        %replaceScopes
         apply replaceScopes_twice to EvMid1 EvLoop4. search.
        %flipOnto
         search.
  %ULI-Step
   GEqI1: apply updateListIndex_pos to ULI3.
   EvCond1: assert <evalExpr {P}> FE
                      ([(Hold, HoldL), (SaveI, intVal I),
                        (SaveE, V)]::G)
                      (not (eq (name SaveI) (num 0))) trueVal
                      ([(Hold, HoldL), (SaveI, intVal I),
                        (SaveE, V)]::G) [].
     unfold. unfold.
     exists intVal I, [(Hold, HoldL), (SaveI, intVal I),
                       (SaveE, V)]::G, [], intVal 0, []. split.
       %eval SaveI
        search.
       %eval 0 0
        search.
       %intVal I != intVal 0
        Or: apply greatereq_integer_greater_or_eq to GEqI0.
        C: case Or.
          %I > 0
           intros E. case E. apply greater_integer_not_eq to C.
          %I = 0
           compute ULI1. LEq: case GEqI1. case LEq.
       %append output
        search.
   EvCond2: assert <evalExpr {P}> FE
                      ([(Hold, HoldL), (SaveI, intVal I),
                        (SaveE, V)]::G)
                      (not (null (name L))) trueVal
                      ([(Hold, HoldL), (SaveI, intVal I),
                        (SaveE, V)]::G) [].
     apply names_exists to Is+. search.
   EvCond: assert <evalExpr {P}> FE
                      ([(Hold, HoldL), (SaveI, intVal I),
                        (SaveE, V)]::G)
                      (exactEval:host:and
                         (not (eq (name SaveI) (num 0)))
                         (not (null (name L)))) trueVal
                      ([(Hold, HoldL), (SaveI, intVal I),
                        (SaveE, V)]::G) [].
   EvBodyA: assert
              <evalStmt {P}> FE
                 ([]::[(Hold, HoldL), (SaveI, intVal I),
                       (SaveE, V)]::G)
                 (assign SaveI (minus (name SaveI) (num 1)))
                 ([]::[(SaveI, intVal I1), (Hold, HoldL),
                       (SaveE, V)]::G) [].
     unfold. exists intVal I1,
               []::[(Hold, HoldL), (SaveI, intVal I), (SaveE, V)]::G.
     split.
       %eval Savei - 1
        search 20.
       %replaceScopes
        assert SaveE = SaveI -> false.
          intros E. case E. backchain NEqIE.
        search 20.
   EvBodyB: assert
               <evalStmt {P}> FE
                  ([]::[(SaveI, intVal I1), (Hold, HoldL),
                        (SaveE, V)]::G)
                  (declare intTy Copy (name L))
                  ([(Copy, recVal Fields)]::[(SaveI, intVal I1),
                       (Hold, HoldL), (SaveE, V)]::G) [].
     unfold. unfold. LS: case LS.
       %LS-FirstScope
        L: case LS. apply NEqHL to _. L': case L1. L'': case L'1.
        apply NEqEL to _. case L''1.
       %LS-Later
        search 10.
   RRV: apply lookup_replaceRecVal_exists to ULI2 with V' = HoldL.
   EvBodyC: assert
               <evalStmt {P}> FE
                  ([(Copy, recVal Fields)]::[(SaveI, intVal I1),
                      (Hold, HoldL), (SaveE, V)]::G)
                  (recUpdate Copy ["tail"] (name Hold))
                  ([(Copy, recVal R)]::[(SaveI, intVal I1),
                      (Hold, HoldL), (SaveE, V)]::G) [].
     unfold. exists HoldL,
               [(Copy, recVal Fields)]::[(SaveI, intVal I1),
                   (Hold, HoldL), (SaveE, V)]::G, Fields, R. split.
       %eval Hold
        assert SaveI = Hold -> false. intros E. case E. backchain NEqHI.
        search.
       %lookupScopes Copy
        search.
       %updateRecFields
        search.
       %replaceScopes
        search.
   EvBodyD: assert
               <evalStmt {P}> FE
                  ([(Copy, recVal R)]::[(SaveI, intVal I1),
                       (Hold, HoldL), (SaveE, V)]::G)
                  (assign Hold (name Copy))
                  ([(Copy, recVal R)]::[(Hold, recVal R),
                       (SaveI, intVal I1), (SaveE, V)]::G) [].
     unfold. exists recVal R, [(Copy, recVal R)]::[(SaveI, intVal I1),
                                 (Hold, HoldL), (SaveE, V)]::G. split.
       %eval Copy
        search.
       %replaceScopes
        assert SaveI = Hold -> false.
          intros E. case E. backchain NEqHI.
        assert SaveE = Hold -> false.
          intros E. case E. backchain NEqHE.
        search 20.
   LS': assert lookupScopes L G (recVal Fields).
     LS: case LS.
       %LS-FirstScope
        L: case LS. apply NEqHL to _. L': case L1. L'': case L'1.
        apply NEqEL to _. case L''1.
       %LS-Later
        search.
   apply lookupScopes_is to _ LS. Is: case Is+.
   apply lookupScopes_replaceScopes_exists to _ _ LS' with V' = Tl.
   EvBodyE: assert
               <evalStmt {P}> FE
                  ([(Copy, recVal R)]::[(Hold, recVal R),
                       (SaveI, intVal I1), (SaveE, V)]::G)
                  (assign L (tail (name L)))
                  ([(Copy, recVal R)]::[(Hold, recVal R),
                       (SaveI, intVal I1), (SaveE, V)]::R1) [].
     unfold. exists Tl, [(Copy, recVal R)]::[(Hold, recVal R),
                            (SaveI, intVal I1), (SaveE, V)]::G.
     split.
       %eval tail(L)
        apply names_exists to Is1. unfold.
        exists Copy::Hold::SaveI::SaveE::N,
           recFieldAccess (name L) "tail", Tl,
           [(Copy, recVal R)]::[(Hold, recVal R),
              (SaveI, intVal I1), (SaveE, V)]::G, [], Fields. split.
          %eval L
           search 20.
          %lookup tail
           search.
          %names
           search 10.
          %proj
           search.
          %eval proj
           search 20.
       %replaceScopes
        search 20.
   EvBody: assert
             <evalStmt {P}> FE
               ([]::[(Hold, HoldL), (SaveI, intVal I), (SaveE, V)]::G)
               (seq (assign SaveI (minus (name SaveI) (num 1)))
                 (seq (declare intTy Copy (name L))
                 (seq (recUpdate Copy ["tail"] (name Hold))
                 (seq (assign Hold (name Copy))
                       (assign L (tail (name L)))))))
               ([(Copy, recVal R)]::[(Hold, recVal R),
                       (SaveI, intVal I1), (SaveE, V)]::R1) [].
   clear EvBodyA EvBodyB EvBodyC EvBodyD EvBodyE. %no longer needed
   ListyH': assert listy (recVal R).
     apply replaceRecVal_lookup to RRV.
     apply replaceRecVal_lookup_other to RRV ULI _. search.
   Is: case Is. Is: case Is2. Is: case Is2. case Is4.
   apply minus_integer_is_integer to _ _ ULI1.
   EvBody': apply drop_proj_rel_evalStmt to EvBody.
   case Is. Is: case Is3. case Is.
   IsR1+: apply evalStmt_isCtx to _ _ _ EvBody'. search 10. search 20.
   assert lookupScopes L ([(Hold, recVal R), (SaveI, intVal I1),
                          (SaveE, V)]::R1) Tl.
     apply replaceScopes_lookupScopes_same to H3. search.
   case IsR1+.
   Sub: apply IH to ULI3 NEqHI NEqHL NEqIE NEqIL NEqHE NEqEL NEqCH
                    NEqCL NEqIC NEqEC ListyH' _ IsFE _ IsC _.
   EvSub: case Sub. %split this to build eval for first loop
   case EvSub2.
   EvLoop1: assert
      <evalStmt {P}> FE
         ([(Hold, HoldL), (SaveI, intVal I), (SaveE, V)]::G)
         (while (exactEval:host:and
                   (not (eq (name SaveI) (num 0)))
                   (not (null (name L))))
            (seq (assign SaveI (minus (name SaveI) (num 1)))
            (seq (declare intTy Copy (name L))
            (seq (recUpdate Copy ["tail"] (name Hold))
            (seq (assign Hold (name Copy))
                 (assign L (tail (name L)))))))) EE1 [].
   exists G', LV, HFs. split.
     %eval
      search.
     %lookup null
      search.
     %replaceScopes
      apply replaceScopes_twice to H3 Sub2. search.
     %flipOnto
      FO: case Sub3.
        %nil-esque
         L: apply replaceRecVal_lookup_other to RRV ULI _.
         apply lookup_unique to FO L.
        %cons-esque
         L: apply replaceRecVal_lookup to RRV.
         apply lookup_unique to FO1 L.
         RRV': apply replaceRecVal_twice to RRV FO2.
         apply replaceRecVal_unique to RRV' ULI4. search.

Theorem replaceScopes_lookupScopes_other[Key, Item] :
  forall (X : Key) (XV : Item) L R Y YV,
    replaceScopes X XV L R -> lookupScopes Y L YV ->
    (X = Y -> false) -> lookupScopes Y R YV.
induction on 2. intros RS LS NEq. LS: case LS.
  %LS-FirstScope
   RS: case RS.
     %RS-FirstScope
      apply remove_all_lookup_other_back to RS1 LS _. search.
     %RS-Later
      search.
  %LS-Later
   RS: case RS.
     %RS-FirstScope
      apply remove_all_no_lookup_back to RS1 LS. search.
     %RS-Later
      apply IH to RS1 LS1 _. search.

Theorem eval_update_loop2_listy :
  forall (Hold Copy L : string) FE G G' O LVal HVal,
    evalStmt FE G
          (while (not (null (name Hold)))
              (seq (declare intTy Copy (name Hold))
              (seq (recUpdate Copy ["tail"] (name L))
              (seq (assign L (name Copy))
                   (assign Hold (tail (name Hold)))))))
          G' O ->
    (Hold = L -> false) -> (Copy = Hold -> false) ->
    (Copy = L -> false) ->
    lookupScopes L G LVal ->
    lookupScopes Hold G HVal ->
    exists LV, listy HVal /\ flipOnto HVal LVal LV.
induction on 1. intros Ev NEqHL NEqCH NEqCL LL LH. Ev: case Ev.
  %E-While-True
   clear Ev3 Ev4. EvC: case Ev. EvC: case EvC. LH': case EvC.
   apply lookupScopes_unique to LH' LH. clear LH'. EvB: case Ev1.
   clear EvB2. EvB: case EvB1. clear EvB3. EvB: case EvB2. clear EvB4.
   EvA: case EvB. L: case EvA. rename Fields to HFs.
   Eq: assert V = recVal HFs.
     L: case L. case L. apply lookupScopes_unique to L1 LH. search.
   case Eq. clear L. EvA: case EvB1. LL': case EvA.
   Eq: assert V1 = LVal.
     L: case LL'.
       %LS-FirstScope
        L: case L. apply NEqCL to _. case L1.
       %LS-Later
        apply lookupScopes_unique to L1 LL. search.
   case Eq. clear LL'.
   Eq: assert FieldVals = HFs.
     L: case EvA1.
       %LS-FirstScope
        L: case L. search. apply L to _.
       %LS-Later
        N: case L. apply N to _.
   case Eq. clear EvA1.
   Eq: assert EE4 = [(Copy, recVal NewVals)]::EE6.
     RS: case EvA3.
       %RS-FirstScope
        RA: case RS1. case RA. search. apply RA to _.
       %RS-Later
        N: case RS. apply N to _.
   case Eq. EvL: case EvB2. LC: case EvL.
   LC': apply replaceScopes_lookupScopes to EvA3.
   apply lookupScopes_unique to LC' LC. clear LC LC' EvA3.
   Eq: assert exists EE', EE5 = [(Copy, recVal NewVals)]::EE' /\
                          replaceScopes L (recVal NewVals) EE6 EE'.
     RS: case EvL1.
       %RS-FirstScope
        M: case RS. apply NEqCL to _. case M.
       %RS-Later
        search.
   RSL: case Eq. clear EvL1. EvH: case EvB3. EvH: case EvH.
   LH+: case EvH.
   Eq: assert Fields = HFs /\ lookupScopes Hold EE' (recVal HFs).
     L: case LH+.
       %LS-FirstScope
        L: case L. apply NEqCH to _. case L1.
       %LS-Later
        assert L = Hold -> false. intros E. case E. backchain NEqHL.
        LH': apply replaceScopes_lookupScopes_other to RSL LH _.
        apply lookupScopes_unique to L1 LH'. search.
   LH': case Eq. clear LH+.
   Eq: assert exists EE'', Scope = [(Copy, recVal NewVals)] /\
                 EE2 = EE'' /\ replaceScopes Hold V3 EE' EE''.
   RS: case EvH1.
     %RS-FirstScope
      M: case RS. apply NEqCH to _. case M.
     %RS-Later
      search.
   RSH: case Eq. clear EvH1.
   LL': apply replaceScopes_lookupScopes to RSL.
   LL'': apply replaceScopes_lookupScopes_other to RSH LL' _.
   LH'': apply replaceScopes_lookupScopes to RSH.
   Sub: apply IH to Ev2 NEqHL NEqCH NEqCL LL'' LH''.
   URF: case EvA2.
     %URF-One
      search.
     %URF-Step
      case URF1.
  %E-While-False
   Ev: case Ev. Ev: case Ev. L: case Ev.
   apply lookupScopes_unique to LH L. search.

Theorem replaceRecVal_other_val : forall F VA L R VB,
  replaceRecVal F VA L R -> exists R', replaceRecVal F VB L R'.
induction on 1. intros R. R: case R.
  %RRV-Here
   search.
  %RRV-Later
   apply IH to R1 with VB = VB. search.

Theorem proj_eval_listUpdate :
  forall OldL VI (Hold SaveI SaveE Copy L : string) HoldL V G FE G1 O1
         G2 O2,
    (Hold = SaveI -> false) -> (Hold = L -> false) ->
    (SaveI = SaveE -> false) -> (SaveI = L -> false) ->
    (Hold = SaveE -> false) -> (SaveE = L -> false) ->
    (Copy = Hold -> false) -> (Copy = L -> false) ->
    (SaveI = Copy -> false) -> (SaveE = Copy -> false) ->
    is_list (is_pair is_string
            (is_pair is_string
            (is_pair is_value
            (is_pair (is_list is_string) is_stmt)))) FE ->
    is_list (is_list (is_pair is_string is_value))
       ([(Hold, HoldL), (SaveI, VI), (SaveE, V)]::G) ->
    is_string Copy ->
    lookupScopes L G OldL ->
    evalStmt FE
       ([(Hold, HoldL), (SaveI, VI), (SaveE, V)]::G)
       (while (exactEval:host:and (not (eq (name SaveI) (num 0)))
                                (not (null (name L))))
            (seq (assign SaveI (minus (name SaveI) (num 1)))
            (seq (declare intTy Copy (name L))
            (seq (recUpdate Copy ["tail"] (name Hold))
            (seq (assign Hold (name Copy))
                 (assign L (tail (name L)))))))) G1 O1 ->
    evalExpr FE G1 (null (name L)) falseVal G1 [] ->
    evalStmt FE G1 (recUpdate L ["head"] (name SaveE)) G2 O2 ->
    exists I NewL, VI = intVal I /\ updateListIndex OldL I V NewL.
induction on 15. intros NEqHI NEqHL NEqIE NEqIL NEqHE NEqEL NEqCH
  NEqCL NEqIC NEqEC IsFE IsG+ IsCopy LS EvW EvNL EvA. EvW: case EvW.
  %E-While-True
   Is: case IsG+ (keep). Is: case Is. case Is. Is: case Is2.
   Is: case Is. Is: case Is2. case Is2. case Is4.
   apply lookupScopes_is to _ LS. apply evalExpr_isCtx to _ _ _ EvW.
   Is++: apply evalStmt_isCtx to _ _ _ EvW1. search 20.
   EvC: case EvW. clear EvC2. EvC: case EvC. EvC: case EvC. case EvC2.
   clear EvC4. LC: case EvC. Eq: assert V1 = VI.
     LS: case LC.
       %LS-FirstScope
        L: case LS1. apply NEqHI to _. L: case L1. search. L: case L2.
        apply L1 to _. case L3.
       %LS-Later
        N: case LS1. N: case N1. apply N1 to _.
   case Eq. clear LC EvC3 EvW4 EvW3. EvC: case EvC1. EvC: case EvC.
   LC: case EvC. Eq: assert OldL = recVal Fields.
     L: case LC.
       %LS-FirstScope
        L: case L. apply NEqHL to _. L: case L1. apply NEqIL to _.
        L: case L2. apply NEqEL to _. case L3.
       %LS-Later
        apply lookupScopes_unique to LS L1. search.
   case Eq. clear LC. EvB: case EvW1. EvB: case EvB1.
   EvB: case EvB3. EvB: case EvB5. clear EvB8 EvB4 EvB2 EvB6.
   EvX: case EvB. EvX: case EvX. LI: case EvX. clear EvX4.
   Eq: assert VI = intVal I1.
     LS: case LI.
       %LS-FirstScope
        case LS1.
       %LS-Later
        LS': case LS2.
          %LS-FirstScope
           L: case LS'. apply NEqHI to _. L: case L1. search.
           L: case L2. apply L1 to _. case L3.
          %LS-Later
           N: case LS'. N: case N1. apply N1 to _.
   case Eq. clear LI. case EvX2. rename EvX3 to Minus.
   Eq: assert EE5 = []::[(SaveI, intVal I), (Hold, HoldL),
                         (SaveE, V)]::G.
     RS: case EvX1.
       %RS-FirstScope
        case RS.
       %RS-Later
        RS': case RS1.
          %RS-FirstScope
           RA: case RS'1. apply NEqHI to _. RA: case RA1.
           RA: case RA1. apply NEqIE to _. case RA2. search.
           apply RA1 to _.
          %RS-Later
           N: case RS'. N: case N1. apply N1 to _.
   case Eq. clear EvX1. EvX: case EvB1.
   Eq: assert V4 = recVal Fields /\ Scope1 = [] /\
          EE11 = [(SaveI, intVal I), (Hold, HoldL), (SaveE, V)]::G.
     L: case EvX. L: case L.
       %LS-FirstScope
        case L.
       %LS-Later
        L: case L1.
          %LS-FirstScope
           L: case L1. apply NEqIL to _. L: case L2. apply NEqHL to _.
           L: case L3. apply NEqEL to _. case L4.
          %LS-Later
           apply lookupScopes_unique to L2 LS. search.
   case Eq. clear EvX. EvRC: case EvB3.
   Eq: assert Fields = FieldVals.
     L: case EvRC1.
       %LS-FirstScope
        L: case L. search. case L1.
       %LS-Later
        N: case L. apply N to _.
   case Eq. clear EvRC1.
   Eq: assert V5 = HoldL /\
          EE12 = [(Copy, recVal FieldVals)]::[(SaveI, intVal I),
                    (Hold, HoldL), (SaveE, V)]::G.
     EvH: case EvRC. L: case EvH.
       %LS-FirstScope
        L: case L. apply NEqCH to _. case L1.
       %LS-Later
        L: case L1.
          %LS-FirstScope
           L: case L1. apply NEqHI to _. L: case L2. search.
           apply L2 to _.
          %LS-Later
           N: case L1. N: case N1. apply N1 to _.
   case Eq. clear EvRC.
   Eq: assert EE7 = [(Copy, recVal NewVals)]::[(SaveI, intVal I),
                     (Hold, HoldL), (SaveE, V)]::G.
     RS: case EvRC3.
       %RS-FirstScope
        RA: case RS1. case RA. search. apply RA to _.
       %RS-Later
        N: case RS. apply N to _.
   case Eq. clear EvRC3. EvHC: case EvB5.
   Eq: assert V6 = recVal NewVals /\
          EE13 = [(Copy, recVal NewVals)]::[(SaveI, intVal I),
                     (Hold, HoldL), (SaveE, V)]::G.
     E: case EvHC. L: case E.
       %LS-FirstScope
        L: case L. search. apply L to _.
       %LS-Later
        N: case L. apply N to _.
   case Eq. clear EvHC.
   Eq: assert EE8 = [(Copy, recVal NewVals)]::[(Hold, recVal NewVals),
                         (SaveI, intVal I), (SaveE, V)]::G.
     RS: case EvHC1.
       %RS-FirstScope
        M: case RS. apply NEqCH to _. case M.
       %RS-Later
        RS: case RS1.
          %RS-FirstScope
           RA: case RS2. apply NEqHI to _. RA: case RA1.
           RA: case RA1. apply NEqHE to _. case RA2. search.
           apply RA1 to _.
          %RS-Later
           N: case RS1. N: case N1. apply N1 to _.
   case Eq. clear EvHC1. EvB: case EvB7. Ev: case EvB. LSL: case Ev.
   Eq: assert Fields1 = FieldVals.
     LSL: case LSL.
       %LS-FirstScope
        L: case LSL. apply NEqCL to _. case L1.
       %LS-Later
        LS': case LSL1.
          %LS-FirstScope
           L: case LS'. apply NEqHL to _. L: case L1. L: case L2.
           apply NEqEL to _. case L3.
          %LS-Later
           apply lookupScopes_unique to LS'1 LS. search.
   case Eq. clear LSL.
   Eq: assert exists G', Scope = [(Copy, recVal NewVals)] /\
          EE2 = [(Hold, recVal NewVals), (SaveI, intVal I),
                 (SaveE, V)]::G' /\ lookupScopes L G' V7.
     RS: case EvB1.
       %RS-FirstScope
        M: case RS. apply NEqCL to _. case M.
       %RS-Later
        RS: case RS1.
          %RS-FirstScope
           M: case RS1. apply NEqHL to _. M: case M. apply NEqIL to _.
           M: case M. apply NEqEL to _. case M.
          %RS-Later
           apply replaceScopes_lookupScopes to RS2. search.
   LS': case Eq. clear EvB1. case Is++.
   ULI: apply IH to NEqHI NEqHL NEqIE NEqIL NEqHE NEqEL NEqCH NEqCL
                    NEqIC NEqEC IsFE _ IsCopy LS' EvW2 _ EvA.
   RRV: assert replaceRecVal "tail" HoldL FieldVals NewVals.
     RRV: case EvRC2.
       %URF-One
        search.
       %URF-Step
        case RRV1.
   RRV': apply replaceRecVal_other_val to RRV with VB = NewL. search.
  %E-While-False
   Eq: assert VI = intVal 0 /\
              G1 = [(Hold, HoldL), (SaveI, intVal 0), (SaveE, V)]::G.
     EvC: case EvW.
       %E-And-False1
        EvC: case EvC. EvC: case EvC. case EvC1. L: case EvC.
        L: case L.
          %LS-FirstScope
           L: case L. apply NEqHI to _. L: case L1. search.
           apply L1 to _.
          %LS-Later
           N: case L. N: case N1. apply N1 to _.
       %E-And-False2
        EvN: case EvC. EvN: case EvN. case EvN1. case EvN.
        EvL: case EvC1. EvL: case EvL (keep). case EvL1.
        case IsG+. apply lookupScopes_is to _ LS.
        apply evalExpr_unique to _ _ _ EvNL EvL.
   case Eq. clear EvW. EvA: case EvA. LL: case EvA.
   Eq: assert V1 = V.
     LL: case LL.
       %LS-FirstScope
        L: case LL. apply NEqHE to _. L: case L1. apply NEqIE to _.
        L: case L2. search. case L3.
       %LS-Later
        N: case LL. N: case N1. N: case N2. apply N2 to _.
   case Eq. clear LL.
   Eq: assert OldL = recVal FieldVals.
     L: case EvA1.
       %LS-FirstScope
        L: case L. apply NEqHL to _. L: case L1. L: case L2.
        apply NEqEL to _. case L3.
       %LS-Later
        apply lookupScopes_unique to LS L1. search.
   case Eq. clear EvA1. Is: case IsG+. apply lookupScopes_is to _ LS.
   apply lookupScopes_replaceScopes_exists to _ _ LS with
       V' = recVal NewVals.
   Eq: assert G2 = [(Hold, HoldL), (SaveI, intVal 0), (SaveE, V)]::R.
     RS: case EvA3.
       %RS-FirstScope
        M: case RS. apply NEqHL to _. M: case M. apply NEqIL to _.
        M: case M. apply NEqEL to _. case M.
       %RS-Later
        apply replaceScopes_unique to RS1 _. search.
   case Eq.
   assert replaceRecVal "head" V FieldVals NewVals.
     RRV: case EvA2. search. case RRV1.
   EvNL: case EvNL. EvNL: case EvNL. L: case EvNL.
     %LS-firstScope
      L: case L. apply NEqHL to _. L: case L1. L: case L2.
      apply NEqEL to _. case L3.
     %LS-Later
      apply lookupScopes_unique to L1 LS. search.


Prove_Constraint exactEval:host:proj_evalExpr_forward.
%Proj-Nil
 case Ev. apply scopes_same_reflexive to IsEE. search.
%Proj-Cons
 Ev: case Ev. case IsE. apply evalExpr_isCtx to _ _ _ Ev.
 IsEE': apply evalExpr_isCtx to _ _ _ Ev1.
 apply scopes_same_reflexive to IsEE'. exists EE'. split.
   %eval
    unfold. unfold. exists EE, [], O. split.
      %eval false
       search.
      %eval rest
       unfold. exists EE3, O2, O3. split.
         %eval V1
          search.
         %eval rest
          unfold. exists EE', O3, []. split.
            %eval V2
             search.
            %eval empty
             search.
            %append output
             IsO3: apply evalExpr_isOutput to _ _ _ Ev1.
             apply is_list_values_append_nil to IsO3. search.
         %append output
          search.
      %append output
       search.
   %scopes_same
    search.
%Proj-Head
 Ev: case Ev. case IsE. IsEE': apply evalExpr_isCtx to _ _ _ Ev.
 apply scopes_same_reflexive to IsEE'. search.
%Proj-Tail
 Ev: case Ev. case IsE. IsEE': apply evalExpr_isCtx to _ _ _ Ev.
 apply scopes_same_reflexive to IsEE'. search.
%Proj-Null
 Ev: case Ev. case IsE. IsEE': apply evalExpr_isCtx to _ _ _ Ev.
 apply scopes_same_reflexive to IsEE'. search.
%Proj-Index
 case IsE. Ev: case Ev.
 apply evalExpr_isCtx to _ _ _ Ev.
 IsIdx+: apply evalExpr_isValue to _ _ _ Ev1. case IsIdx+.
 %build evaluation of declaring SaveL
 Len: apply length_exists_list_pair_string_value to IsEE.
 rename N to LengthEE.
 NNS_L: assert newNameScopes [[]] LengthEE ([]::EE) EE.
   unfold. exists 1, [], Names. split. search. search. search. search.
   search. intros M. case M.
 Ev_L: apply evalExpr_newNameScopes_exists to _ _ _ _ Ev NNS_L.
 NNS_L': apply evalExpr_newNameScopes_ctx to _ _ _ _ Ev_L Ev NNS_L.
 LenEE3: apply evalExpr_keep_scopes to _ _ _ Ev Len.
 Eq: assert EE_A' = []::EE3.
   NNS': case NNS_L'.
     %end
      Take: case NNS'2. case Take1. compute Take. Drop: case NNS'1.
      Drop': case Drop1.
        %Drop-0
         search.
        %Drop-Step
         G: apply drop_geq_0 to Drop'1. P: assert 1 + -1 = 0.
         apply drop_is_integer to Drop'1.
         apply plus_integer_is_integer to _ _ Drop'.
         apply plus_integer_unique_addend to _ _ _ Take Drop.
         apply plus_integer_unique_addend to _ _ _ Drop' P.
         L: case G. case L.
     %step
      LenBR: case LenEE3. apply length_is to LenBR.
      LEq: apply newNameScopes_length to NNS' LenBR.
      L: apply lt_plus_one to LenBR1 _.
      apply less_lesseq_flip_false to L LEq.
 case Eq.
 Ev_DL: assert evalStmt FE ([]::EE) (declare intTy SaveL Lst)
                  ([(SaveL, LV)]::EE3) O2.
 %build evaluation of declaring SaveI
 IsEE3: apply evalExpr_isCtx to _ _ _ Ev.
 apply evalExpr_isValue to _ _ _ Ev.
 apply fresh_name_is to _ Pr1. apply fresh_name_is to _ Pr2.
 NamesEE3: apply names_exists to IsEE3.
 NNS_I: assert newNameScopes [[(SaveL, LV)]] LengthEE
                  ([(SaveL, LV)]::EE3) EE3.
   unfold. exists 1, [SaveL], N. split. search. search. search.
     %names [[(SaveL, LV)]] [SaveL]
      search.
     %names EE3 N
      search.
     %mem [SaveL] -> mem N -> false
      intros ML MN. ML: case ML.
        %Mem-Here
         NS: apply evalExpr_names_same to _ _ _ Ev.
         NS': apply names_same_symmetric to NS.
         MNames: apply names_same_names to _ NamesEE3 Names MN.
         apply fresh_name_not_mem to Pr2 MNames.
        %Mem-Later
         case ML.
 Ev_I: apply evalExpr_newNameScopes_exists to _ _ _ _ Ev1 NNS_I.
 NNS_If: apply evalExpr_newNameScopes_ctx to _ _ _ _ Ev_I Ev1 NNS_I.
 LenEE': apply evalExpr_keep_scopes to _ _ _ Ev1 LenEE3.
 Eq: assert EE_A'1 = [(SaveL, LV)]::EE'.
   NNS': case NNS_If.
     %end
      Take: case NNS'2. case Take1. compute Take. Drop: case NNS'1.
      Drop': case Drop1.
        %Drop-0
         search.
        %Drop-Step
         G: apply drop_geq_0 to Drop'1. P: assert 1 + -1 = 0.
         apply drop_is_integer to Drop'1.
         apply plus_integer_is_integer to _ _ Drop'.
         apply plus_integer_unique_addend to _ _ _ Take Drop.
         apply plus_integer_unique_addend to _ _ _ Drop' P.
         L: case G. case L.
     %step
      LenBR: case LenEE'. apply length_is to LenBR.
      LEq: apply newNameScopes_length to NNS' LenBR.
      L: apply lt_plus_one to LenBR1 _.
      apply less_lesseq_flip_false to L LEq.
 case Eq.
 Ev_DI: assert evalStmt FE ([(SaveL, LV)]::EE3)
                  (declare intTy SaveI Index)
                  ([(SaveI, intVal Idx), (SaveL, LV)]::EE') O3.
 %build evaluation of ifThenElse
 GEq: apply listIndex_geq_0 to _ Ev2. case GEq.
 Ev_C: assert evalExpr FE ([(SaveI, intVal Idx), (SaveL, LV)]::EE')
                 (greater (num 0) (name SaveI)) falseVal
                 ([(SaveI, intVal Idx), (SaveL, LV)]::EE') [].
 EvIf : assert evalStmt FE ([(SaveI, intVal Idx), (SaveL, LV)]::EE')
           (ifThenElse (greater (num 0) (name SaveI))
               (printVal (errorExpr (stringLit "Die") intTy))
               noop) ([(SaveI, intVal Idx), (SaveL, LV)]::EE') [].
 %build evaluation of while loop
 NEq: assert SaveL = SaveI -> false.
   intros E. case E. AppI: apply fresh_name_start to _ Pr1.
   AppL: apply fresh_name_start to _ Pr2. case AppI. case AppL.
 EvWhile: apply index_to_while to Ev2 NEq _ with Ctx = EE', FE = FE.
 Ev_W: apply drop_ext_size_evalStmt to EvWhile.
 %build evaluation of recFieldAccess
 assert SaveI = SaveL -> false. intros E. case E. backchain NEq.
 assert lookupScopes SaveL
           ([(SaveI, intVal 0), (SaveL, recVal Fields)]::EE')
           (recVal Fields).
 assert evalExpr FE ([(SaveI, intVal 0), (SaveL, recVal Fields)]::EE')
           (recFieldAccess (name SaveL) "head") V
           ([(SaveI, intVal 0), (SaveL, recVal Fields)]::EE') [].
 %put it together
 exists EE'. split.
   %eval
    IsO2: apply evalExpr_isOutput to _ _ _ Ev.
    IsO3: apply evalExpr_isOutput to _ _ _ Ev1.
    IsO: apply append_values_is to _ _ Ev3.
    apply is_list_values_append_nil to IsO3. unfold.
    exists ([(SaveI, intVal 0), (SaveL, recVal Fields)]::EE'),
           O, [(SaveI, intVal 0), (SaveL, recVal Fields)], []. split.
      %eval everything else
       search.
      %eval SaveL.head
       search.
      %append output
       backchain is_list_values_append_nil.
   %scopes_same
    apply evalStmt_isCtx to _ _ _ Ev_DL.
    apply evalStmt_isCtx to _ _ _ Ev_DI.
    IsEE'+: apply evalStmt_isCtx to _ _ _ Ev_W. search 20.
    case IsEE'+. backchain scopes_same_reflexive.
%Proj-Length
 case IsE. Ev: case Ev.
 %declare SaveL
 LenEE: apply length_exists_list_pair_string_value to IsEE.
 NNS: assert newNameScopes [[]] N ([]::EE) EE.
   unfold. exists 1, [], Names. split. search. search. search. search.
   search. intros M. case M.
 Ev_L: apply evalExpr_newNameScopes_exists to _ _ _ _ Ev NNS.
 NNS_L: apply evalExpr_newNameScopes_ctx to _ _ _ _ Ev_L Ev NNS.
 LenEE': apply evalExpr_keep_scopes to _ _ _ Ev LenEE.
 Eq: assert EE_A' = []::EE'.
   NNS': case NNS_L.
     Take: case NNS'2. case Take1. compute Take. Drop: case NNS'1.
      Drop': case Drop1.
        %Drop-0
         search.
        %Drop-Step
         G: apply drop_geq_0 to Drop'1. P: assert 1 + -1 = 0.
         apply drop_is_integer to Drop'1.
         apply plus_integer_is_integer to _ _ Drop'.
         apply plus_integer_unique_addend to _ _ _ Take Drop.
         apply plus_integer_unique_addend to _ _ _ Drop' P.
         L: case G. case L.
     %step
      LenBR: case LenEE'. apply length_is to LenBR.
      LEq: apply newNameScopes_length to NNS' LenBR.
      L: apply lt_plus_one to LenBR1 _.
      apply less_lesseq_flip_false to L LEq.
 case Eq. Ev_DL: assert evalStmt FE ([]::EE) (declare intTy SaveL E1)
                           ([(SaveL, V1)]::EE') O.
 %declare Len
 Ev_DLen: assert evalStmt FE ([(SaveL, V1)]::EE')
                    (declare intTy Len (num 0))
                    ([(Len, intVal 0), (SaveL, V1)]::EE') [].
 IsO: apply evalExpr_isOutput to _ _ _ Ev.
 %while loop
 apply evalExpr_isValue to _ _ _ Ev. apply listLength_is to _ Ev1.
 NEq: assert SaveL = Len -> false.
   intros E. case E. AppLen: apply fresh_name_start to _ Pr2.
   FrL: case Pr1.
     %FN-Final
      App: case AppLen. case App.
     %FN-Step
      AppL: case FrL1. case AppL.
      AppL: apply fresh_name_start to _ FrL2. AppL: case AppL.
      case AppL. AppLen: case AppLen. case AppLen.
 P: assert 0 + I = I. P': apply plus_integer_comm to _ _ P.
 Ev_W_ES: apply length_to_while to Ev1 NEq P' _ _ with
             FE = FE, Ctx = EE'.
 Ev_W: apply drop_ext_size_evalStmt to Ev_W_ES.
 %final name
 LS: assert lookupScopes Len
               ([(Len, intVal I), (SaveL, recVal Fields)]::EE')
               (intVal I).
 Ev_N: assert evalExpr FE
                 ([(Len, intVal I), (SaveL, recVal Fields)]::EE')
                 (name Len) (intVal I)
                 ([(Len, intVal I), (SaveL, recVal Fields)]::EE') [].
 %put it together
  exists EE'. split.
   %eval
    apply is_list_values_append_nil to IsO. search.
   %scopes_same
    apply evalExpr_isCtx to _ _ _ Ev.
    backchain scopes_same_reflexive.

Prove_Constraint exactEval:host:proj_evalExpr_backward.
%Proj-Nil
 Ev: case Ev. Ev: case Ev. case Ev. case Ev1. case Ev2.
 apply scopes_same_reflexive to IsEE. search.
%Proj-Cons
 Ev: case Ev. Ev: case Ev. case Ev. Ev: case Ev1. Ev: case Ev1.
 case Ev4. case Ev2. apply append_nil_right to Ev5. case IsE.
 EN: case EN. case EN2. apply evalExpr_isCtx to _ _ _ Ev.
 IsEE': apply evalExpr_isCtx to _ _ _ Ev1.
 apply scopes_same_reflexive to IsEE'. search.
%Proj-Head
 Ev: case Ev. case IsE. IsEE': apply evalExpr_isCtx to _ _ _ Ev.
 apply scopes_same_reflexive to IsEE'. search.
%Proj-Tail
 Ev: case Ev. case IsE. IsEE': apply evalExpr_isCtx to _ _ _ Ev.
 apply scopes_same_reflexive to IsEE'. search.
%Proj-Null
 Ev: case Ev. case IsE. IsEE': apply evalExpr_isCtx to _ _ _ Ev.
 apply scopes_same_reflexive to IsEE'. search.
%Proj-Index
 case IsE. EN: case EN. case EN2. Ev: case Ev. Ev: case Ev.
 Ev: case Ev3. Ev: case Ev. Ev: case Ev3. Ev: case Ev1.
 Ev: case Ev1. Ev: case Ev5.
 %move eval Lst to EE
 Len: apply length_exists_list_pair_string_value to IsEE.
 rename N to LengthEE.
 NNS_L: assert newNameScopes [[]] LengthEE ([]::EE) EE.
   unfold. exists 1, [], Names. split. search. search. search. search.
   search. intros M. case M.
 Ev_L: apply evalExpr_newNameScopes_exists_back to
          _ _ _ _ _ _ EN Ev NNS_L.
 NNS_L': apply evalExpr_newNameScopes_ctx to _ _ _ _ Ev Ev_L NNS_L.
 %move eval Index to EE5
 IsLenEE: apply length_is to Len.
 P: apply plus_integer_total to _ IsLenEE with N1 = 1.
 LenEE+: assert length ([]::EE) N3.
 Eq: assert EE_B' = EE5 /\ Scope1 = [].
   NNS': case NNS_L'.
     %end
      Take: case NNS'2. case Take1. compute Take. Drop: case NNS'1.
      Drop': case Drop1.
        %Drop-0
         search.
        %Drop-Step
         G: apply drop_geq_0 to Drop'1. P': assert 1 + -1 = 0.
         apply drop_is_integer to Drop'1.
         apply plus_integer_is_integer to _ _ Drop'.
         apply plus_integer_unique_addend to _ _ _ Take Drop.
         apply plus_integer_unique_addend to _ _ _ Drop' P'.
         L: case G. case L.
     %step
      LenBR+: apply evalExpr_keep_scopes to _ _ _ Ev_L Len.
      LenBR: case LenBR+. apply length_is to LenBR.
      LEq: apply newNameScopes_length to NNS' LenBR.
      L: apply lt_plus_one to LenBR1 _.
      apply less_lesseq_flip_false to L LEq.
 case Eq.
 LenEE5: apply evalExpr_keep_scopes to _ _ _ Ev_L Len.
 IsEE5: apply evalExpr_isCtx to _ _ _ Ev_L.
 NamesEE5: apply names_exists to IsEE5.
 NNS_I: assert newNameScopes [[(SaveL, V1)]] LengthEE
                  ([(SaveL, V1)]::EE5) EE5.
   unfold. exists 1, [SaveL], N. split. search. search. search.
     %names [[(SaveL, LV)]] [SaveL]
      search.
     %names EE5 N
      search.
     %mem [SaveL] -> mem N -> false
      intros ML MN. ML: case ML.
        %Mem-Here
         NS: apply evalExpr_names_same to _ _ _ Ev_L.
         NS': apply names_same_symmetric to NS.
         MNames: apply names_same_names to _ NamesEE5 Names MN.
         apply fresh_name_not_mem to Pr2 MNames.
        %Mem-Later
         case ML.
 apply evalExpr_ctx_names to _ _ _ _ _ EN Ev_L.
 apply fresh_name_is to _ Pr1. apply fresh_name_is to _ Pr2.
 apply evalExpr_isValue to _ _ _ Ev.
 Ev_I: apply evalExpr_newNameScopes_exists_back to
          _ _ _ _ _ _ EN1 Ev3 NNS_I.
 %show Index evaluates to a number >= 0 from ifThenElse
 NNS_I': apply evalExpr_newNameScopes_ctx to _ _ _ _ Ev3 Ev_I _.
 Eq: assert Scope2 = [(SaveL, V1)] /\ EE_B'1 = EE6.
   NNS': case NNS_I'.
     %end
      Take: case NNS'2. case Take1. compute Take. Drop: case NNS'1.
      Drop': case Drop1.
        %Drop-0
         search.
        %Drop-Step
         G: apply drop_geq_0 to Drop'1. P': assert 1 + -1 = 0.
         apply drop_is_integer to Drop'1.
         apply plus_integer_is_integer to _ _ Drop'.
         apply plus_integer_unique_addend to _ _ _ Take Drop.
         apply plus_integer_unique_addend to _ _ _ Drop' P'.
         L: case G. case L.
     %step
      LenBR+: apply evalExpr_keep_scopes to _ _ _ Ev_I LenEE5.
      LenBR: case LenBR+. apply length_is to LenBR.
      LEq: apply newNameScopes_length to NNS' LenBR.
      L: apply lt_plus_one to LenBR1 _.
      apply less_lesseq_flip_false to L LEq.
 case Eq.
 Eq: assert exists IV, V2 = intVal IV /\ IV >= 0 /\
               EE4 = [(SaveI, V2), (SaveL, V1)]::EE6 /\ O7 = [].
   EvIf: case Ev5.
     %E-If-True
      EvP: case EvIf1. case EvP. case EvP. case EvP. case EvP.
     %E-If-False
      case EvIf1. EvG: case EvIf. case EvG. case EvG3. LS: case EvG1.
      case EvIf2. LS: case LS.
        %LS-FirstScope
         L: case LS.
           %Lkp-Here
            search.
           %Lkp-Later
            apply L to _.
        %LS-Later
         NL: case LS. apply NL to _.
 case Eq.
 %show listIndex from while
 NEq: assert SaveL = SaveI -> false.
   intros E. case E. AppI: apply fresh_name_start to _ Pr1.
   AppL: apply fresh_name_start to _ Pr2. case AppI. case AppL.
 case Ev9. IsI: apply evalExpr_isValue to _ _ _ Ev_I. case IsI.
 apply while_to_index to Ev8 Ev1 Ev7 _ _ NEq.
 apply append_nil_right to Ev2. apply append_nil_right to Ev6.
 exists EE6. split.
   %eval index
    search.
   %scopes_same
    apply evalExpr_isCtx to _ _ _ Ev_I.
    backchain scopes_same_reflexive.
%Proj-Length
 case IsE. EN: case EN. Ev: case Ev. Ev: case Ev1.
 apply append_nil_right to Ev2. clear Ev2. Ev: case Ev. Ev: case Ev.
 Ev: case Ev2. Ev: case Ev2. case Ev2. case Ev5.
 %eval E1 under basic scopes
 LenEE: apply length_exists_list_pair_string_value to IsEE.
 NNS: assert newNameScopes [[]] N ([]::EE) EE.
   unfold. exists 1, [], Names. split. search. search. search. search.
   search. intros M. case M.
 Ev_E1: apply evalExpr_newNameScopes_exists_back to
           _ _ _ _ _ _ EN Ev NNS.
 NNS': apply evalExpr_newNameScopes_ctx to _ _ _ _ Ev Ev_E1 NNS.
 LenEE_B': apply evalExpr_keep_scopes to _ _ _ Ev_E1 LenEE.
 Eq: assert Scope1::EE6 = []::EE_B'.
   NNS': case NNS'.
     %end
      Take: case NNS'2. case Take1. compute Take. Drop: case NNS'1.
      Drop': case Drop1.
        %Drop-0
         search.
        %Drop-Step
         G: apply drop_geq_0 to Drop'1. P': assert 1 + -1 = 0.
         apply drop_is_integer to Drop'1.
         apply plus_integer_is_integer to _ _ Drop'.
         apply plus_integer_unique_addend to _ _ _ Take Drop.
         apply plus_integer_unique_addend to _ _ _ Drop' P'.
         L: case G. case L.
     %step
      LenBR: case LenEE_B'. apply length_is to LenBR.
      LEq: apply newNameScopes_length to NNS' LenBR.
      L: apply lt_plus_one to LenBR1 _.
      apply less_lesseq_flip_false to L LEq.
 case Eq.
 %eval while -> list length
 NEq: assert SaveL = Len -> false.
   intros E. case E. AppLen: apply fresh_name_start to _ Pr2.
   FrL: case Pr1.
     %FN-Final
      App: case AppLen. case App.
     %FN-Step
      AppL: case FrL1. case AppL.
      AppL: apply fresh_name_start to _ FrL2. AppL: case AppL.
      case AppL. AppLen: case AppLen. case AppLen.
 LL: apply while_to_length to Ev4 Ev1 _ NEq.
 P: apply plus_integer_comm to _ _ LL2. case P.
 %put it together
 exists EE_B'. split.
   %eval
    apply append_nil_right to Ev3. search.
   %scopes_same
    apply evalExpr_isCtx to _ _ _ Ev_E1.
    backchain scopes_same_reflexive.


Theorem drop_one[A] : forall (L D : list A),
  drop 1 L D -> exists S, L = S::D.
intros D. D: case D. apply drop_is_integer to D1. D': case D1.
  %Drop-0
   search.
  %Drop-Step
   apply drop_is_integer to D'1. P: assert 1 + 0 = 1.
   apply plus_integer_unique_addend to _ _ _ D P.
   P': assert 1 + -1 = 0.
   apply plus_integer_unique_addend to _ _ _ D' P'.
   GEq: apply drop_geq_0 to D'1. LEq: case GEq. case LEq.


Theorem eval_while_names_same : forall C B FE EE EE' O,
  is_expr C -> is_stmt B ->
  is_list (is_pair is_string (is_pair is_string
      (is_pair is_value (is_pair (is_list is_string) is_stmt)))) FE ->
  is_list (is_list (is_pair is_string is_value)) EE ->
  evalStmt FE EE (while C B) EE' O ->
  names_same EE EE'.
induction on 5. intros IsC IsB IsFE IsEE Ev. Ev: case Ev.
  %E-While-True
   NS: apply evalExpr_names_same to _ _ _ Ev.
   apply evalExpr_isCtx to _ _ _ Ev.
   NS1: apply evalStmt_names_same to _ _ _ Ev1.
   Is+: apply evalStmt_isCtx to _ _ _ Ev1. case Is+.
   NS2: apply IH to _ _ _ _ Ev2.
   NS': apply names_same_transitive to NS NS1.
   apply names_same_transitive to NS' NS2. search.
  %E-While-False
   apply evalExpr_names_same to _ _ _ Ev. search.


Theorem names_lookupScopes : forall Ctx X Names,
  is_list (is_list (is_pair is_string is_value)) Ctx ->
  names Ctx Names -> mem X Names -> exists V, lookupScopes X Ctx V.
induction on 2. intros IsCtx Names Mem. apply names_is to _ Names.
Names: case Names.
  %Names-Nil
   case Mem.
  %Names-Cons
   Is: case IsCtx. IsX: apply mem_is_string to _ Mem.
   Or: apply mem_append to Mem Names2. M: case Or.
     %mem X NScope
      MXB: apply mem_domain to Names M.
      L: apply mem_lookup to _ MXB. search.
     %mem X NRest
      Or: apply lookup_string_value_list_or_no to Is IsX. case Or.
        %lookup Scope
         search.
        %no_lookup Scope
         LS: apply IH to _ Names1 M. search.


Prove_Constraint exactEval:host:proj_evalStmt_forward.
%Proj-ListUpdate
 Is: case IsS. Ev: case Ev.
 assert SaveE = L -> false.
   intros E. case E. apply fresh_name_not_mem to Pr3 _.
 assert SaveI = L -> false.
   intros E. case E. apply fresh_name_not_mem to Pr1 _.
 assert Hold = L -> false.
   intros E. case E. apply fresh_name_not_mem to Pr2 _.
 assert Copy = L -> false.
   intros E. case E. apply fresh_name_not_mem to Pr4 _.
 assert Hold = SaveE -> false.
   intros E. case E. AppE: apply fresh_name_start to _ Pr3.
   AppH: apply fresh_name_start to _ Pr2. search 6.
   case AppE. case AppH.
 assert Hold = SaveI -> false.
   intros E. case E. AppI: apply fresh_name_start to _ Pr1.
   AppH: apply fresh_name_start to _ Pr2. search 6.
   case AppI. case AppH.
 NEqIE: assert SaveI = SaveE -> false.
   intros E. case E. AppI: apply fresh_name_start to _ Pr1.
   AppE: apply fresh_name_start to _ Pr3. case AppI. case AppE.
 assert Copy = Hold -> false.
   intros E. case E. AppC: apply fresh_name_start to _ Pr4.
   AppH: apply fresh_name_start to _ Pr2. search 6.
   case AppC. case AppH.
 assert SaveE = Copy -> false.
   intros E. case E. AppC: apply fresh_name_start to _ Pr4.
   AppE: apply fresh_name_start to _ Pr3. case AppC. case AppE.
 assert SaveI = Copy -> false.
   intros E. case E. AppC: apply fresh_name_start to _ Pr4.
   AppI: apply fresh_name_start to _ Pr1. case AppC. case AppI.
 LenEE: apply length_exists_list_pair_string_value to IsEE.
 rename N1 to Len.
 NNS: assert newNameScopes [[]] Len ([]::EE) EE.
   unfold. exists 1, [], Names. split. search. search. search. search.
   search. intros M. case M.
 EvI': apply evalExpr_newNameScopes_exists to _ _ _ _ Ev NNS.
 NNS': apply evalExpr_newNameScopes_ctx to _ _ _ _ EvI' Ev _.
 Eq: assert EE_A' = []::EE2.
   NNS': case NNS'.
     %end
      Take: case NNS'2. case Take1. compute Take.
      apply drop_one to NNS'1. search.
     %step
      LenBR+: apply evalExpr_keep_scopes to _ _ _ Ev LenEE.
      LenBR: case LenBR+. apply length_is to LenBR.
      L: apply lt_plus_one to LenBR1 _.
      LEq: apply newNameScopes_length to NNS' LenBR.
      apply less_lesseq_flip_false to L LEq.
 case Eq.
 EvAI: assert evalStmt FE ([]::EE) (declare intTy SaveI I)
                       ([(SaveI, intVal N)]::EE2) O2.
 apply fresh_name_is to _ Pr1. apply evalExpr_isValue to _ _ _ Ev.
 IsEE2: apply evalExpr_isCtx to _ _ _ Ev.
 Names2: apply names_exists to IsEE2.
 NS: apply evalExpr_names_same to _ _ _ Ev.
 Len2: apply evalExpr_keep_scopes to _ _ _ Ev LenEE.
 NNS+: assert newNameScopes [[(SaveI, intVal N)]] Len
                 ([(SaveI, intVal N)]::EE2) EE2.
   unfold. exists 1, [SaveI], N1. split. search. search. search.
   search. search.
   intros M MX. M: case M. NS': apply names_same_symmetric to NS.
   M': apply names_same_names to NS' Names2 Names MX.
   apply fresh_name_not_mem to Pr1 _. case M.
 EvE': apply evalExpr_newNameScopes_exists to _ _ _ _ Ev1 NNS+.
 NNS'': apply evalExpr_newNameScopes_ctx to _ _ _ _ EvE' Ev1 _.
 Len4: apply evalExpr_keep_scopes to _ _ _ Ev1 Len2.
 Eq: assert EE_A'1 = [(SaveI, intVal N)]::EE4.
   NN: case NNS''.
     %end
      Take: case NN2. Take: case Take1. compute Take.
      apply drop_one to NN1. search.
     %step
      LenBR: case Len4. apply length_is to LenBR.
      L: apply lt_plus_one to LenBR1 _.
      LEq: apply newNameScopes_length to NN LenBR.
      apply less_lesseq_flip_false to L LEq.
 case Eq.
 EvAE: assert evalStmt FE ([(SaveI, intVal N)]::EE2)
                       (declare intTy SaveE E)
                       ([(SaveE, V), (SaveI, intVal N)]::EE4) O3.
 apply fresh_name_is to _ Pr3. apply evalExpr_isValue to _ _ _ Ev1.
 IsEE4: apply evalExpr_isCtx to _ _ _ Ev1.
 EvMI: assert evalStmt FE ([(SaveE, V), (SaveI, intVal N)]::EE4)
                       (assign SaveI (name SaveI))
                       ([(SaveI, intVal N), (SaveE, V)]::EE4) [].
    assert SaveE = SaveI -> false. intros E. case E. backchain NEqIE.
    search.
 EvH: assert evalStmt FE ([(SaveI, intVal N), (SaveE, V)]::EE4)
                      (declare intTy Hold (exactEval:list:nil intTy))
                      ([(Hold, recVal [("null", trueVal)]),
                        (SaveI, intVal N),
                        (SaveE, V)]::EE4) [].
 IsSaveI: apply fresh_name_is to _ Pr1.
 IsHold: apply fresh_name_is to _ Pr2. search 6.
 IsCopy: apply fresh_name_is to _ Pr4.
 GEq: apply updateListIndex_pos to Ev3.
 apply evalExpr_isValue to _ _ _ Ev1.
 Main: apply proj_listUpdate_eval to
         _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ with
         OldL = LV, I = N, V = V, NewL = LV2, Hold = Hold,
         Copy = Copy, SaveI = SaveI, SaveE = SaveE, G = EE4, L = L,
         HoldL = recVal [("null", trueVal)]. search 12.
 apply drop_proj_rel_evalStmt to Main.
 exists G'. IsO3: apply evalExpr_isOutput to _ _ _ Ev1.
 apply is_list_values_append_nil to IsO3. split.
   %eval
    search 20.
   %scopes_same
    FO: case Main3.
      %nil-esque
       apply replaceScopes_unique to Main2 Ev4.
       apply lookupScopes_is to _ Ev2.
       apply updateListIndex_is to _ _ Ev3.
       apply replaceScopes_is to _ _ Main2.
       backchain scopes_same_reflexive.
      %cons-esque
       L: case FO. apply L to _.
%Proj-ListForeach
 case IsS. Ev: case Ev. apply evalExpr_isValue to _ _ _ Ev.
 NS: apply evalExpr_names_same to _ _ _ Ev.
 NS': apply names_same_symmetric to NS.
 IsEE3: apply evalExpr_isCtx to _ _ _ Ev.
 Names3: apply names_exists to IsEE3. IsN: apply names_is to _ Names3.
 Fr: apply fresh_name_exists to _ _ with Base = "L", Names = X::N.
 apply fresh_name_unique_mems to Fr Pr1 _ _.
   %mem X::Names -> mem X::N
    intros M. M: case M. search.
    apply names_same_names to NS Names Names3 M. search.
   %mem X::N -> mem X::Names
    intros M. M: case M. search.
    apply names_same_names to NS' Names3 Names M. search.
 apply iterateList_to_while to _ _ _ _ _ Ev1 Names3 Fr.
 Len: apply length_exists_list_pair_string_value to IsEE.
 NNS: assert newNameScopes [[]] N1 ([]::EE) EE.
   unfold. exists 1, [], Names. split. search. search. search. search.
   search. intros M. case M.
 Ev': apply evalExpr_newNameScopes_exists to _ _ _ _ Ev NNS.
 NNS': apply evalExpr_newNameScopes_ctx to _ _ _ _ Ev' Ev NNS.
 NNS': case NNS'.
   %end
    Take: case NNS'2. case Take1. compute Take. Drop: case NNS'1.
    apply drop_is_integer to Drop1.
    apply plus_integer_unique_addend to _ _ _ Take Drop.
    Eq: assert L1 = EE3.
      D: case Drop1. search. apply drop_is_integer to D1.
      P: assert 1 + -1 = 0.
      apply plus_integer_unique_addend to _ _ _ P D.
      GEq: apply drop_geq_0 to D1. LEq: case GEq. case LEq.
    case Eq. clear Take Drop Drop1. exists EE'. split.
      %eval
       search.
      %scopes_same
       apply iterateList_isCtx to _ _ _ _ _ Ev1.
       backchain scopes_same_reflexive.
   %step
    LenBR+: apply names_same_length to NS Len. LenBR: case LenBR+.
    LEq: apply newNameScopes_length to NNS' LenBR.
    apply length_is to LenBR. L: apply lt_plus_one to LenBR1 _.
    apply less_lesseq_flip_false to L LEq.


Prove_Constraint exactEval:host:proj_evalStmt_backward.
%Proj-ListUpdate
 case IsS. apply fresh_name_is to _ Pr1. apply fresh_name_is to _ Pr3.
 apply fresh_name_is to _ Pr2. search 6. apply fresh_name_is to _ Pr4.
 %get all the names unique
 NEqHI: assert (Hold = SaveI -> false).
   intros E. case E. AppI: apply fresh_name_start to _ Pr1. case AppI.
   AppH: apply fresh_name_start to _ Pr2. search 6. case AppH.
 NEqHL: assert (Hold = L -> false).
   intros E. case E. apply fresh_name_not_mem to Pr2 _.
 NEqIE: assert (SaveI = SaveE -> false).
   intros E. case E. AppI: apply fresh_name_start to _ Pr1. case AppI.
   AppE: apply fresh_name_start to _ Pr3. case AppE.
 NEqIL: assert (SaveI = L -> false).
   intros E. case E. apply fresh_name_not_mem to Pr1 _.
 NEqHE: assert (Hold = SaveE -> false).
   intros E. case E. AppE: apply fresh_name_start to _ Pr3. case AppE.
   AppH: apply fresh_name_start to _ Pr2. search 6. case AppH.
 NEqEL: assert (SaveE = L -> false).
   intros E. case E. apply fresh_name_not_mem to Pr3 _.
 NEqCH: assert (Copy = Hold -> false).
   intros E. case E. AppC: apply fresh_name_start to _ Pr4. case AppC.
   AppH: apply fresh_name_start to _ Pr2. search 6. case AppH.
 NEqCL: assert (Copy = L -> false).
   intros E. case E. apply fresh_name_not_mem to Pr4 _.
 NEqIC: assert (SaveI = Copy -> false).
   intros E. case E. AppI: apply fresh_name_start to _ Pr1. case AppI.
   AppC: apply fresh_name_start to _ Pr4. case AppC.
 NEqEC: assert (SaveE = Copy -> false).
   intros E. case E. AppC: apply fresh_name_start to _ Pr4. case AppC.
   AppE: apply fresh_name_start to _ Pr3. case AppE.
 %break down names and evaluation
 SN: case SN. case SN3.
 Ev: case Ev. Ev: case Ev. EvI: case Ev. Ev: case Ev1. EvE: case Ev.
 Ev: case Ev1. EvMI: case Ev. LI: case EvMI. Ev: case Ev1.
 Ev: case Ev. case Ev. case Ev5. EvW: case Ev1. Ev: case EvW1.
 EvA: case Ev1. rename EvW2 to EvW1. rename EvA1 to EvW2.
 EvNL: assert evalExpr FE EE8 (null (name L)) falseVal EE8 [] /\
              EE10 = EE8 /\ O11 = [].
   Ev: case Ev.
     %E-IfThenElse-True
      EvD: case Ev1. case EvD.
     %E-IfThenElse-False
      EvL: case Ev. case EvL. case Ev1. case Ev6. search.
 EvNL: case EvNL. case Ev4. case Ev5.
 %fill out EvI context
 ENI: apply exprNames_relatedCtxs to _ _ _ _ _ SN1 with
         CtxB = []::Ctx'.
   intros M. M: case M. case M. search.
 apply ctx_names_add_scope to Ctxs.
 IsEE2+: apply evalExpr_isCtx to _ _ _ EvI. IsEE2: case IsEE2+.
 Ctxs': apply evalExpr_ctx_names to _ _ _ _ _ ENI EvI.
 Ctxs': case Ctxs'. Eq: assert Scope1 = [].
   Is: case IsEE2. search. case Is.
   M: apply Ctxs' to _ with K = A, I = B. case M.
 case Eq. apply evalExpr_isValue to _ _ _ EvI.
 LenEE: apply length_exists_list_pair_string_value to IsEE.
 rename N to Len.
 NNS: assert newNameScopes [[]] Len ([]::EE) EE.
   unfold. exists 1, [], Names. split. search. search. search. search.
   search. intros M. case M.
 EvI': apply evalExpr_newNameScopes_exists_back to
          _ _ _ _ _ _ SN1 EvI NNS.
 LenEE2: apply evalExpr_keep_scopes to _ _ _ EvI' LenEE.
 NNS': apply evalExpr_newNameScopes_ctx to _ _ _ _ EvI EvI' NNS.
 Eq: assert EE_B' = EE2.
   NNS': case NNS'.
     %end
      Take: case NNS'2. Take: case Take1. compute Take.
      apply drop_one to NNS'1. search.
     %step
      LenBR: case LenEE2. apply length_is to LenBR.
      L: apply lt_plus_one to LenBR1 _.
      LEq: apply newNameScopes_length to NNS' LenBR.
      apply less_lesseq_flip_false to L LEq.
 case Eq. clear Ctxs' Ctxs'1.
 %fill out EvE context
 Names2: apply names_exists to _ with L = EE2.
 NNS'': assert newNameScopes [[(SaveI, V)]] Len
                  ([(SaveI, V)]::EE2) EE2.
   unfold. exists 1, [SaveI], N. split. search. search. search.
   search. search. intros M MN. M: case M.
     %Mem-Here:  X = SaveI
      NS: apply evalExpr_names_same to _ _ _ EvI. NS: case NS.
      apply names_same_symmetric to NS2.
      apply names_same_names to _ Names2 Names MN.
      apply fresh_name_not_mem to Pr1 _.
     %Mem-Later
      case M.
 EvE': apply evalExpr_newNameScopes_exists_back to
          _ _ _ _ _ _ _ EvE NNS''.
 LenEE5: apply evalExpr_keep_scopes to _ _ _ EvE' LenEE2.
 NNS+: apply evalExpr_newNameScopes_ctx to _ _ _ _ EvE EvE' NNS''.
 Eq: assert Scope2 = [(SaveI, V)] /\ EE_B'1 = EE5.
   NNS+: case NNS+.
     %end
      Take: case NNS+2. Take: case Take1. compute Take.
      apply drop_one to NNS+1. search.
     %step
      Len: case LenEE5. apply length_is to Len.
      L: apply lt_plus_one to Len1 _.
      LEq: apply newNameScopes_length to NNS+ Len.
      apply less_lesseq_flip_false to L LEq.
 case Eq.
 %fill out SaveI = SaveI context
 Eq: assert V2 = V.
   L: case LI.
     %LS-FirstScope
      L: case L. apply NEqIE to _. L: case L1. search. apply L1 to _.
     %LS-Later
      N: case L. N: case N1. apply N1 to _.
 case Eq.
 Eq: assert Scope3::EE9 = [(SaveI, V), (SaveE, V1)]::EE5.
   RS: case EvMI1.
     %RS-FirstScope
      RA: case RS1. apply NEqIE to _. RA: case RA1. case RA1. search.
      apply RA1 to _.
     %RS-Later
      N: case RS. N: case N1. apply N1 to _.
 case Eq. clear LI EvMI1.
 %build updateListIndex
 apply evalExpr_isValue to _ _ _ EvE'.
 apply evalExpr_isCtx to _ _ _ EvE'.
 Eq: assert O13 = [] /\ exists LV, lookupScopes L EE8 LV.
   EvA: case EvA. case EvA. search.
 LL: case Eq. case EvA2.
 LS: assert exists LV, lookupScopes L EE5 LV.
   NS: apply eval_while_names_same to _ _ _ _ EvW.
      search 20. search 30.
   NS: case NS. Names5: apply names_exists to _ with L = EE5.
   IsEE8: apply evalStmt_isCtx to _ _ _ EvW. search 20. search 30.
   Names8: apply names_exists to IsEE8. LL: case LL.
     %LS-FirstScope
      ML: apply lookup_mem to LL. M: apply NS1 to ML. M: case M.
      apply NEqHL to _. M: case M. apply NEqIL to _. M: case M.
      apply NEqEL to _. case M.
     %LS-Later
      Names: case Names8. ML: apply lookupScopes_names to LL1 Names3.
      apply names_same_symmetric to NS2.
      MN1: apply names_same_names to _ Names3 Names5 ML.
      apply names_lookupScopes to _ Names5 MN1. search.
 LS: case LS.
 ULI: apply proj_eval_listUpdate to NEqHI NEqHL NEqIE NEqIL NEqHE
    NEqEL NEqCH NEqCL NEqIC NEqEC IsFE _ _ LS EvW EvNL EvA. search 20.
 %get it to be the right relationships between values
 GEq: apply updateListIndex_pos to ULI.
 LS': assert lookupScopes L ([(Hold, recVal [("null", trueVal)]),
                (SaveI, intVal I1), (SaveE, V1)]::EE5) LV1.
 EvAgain: apply proj_listUpdate_eval to ULI NEqHI NEqHL NEqIE NEqIL
             NEqHE NEqEL NEqCH NEqCL NEqIC NEqEC _ GEq IsFE _ _ LS'.
   search 20.
 EvG: apply drop_proj_rel_evalStmt to EvAgain.
 EvG: case EvG. EvG: case EvG1. EvG: case EvG3.
 case EvG2. case EvG4. case EvG6.
 apply evalStmt_unique to _ _ _ EvG EvW. search 20. search 30.
 NS: apply evalStmt_names_same to _ _ _ EvW. search 20. search 30.
 IsEE''+: apply evalStmt_isCtx to _ _ _ EvW. search 20. search 30.
 apply evalStmt_unique to _ _ _ EvG1 Ev. search 20.
 apply evalStmt_unique to _ _ _ EvG3 EvA. search 10.
 NS: apply evalStmt_names_same to _ _ _ EvA. search 10.
 IsEE''1+: apply evalStmt_isCtx to _ _ _ EvA. search 10.
 apply evalStmt_unique to _ _ _ EvG5 EvW2. search 20.
 case EvW1. apply append_nil_right to Ev3. clear Ev3.
 %finish up
 FO: case EvAgain3.
   %nil-esque
    exists EE'. split.
      %eval listUpdate
       search.
      %scopes_same
       apply lookupScopes_is to _ LS.
       apply updateListIndex_is to _ _ ULI.
       apply replaceScopes_is to _ _ EvAgain2.
       backchain scopes_same_reflexive.
   %cons-esque
    L: case FO. apply L to _.
%Proj-ListForeach
 case IsS. Ev: case Ev. Ev: case Ev. Ev: case Ev. SN: case SN.
 case SN2.
 EN: apply exprNames_relatedCtxs to _ _ _ _ _ SN with CtxB = []::Ctx'.
   %mems []::Ctx' -> mems Ctx'
    intros M. M: case M. case M. search.
 apply ctx_names_add_scope to Ctxs.
 Ctxs': apply evalExpr_ctx_names to _ _ _ _ _ EN Ev.
 IsEE2+: apply evalExpr_isCtx to _ _ _ Ev. IsEE2: case IsEE2+.
 Ctxs': case Ctxs'. Eq: assert Scope1 = [].
   Is: case IsEE2. search. case Is. M: apply Ctxs' to _. case M.
 case Eq. apply evalExpr_isValue to _ _ _ Ev.
 Names2: apply names_exists to IsEE1. apply names_is to _ Names2.
 Fr: apply fresh_name_exists to _ _ with Base = "L", Names = X::N.
 NS: apply evalExpr_names_same to _ _ _ Ev. NS: case NS.
 apply fresh_name_unique_mems to Fr Pr1 _ _.
   %mem X::Names -> mem X::N
    intros M. M: case M. search.
    apply names_same_names to NS2 Names Names2 M. search.
   %mem X::N -> mem X::Names
    intros M. M: case M. search.
    NS': apply names_same_symmetric to NS2.
    apply names_same_names to NS' Names2 Names M. search.
 apply while_to_iterateList to _ _ _ _ _ _ Names2 Fr _ SN1 Ev1.
 Len: apply length_exists_list_pair_string_value to IsEE.
 NNS: assert newNameScopes [[]] N1 ([]::EE) EE.
   unfold. exists 1, [], Names. split. search. search. search. search.
   search. intros M. case M.
 Ev': apply evalExpr_newNameScopes_exists_back to
         _ _ _ _ _ _ SN Ev NNS.
 NNS': apply evalExpr_newNameScopes_ctx to _ _ _ _ Ev Ev' NNS.
 NNS': case NNS'.
   %end
    Take: case NNS'2. case Take1. compute Take. Drop: case NNS'1.
    apply drop_is_integer to Drop1.
    apply plus_integer_unique_addend to _ _ _ Take Drop.
    Eq: assert EE2 = EE_B'.
      D: case Drop1. search. apply drop_is_integer to D1.
      P: assert 1 + -1 = 0.
      apply plus_integer_unique_addend to _ _ _ P D.
      GEq: apply drop_geq_0 to D1. LEq: case GEq. case LEq.
    case Eq. clear Take Drop Drop1. exists EE'. split.
      %eval
       search.
      %scopes_same
       apply fresh_name_is to _ Fr.
       IsEE'+: apply evalStmt_isCtx to _ _ _ Ev1. search 20.
       case IsEE'+. backchain scopes_same_reflexive.
   %step
    NS': apply evalExpr_names_same to _ _ _ Ev'.
    LenBR+: apply names_same_length to NS' Len. LenBR: case LenBR+.
    apply length_is to LenBR. L: apply lt_plus_one to LenBR1 _.
    LEq: apply newNameScopes_length to NNS' LenBR.
    apply less_lesseq_flip_false to L LEq.


Prove_Ext_Ind exactEval:host:evalExpr,
              exactEval:host:evalArgs,
              exactEval:host:evalRecFields,
              exactEval:host:evalStmt
with forall FE EE V X Body EE' O,
        iterateList FE EE V X Body EE' O with
           IsFE : is_list (is_pair is_string
                          (is_pair is_string
                          (is_pair is_value
                          (is_pair (is_list is_string) is_stmt)))) FE,
           IsEE : is_list (is_list (is_pair is_string is_value)) EE,
           IsV : is_value V,
           IsX : is_string X,
           IsBody : is_stmt Body
and
  iterateList_to_while_P :
    forall FE SaveL V EE X Body EE' O Names N N',
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsEE : is_list (is_list (is_pair is_string is_value))
                ([(SaveL, V)]::EE) ->
      IsV : is_value V ->
      IsX : is_string X ->
      IsBody : is_stmt Body ->
      IL : <iterateList {ES}> FE EE V X Body EE' O N ->
      /*
        The reason we do `acc (N + 1)` is because we need to use the
        IH for acc to change a derivation of evaluation for the body
        into evalStmt_P, where the derivation is not annotated.  Thus
        we need to know its size is smaller, but that is not
        guaranteed for the iterateList size directly.  However,
        whenever we want to use this, we evaluated the iterateList
        with its larger size, and thus have acc for the size of the
        iterateList derivation + 1.
      */
      Plus : 1 + N = N' ->
      Acc : acc N' ->
      Names : names EE Names ->
      Fr : fresh_name "L" (X::Names) SaveL ->
      %
      exists V',
        <evalStmt {P}> FE ([(SaveL, V)]::EE)
           (while (not (null (name SaveL)))
              (seq (declare intTy X (head (name SaveL)))
              (seq (assign SaveL (tail (name SaveL)))
                   Body))) ([(SaveL, V')]::EE') O
  on Acc as IH_IL_W_A, IL * as IH_IL_W.
%evalExpr
 %E-Nil
  apply names_exists to IsEE. search.
 %E-Cons
  apply names_exists to IsEE. apply ext_size_is_int_evalExpr to R3.
  apply ext_size_is_int_evalExpr to R4. case IsE.
  apply plus_integer_is_integer to _ _ R2.
  L: apply lt_plus_one to R1 _. apply ext_size_pos_evalExpr to R3.
  apply ext_size_pos_evalExpr to R4. Acc: case Acc.
  RP1: assert <evalExpr {P}> FE EE E1 V1 EE3 O2.
    Or: apply lt_left to R2 _ _. L': case Or.
      %N2 < N4
       L'': apply less_integer_transitive to L' L.
       A2: apply Acc to _ L''. apply IH to R3 A2 _ _ _. search.
      %N2 = N4
       A2: apply Acc to _ L. apply IH to R3 A2 _ _ _. search.
  RP2: assert <evalExpr {P}> FE EE3 E2 V2 EE' O3.
    Ev1: apply drop_ext_size_evalExpr to R3.
    apply evalExpr_isCtx to _ _ _ Ev1.
    Or: apply lt_right to R2 _ _ _. L': case Or.
      %N3 < N4
       L'': apply less_integer_transitive to L' L.
       A3: apply Acc to _ L''. apply IH to R4 A3 _ _ _. search.
      %N3 = N4
       A3: apply Acc to _ L. apply IH to R4 A3 _ _ _. search.
  unfold. exists N1,
            (recBuild (consRecFieldExprs "null" exactEval:host:false
                      (consRecFieldExprs "head" E1
                      (consRecFieldExprs "tail" E2
                       nilRecFieldExprs)))),
            recVal [("null", falseVal), ("head", V1), ("tail", V2)],
            EE', O, EE3, O2, O3. split.
    %eval_P E1
     search.
    %eval_P E2
     search.
    %append output
     search.
    %names
     search.
    %proj
     search.
    %eval proj
     Ev1: apply drop_ext_size_evalExpr to R3.
     Ev2: apply drop_ext_size_evalExpr to R4.
     apply evalExpr_isCtx to _ _ _ Ev1.
     IsO2: apply evalExpr_isOutput to _ _ _ Ev1.
     IsO3: apply evalExpr_isOutput to _ _ _ Ev2.
     apply is_list_values_append_nil to IsO2.
     apply is_list_values_append_nil to IsO3. search.
 %E-Head
  apply names_exists to IsEE. apply ext_size_is_int_evalExpr to R2.
  apply ext_size_pos_evalExpr to R2. case IsE. Acc: case Acc.
  L: apply lt_plus_one to R1 _. A: apply Acc to _ L.
  apply IH to R2 A _ _ _. Ev: apply drop_ext_size_evalExpr to R2.
  IsO: apply evalExpr_isOutput to _ _ _ Ev.
  apply is_list_values_append_nil to IsO. search.
 %E-Tail
  apply names_exists to IsEE. apply ext_size_is_int_evalExpr to R2.
  apply ext_size_pos_evalExpr to R2. case IsE. Acc: case Acc.
  L: apply lt_plus_one to R1 _. A: apply Acc to _ L.
  apply IH to R2 A _ _ _. Ev: apply drop_ext_size_evalExpr to R2.
  IsO: apply evalExpr_isOutput to _ _ _ Ev.
  apply is_list_values_append_nil to IsO. search.
 %E-Null
  apply names_exists to IsEE. apply ext_size_is_int_evalExpr to R2.
  apply ext_size_pos_evalExpr to R2. case IsE. Acc: case Acc.
  L: apply lt_plus_one to R1 _. A: apply Acc to _ L.
  apply IH to R2 A _ _ _. Ev: apply drop_ext_size_evalExpr to R2.
  IsO: apply evalExpr_isOutput to _ _ _ Ev.
  apply is_list_values_append_nil to IsO. search.
 %E-Index
  case IsE. Ev: apply drop_ext_size_evalExpr to R3.
  Ev1: apply drop_ext_size_evalExpr to R4.
  apply evalExpr_isCtx to _ _ _ Ev.
  IsIdx+: apply evalExpr_isValue to _ _ _ Ev1. case IsIdx+.
  %build evaluation of declaring SaveL
  Len: apply length_exists_list_pair_string_value to IsEE.
  rename N1 to LengthEE. Names: apply names_exists to IsEE.
  NNS_L: assert newNameScopes [[]] LengthEE ([]::EE) EE.
    unfold. exists 1, [], N1. split. search. search. search.
    search. search. intros M. case M.
  Ev_LES: apply evalExpr_newNameScopes_exists_ES to _ _ _ _ R3 NNS_L.
  Ev_L: apply drop_ext_size_evalExpr to Ev_LES.
  NNS_L': apply evalExpr_newNameScopes_ctx to _ _ _ _ Ev_L Ev NNS_L.
  LenEE3: apply evalExpr_keep_scopes to _ _ _ Ev Len.
  Eq: assert EE_A' = []::EE3.
    NNS': case NNS_L'.
      %end
       Take: case NNS'2. case Take1. compute Take. Drop: case NNS'1.
       Drop': case Drop1.
         %Drop-0
          search.
         %Drop-Step
          G: apply drop_geq_0 to Drop'1. P: assert 1 + -1 = 0.
          apply drop_is_integer to Drop'1.
          apply plus_integer_is_integer to _ _ Drop'.
          apply plus_integer_unique_addend to _ _ _ Take Drop.
          apply plus_integer_unique_addend to _ _ _ Drop' P.
          L: case G. case L.
      %step
       LenBR: case LenEE3. apply length_is to LenBR.
       LEq: apply newNameScopes_length to NNS' LenBR.
       L: apply lt_plus_one to LenBR1 _.
       apply less_lesseq_flip_false to L LEq.
  case Eq. IsNames: apply names_is to _ Names.
  FrL: apply fresh_name_exists to _ IsNames with Base = "L".
  FrI: apply fresh_name_exists to _ IsNames with Base = "I".
  rename F to SaveL. rename F1 to SaveI.
  Ev_DL: assert <evalStmt {ES}> FE ([]::EE) (declare intTy SaveL L)
                    ([(SaveL, LV)]::EE3) O2 N2.
  %build evaluation of declaring SaveI
  IsEE3: apply evalExpr_isCtx to _ _ _ Ev.
  apply evalExpr_isValue to _ _ _ Ev.
  apply fresh_name_is to _ FrL. apply fresh_name_is to _ FrI.
  NamesEE3: apply names_exists to IsEE3.
  NNS_I: assert newNameScopes [[(SaveL, LV)]] LengthEE
                   ([(SaveL, LV)]::EE3) EE3.
    unfold. exists 1, [SaveL], N5. split. search. search. search.
      %names [[(SaveL, LV)]] [SaveL]
       search.
      %names EE3 N5
       search.
      %mem [SaveL] -> mem N -> false
       intros ML MN. ML: case ML.
         %Mem-Here
          NS: apply evalExpr_names_same to _ _ _ Ev.
          NS': apply names_same_symmetric to NS.
          MNames: apply names_same_names to _ NamesEE3 Names MN.
          apply fresh_name_not_mem to FrL MNames.
         %Mem-Later
          case ML.
  Ev_IES: apply evalExpr_newNameScopes_exists_ES to _ _ _ _ R4 NNS_I.
  Ev_I: apply drop_ext_size_evalExpr to Ev_IES.
  NNS_If: apply evalExpr_newNameScopes_ctx to _ _ _ _ Ev_I Ev1 NNS_I.
  LenEE': apply evalExpr_keep_scopes to _ _ _ Ev1 LenEE3.
  Eq: assert EE_A'1 = [(SaveL, LV)]::EE'.
    NNS': case NNS_If.
      %end
       Take: case NNS'2. case Take1. compute Take. Drop: case NNS'1.
       Drop': case Drop1.
         %Drop-0
          search.
         %Drop-Step
          G: apply drop_geq_0 to Drop'1. P: assert 1 + -1 = 0.
          apply drop_is_integer to Drop'1.
          apply plus_integer_is_integer to _ _ Drop'.
          apply plus_integer_unique_addend to _ _ _ Take Drop.
          apply plus_integer_unique_addend to _ _ _ Drop' P.
          L: case G. case L.
      %step
       LenBR: case LenEE'. apply length_is to LenBR.
       LEq: apply newNameScopes_length to NNS' LenBR.
       L: apply lt_plus_one to LenBR1 _.
       apply less_lesseq_flip_false to L LEq.
  case Eq.
  Ev_DI: assert <evalStmt {ES}> FE ([(SaveL, LV)]::EE3)
                    (declare intTy SaveI I)
                    ([(SaveI, intVal Idx), (SaveL, LV)]::EE') O3 N3.
  %build evaluation of ifThenElse
  GEq: apply listIndex_geq_0 to _ R5. case GEq.
  Ev_C: assert <evalExpr {ES}> FE
                   ([(SaveI, intVal Idx), (SaveL, LV)]::EE')
                   (greater (num 0) (name SaveI)) falseVal
                   ([(SaveI, intVal Idx), (SaveL, LV)]::EE') [] 0.
  EvIf : assert <evalStmt {ES}> FE
            ([(SaveI, intVal Idx), (SaveL, LV)]::EE')
            (ifThenElse (greater (num 0) (name SaveI))
                (printVal (errorExpr (stringLit "Die") intTy))
                noop) ([(SaveI, intVal Idx), (SaveL, LV)]::EE') [] 0.
  %build evaluation of while loop
  NEq: assert SaveL = SaveI -> false.
    intros E. case E. AppI: apply fresh_name_start to _ FrI.
    AppL: apply fresh_name_start to _ FrL. case AppI. case AppL.
  EvWhile: apply index_to_while to R5 NEq _ with Ctx = EE', FE = FE.
  Ev_W: apply drop_ext_size_evalStmt to EvWhile.
  %build evaluation of recFieldAccess
  assert SaveI = SaveL -> false. intros E. case E. backchain NEq.
  assert lookupScopes SaveL
            ([(SaveI, intVal 0), (SaveL, recVal Fields)]::EE')
            (recVal Fields).
  Ev_RFA: assert <evalExpr {ES}> FE
             ([(SaveI, intVal 0), (SaveL, recVal Fields)]::EE')
             (recFieldAccess (name SaveL) "head") V
             ([(SaveI, intVal 0), (SaveL, recVal Fields)]::EE') [] 0.
  %put it together
  apply ext_size_is_int_evalExpr to R3.
  apply ext_size_is_int_evalExpr to R4.
  apply ext_size_pos_evalExpr to R3.
  apply ext_size_pos_evalExpr to R4.
  apply plus_integer_is_integer to _ _ R2.
  L4: apply lt_plus_one to R1 _. Acc: case Acc.
  L2: assert N2 < N.
    Or: apply lt_left to R2 _ _. C: case Or.
    apply less_integer_transitive to C L4. search. search.
  L3: assert N3 < N.
    Or: apply lt_right to R2 _ _ _. C: case Or.
    apply less_integer_transitive to C L4. search. search.
  A2: apply Acc to _ L2. A3: apply Acc to _ L3.
  apply ext_size_pos_evalExpr to R.
  GEq4: apply greatereq_integer__add_positive to _ _ _ with
           N1 = N2, N2 = N3, Base = 0, Sum = N4.
  GEqN: apply greatereq_integer__add_positive to _ _ _ with
           N1 = 1, N2 = N4, Base = 0, Sum = N.
  OrN: apply greatereq_integer_greater_or_eq to GEqN.
  L0: assert 0 < N.
    C: case OrN.
      %N > 0
       case C. search.
      %N = 0
       P: assert 1 + -1 = 0.
       apply plus_integer_unique_addend to _ _ _ P R1. L: case GEq4.
       case L.
  A0: apply Acc to _ L0.
  apply IH3 to Ev_DL A2 _ _ _. apply IH3 to Ev_DI A3 _ _ _.
  apply evalExpr_isCtx to _ _ _ Ev1.
  apply IH3 to EvIf A0 _ _ _. search 20.
  apply IH3 to EvWhile A0 _ _ _. search 20.
  apply IH to R3 A2 _ _ _. apply IH to R4 A3 _ _ _.
  IsO2: apply evalExpr_isOutput to _ _ _ Ev.
  IsO3: apply evalExpr_isOutput to _ _ _ Ev1.
  IsO: apply append_values_is to _ _ R6.
  apply is_list_values_append_nil to IsO3. unfold.
  exists N1,
     stmtExpr (seq (declare intTy SaveL L)
              (seq (declare intTy SaveI I)
              (seq (ifThenElse (greater (num 0) (name SaveI))
                       (printVal (errorExpr (stringLit "Die") intTy))
                       noop)
                   (while (greater (name SaveI) (num 0))
                       (seq (assign SaveL
                                (recFieldAccess (name SaveL) "tail"))
                            (assign SaveI
                                (minus (name SaveI) (num 1))))))))
              (recFieldAccess (name SaveL) "head"), V,
     EE', O, LV, EE3, O2, Idx, O3. split.
    %eval L
     search.
    %eval I
     search.
    %listIndex
     search.
    %append output
     search.
    %names
     search.
    %proj
     search.
    %eval proj
     unfold.
     exists [(SaveI, intVal 0), (SaveL, recVal Fields)]::EE',
            O, [(SaveI, intVal 0), (SaveL, recVal Fields)], []. split.
       %eval stmt
        search.
       %eval recFieldAccess
        search.
       %aappend output
        backchain is_list_values_append_nil.
 %E-Length
  case IsE. Ev: apply drop_ext_size_evalExpr to R2.
  %make names and fresh vars for proj
  Names: apply names_exists to IsEE. IsN1: apply names_is to _ Names.
  FrL: apply fresh_name_exists to _ IsN1 with Base = "L".
  FrLen: apply fresh_name_exists to _ IsN1 with Base = "Len".
  rename F to SaveL. rename F1 to Len.
  NEq: assert SaveL = Len -> false.
    intros E. case E. AppLen: apply fresh_name_start to _ FrLen.
    FrL: case FrL.
      %FN-Final
       App: case AppLen. case App.
      %FN-Step
       AppL: case FrL1. case AppL.
       AppL: apply fresh_name_start to _ FrL2. AppL: case AppL.
       case AppL. AppLen: case AppLen. case AppLen.
  %declare SaveL
  LenEE: apply length_exists_list_pair_string_value to IsEE.
  NNS: assert newNameScopes [[]] N3 ([]::EE) EE.
    unfold. exists 1, [], N1. split. search. search. search. search.
    search. intros M. case M.
  Ev_L_ES: apply evalExpr_newNameScopes_exists_ES to _ _ _ _ R2 NNS.
  Ev_L: apply drop_ext_size_evalExpr to Ev_L_ES.
  NNS_L: apply evalExpr_newNameScopes_ctx to _ _ _ _ Ev_L Ev NNS.
  LenEE': apply evalExpr_keep_scopes to _ _ _ Ev LenEE.
  Eq: assert EE_A' = []::EE'.
    NNS': case NNS_L.
      Take: case NNS'2. case Take1. compute Take. Drop: case NNS'1.
       Drop': case Drop1.
         %Drop-0
          search.
         %Drop-Step
          G: apply drop_geq_0 to Drop'1. P: assert 1 + -1 = 0.
          apply drop_is_integer to Drop'1.
          apply plus_integer_is_integer to _ _ Drop'.
          apply plus_integer_unique_addend to _ _ _ Take Drop.
          apply plus_integer_unique_addend to _ _ _ Drop' P.
          L: case G. case L.
      %step
       LenBR: case LenEE'. apply length_is to LenBR.
       LEq: apply newNameScopes_length to NNS' LenBR.
       L: apply lt_plus_one to LenBR1 _.
       apply less_lesseq_flip_false to L LEq.
  case Eq.
  Ev_DL: assert <evalStmt {ES}> FE ([]::EE) (declare intTy SaveL E1)
                    ([(SaveL, V1)]::EE') O N2.
  %declare Len
  Ev_DLen: assert <evalStmt {ES}> FE ([(SaveL, V1)]::EE')
                      (declare intTy Len (num 0))
                      ([(Len, intVal 0), (SaveL, V1)]::EE') [] 0.
  %while loop
  apply evalExpr_isValue to _ _ _ Ev. apply listLength_is to _ R3.
  P: assert 0 + I = I. P': apply plus_integer_comm to _ _ P.
  Ev_W_ES: apply length_to_while to R3 NEq P' _ _ with
              FE = FE, Ctx = EE'.
  Ev_W: apply drop_ext_size_evalStmt to Ev_W_ES.
  %final name
  LS: assert lookupScopes Len
                ([(Len, intVal I), (SaveL, recVal Fields)]::EE')
                (intVal I).
  Ev_N: assert <evalExpr {ES}> FE
            ([(Len, intVal I), (SaveL, recVal Fields)]::EE')
            (name Len) (intVal I)
            ([(Len, intVal I), (SaveL, recVal Fields)]::EE') [] 0.
  %put it together
  apply ext_size_is_int_evalExpr to R2.
  P2: apply ext_size_pos_evalExpr to R2.
  L2: apply lt_plus_one to R1 _.
  Acc: case Acc. A2: apply Acc to _ L2.
  LEqN: apply ext_size_pos_evalExpr to R.
  OrN: apply greatereq_integer_greater_or_eq to _ with A = N, B = 0.
  L0: assert 0 < N.
    C: case OrN.
      %N > 0
       case C. search.
      %N = 0
       P'': assert 1 + -1 = 0.
       apply plus_integer_unique_addend to _ _ _ P'' R1.
       L: case P2.
  A0: apply Acc to _ L0.
  apply fresh_name_is to _ FrL. apply fresh_name_is to _ FrLen.
  apply IH to R2 A2 _ _ _. apply IH3 to Ev_DL A2 _ _ _.
  apply evalExpr_isCtx to _ _ _ Ev. apply IH3 to Ev_DLen A0 _ _ _.
  apply IH3 to Ev_W_ES A0 _ _ _. search 20.
  apply evalStmt_isCtx to _ _ _ Ev_W. search 20.
  apply IH to Ev_N A0 _ _ _. unfold.
  exists N1,
    stmtExpr
       (seq (declare intTy SaveL E1)
       (seq (declare intTy Len (num 0))
            (while (not (recFieldAccess (name SaveL) "null"))
              (seq (assign SaveL (recFieldAccess (name SaveL) "tail"))
                   (assign Len (plus (name Len) (num 1)))))))
       (name Len), intVal I, EE', O, V1. split.
    %eval E1
     search.
    %listLength
     search.
    %names
     search.
    %proj
     search.
    %eval proj
     IsO: apply evalExpr_isOutput to _ _ _ Ev.
     apply is_list_values_append_nil to IsO. search.
%evalStmt
 %E-ListUpdate
  Is: case IsS.
  Ev: apply drop_ext_size_evalExpr to R3.
  Ev1: apply drop_ext_size_evalExpr to R4.
  apply ext_size_is_int_evalExpr to R3.
  apply ext_size_is_int_evalExpr to R4.
  apply plus_integer_is_integer to _ _ R2.
  L4: apply lt_plus_one to R1 _. Acc: case Acc.
  apply ext_size_pos_evalExpr to R3.
  apply ext_size_pos_evalExpr to R4.
  L2: assert N2 < N.
    Or: apply lt_right to R2 _ _ _. L': case Or.
      %N2 < N4
       L'': apply less_integer_transitive to L' L4. search.
      %N2 = N4
       search.
  L3: assert N3 < N.
    Or: apply lt_left to R2 _ _. L': case Or.
      %N3 < N4
       L'': apply less_integer_transitive to L' L4. search.
      %N3 = N4
       search.
  A2: apply Acc to _ L2. A3: apply Acc to _ L3.
  apply evalExpr_isCtx to _ _ _ Ev.
  apply IH to R3 A3 _ _ _. apply IH to R4 A2 _ _ _.
  %set up for projection
  Names: apply names_exists to IsEE.
  IsNames: apply names_is to _ Names.
  Is+: assert is_list is_string (L::N5).
  Pr3: apply fresh_name_exists to _ Is+ with Base = "E".
  Pr1: apply fresh_name_exists to _ Is+ with Base = "I".
  Pr2: apply fresh_name_exists to _ Is+ with Base = "Hold". search 6.
  Pr3: apply fresh_name_exists to _ Is+ with Base = "C".
  rename F to SaveE. rename F1 to SaveI. rename F2 to Hold.
  rename F3 to Copy.
  assert SaveE = L -> false.
    intros E. case E. apply fresh_name_not_mem to Pr3 _.
  assert SaveI = L -> false.
    intros E. case E. apply fresh_name_not_mem to Pr1 _.
  assert Hold = L -> false.
    intros E. case E. apply fresh_name_not_mem to Pr2 _.
  assert Copy = L -> false.
    intros E. case E. apply fresh_name_not_mem to Pr4 _.
  assert Hold = SaveE -> false.
    intros E. case E. AppE: apply fresh_name_start to _ Pr3.
    AppH: apply fresh_name_start to _ Pr2. search 6.
    case AppE. case AppH.
  assert Hold = SaveI -> false.
    intros E. case E. AppI: apply fresh_name_start to _ Pr1.
    AppH: apply fresh_name_start to _ Pr2. search 6.
    case AppI. case AppH.
  NEqIE: assert SaveI = SaveE -> false.
    intros E. case E. AppI: apply fresh_name_start to _ Pr1.
    AppE: apply fresh_name_start to _ Pr3. case AppI. case AppE.
  assert Copy = Hold -> false.
    intros E. case E. AppC: apply fresh_name_start to _ Pr4.
    AppH: apply fresh_name_start to _ Pr2. search 6.
    case AppC. case AppH.
  assert SaveE = Copy -> false.
    intros E. case E. AppC: apply fresh_name_start to _ Pr4.
    AppE: apply fresh_name_start to _ Pr3. case AppC. case AppE.
  assert SaveI = Copy -> false.
    intros E. case E. AppC: apply fresh_name_start to _ Pr4.
    AppI: apply fresh_name_start to _ Pr1. case AppC. case AppI.
  LenEE: apply length_exists_list_pair_string_value to IsEE.
  rename N6 to Len.
  NNS: assert newNameScopes [[]] Len ([]::EE) EE.
    unfold. exists 1, [], N5. split. search. search. search.
    search. search. intros M. case M.
  EvI': apply evalExpr_newNameScopes_exists_ES to _ _ _ _ R3 NNS.
  EvI'': apply drop_ext_size_evalExpr to EvI'.
  NNS': apply evalExpr_newNameScopes_ctx to _ _ _ _ EvI'' Ev _.
  Eq: assert EE_A' = []::EE2.
    NNS': case NNS'.
      %end
       Take: case NNS'2. case Take1. compute Take.
       apply drop_one to NNS'1. search.
      %step
       LenBR+: apply evalExpr_keep_scopes to _ _ _ Ev LenEE.
       LenBR: case LenBR+. apply length_is to LenBR.
       L: apply lt_plus_one to LenBR1 _.
       LEq: apply newNameScopes_length to NNS' LenBR.
       apply less_lesseq_flip_false to L LEq.
  case Eq.
  apply IH to EvI' A3 _ _ _.
  EvAI: assert <evalStmt {P}> FE ([]::EE) (declare intTy SaveI I)
                        ([(SaveI, intVal N1)]::EE2) O2.
  apply fresh_name_is to _ Pr1. apply evalExpr_isValue to _ _ _ Ev.
  IsEE2: apply evalExpr_isCtx to _ _ _ Ev.
  Names2: apply names_exists to IsEE2.
  NS: apply evalExpr_names_same to _ _ _ Ev.
  Len2: apply evalExpr_keep_scopes to _ _ _ Ev LenEE.
  NNS+: assert newNameScopes [[(SaveI, intVal N1)]] Len
                  ([(SaveI, intVal N1)]::EE2) EE2.
    unfold. exists 1, [SaveI], N6. split. search. search. search.
    search. search.
    intros M MX. M: case M. NS': apply names_same_symmetric to NS.
    M': apply names_same_names to NS' Names2 Names MX.
    apply fresh_name_not_mem to Pr1 _. case M.
  EvE': apply evalExpr_newNameScopes_exists_ES to _ _ _ _ R4 NNS+.
  EvE'': apply drop_ext_size_evalExpr to EvE'.
  NNS'': apply evalExpr_newNameScopes_ctx to _ _ _ _ EvE'' Ev1 _.
  Len4: apply evalExpr_keep_scopes to _ _ _ Ev1 Len2.
  Eq: assert EE_A'1 = [(SaveI, intVal N1)]::EE4.
    NN: case NNS''.
      %end
       Take: case NN2. Take: case Take1. compute Take.
       apply drop_one to NN1. search.
      %step
       LenBR: case Len4. apply length_is to LenBR.
       L: apply lt_plus_one to LenBR1 _.
       LEq: apply newNameScopes_length to NN LenBR.
       apply less_lesseq_flip_false to L LEq.
  case Eq.
  apply IH to EvE' A2 _ _ _.
  EvAE: assert <evalStmt {P}> FE ([(SaveI, intVal N1)]::EE2)
                        (declare intTy SaveE E)
                        ([(SaveE, V), (SaveI, intVal N1)]::EE4) O3.
  apply fresh_name_is to _ Pr3. apply evalExpr_isValue to _ _ _ Ev1.
  IsEE4: apply evalExpr_isCtx to _ _ _ Ev1.
  EvMI: assert <evalStmt {P}>
                   FE ([(SaveE, V), (SaveI, intVal N1)]::EE4)
                   (assign SaveI (name SaveI))
                   ([(SaveI, intVal N1), (SaveE, V)]::EE4) [].
     assert SaveE = SaveI -> false. intros E. case E. backchain NEqIE.
     search.
  IsEE4: apply evalExpr_isCtx to _ _ _ Ev1.
  Names4: apply names_exists to IsEE4. apply names_is to _ Names4.
  EvH: assert <evalStmt {P}>
                  FE ([(SaveI, intVal N1), (SaveE, V)]::EE4)
                  (declare intTy Hold (exactEval:list:nil intTy))
                  ([(Hold, recVal [("null", trueVal)]),
                    (SaveI, intVal N1),
                    (SaveE, V)]::EE4) []. search 6.
  IsSaveI: apply fresh_name_is to _ Pr1.
  IsHold: apply fresh_name_is to _ Pr2. search 6.
  IsCopy: apply fresh_name_is to _ Pr4.
  GEq: apply updateListIndex_pos to R6.
  apply evalExpr_isValue to _ _ _ Ev1.
  Main: apply proj_listUpdate_eval to
          _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ with
          OldL = LV, I = N1, V = V, NewL = LV2, Hold = Hold,
          Copy = Copy, SaveI = SaveI, SaveE = SaveE, G = EE4, L = L,
          HoldL = recVal [("null", trueVal)]. search 12.
  exists G'. IsO3: apply evalExpr_isOutput to _ _ _ Ev1.
  apply is_list_values_append_nil to IsO3. search 20.
 %E-ListForeach
  IsS: case IsS.
  %R_P for sub-derivations are smaller
  apply ext_size_is_int_evalExpr to R3.
  apply ext_size_is_int_iterateList to R4.
  apply ext_size_pos_evalExpr to R3.
  apply ext_size_pos_iterateList to R4.
  apply plus_integer_is_integer to _ _ R2.
  L4: apply lt_plus_one to R1 _. Acc': case Acc (keep).
  L2: assert N2 < N.
    Or: apply lt_left to R2 _ _. L': case Or.
      %N2 < N4
       apply less_integer_transitive to L' L4. search.
      %N2 = N4
       search.
  L3: assert N3 < N.
    Or: apply lt_right to R2 _ _ _. L': case Or.
      %N3 < N4
       apply less_integer_transitive to L' L4. search.
      %N3 = N4
       search.
  A2: apply Acc' to _ L2. apply IH to R3 A2 _ _ _.
  Ev: apply drop_ext_size_evalExpr to R3.
  apply evalExpr_isValue to _ _ _ Ev. apply evalExpr_isCtx to _ _ _ Ev.
  A3: apply Acc' to _ L3. ILP: apply IH10 to R4 A3 _ _ _ _ _.
  %create proj rel derivation for projection
  EvE: apply drop_ext_size_evalExpr to R3.
  IsEE3: apply evalExpr_isCtx to _ _ _ EvE.
  Names: apply names_exists to IsEE. IsN1: apply names_is to _ Names.
  Fr: apply fresh_name_exists to _ _ with Base = "L", Names = X::N1.
  LenEE3: apply length_exists_list_pair_string_value to IsEE3.
  rename F to SaveL. rename N5 to Len.
  Names3: apply names_exists to IsEE3.
  NS: apply evalExpr_names_same to _ _ _ EvE.
  NNS: assert newNameScopes [[(SaveL, LV)]] Len
                 ([(SaveL, LV)]::EE3) EE3.
    unfold. exists 1, [SaveL], N5. split. search. search. search.
    search. search. intros MSL MX. MSL: case MSL.
      NS': apply names_same_symmetric to NS.
      MX1: apply names_same_names to NS' Names3 Names MX.
      apply fresh_name_not_mem to Fr _. case MSL.
  apply fresh_name_is to _ Fr.
  ILP': apply iterateList_newNameScopes_exists_ES to
           _ _ _ _ _ _ R4 NNS.
  IL: apply drop_ext_size_iterateList to R4.
  IL': apply drop_ext_size_iterateList to ILP'.
  NNS': apply iterateList_newNameScopes to _ _ _ _ _ _ IL' IL NNS.
  NNS': case NNS'.
    %end
     Take: case NNS'2. case Take1. compute Take. Drop: case NNS'1.
     IsN8: apply drop_is_integer to Drop1.
     apply plus_integer_unique_addend to _ _ _ Take Drop.
     Eq: assert L1 = EE'.
       D: case Drop1. search. GEq: apply drop_geq_0 to D1.
       apply drop_is_integer to D1. P: assert 1 + -1 = 0.
       apply plus_integer_unique_addend to _ _ _ P D.
       LEq: case GEq. case LEq.
     case Eq. clear Take Drop Drop1 IsN8.
     ILP'': apply IH4 to ILP' A3 _ _ _ _ _.
     Fr': assert fresh_name "L" (X::N5) SaveL.
       apply names_is to _ Names3.
       Fr': apply fresh_name_exists to
               _ _ with Base = "L", Names = X::N5.
       apply fresh_name_unique_mems to Fr Fr' _ _.
         %mem X::N5 -> mem X::N1
          intros M. M: case M. search.
          NS': apply names_same_symmetric to NS.
          apply names_same_names to NS' Names3 Names M. search.
         %mem X::N1 -> mem X::N5
          intros M. M: case M. search.
          apply names_same_names to NS Names Names3 M. search.
       search.
     Plus: apply plus_integer_total to _ _ with N1 = 1, N2 = N3.
     EvWP: assert exists V',
           <evalStmt {P}> FE ([(SaveL, LV)]::EE3)
              (while (not (null (name SaveL)))
                 (seq (declare intTy X (head (name SaveL)))
                 (seq (assign SaveL (tail (name SaveL))) Body)))
                      ([(SaveL, V')]::EE') O3.
       Or: apply lt_right to R2 _ _ _. L: case Or.
         %N3 < N4
          LEq: apply less_integer_step_lesseq to _ _ L Plus.
          Or: apply lesseq_integer_less_or_eq to LEq. L': case Or.
            %N9 < N4
             L9: apply less_integer_transitive to L' L4.
             apply lesseq_integer__add_positive to _ _ Plus with
                Base = 0. A9: apply Acc' to _ L9.
             apply IH_IL_W to _ _ _ _ _ R4 Plus A9 Names3 Fr'. search.
            %N9 = N4
             apply lesseq_integer__add_positive to _ _ R2 with
               Base = 0. A4: apply Acc' to _ L4.
             apply IH_IL_W to _ _ _ _ _ R4 Plus A4 Names3 Fr'. search.
         %N3 = N4
          apply plus_integer_unique to Plus R1.
          apply IH_IL_W to _ _ _ _ _ R4 Plus Acc Names3 Fr'.
          search.
     EvWP: case EvWP.
     %eval decl in projection
     LenEE: apply length_exists_list_pair_string_value to IsEE.
     NNS_: assert newNameScopes [[]] N11 ([]::EE) EE.
       unfold. exists 1, [], N1. split. search. search. search.
       search. search. intros M. case M.
     EvE+: apply evalExpr_newNameScopes_exists_ES to _ _ _ _ R3 NNS_.
     EvE+': apply drop_ext_size_evalExpr to EvE+.
     NNS+: apply evalExpr_newNameScopes_ctx to _ _ _ _ EvE+' EvE _.
     NNS+: case NNS+.
       %end
        Take: case NNS+2. case Take1. compute Take. Drop: case NNS+1.
        Eq: assert L2 = EE3.
          apply drop_is_integer to Drop1. D: case Drop1. search.
          apply plus_integer_unique_addend to _ _ _ Take Drop.
          P: assert 1 + -1 = 0. apply drop_is_integer to D1.
          apply plus_integer_unique_addend to _ _ _ P D.
          GEq: apply drop_geq_0 to D1. LEq: case GEq. case LEq.
        case Eq. clear Take Drop Drop1 NNS+4 NNS+3 NNS+5 NNS+.
        unfold. exists N1,
          scopeStmt
            (seq (declare intTy SaveL L)
                 (while (not (null (name SaveL)))
                    (seq (declare intTy X (head (name SaveL)))
                    (seq (assign SaveL (tail (name SaveL))) Body)))),
          EE', O, LV, EE3, O2, O3. split.
          %evalExpr
           search.
          %iterateList
           search.
          %append output
           search.
          %names
           search.
          %proj
           search.
          %eval proj
           unfold. exists [(SaveL, V')]. unfold.
           exists [(SaveL, LV)]::EE3, O2, O3. split.
             %eval declare
              apply IH to EvE+ A2 _ _ _. search.
             %eval while
              search.
             %append output
              search.
       %step
        NSE: apply evalExpr_names_same to _ _ _ EvE.
        LenBR+: apply names_same_length to NSE LenEE.
        LenBR: case LenBR+. apply length_is to LenBR.
        L: apply lt_plus_one to LenBR1 _.
        LEq: apply newNameScopes_length to NNS+ LenBR.
        apply less_lesseq_flip_false to L LEq.
    %step
     NSI: apply iterateList_names_same to _ _ _ _ _ IL.
     LenBR+: apply names_same_length to NSI LenEE3. LenBR: case LenBR+.
     apply length_is to LenBR. L: apply lt_plus_one to LenBR1 _.
     LEq: apply newNameScopes_length to NNS' LenBR.
     apply less_lesseq_flip_false to L LEq.
%iterateList
 %IL-Nil
  search.
 %IL-Cons
  case IsV. apply lookup_is_value to _ R3.
  apply lookup_is_value to _ R5.
  Ev: apply drop_ext_size_evalStmt to R4.
  IL: apply drop_ext_size_iterateList to R6.
  IsEE3+: apply evalStmt_isCtx to _ _ _ Ev. case IsEE3+.
  apply ext_size_is_int_evalStmt to R4.
  apply ext_size_is_int_iterateList to R6.
  apply plus_integer_is_integer to _ _ R1.
  Acc': case Acc (keep). apply ext_size_pos_evalStmt to R4.
  apply ext_size_pos_iterateList to R6.
  assert <evalStmt {P}> FE ([(X, Hd)]::EE) Body (Scope::EE3) O2.
    Or: apply lt_left to R1 _ _. L': case Or.
      %N2 < N
       A2: apply Acc' to _ L'. apply IH9 to R4 A2 _ _ _. search.
      %N2 = N
       apply IH9 to R4 Acc _ _ _. search.
  assert <iterateList {P}> FE EE3 Tl X Body EE' O3.
    Or: apply lt_right to R1 _ _ _. L': case Or.
      %N3 < N
       A3: apply Acc' to _ L'. apply IH10 to R6 A3 _ _ _ _ _. search.
      %N3 = N
       apply IH10 to R6 Acc _ _ _ _ _. search.
  search.
%iterateList_to_while_P
 %IL-Nil
  search 20.
 %IL-Cons
  IsFields: case IsV.
  assert <evalExpr {P}> FE ([(SaveL, recVal Fields)]::EE)
                        (not (null (name SaveL))) trueVal
                        ([(SaveL, recVal Fields)]::EE) []. search 20.
  assert <evalStmt {P}> FE ([]::[(SaveL, recVal Fields)]::EE)
                        (declare intTy X (head (name SaveL)))
                        ([(X, Hd)]::[(SaveL, recVal Fields)]::EE) [].
     search 20.
  NEq: assert X = SaveL -> false.
    intros E. case E. apply fresh_name_not_mem to Fr _.
  assert <evalStmt {P}> FE ([(X, Hd)]::[(SaveL, recVal Fields)]::EE)
                        (assign SaveL (tail (name SaveL)))
                        ([(X, Hd)]::[(SaveL, Tl)]::EE) []. search 20.
  %body evaluation
  IsSaveL: apply fresh_name_is to _ Fr.
  IsHd: apply lookup_is_value to _ IL3.
  IsTl: apply lookup_is_value to _ IL5. IsEE: case IsEE.
  LenEE: apply length_exists_list_pair_string_value to IsEE1.
  rename N1 to Len. Acc': case Acc (keep).
  NNS: assert newNameScopes [[(SaveL, Tl)]] Len
                            ([(SaveL, Tl)]::EE) EE.
    unfold. exists 1, [SaveL], Names. split. search. search. search.
    search. search. intros ML MN. ML: case ML.
      %Mem-Here
       apply fresh_name_not_mem to Fr _.
      %Mem-Later
       case ML.
  Ev: apply evalStmt_newNameScopes_exists_ES to _ _ _ _ IL4 NNS.
  apply ext_size_is_int_iterateList to IL.
  LN: apply lt_plus_one to Plus _.
  EvP: assert <evalStmt {P}> FE ([(X, Hd)]::([(SaveL, Tl)]::EE)) Body
                             EE_A' O2.
     apply ext_size_is_int_evalStmt to IL4.
     apply ext_size_pos_evalStmt to IL4.
     apply ext_size_pos_iterateList to IL6.
     Or: apply lt_left to IL1 _ _. L: case Or.
       %N2 < N
        L': apply less_integer_transitive to L LN.
        A2: apply Acc' to _ L'. apply IH3 to Ev A2 _ _ _. search.
       %N2 = N
        A2: apply Acc' to _ LN. apply IH3 to Ev A2 _ _ _. search.
  %rest of loop
  Ev': apply drop_ext_size_evalStmt to Ev.
  EvB: apply drop_ext_size_evalStmt to IL4.
  Eq: assert EE_A' = Scope::[(SaveL, Tl)]::EE3.
    NNS+: apply evalStmt_newNameScopes to _ _ _ _ Ev' EvB NNS.
    NNS+: case NNS+.
      %end
       IsLen: apply length_is to LenEE.
       P: apply plus_integer_total to _ IsLen with N1 = 1.
       LenEE+: assert length ([(X, Hd)]::EE) N4.
       LenEE3+: apply evalStmt_keep_scopes to _ _ _ EvB LenEE+.
       apply length_unique to LenEE3+ NNS+.
       L: apply lt_plus_one to P _. apply less_integer_not_eq to L.
      %step
       NNS+: case NNS+.
         %end
          Take: case NNS+2. case Take1. compute Take.
          Drop: case NNS+1. apply drop_is_integer to Drop1.
          apply plus_integer_unique_addend to _ _ _ Take Drop.
          Eq: assert L = EE3.
            Drop': case Drop1. search.
            GEq: apply drop_geq_0 to Drop'1.  P: assert 1 + -1 = 0.
            apply drop_is_integer to Drop'1.
            apply plus_integer_unique_addend to _ _ _ P Drop'.
            LEq: case GEq. case LEq.
          case Eq. search.
         %step
          IsLen: apply length_is to LenEE.
          P: apply plus_integer_total to _ IsLen with N1 = 1.
          LenEE+: assert length ([(X, Hd)]::EE) N1.
          LenBR++: apply evalStmt_keep_scopes to _ _ _ EvB LenEE+.
          LenBR+: case LenBR++. apply length_is to LenBR+.
          LenBR: case LenBR+. apply length_is to LenBR.
          LEq: apply newNameScopes_length to NNS+ LenBR.
          apply plus_integer_unique_addend to _ _ _ P LenBR+1.
          L: apply lt_plus_one to LenBR1 _.
          apply less_lesseq_flip_false to L LEq.
  case Eq. Is': apply evalStmt_isCtx to _ _ _ Ev'. Is': case Is'.
  IsN3: apply ext_size_is_int_iterateList to IL6.
  apply ext_size_pos_iterateList to IL6.
  P: apply plus_integer_total to _ IsN3 with N1 = 1.
  apply lesseq_integer__add_positive to _ _ P with Base = 0.
  apply ext_size_pos_evalStmt to IL4.
  Is'': case Is'1. N: apply names_exists to Is''1.
  apply names_is to _ N.
  Fr': apply fresh_name_exists to _ _ with Base = "L", Names = X::N4.
  NS: apply evalStmt_names_same to _ _ _ EvB.
  apply fresh_name_unique_mems to Fr' Fr _ _.
    intros M. M: case M. search.
      apply names_same_names to NS Names N M. search.
    intros M. M: case M. search.
      NS': apply names_same_symmetric to NS.
      apply names_same_names to NS' N Names M. search.
  Or: apply lt_right to IL1 _ _ _. L: case Or.
    %N3 < N
     LEq: apply less_integer_step_lesseq to _ _ L P.
     Or: apply lesseq_integer_less_or_eq to LEq. L': case Or.
       %N1 < N
        L'': apply less_integer_transitive to L' LN.
        A: apply Acc' to _ L''.
        apply IH_IL_W to _ _ _ _ _ IL6 P A N Fr'. search.
       %N1 = N
        A: apply Acc' to _ LN.
        apply IH_IL_W to _ _ _ _ _ IL6 P A N Fr'. search.
    %N3 = N
     apply IH_IL_W to _ _ _ _ _ IL6 Plus Acc N Fr'. search.


Prove exactEval:host:paramName_unique.
Prove_Constraint exactEval:host:proj_paramName_forward.
Prove_Constraint exactEval:host:proj_paramName_back.
Prove exactEval:host:getFunEvalInfo_unique.
Prove_Constraint exactEval:host:proj_getFunEvalInfo_forward.
Prove_Constraint exactEval:host:proj_getFunEvalInfo_back.

Prove exactEval:host:evalProgram_unique.
Prove_Constraint exactEval:host:proj_evalProgram_forward.
Prove_Constraint exactEval:host:proj_evalProgram_back.


Theorem listIndex_typePres : forall L Ty I V,
  valueType L (listTy Ty) -> listIndex L I V -> valueType V Ty.
induction on 2. intros VT LI. LI: case LI.
  %LI-0
   VT: case VT.
     %VT-ListNil
      L: case LI. case L1.
     %VT-ListCons
      L: case LI. L: case L1.
        %Lkp-Here
         search.
        %Lkp-Later
         apply L1 to _.
  %LI-Step
   VT: case VT.
     %VT-ListNil
      L: case LI1. case L1.
     %VT-ListCons
      L: case LI1. L: case L1. L: case L2.
        %Lkp-Here
         apply IH to _ LI2. search.
        %Lkp-Later
         apply L2 to _.


Theorem updateListIndex_typePres : forall L Ty I V Out,
  valueType L (listTy Ty) -> valueType V Ty ->
  updateListIndex L I V Out -> valueType Out (listTy Ty).
induction on 3. intros VTL VTV ULI. ULI: case ULI.
  %ULI-0
   VTL: case VTL.
     %VT-ListNil
      R: case ULI1. case R1.
     %VT-ListCons
      R: case ULI1. R: case R1.
        %RRV-Here
         search.
        %RRV-Later
         apply R1 to _.
  %ULI-Step
   VTL: case VTL.
     %VT-ListNil
      L: case ULI2. case L1.
     %VT-ListCons
      L: case ULI2. L: case L1. L: case L2.
        %Lkp-Here
         apply IH to _ _ ULI3. R: case ULI4. R: case R1. R: case R2.
           %RRV-Here
            search.
           %RRV-Later
            apply R2 to _.
        %Lkp-Later
         apply L2 to _.


Prove exactEval:host:evalExpr_typePres_ctx,
      exactEval:host:evalExpr_typePres,
      exactEval:host:evalStmt_typePres,
      exactEval:host:evalArgs_typePres_Ctx,
      exactEval:host:evalArgs_typePres,
      exactEval:host:evalRecFields_typePres_Ctx,
      exactEval:host:evalRecFields_typePres
with
  iterateList_typePres : forall V X Body FT ET Ty Sc ET' FE EE EE' O,
    IsV : is_value V ->
    IsX : is_string X ->
    IsBody : is_stmt Body ->
    IsFT : is_list (is_pair is_string
                   (is_pair is_typ (is_list is_typ))) FT ->
    IsET : is_list (is_list (is_pair is_string is_typ)) ET ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    Ty : stmtOK FT ([(X, Ty)]::ET) Body (Sc::ET') ->
    VTy : valueType V (listTy Ty) ->
    IsTy : is_typ Ty ->
    IL : iterateList FE EE V X Body EE' O ->
    Funs : (forall F RetTy ArgTys ArgNames Body RetVar RVVal,
              lookup FT F (RetTy, ArgTys) ->
              lookup FE F (RetVar, RVVal, ArgNames, Body) ->
              exists Scope TyEnv',
                zip ArgNames ArgTys Scope /\
                valueType RVVal RetTy /\
                stmtOK FT [((RetVar, RetTy)::Scope)] Body TyEnv') ->
    Ctxs : related_all_scopes ET EE ->
    related_all_scopes ET' EE'
  on IL as IH_IL.
%evalExpr_typePres_ctx
 %E-Nil
  search.
 %E-Cons
  case IsE. Ty: case Ty. apply IH_C_E to _ _ _ _ _ _ Ev1 _ _.
  apply evalExpr_isCtx to _ _ _ Ev1.
  apply IH_C_E to _ _ _ _ _ _ Ev2 _ _. search.
 %E-Head
  case IsE. Ty: case Ty. apply IH_C_E to _ _ _ _ _ _ Ev1 _ _.
  search.
 %E-Tail
  case IsE. Ty: case Ty. apply IH_C_E to _ _ _ _ _ _ Ev1 _ _.
  search.
 %E-Null
  case IsE. Ty: case Ty. apply IH_C_E to _ _ _ _ _ _ Ev1 _ _.
  search.
 %E-Index
  case IsE. Ty: case Ty. apply IH_C_E to _ _ _ _ _ _ Ev1 _ _.
  apply evalExpr_isCtx to _ _ _ Ev1.
  apply IH_C_E to _ _ _ _ _ _ Ev2 _ _. search.
 %E-Length
  case IsE. Ty: case Ty. apply IH_C_E to _ _ _ _ _ _ Ev1 _ _.
  search.
%evalExpr_typePres
 %E-Nil
  case Ty. search.
 %E-Cons
  case IsE. Ty: case Ty. apply IH_C_E to _ _ _ _ _ _ Ev1 _ _.
  apply evalExpr_isCtx to _ _ _ Ev1.
  apply IH_T_E to _ _ _ _ _ _ Ev1 _ _.
  apply IH_T_E to _ _ _ _ _ _ Ev2 _ _. search.
 %E-Head
  case IsE. Ty: case Ty. VT: apply IH_T_E to _ _ _ _ _ _ Ev1 _ _.
  VT: case VT.
    %VT-ListNil
     L: case Ev2. case L1.
    %VT-ListCons
     L: case Ev2. L: case L1.
       %Lkp-Here
        search.
       %Lkp-Later
        apply L1 to _.
 %E-Tail
  case IsE. Ty: case Ty. VT: apply IH_T_E to _ _ _ _ _ _ Ev1 _ _.
  VT: case VT.
    %VT-ListNil
     L: case Ev2. case L1.
    %VT-ListCons
     L: case Ev2. L: case L1. L: case L2.
       %Lkp-Here
        search.
       %Lkp-Later
        apply L2 to _.
 %E-Null
  case IsE. Ty: case Ty. VT: apply IH_T_E to _ _ _ _ _ _ Ev1 _ _.
  VT: case VT.
    %VT-ListNil
     L: case Ev2. search. apply L to _.
    %VT-ListCons
     L: case Ev2. search. apply L to _.
 %E-Index
  case IsE. Ty: case Ty. apply IH_T_E to _ _ _ _ _ _ Ev1 _ _.
  apply listIndex_typePres to _ Ev3. search.
 %E-Length
  case Ty. search.
%evalStmt_typePres
 %E-ListUpdate
  case IsS. Ty: case Ty. apply IH_C_E to _ _ _ _ _ _ Ev1 _ _.
  apply evalExpr_isCtx to _ _ _ Ev1.
  Ctxs': apply IH_C_E to _ _ _ _ _ _ Ev2 _ _.
  apply IH_T_E to _ _ _ _ _ _ Ev2 _ _.
  apply evalExpr_isCtx to _ _ _ Ev2.
  apply related_all_scopes_lookupScopes to Ctxs' Ty Ev3.
  apply updateListIndex_typePres to _ _ Ev4.
  apply related_all_scopes_replaceScopes to _ _ _ Ev5 _ _. search.
 %E-ListForeach
  case IsS. Ty: case Ty. apply IH_C_E to _ _ _ _ _ _ Ev1 _ _.
  IsLTy: apply typeOf_isTy to _ _ _ Ty. case IsLTy.
  apply stmtOK_older_scopes_same to _ _ _ Ty1.
  apply evalExpr_isCtx to _ _ _ Ev1.
  apply evalExpr_isValue to _ _ _ Ev1.
  apply IH_T_E to _ _ _ _ _ _ Ev1 _ _.
  apply IH_IL to _ _ _ _ _ _ _ Ty1 _ _ Ev2 _ _. search.
%iterateList_typePres
 %IL-Nil
  apply stmtOK_older_scopes_same to _ _ _ Ty. search.
 %IL-Cons
  apply stmtOK_older_scopes_same to _ _ _ Ty. case IsV.
  apply lookup_is_value to _ IL2. apply lookup_is_value to _ IL4.
  And: assert valueType Hd Ty /\ valueType Tl (listTy Ty).
    VTy: case VTy.
      %VT-ListNil
       L: case IL4. case L1.
      %VT-ListCons
       split.
         %Hd
          LH: case IL2. LH: case LH1. search. apply LH1 to _.
         %Tl
          LT: case IL4. LT: case LT1. LT: case LT2. search. case LT3.
  case And. assert related_all_scopes ([(X, Ty)]::ET) ([(X, Hd)]::EE).
    unfold.
      %lookup
       intros L. L: case L. search. case L1.
      %no_lookup
       intros NL. case NL. search.
      %rest
       search.
  Ctxs': apply IH_C_S to _ _ _ _ _ Ty IL3 _ _. case Ctxs'.
  IsEE3+: apply evalStmt_isCtx to _ _ _ IL3. case IsEE3+.
  apply IH_IL to _ _ _ _ _ _ _ Ty _ _ IL5 _ _. search.


Prove exactEval:host:paramTy_paramName_same.
Prove exactEval:host:funOK_getFunEvalInfo_related.


Prove exactEval:host:evalExpr_output_forms,
      exactEval:host:evalStmt_output_forms,
      exactEval:host:evalArgs_output_forms,
      exactEval:host:evalRecFields_output_forms
with
  iterateList_output_forms : forall V X Body FE EE EE' O,
    IsV : is_value V ->
    IsX : is_string X ->
    IsBody : is_stmt Body ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    IL : iterateList FE EE V X Body EE' O ->
    output_forms O
  on IL as IH_IL.
%evalExpr_output_forms
 %E-Nil
  search.
 %E-Cons
  case IsE. apply IH_E to _ _ _ Ev1.
  apply evalExpr_isCtx to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply output_forms_append to _ _ Ev3. search.
 %E-Head
  case IsE. apply IH_E to _ _ _ Ev1. search.
 %E-Tail
  case IsE. apply IH_E to _ _ _ Ev1. search.
 %E-Null
  case IsE. apply IH_E to _ _ _ Ev1. search.
 %E-Index
  case IsE. apply IH_E to _ _ _ Ev1.
  apply evalExpr_isCtx to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply output_forms_append to _ _ Ev4. search.
 %E-Length
  case IsE. apply IH_E to _ _ _ Ev1. search.
%evalStmt_output_forms
 %E-ListUpdate
  case IsS. apply IH_E to _ _ _ Ev1.
  apply evalExpr_isCtx to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply output_forms_append to _ _ Ev6. search.
 %E-ListForeach
  case IsS. apply IH_E to _ _ _ Ev1.
  apply evalExpr_isCtx to _ _ _ Ev1.
  apply evalExpr_isValue to _ _ _ Ev1.
  apply IH_IL to _ _ _ _ _ Ev2.
  apply output_forms_append to _ _ Ev3. search.
%iterateList_output_forms
 %IL-Nil
  search.
 %IL-Cons
  case IsV. apply lookup_is_value to _ IL2.
  apply lookup_is_value to _ IL4. apply IH_S to _ _ _ IL3.
  IsEE3+: apply evalStmt_isCtx to _ _ _ IL3. case IsEE3+.
  apply IH_IL to _ _ _ _ _ IL5. apply output_forms_append to _ _ IL6.
  search.


Prove exactEval:host:evalProgram_output_forms.


Prove exactEval:host:paramName_exists.
Prove exactEval:host:getFunEvalInfo_exists.
