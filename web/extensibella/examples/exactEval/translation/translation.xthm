Module exactEval:translation.


Prove_Constraint exactEval:host:proj_expr_unique.
Prove_Constraint exactEval:host:proj_expr_is.
Prove_Constraint exactEval:host:proj_expr_other.
Prove_Constraint exactEval:host:proj_stmt_unique.
Prove_Constraint exactEval:host:proj_stmt_is.
Prove_Constraint exactEval:host:proj_stmt_other.
Prove_Constraint exactEval:host:proj_fun_unique.
Prove_Constraint exactEval:host:proj_fun_is.
Prove_Constraint exactEval:host:proj_param_unique.
Prove_Constraint exactEval:host:proj_param_is.
Prove_Constraint exactEval:host:proj_program_unique.
Prove_Constraint exactEval:host:proj_program_is.
Prove_Constraint exactEval:host:proj_typ_unique.
Prove_Constraint exactEval:host:proj_typ_is.


Add_Proj_Rel exactEval:host:is_expr, exactEval:host:is_args,
             exactEval:host:is_recFieldExprs, exactEval:host:is_stmt.
Prove_Ext_Ind exactEval:host:is_expr, exactEval:host:is_args,
              exactEval:host:is_recFieldExprs, exactEval:host:is_stmt.

Prove exactEval:host:is_args_nilArgs_or_consArgs.
Prove exactEval:host:is_recFieldExprs_nilRecFieldExprs_or_consRecFieldExprs.


Prove exactEval:host:vars_unique.
Prove exactEval:host:vars_is.
Prove exactEval:host:vars_exist,
      exactEval:host:varsArgs_exist,
      exactEval:host:varsRecFields_exist.


Prove exactEval:host:stmtNames_is,
      exactEval:host:stmtNames_isCtx,
      exactEval:host:exprNames_is.
Prove exactEval:host:stmtNames_unique,
      exactEval:host:exprNames_unique.
Prove exactEval:host:stmtNames_keep_older.
Prove exactEval:host:stmtNames_exists,
      exactEval:host:exprNames_exists,
      exactEval:host:argsNames_exists,
      exactEval:host:recFieldNames_exists.
Prove exactEval:host:stmtNames_not_in_ctx,
      exactEval:host:exprNames_not_in_ctx.
Prove exactEval:host:stmtNames_relatedCtxs,
      exactEval:host:stmtNames_relatedCtxs_ctx_fwd,
      exactEval:host:stmtNames_relatedCtxs_ctx_back,
      exactEval:host:exprNames_relatedCtxs.
Prove exactEval:host:stmtNames_increaseCtxs,
      exactEval:host:stmtNames_increaseCtxs_ctxs,
      exactEval:host:exprNames_increaseCtxs.

Prove_Constraint exactEval:host:proj_exprNames.
Prove_Constraint exactEval:host:proj_stmtNames.
Prove_Constraint exactEval:host:proj_stmtNames_names_forward.
Prove_Constraint exactEval:host:proj_stmtNames_names_backward.


Prove exactEval:host:typeOf_isTy,
      exactEval:host:stmtOK_isCtx.
Prove exactEval:host:stmtOK_keep_scopes.
Prove exactEval:host:stmtOK_older_scopes_same.
Prove exactEval:host:stmtOK_first_scope_lookup_same.
Prove exactEval:host:typeOf_unique,
      exactEval:host:stmtOK_unique.

Prove exactEval:host:paramTy_is.
Prove exactEval:host:getFunInfo_is.
Prove exactEval:host:paramTy_exists.
Prove exactEval:host:getFunInfo_exists.


Prove exactEval:host:evalExpr_isCtx,
      exactEval:host:evalExpr_isValue,
      exactEval:host:evalStmt_isCtx,
      exactEval:host:evalArgs_isCtx,
      exactEval:host:evalArgs_isValue,
      exactEval:host:evalRecFields_isCtx,
      exactEval:host:evalRecFields_isValue.
Prove exactEval:host:evalExpr_isOutput,
      exactEval:host:evalStmt_isOutput,
      exactEval:host:evalArgs_isOutput,
      exactEval:host:evalRecFields_isOutput.

Prove exactEval:host:paramName_is.
Prove exactEval:host:getFunEvalInfo_is.

Prove exactEval:host:evalProgram_isOutput.


Prove exactEval:host:evalExpr_names_same,
      exactEval:host:evalStmt_names_same,
      exactEval:host:evalArgs_names_same,
      exactEval:host:evalRecFields_names_same.

Prove exactEval:host:evalExpr_newNameScopes,
      exactEval:host:evalExpr_newNameScopes_output,
      exactEval:host:evalExpr_newNameScopes_ctx,
      exactEval:host:evalStmt_newNameScopes_output,
      exactEval:host:evalStmt_newNameScopes,
      exactEval:host:evalArgs_newNameScopes,
      exactEval:host:evalArgs_newNameScopes_output,
      exactEval:host:evalArgs_newNameScopes_ctx,
      exactEval:host:evalRecFields_newNameScopes,
      exactEval:host:evalRecFields_newNameScopes_output,
      exactEval:host:evalRecFields_newNameScopes_ctx.

Add_Ext_Size exactEval:host:evalExpr,
             exactEval:host:evalArgs,
             exactEval:host:evalRecFields,
             exactEval:host:evalStmt.
Add_Proj_Rel exactEval:host:evalExpr,
             exactEval:host:evalArgs,
             exactEval:host:evalRecFields,
             exactEval:host:evalStmt.

Prove exactEval:host:evalExpr_newNameScopes_exists_ES,
      exactEval:host:evalStmt_newNameScopes_exists_ES,
      exactEval:host:evalArgs_newNameScopes_exists_ES,
      exactEval:host:evalRecFields_newNameScopes_exists_ES.

Prove exactEval:host:evalExpr_ctx_names,
      exactEval:host:evalStmt_ctx_names,
      exactEval:host:evalArgs_ctx_names,
      exactEval:host:evalRecFields_ctx_names.
Prove exactEval:host:evalExpr_newNameScopes_exists_back,
      exactEval:host:evalStmt_newNameScopes_exists_back,
      exactEval:host:evalArgs_newNameScopes_exists_back,
      exactEval:host:evalRecFields_newNameScopes_exists_back.

Prove exactEval:host:evalExpr_scopes_same,
      exactEval:host:evalExpr_scopes_same_ctx,
      exactEval:host:evalStmt_scopes_same,
      exactEval:host:evalStmt_scopes_same_ctx,
      exactEval:host:evalArgs_scopes_same,
      exactEval:host:evalArgs_scopes_same_ctx,
      exactEval:host:evalRecFields_scopes_same,
      exactEval:host:evalRecFields_scopes_same_ctx.
Prove exactEval:host:evalExpr_scopes_same_exists,
      exactEval:host:evalStmt_scopes_same_exists,
      exactEval:host:evalArgs_scopes_same_exists,
      exactEval:host:evalRecFields_scopes_same_exists.

Prove_Constraint exactEval:host:proj_evalExpr_forward.
Prove_Constraint exactEval:host:proj_evalExpr_backward.
Prove_Constraint exactEval:host:proj_evalStmt_forward.
Prove_Constraint exactEval:host:proj_evalStmt_backward.

Prove_Ext_Ind exactEval:host:evalExpr,
              exactEval:host:evalArgs,
              exactEval:host:evalRecFields,
              exactEval:host:evalStmt.

Prove exactEval:host:paramName_unique.
Prove_Constraint exactEval:host:proj_paramName_forward.
Prove_Constraint exactEval:host:proj_paramName_back.
Prove exactEval:host:getFunEvalInfo_unique.
Prove_Constraint exactEval:host:proj_getFunEvalInfo_forward.
Prove_Constraint exactEval:host:proj_getFunEvalInfo_back.

Prove exactEval:host:evalProgram_unique.
Prove_Constraint exactEval:host:proj_evalProgram_forward.
Prove_Constraint exactEval:host:proj_evalProgram_back.

Prove exactEval:host:evalExpr_typePres_ctx,
      exactEval:host:evalExpr_typePres,
      exactEval:host:evalStmt_typePres,
      exactEval:host:evalArgs_typePres_Ctx,
      exactEval:host:evalArgs_typePres,
      exactEval:host:evalRecFields_typePres_Ctx,
      exactEval:host:evalRecFields_typePres.

Prove exactEval:host:paramTy_paramName_same.
Prove exactEval:host:funOK_getFunEvalInfo_related.

Prove exactEval:host:evalExpr_output_forms,
      exactEval:host:evalStmt_output_forms,
      exactEval:host:evalArgs_output_forms,
      exactEval:host:evalRecFields_output_forms.

Prove exactEval:host:evalProgram_output_forms.
Prove exactEval:host:paramName_exists.
Prove exactEval:host:getFunEvalInfo_exists.





/********************************************************************
  _______                  _       _   _
 |__   __|                | |     | | (_)
    | |_ __ __ _ _ __  ___| | __ _| |_ _  ___  _ __
    | | '__/ _` | '_ \/ __| |/ _` | __| |/ _ \| '_ \
    | | | | (_| | | | \__ \ | (_| | |_| | (_) | | | |
    |_|_|  \__,_|_| |_|___/_|\__,_|\__|_|\___/|_| |_|
   _____                         _
  / ____|                       | |
 | |     ___  _ __ _ __ ___  ___| |_ _ __   ___  ___ ___
 | |    / _ \| '__| '__/ _ \/ __| __| '_ \ / _ \/ __/ __|
 | |___| (_) | |  | | |  __/ (__| |_| | | |  __/\__ \__ \
  \_____\___/|_|  |_|  \___|\___|\__|_| |_|\___||___/___/

 Translation Correctness
 ********************************************************************/

/*********************************************************************
 Is relations for translation
 *********************************************************************/
Theorem join_is : forall L J,
  is_list (is_list is_string) L -> join L J -> is_list is_string J.
induction on 2. intros Is J. J: case J.
  %Join-Nil
   search.
  %Join-Cons
   case Is. apply IH to _ J. apply append_list_string_is to _ _ J1.
   search.


Extensible_Theorem
  transE_is : forall Names E T,
    IsE : is_expr E ->
    IsNames : is_list (is_list is_string) Names ->
    Trans : transE Names E T ->
    is_expr T
  on Trans as IH_E,
  transS_is : forall Names S T Names',
    IsS : is_stmt S ->
    IsNames : is_list (is_list is_string) Names ->
    Trans : transS Names S T Names' ->
    is_stmt T
  on Trans as IH_S,
  transS_isNames : forall Names S T Names',
    IsS : is_stmt S ->
    IsNames : is_list (is_list is_string) Names ->
    Trans : transS Names S T Names' ->
    is_list (is_list is_string) Names'
  on Trans as IH_S_C
also
  transA_is : forall Names A T,
    IsA : is_args A ->
    IsNames : is_list (is_list is_string) Names ->
    Trans : transA Names A T ->
    is_args T
  on Trans as IH_A,
  transRF_is : forall Names RF T,
    IsRF : is_recFieldExprs RF ->
    IsNames : is_list (is_list is_string) Names ->
    Trans : transRF Names RF T ->
    is_recFieldExprs T
  on Trans as IH_RF.
%transE_is
 %TE-Num
  search.
 %TE-Plus
  case IsE. apply IH_E to _ _ Trans1. apply IH_E to _ _ Trans2.
  search.
 %TE-Minus
  case IsE. apply IH_E to _ _ Trans1. apply IH_E to _ _ Trans2.
  search.
 %TE-Mult
  case IsE. apply IH_E to _ _ Trans1. apply IH_E to _ _ Trans2.
  search.
 %TE-Div
  case IsE. apply IH_E to _ _ Trans1. apply IH_E to _ _ Trans2.
  search.
 %TE-True
  search.
 %TE-False
  search.
 %TE-And
  case IsE. apply IH_E to _ _ Trans1. apply IH_E to _ _ Trans2.
  search.
 %TE-Or
  case IsE. apply IH_E to _ _ Trans1. apply IH_E to _ _ Trans2.
  search.
 %TE-Not
  case IsE. apply IH_E to _ _ Trans1. search.
 %TE-Greater
  case IsE. apply IH_E to _ _ Trans1. apply IH_E to _ _ Trans2.
  search.
 %TE-Eq
  case IsE. apply IH_E to _ _ Trans1. apply IH_E to _ _ Trans2.
  search.
 %TE-String
  search.
 %TE-StringApp
  case IsE. apply IH_E to _ _ Trans1. apply IH_E to _ _ Trans2.
  search.
 %TE-Name
  search.
 %TE-Call
  case IsE. apply IH_A to _ _ Trans1. search.
 %TE-StmtExpr
  case IsE. apply IH_S to _ _ Trans1. apply IH_S_C to _ _ Trans1.
  apply IH_E to _ _ Trans2. search.
 %TE-RecBuild
  case IsE. apply IH_RF to _ _ Trans1. search.
 %TE-RecFieldAccess
  case IsE. apply IH_E to _ _ Trans1. search.
 %TE-ErrorExpr
  case IsE. apply IH_E to _ _ Trans1. search.
 %TE-Default
  apply join_is to _ Trans1. apply proj_expr_is to Trans2 _ _.
  apply IH_E to _ _ Trans3. search.
%transS_is
 %TS-Noop
  search.
 %TS-Seq
  case IsS. apply IH_S to _ _ Trans1. apply IH_S_C to _ _ Trans1.
  apply IH_S to _ _ Trans2. search.
 %TS-Declare
  case IsS. apply IH_E to _ _ Trans1. search.
 %TS-Assign
  case IsS. apply IH_E to _ _ Trans1. search.
 %TS-RecUpdate
  case IsS. apply IH_E to _ _ Trans1. search.
 %TS-If
  case IsS. apply IH_E to _ _ Trans1. apply IH_S to _ _ Trans2.
  apply IH_S to _ _ Trans3. search.
 %TS-While
  case IsS. apply IH_E to _ _ Trans1. apply IH_S to _ _ Trans2.
  search.
 %TS-ScopeStmt
  case IsS. apply IH_S to _ _ Trans1. search.
 %TS-Print
  case IsS. apply IH_E to _ _ Trans1. search.
 %TS-Default
  apply join_is to _ Trans1. apply proj_stmt_is to Trans2 _ _.
  apply IH_S to _ _ Trans3. search.
%transS_isNames
 %TS-Noop
  search.
 %TS-Seq
  case IsS. apply IH_S_C to _ _ Trans1. apply IH_S_C to _ _ Trans2.
  search.
 %TS-Declare
  case IsS. case IsNames. search.
 %TS-Assign
  search.
 %TS-RecUpdate
  search.
 %TS-If
  search.
 %TS-While
  search.
 %TS-ScopeStmt
  search.
 %TS-Print
  search.
 %TS-Default
  apply join_is to _ Trans1. apply proj_stmt_is to Trans2 _ _.
  apply IH_S_C to _ _ Trans3. search.
%transA_is
 Trans: case Trans (keep).
   %TA-Nil
    search.
   %TA-Cons
    case IsA. apply IH_E to _ _ Trans1. apply IH_A to _ _ Trans2.
    search.
%transRF_is
 Trans: case Trans (keep).
   %TRF-Nil
    search.
   %TRF-Cons
    case IsRF. apply IH_E to _ _ Trans1. apply IH_RF to _ _ Trans2.
    search.


Theorem domain_is_tys : forall L D,
  is_list (is_pair is_string is_typ) L -> domain L D ->
  is_list is_string D.
induction on 2. intros Is D. D: case D.
  %Dmn-Nil
   search.
  %Dmn-Cons
   Is: case Is. case Is. apply IH to _ D. search.

Extensible_Theorem
  transF_is : forall F T,
    IsF : is_fun F ->
    Trans : transF F T ->
    is_fun T
  on Trans.
%TF-Fun
 case IsF. apply paramTys_is to _ Trans1.
 apply domain_is_tys to _ Trans2. apply transS_is to _ _ Trans3.
 search.
%TF-Default
 apply proj_fun_is to Trans1 _. apply IH to _ Trans2. search.


Theorem transFuns_is : forall Fs Ts,
  is_list is_fun Fs -> transFuns Fs Ts -> is_list is_fun Ts.
induction on 2. intros IsFs TF. TF: case TF.
  %TFs-Nil
   search.
  %TFs-Cons
   case IsFs. apply IH to _ TF1. apply transF_is to _ TF. search.


Extensible_Theorem
  transP_is : forall P T,
    IsP : is_program P ->
    Trans : transP P T ->
    is_program T
  on Trans.
%TP-Program
 case IsP. apply transFuns_is to _ Trans1.
 apply transF_is to _ Trans2. search.
%TP-Default
 apply proj_program_is to Trans1 _. apply IH to _ Trans2. search.





/********************************************************************
 Older scopes in translation names are not changed
 ********************************************************************/
Extensible_Theorem
  transS_old_scopes : forall Names Scope S S' Names',
    IsS : is_stmt S ->
    IsNames : is_list (is_list is_string) (Scope::Names) ->
    Trans : transS (Scope::Names) S S' Names' ->
    exists Scope', Names' = Scope'::Names
  on Trans.
%TS-Noop
 search.
%TS-Seq
 case IsS. apply IH to _ _ Trans1. apply transS_isNames to _ _ Trans1.
 apply IH to _ _ Trans2. search.
%TS-Declare
 search.
%TS-Assign
 search.
%TS-RecUpdate
 search.
%TS-If
 search.
%TS-While
 search.
%TS-ScopeStmt
 search.
%TS-Print
 search.
%TS-Default
 apply join_is to _ Trans1. apply proj_stmt_is to Trans2 _ _.
 apply IH to _ _ Trans3. search.





/********************************************************************
 Projection is unique under ctx_names
 ********************************************************************/
Theorem mem_names[K, V] : forall (EE : list (list (pair K V))) N X,
  names EE N -> mem X N -> exists V, mems (X, V) EE.
induction on 1. intros Names M. Names: case Names.
  %Names-Nil
   case M.
  %Names-Cons
   Or: apply mem_append to M Names2. M': case Or.
     %mem X NScope
      apply mem_domain to Names M'. search.
     %mem X NRest
      apply IH to Names1 M'. search.


Theorem mems_names[K, V] : forall EE N (X : K) (V : V),
  names EE N -> mems (X, V) EE -> mem X N.
induction on 2. intros N M. M: case M.
  %Mems-Here
   N: case N. MNS: apply domain_mem to M N.
   apply mem_append_left to MNS N2. search.
  %Mems-Later
   N: case N. MNR: apply IH to N1 M. apply mem_append_right to MNR N2.
   search.


Theorem mem_join[A] : forall (L : list (list A)) J X,
  join L J -> mem X J -> mems X L.
induction on 1. intros J M. J: case J.
  %Join-Nil
   case M.
  %Join-Cons
   Or: apply mem_append to M J1. M': case Or.
     %mem X S
      search.
     %mem X Rest
      apply IH to J M'. search.


Theorem mems_join[A] : forall L J (X : A),
  join L J -> mems X L -> mem X J.
induction on 2. intros J M. M: case M.
  %Mems-Here
   J: case J. apply mem_append_left to M J1. search.
  %Mems-Later
   J: case J. MR: apply IH to J M. apply mem_append_right to MR J1.
   search.


Theorem ctx_names_mems_fwd[K, V] : forall EE N (X : K) (V : V),
  ctx_names EE N -> mems (X, V) EE -> mems X N.
induction on 2. intros Ctxs M. M: case M.
  %Mems-Here
   C: case Ctxs. apply C to M. search.
  %Mems-Later
   C: case Ctxs. apply IH to C2 M. search.


Theorem ctx_names_mem_back[K, V] : forall EE N (X : K),
  ctx_names EE N -> mems X N -> exists (V : V), mems (X, V) EE.
induction on 2. intros Ctxs M. M: case M.
  %Mems-Here
   C: case Ctxs. apply C1 to M. search.
  %Mems-Later
   C: case Ctxs. apply IH to C2 M. search.


Theorem proj_expr_unique_ctx_names : forall E EA EB Names NA EE NB,
  is_expr E -> is_list (is_list is_string) Names ->
  is_list (is_list (is_pair is_string is_value)) EE ->
  ctx_names EE Names -> join Names NA -> names EE NB ->
  NA |{expr}- E ~~> EA -> NB |{expr}- E ~~> EB -> EA = EB.
intros IsE IsNames IsEE Ctxs J N PrA PrB. apply join_is to _ J.
apply names_is to _ N. apply proj_expr_unique to PrA PrB _ _ _ _ _.
  %mem NB -> mem NA
   intros MB. MEE: apply mem_names to N MB.
   MN: apply ctx_names_mems_fwd to Ctxs MEE. apply mems_join to J MN.
   search.
  %mem NA -> mem NB
   intros MA. MN: apply mem_join to J MA.
   MEE: apply ctx_names_mem_back to Ctxs MN.
   apply mems_names to N MEE. search.
search.


Theorem proj_stmt_unique_ctx_names : forall S SA SB Names NA EE NB,
  is_stmt S -> is_list (is_list is_string) Names ->
  is_list (is_list (is_pair is_string is_value)) EE ->
  ctx_names EE Names -> join Names NA -> names EE NB ->
  NA |{stmt}- S ~~> SA -> NB |{stmt}- S ~~> SB -> SA = SB.
intros IsS IsNames IsEE Ctxs J N PrA PrB. apply join_is to _ J.
apply names_is to _ N. apply proj_stmt_unique to PrA PrB _ _ _ _ _.
  %mem NB -> mem NA
   intros MB. MEE: apply mem_names to N MB.
   MN: apply ctx_names_mems_fwd to Ctxs MEE. apply mems_join to J MN.
   search.
  %mem NA -> mem NB
   intros MA. MN: apply mem_join to J MA.
   MEE: apply ctx_names_mem_back to Ctxs MN.
   apply mems_names to N MEE. search.
search.





/********************************************************************
 Evaluation and translation names are related
 ********************************************************************/
Theorem ctx_names_scopes_same : forall N EE_A EE_B,
  is_list (is_list (is_pair is_string is_value)) EE_A ->
  is_list (is_list (is_pair is_string is_value)) EE_B ->
  ctx_names EE_B N -> scopes_same EE_A EE_B -> ctx_names EE_A N.
induction on 3. intros IsA IsB CN SS. CN: case CN.
  %nil
   case SS. search.
  %cons
   SS: case SS. unfold.
     %mem A1 -> mem B
      intros MA1. IsA: case IsA. IsP: apply mem_is to _ MA1. case IsP.
      L: apply mem_lookup to IsA MA1. LA: apply SS to L.
      apply lookup_mem to LA. backchain CN.
     %mem B -> mem A1
      intros MB. MA: apply CN1 to MB. IsB: case IsB.
      IsP: apply mem_is to _ MA. case IsP.
      L: apply mem_lookup to _ MA. L': apply SS1 to L.
      apply lookup_mem to L'. search.
     %rest
      case IsA. case IsB. apply IH to _ _ CN2 SS2. search.

Extensible_Theorem
  evalExpr_trans_ctx_names : forall Names E T FE EE V EE' O,
    IsE : is_expr E ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    IsNames : is_list (is_list is_string) Names ->
    Ctxs : ctx_names EE Names ->
    Trans : transE Names E T ->
    Ev : evalExpr FE EE E V EE' O ->
    ctx_names EE' Names
  on Ev as IH_E,
  evalStmt_trans_ctx_names : forall Names S T Names' FE Scope EE EE' O,
    IsS : is_stmt S ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value))
               (Scope::EE) ->
    IsNames : is_list (is_list is_string) Names ->
    Ctxs : ctx_names (Scope::EE) Names ->
    Trans : transS Names S T Names' ->
    Ev : evalStmt FE (Scope::EE) S EE' O ->
    ctx_names EE' Names'
  on Ev as IH_S,
  evalArgs_trans_ctx_names : forall Names A T FE EE V EE' O,
    IsA : is_args A ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    IsNames : is_list (is_list is_string) Names ->
    Ctxs : ctx_names EE Names ->
    Trans : transA Names A T ->
    Ev : evalArgs FE EE A V EE' O ->
    ctx_names EE' Names
  on Ev as IH_A,
  evalRecFields_trans_ctx_names : forall Names RF T FE EE V EE' O,
    IsRF : is_recFieldExprs RF ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    IsNames : is_list (is_list is_string) Names ->
    Ctxs : ctx_names EE Names ->
    Trans : transRF Names RF T ->
    Ev : evalRecFields FE EE RF V EE' O ->
    ctx_names EE' Names
  on Ev as IH_RF.
%Ext_Ind use valid
 %evalExpr_trans_ctx_names
  search.
 %evalStmt_trans_ctx_names
  search.
 %evalArgs_trans_ctx_names
  search.
 %evalRecFields_trans_ctx_names
  search.
%actual properties
 %evalExpr_trans_ctx_names
  %E-Num
   search.
  %E-Plus
   case IsE. Trans: case Trans. apply evalExpr_isCtx to _ _ _ Ev1.
   Ctxs1: apply IH_E to _ _ _ _ _ Trans Ev1.
   Ctxs2: apply IH_E to _ _ _ _ _ Trans1 Ev2. search.
  %E-Minus
   case IsE. Trans: case Trans. apply evalExpr_isCtx to _ _ _ Ev1.
   Ctxs1: apply IH_E to _ _ _ _ _ Trans Ev1.
   Ctxs2: apply IH_E to _ _ _ _ _ Trans1 Ev2. search.
  %E-Mult
   case IsE. Trans: case Trans. apply evalExpr_isCtx to _ _ _ Ev1.
   Ctxs1: apply IH_E to _ _ _ _ _ Trans Ev1.
   Ctxs2: apply IH_E to _ _ _ _ _ Trans1 Ev2. search.
  %E-Div
   case IsE. Trans: case Trans. apply evalExpr_isCtx to _ _ _ Ev1.
   Ctxs1: apply IH_E to _ _ _ _ _ Trans Ev1.
   Ctxs2: apply IH_E to _ _ _ _ _ Trans1 Ev2. search.
  %E-True
   search.
  %E-False
   search.
  %E-And-True
   case IsE. Trans: case Trans. apply evalExpr_isCtx to _ _ _ Ev1.
   Ctxs1: apply IH_E to _ _ _ _ _ Trans Ev1.
   Ctxs2: apply IH_E to _ _ _ _ _ Trans1 Ev2. search.
  %E-And-False1
   case IsE. Trans: case Trans. apply IH_E to _ _ _ _ _ Trans Ev1.
   search.
  %E-And-False2
   case IsE. Trans: case Trans. apply evalExpr_isCtx to _ _ _ Ev1.
   Ctxs1: apply IH_E to _ _ _ _ _ Trans Ev1.
   Ctxs2: apply IH_E to _ _ _ _ _ Trans1 Ev2. search.
  %E-Or-True1
   case IsE. Trans: case Trans. apply IH_E to _ _ _ _ _ Trans Ev1.
   search.
  %E-Or-True2
   case IsE. Trans: case Trans. apply evalExpr_isCtx to _ _ _ Ev1.
   Ctxs1: apply IH_E to _ _ _ _ _ Trans Ev1.
   Ctxs2: apply IH_E to _ _ _ _ _ Trans1 Ev2. search.
  %E-Or-False
   case IsE. Trans: case Trans. apply evalExpr_isCtx to _ _ _ Ev1.
   Ctxs1: apply IH_E to _ _ _ _ _ Trans Ev1.
   Ctxs2: apply IH_E to _ _ _ _ _ Trans1 Ev2. search.
  %E-Not-True
   case IsE. Trans: case Trans. apply IH_E to _ _ _ _ _ Trans Ev1.
   search.
  %E-Not-False
   case IsE. Trans: case Trans. apply IH_E to _ _ _ _ _ Trans Ev1.
   search.
  %E-Greater-True
   case IsE. Trans: case Trans. apply evalExpr_isCtx to _ _ _ Ev1.
   Ctxs1: apply IH_E to _ _ _ _ _ Trans Ev1.
   Ctxs2: apply IH_E to _ _ _ _ _ Trans1 Ev2. search.
  %E-Greater-False
   case IsE. Trans: case Trans. apply evalExpr_isCtx to _ _ _ Ev1.
   Ctxs1: apply IH_E to _ _ _ _ _ Trans Ev1.
   Ctxs2: apply IH_E to _ _ _ _ _ Trans1 Ev2. search.
  %E-Eq-True
   case IsE. Trans: case Trans. apply evalExpr_isCtx to _ _ _ Ev1.
   Ctxs1: apply IH_E to _ _ _ _ _ Trans Ev1.
   Ctxs2: apply IH_E to _ _ _ _ _ Trans1 Ev2. search.
  %E-Eq-False
   case IsE. Trans: case Trans. apply evalExpr_isCtx to _ _ _ Ev1.
   Ctxs1: apply IH_E to _ _ _ _ _ Trans Ev1.
   Ctxs2: apply IH_E to _ _ _ _ _ Trans1 Ev2. search.
  %E-String
   search.
  %E-AppString
   case IsE. Trans: case Trans. apply evalExpr_isCtx to _ _ _ Ev1.
   Ctxs1: apply IH_E to _ _ _ _ _ Trans Ev1.
   Ctxs2: apply IH_E to _ _ _ _ _ Trans1 Ev2. search.
  %E-Name
   search.
  %E-Call
   case IsE. Trans: case Trans. apply IH_A to _ _ _ _ _ Trans Ev2.
   search.
  %E-StmtExpr
   case IsE. Trans: case Trans. apply evalStmt_isCtx to _ _ _ Ev1.
   apply ctx_names_add_scope to Ctxs.
   apply IH_S to _ _ _ _ _ Trans Ev1.
   apply transS_isNames to _ _ Trans.
   Ctxs': apply IH_E to _ _ _ _ _ Trans1 Ev2. case Ctxs'.
   apply transS_old_scopes to _ _ Trans. search.
  %E-RecBuild
   case IsE. Trans: case Trans. apply IH_RF to _ _ _ _ _ Trans Ev1.
   search.
  %E-RecAccess
   case IsE. Trans: case Trans. apply IH_E to _ _ _ _ _ Trans Ev1.
   search.
  %E-Expr-Q
   Trans: case Trans. apply join_is to _ Trans.
   apply proj_expr_is to Trans1 _ _.
   apply proj_expr_unique_ctx_names to _ _ _ _ Trans Ev1 Trans1 Ev2.
   C: apply IH_E to _ _ _ _ _ Trans2 Ev3.
   SS: apply proj_evalExpr_forward to Ev2 Ev1 _ _ _ Ev.
   apply evalExpr_unique to _ _ _ SS Ev3.
   apply evalExpr_isCtx to _ _ _ SS. apply evalExpr_isCtx to _ _ _ Ev.
   apply ctx_names_scopes_same to _ _ C SS1. search.
 %evalStmt_trans_ctx_names
  %E-Noop
   case Trans. search.
  %E-Seq
   case IsS. Trans: case Trans. apply evalStmt_isCtx to _ _ _ Ev1.
   apply transS_isNames to _ _ Trans.
   C: apply IH_S to _ _ _ _ _ Trans Ev1. case Ctxs (keep).
   apply transS_old_scopes to _ _ Trans. case C (keep).
   apply IH_S to _ _ _ _ _ Trans1 Ev2. search.
  %E-Declare
   case IsS. Trans: case Trans. C: apply IH_E to _ _ _ _ _ Trans Ev1.
   C: case C. unfold.
     %mem EE -> mem Names
      intros M. M: case M.
        %Mem-Here
         search.
        %Mem-Later
         apply C to M. search.
     %mem Names -> mem EE
      intros M. M: case M.
        %Mem-Here
         search.
        %Mem-Later
         apply C1 to M. search.
     %rest
      search.
  %E-Assign
   case IsS. Trans: case Trans. C: apply IH_E to _ _ _ _ _ Trans Ev1.
   apply evalExpr_isCtx to _ _ _ Ev1.
   apply ctx_names_replaceScopes to _ _ C Ev2. search.
  %E-RecUpdate
   case IsS. Trans: case Trans. C: apply IH_E to _ _ _ _ _ Trans Ev1.
   apply evalExpr_isCtx to _ _ _ Ev1.
   apply ctx_names_replaceScopes to _ _ C Ev4. search.
  %E-If-True
   case IsS. Trans: case Trans. C: apply IH_E to _ _ _ _ _ Trans Ev1.
   C+: apply ctx_names_add_scope to C.
   apply evalExpr_isCtx to _ _ _ Ev1.
   C': apply IH_S to _ _ _ _ _ Trans1 Ev2.
   apply transS_old_scopes to _ _ Trans1. case C'. search.
  %E-If-False
   case IsS. Trans: case Trans. C: apply IH_E to _ _ _ _ _ Trans Ev1.
   C+: apply ctx_names_add_scope to C.
   apply evalExpr_isCtx to _ _ _ Ev1.
   C': apply IH_S to _ _ _ _ _ Trans2 Ev2.
   apply transS_old_scopes to _ _ Trans2. case C'. search.
  %E-While-True
   case IsS. Trans: case Trans (keep).
   C: apply IH_E to _ _ _ _ _ Trans1 Ev1.
   C+: apply ctx_names_add_scope to C.
   apply evalExpr_isCtx to _ _ _ Ev1.
   C': apply IH_S to _ _ _ _ _ Trans2 Ev2. C'': case C'.
   apply transS_old_scopes to _ _ Trans2.
   IsEE4+: apply evalStmt_isCtx to _ _ _ Ev2. case IsEE4+.
   case Ctxs. case C''2 (keep). apply IH_S to _ _ _ _ _ Trans Ev3.
   search.
  %E-While-False
   case IsS. Trans: case Trans. apply IH_E to _ _ _ _ _ Trans Ev1.
   search.
  %E-ScopeStmt
   case IsS. Trans: case Trans. apply transS_old_scopes to _ _ Trans.
   apply ctx_names_add_scope to Ctxs.
   C: apply IH_S to _ _ _ _ _ Trans Ev1. case C. search.
  %E-Print-Int
   case IsS. Trans: case Trans. apply IH_E to _ _ _ _ _ Trans Ev1.
   search.
  %E-Print-True
   case IsS. Trans: case Trans. apply IH_E to _ _ _ _ _ Trans Ev1.
   search.
  %E-Print-False
   case IsS. Trans: case Trans. apply IH_E to _ _ _ _ _ Trans Ev1.
   search.
  %E-Print-String
   case IsS. Trans: case Trans. apply IH_E to _ _ _ _ _ Trans Ev1.
   search.
  %E-Stmt-Q
   Trans: case Trans. apply join_is to _ Trans.
   apply proj_stmt_is to Trans1 _ _.
   apply proj_stmt_unique_ctx_names to _ _ _ _ Trans Ev1 Trans1 Ev2.
   C: apply IH_S to _ _ _ _ _ Trans2 Ev3.
   SS: apply proj_evalStmt_forward to Ev2 Ev1 _ _ _ Ev.
   apply evalStmt_unique to _ _ _ SS Ev3.
   apply evalStmt_isCtx to _ _ _ SS. apply evalStmt_isCtx to _ _ _ Ev.
   apply ctx_names_scopes_same to _ _ C SS1. search.
 %evalArgs_trans_ctx_names
  %EA-Nil
   search.
  %EA-Cons
   case IsA. Trans: case Trans. apply evalExpr_isCtx to _ _ _ Ev1.
   apply IH_E to _ _ _ _ _ Trans Ev1.
   apply IH_A to _ _ _ _ _ Trans1 Ev2. search.
  %unknown K evalArgs
   Or: apply is_args_nilArgs_or_consArgs to IsA. case Or.
 %evalRecFields_trans_ctx_names
  %ERF-Nil
   search.
  %ERF-Cons
   case IsRF. Trans: case Trans. apply evalExpr_isCtx to _ _ _ Ev1.
   apply IH_E to _ _ _ _ _ Trans Ev1.
   apply IH_RF to _ _ _ _ _ Trans1 Ev2. search.
  %unknown K evalRecFields
   Or: apply is_recFieldExprs_nilRecFieldExprs_or_consRecFieldExprs to
          IsRF. case Or.





/********************************************************************
 Evaluation of original and translated terms is related
 ********************************************************************/
Define rel_FE :
     list (pair string (pair string (pair value
                   (pair (list string) stmt)))) ->
     list (pair string (pair string (pair value
                   (pair (list string) stmt)))) -> prop by
rel_FE FE FE_T :=
   (forall F RetVar RVVal PNames Body,
       lookup FE F (RetVar, RVVal, PNames, Body) ->
       exists Body_T Names,
          lookup FE_T F (RetVar, RVVal, PNames, Body_T) /\
          transS [RetVar::PNames] Body Body_T Names) /\
   (forall F RetVar RVVal PNames Body_T,
       lookup FE_T F (RetVar, RVVal, PNames, Body_T) ->
       exists Body Names,
          lookup FE F (RetVar, RVVal, PNames, Body) /\
          transS [RetVar::PNames] Body Body_T Names).


Theorem zip_ctx_names[A, B] : forall A B (Z : list (pair A B)),
  zip A B Z -> ctx_names [Z] [A].
intros Z. unfold.
  %mem Z -> mem A
   intros M. apply zip_mem_after to Z M. search.
  %mem A -> mem Z
   intros M. apply zip_mem_before1 to Z M. search.
  %rest
   search.


Extensible_Theorem
  trans_evalExpr_same :
    forall E T Names EE EE_T FE FE_T V V_T EE' EE_T' O O_T,
      IsE : is_expr E ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsFE_T : is_list
                   (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE_T ->
      IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
      IsEE_T : is_list (is_list (is_pair is_string is_value)) EE_T ->
      IsNames : is_list (is_list is_string) Names ->
      RFE : rel_FE FE FE_T ->
      SS : scopes_same EE EE_T ->
      Ctxs : ctx_names EE Names ->
      Trans : transE Names E T ->
      Ev : evalExpr FE EE E V EE' O ->
      EvT : evalExpr FE_T EE_T T V_T EE_T' O_T ->
      V = V_T /\ O = O_T
    on Ev as IH_E,
  trans_evalExpr_relCtxs :
    forall E T Names EE EE_T FE FE_T V V_T EE' EE_T' O O_T,
      IsE : is_expr E ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsFE_T : is_list
                   (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE_T ->
      IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
      IsEE_T : is_list (is_list (is_pair is_string is_value)) EE_T ->
      IsNames : is_list (is_list is_string) Names ->
      RFE : rel_FE FE FE_T ->
      SS : scopes_same EE EE_T ->
      Ctxs : ctx_names EE Names ->
      Trans : transE Names E T ->
      Ev : evalExpr FE EE E V EE' O ->
      EvT : evalExpr FE_T EE_T T V_T EE_T' O_T ->
      scopes_same EE' EE_T'
    on Ev as IH_E_C,
  %
  trans_evalStmt_same :
    forall S T Names Names' Scope EE EE_T FE FE_T EE' EE_T' O O_T,
      IsS : is_stmt S ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsFE_T : is_list
                   (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE_T ->
      IsEE : is_list (is_list (is_pair is_string is_value))
                 (Scope::EE) ->
      IsEE_T : is_list (is_list (is_pair is_string is_value)) EE_T ->
      IsNames : is_list (is_list is_string) Names ->
      RFE : rel_FE FE FE_T ->
      SS : scopes_same (Scope::EE) EE_T ->
      Ctxs : ctx_names (Scope::EE) Names ->
      Trans : transS Names S T Names' ->
      Ev : evalStmt FE (Scope::EE) S EE' O ->
      EvT : evalStmt FE_T EE_T T EE_T' O_T ->
      O = O_T
    on Ev as IH_S,
  trans_evalStmt_relCtxs :
    forall S T Names Names' Scope EE EE_T FE FE_T EE' EE_T' O O_T,
      IsS : is_stmt S ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsFE_T : is_list
                   (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE_T ->
      IsEE : is_list (is_list (is_pair is_string is_value))
                 (Scope::EE) ->
      IsEE_T : is_list (is_list (is_pair is_string is_value)) EE_T ->
      IsNames : is_list (is_list is_string) Names ->
      RFE : rel_FE FE FE_T ->
      SS : scopes_same (Scope::EE) EE_T ->
      Ctxs : ctx_names (Scope::EE) Names ->
      Trans : transS Names S T Names' ->
      Ev : evalStmt FE (Scope::EE) S EE' O ->
      EvT : evalStmt FE_T EE_T T EE_T' O_T ->
      scopes_same EE' EE_T'
    on Ev as IH_S_C,
  %
  trans_evalArgs_same :
    forall A T Names EE EE_T FE FE_T V V_T EE' EE_T' O O_T,
      IsA : is_args A ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsFE_T : is_list
                   (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE_T ->
      IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
      IsEE_T : is_list (is_list (is_pair is_string is_value)) EE_T ->
      IsNames : is_list (is_list is_string) Names ->
      RFE : rel_FE FE FE_T ->
      SS : scopes_same EE EE_T ->
      Ctxs : ctx_names EE Names ->
      Trans : transA Names A T ->
      Ev : evalArgs FE EE A V EE' O ->
      EvT : evalArgs FE_T EE_T T V_T EE_T' O_T ->
      V = V_T /\ O = O_T
    on Ev as IH_A,
  trans_evalArgs_relCtxs :
    forall A T Names EE EE_T FE FE_T V V_T EE' EE_T' O O_T,
      IsA: is_args A ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsFE_T : is_list
                   (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE_T ->
      IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
      IsEE_T : is_list (is_list (is_pair is_string is_value)) EE_T ->
      IsNames : is_list (is_list is_string) Names ->
      RFE : rel_FE FE FE_T ->
      SS : scopes_same EE EE_T ->
      Ctxs : ctx_names EE Names ->
      Trans : transA Names A T ->
      Ev : evalArgs FE EE A V EE' O ->
      EvT : evalArgs FE_T EE_T T V_T EE_T' O_T ->
      scopes_same EE' EE_T'
    on Ev as IH_A_C,
  %
  trans_evalRecFields_same :
    forall RF T Names EE EE_T FE FE_T V V_T EE' EE_T' O O_T,
      IsRF : is_recFieldExprs RF ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsFE_T : is_list
                   (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE_T ->
      IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
      IsEE_T : is_list (is_list (is_pair is_string is_value)) EE_T ->
      IsNames : is_list (is_list is_string) Names ->
      RFE : rel_FE FE FE_T ->
      SS : scopes_same EE EE_T ->
      Ctxs : ctx_names EE Names ->
      Trans : transRF Names RF T ->
      Ev : evalRecFields FE EE RF V EE' O ->
      EvT : evalRecFields FE_T EE_T T V_T EE_T' O_T ->
      V = V_T /\ O = O_T
    on Ev as IH_RF,
  trans_evalRecFields_relCtxs :
    forall RF T Names EE EE_T FE FE_T V V_T EE' EE_T' O O_T,
      IsRF : is_recFieldExprs RF ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsFE_T : is_list
                   (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE_T ->
      IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
      IsEE_T : is_list (is_list (is_pair is_string is_value)) EE_T ->
      IsNames : is_list (is_list is_string) Names ->
      RFE : rel_FE FE FE_T ->
      SS : scopes_same EE EE_T ->
      Ctxs : ctx_names EE Names ->
      Trans : transRF Names RF T ->
      Ev : evalRecFields FE EE RF V EE' O ->
      EvT : evalRecFields FE_T EE_T T V_T EE_T' O_T ->
      scopes_same EE' EE_T'
    on Ev as IH_RF_C.
%Ext_Ind use valid
 %trans_evalExpr_same
  search.
 %trans_evalExpr_relCtxs
  search.
 %trans_evalStmt_same
  search.
 %trans_evalStmt_relCtxs
  search.
 %trans_evalArgs_same
  search.
 %trans_evalArgs_relCtxs
  search.
 %trans_evalRecFieldExprs_same
  search.
 %trans_evalRecFieldExprs_relCtxs
  search.
%actual properties
 %trans_evalExpr_same
  %E-Num
   case Trans. case EvT. search.
  %E-Plus
   case IsE. Trans: case Trans. EvT: case EvT.
   apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvT.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
   apply append_unique to Ev4 EvT3.
   apply plus_integer_unique to Ev3 EvT2. search.
  %E-Minus
   case IsE. Trans: case Trans. EvT: case EvT.
   apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvT.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
   apply append_unique to Ev4 EvT3.
   apply minus_integer_unique to Ev3 EvT2. search.
  %E-Mult
   case IsE. Trans: case Trans. EvT: case EvT.
   apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvT.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
   apply append_unique to Ev4 EvT3.
   apply multiply_integer_unique to Ev3 EvT2. search.
  %E-Div
   case IsE. Trans: case Trans. EvT: case EvT.
   apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvT.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
   apply append_unique to Ev4 EvT3.
   apply divide_integer_unique to Ev3 EvT2. search.
  %E-True
   case Trans. case EvT. search.
  %E-False
   case Trans. case EvT. search.
  %E-And-True
   case IsE. Trans: case Trans. EvT: case EvT.
     %E-And-True
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
      apply append_unique to Ev3 EvT2. search.
     %E-And-False1
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-And-False2
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
  %E-And-False1
   case IsE. Trans: case Trans. EvT: case EvT.
     %E-And-True
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-And-False1
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT. search.
     %E-And-False2
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
  %E-And-False2
   case IsE. Trans: case Trans. EvT: case EvT.
     %E-And-True
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
     %E-And-False1
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-And-False2
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
      apply append_unique to Ev3 EvT2. search.
  %E-Or-True1
   case IsE. Trans: case Trans. EvT: case EvT.
     %E-Or-True1
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT. search.
     %E-Or-True2
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Or-False
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
  %E-Or-True2
   case IsE. Trans: case Trans. EvT: case EvT.
     %E-Or-True1
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Or-True2
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
      apply append_unique to Ev3 EvT2. search.
     %E-Or-False
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
  %E-Or-False
   case IsE. Trans: case Trans. EvT: case EvT.
     %E-Or-True1
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Or-True2
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
     %E-Or-False
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
      apply append_unique to Ev3 EvT2. search.
  %E-Not-True
   case IsE. Trans: case Trans. EvT: case EvT.
     %E-Not-True
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT. search.
     %E-Not-False
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
  %E-Not-False
   case IsE. Trans: case Trans. EvT: case EvT.
     %E-Not-True
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Not-False
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT. search.
  %E-Greater-True
   case IsE. Trans: case Trans. EvT: case EvT.
     %E-Greater-True
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
      apply append_unique to Ev4 EvT3. search.
     %E-Greater-False
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
      L: case Ev3. apply less_lesseq_flip_false to L EvT2.
  %E-Greater-False
   case IsE. Trans: case Trans. EvT: case EvT.
     %E-Greater-True
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
      L: case EvT2. apply less_lesseq_flip_false to L Ev3.
     %E-Greater-False
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
      apply append_unique to Ev4 EvT3. search.
  %E-Eq-True
   case IsE. Trans: case Trans. EvT: case EvT.
     %E-Eq-True
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
      apply append_unique to Ev3 EvT2. search.
     %E-Eq-False
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
      apply EvT2 to _.
  %E-Eq-False
   case IsE. Trans: case Trans. EvT: case EvT.
     %E-Eq-True
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
      apply Ev3 to _.
     %E-Eq-False
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
      apply append_unique to Ev4 EvT3. search.
  %E-String
   case Trans. case EvT. search.
  %E-AppString
   case IsE. Trans: case Trans. EvT: case EvT.
   apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvT.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
   apply append_unique to Ev4 EvT3. apply append_unique to Ev3 EvT2.
   search.
  %E-Name
   case IsE. case Trans. EvT: case EvT.
   apply scopes_same_lookupScopes to _ _ SS Ev1 EvT. search.
  %E-Call
   case IsE. Trans: case Trans. EvT: case EvT. R: case RFE (keep).
   L_T: apply R to Ev1. apply lookup_unique to EvT L_T.
   clear L_T R R1. apply IH_A to _ _ _ _ _ _ _ _ _ Trans Ev2 EvT1.
   apply zip_unique to Ev3 EvT2. apply evalArgs_isValue to _ _ _ Ev2.
   IsP: apply lookup_is_value_funCtx to _ Ev1. IsP: case IsP.
   IsP: case IsP1. IsP: case IsP2. apply zip_is to _ _ Ev3.
   Z: assert zip (RetVar::ArgNames) (RVVal::ArgVals1)
                 ((RetVar, RVVal)::InitEnv1).
   apply zip_ctx_names to Z.
   apply IH_S to _ _ _ _ _ _ _ _ _ L_T1 Ev4 EvT3.
   SS': apply IH_S_C to _ _ _ _ _ _ _ _ _ L_T1 Ev4 EvT3.
   apply append_unique to Ev5 EvT4. apply evalStmt_isCtx to _ _ _ Ev4.
   apply transS_is to _ _ L_T1. apply evalStmt_isCtx to _ _ _ EvT3.
   apply scopes_same_lookupScopes to _ _ _ Ev6 EvT5. search.
  %E-StmtExpr
   case IsE. Trans: case Trans. EvT: case EvT.
   apply ctx_names_add_scope to Ctxs.
   apply IH_S to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply IH_S_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply evalStmt_trans_ctx_names to _ _ _ _ _ Trans Ev1.
   apply evalStmt_isCtx to _ _ _ Ev1.
   apply transS_isNames to _ _ Trans. apply transS_is to _ _ Trans.
   apply evalStmt_isCtx to _ _ _ EvT.
   apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
   apply append_unique to Ev3 EvT2. search.
  %E-RecBuild
   case IsE. Trans: case Trans. EvT: case EvT.
   apply IH_RF to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT. search.
  %E-RecAccess
   case IsE. Trans: case Trans. EvT: case EvT.
   apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply lookup_unique to Ev2 EvT1. search.
  %E-Expr-Q
   Trans: case Trans. apply names_is to _ Ev1.
   apply proj_expr_is to Ev2 _ _.
   apply proj_expr_unique_ctx_names to
      _ _ _ Ctxs Trans Ev1 Trans1 Ev2.
   apply IH_E to _ _ _ _ _ _ _ _ _ Trans2 Ev3 EvT.
   Ev': apply proj_evalExpr_forward to Ev2 Ev1 _ _ _ Ev.
   apply evalExpr_unique to _ _ _ Ev' Ev3. search.
 %trans_evalExpr_relCtxs
  %E-Num
   case Trans. case EvT. search.
  %E-Plus
   case IsE. Trans: case Trans. EvT: case EvT.
   apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvT.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1. search.
  %E-Minus
   case IsE. Trans: case Trans. EvT: case EvT.
   apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvT.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1. search.
  %E-Mult
   case IsE. Trans: case Trans. EvT: case EvT.
   apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvT.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1. search.
  %E-Div
   case IsE. Trans: case Trans. EvT: case EvT.
   apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvT.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1. search.
  %E-True
   case Trans. case EvT. search.
  %E-False
   case Trans. case EvT. search.
  %E-And-True
   case IsE. Trans: case Trans. EvT: case EvT.
     %E-And-True
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1. search.
     %E-And-False1
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-And-False2
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
  %E-And-False1
   case IsE. Trans: case Trans. EvT: case EvT.
     %E-And-True
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-And-False1
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT. search.
     %E-And-False2
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
  %E-And-False2
   case IsE. Trans: case Trans. EvT: case EvT.
     %E-And-True
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
     %E-And-False1
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-And-False2
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1. search.
  %E-Or-True1
   case IsE. Trans: case Trans. EvT: case EvT.
     %E-Or-True1
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT. search.
     %E-Or-True2
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Or-False
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
  %E-Or-True2
   case IsE. Trans: case Trans. EvT: case EvT.
     %E-Or-True1
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Or-True2
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1. search.
     %E-Or-False
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
  %E-Or-False
   case IsE. Trans: case Trans. EvT: case EvT.
     %E-Or-True1
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Or-True2
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
     %E-Or-False
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1. search.
  %E-Not-True
   case IsE. Trans: case Trans. EvT: case EvT.
     %E-Not-True
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT. search.
     %E-Not-False
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
  %E-Not-False
   case IsE. Trans: case Trans. EvT: case EvT.
     %E-Not-True
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Not-False
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT. search.
  %E-Greater-True
   case IsE. Trans: case Trans. EvT: case EvT.
     %E-Greater-True
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1. search.
     %E-Greater-False
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1. search.
  %E-Greater-False
   case IsE. Trans: case Trans. EvT: case EvT.
     %E-Greater-True
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1. search.
     %E-Greater-False
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1. search.
  %E-Eq-True
   case IsE. Trans: case Trans. EvT: case EvT.
     %E-Eq-True
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1. search.
     %E-Eq-False
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1. search.
  %E-Eq-False
   case IsE. Trans: case Trans. EvT: case EvT.
     %E-Eq-True
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1. search.
     %E-Eq-False
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
      apply evalExpr_isCtx to _ _ _ EvT.
      apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1. search.
  %E-String
   case Trans. case EvT. search.
  %E-AppString
   case IsE. Trans: case Trans. EvT: case EvT.
   apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvT.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1. search.
  %E-Name
   case Trans. case EvT. search.
  %E-Call
   case IsE. Trans: case Trans. EvT: case EvT.
   apply IH_A_C to _ _ _ _ _ _ _ _ _ Trans Ev2 EvT1. search.
  %E-StmtExpr
   case IsE. Trans: case Trans. EvT: case EvT.
   apply ctx_names_add_scope to Ctxs.
   apply IH_S_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply evalStmt_isCtx to _ _ _ Ev1. apply transS_is to _ _ Trans.
   apply evalStmt_isCtx to _ _ _ EvT.
   apply evalStmt_trans_ctx_names to _ _ _ _ _ Trans Ev1.
   apply transS_isNames to _ _ Trans.
   SS': apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
   case SS'. search.
  %E-RecBuild
   case IsE. Trans: case Trans. EvT: case EvT.
   apply IH_RF_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT. search.
  %E-RecAccess
   case IsE. Trans: case Trans. EvT: case EvT.
   apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT. search.
  %E-Expr-Q
   Trans: case Trans. apply names_is to _ Ev1.
   apply proj_expr_is to Ev2 _ _.
   apply proj_expr_unique_ctx_names to
      _ _ _ Ctxs Trans Ev1 Trans1 Ev2.
   SS': apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans2 Ev3 EvT.
   Ev': apply proj_evalExpr_forward to Ev2 Ev1 _ _ _ Ev.
   apply evalExpr_unique to _ _ _ Ev' Ev3.
   apply scopes_same_trans to Ev'1 SS'. search.
 %trans_evalStmt_same
  %E-Noop
   case Trans. case EvT. search.
  %E-Seq
   case IsS. Trans: case Trans. EvT: case EvT.
   apply IH_S to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   SS': apply IH_S_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply evalStmt_isCtx to _ _ _ Ev1. apply transS_is to _ _ Trans.
   apply transS_isNames to _ _ Trans.
   apply evalStmt_isCtx to _ _ _ EvT.
   C: apply evalStmt_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   case Ctxs. apply transS_old_scopes to _ _ Trans. case C (keep).
   apply IH_S to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
   apply append_unique to Ev3 EvT2. search.
  %E-Declare
   case IsS. Trans: case Trans. EvT: case EvT.
   apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT. search.
  %E-Assign
   case IsS. Trans: case Trans. EvT: case EvT.
   apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT. search.
  %E-RecUpdate
   case IsS. Trans: case Trans. EvT: case EvT.
   apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT. search.
  %E-If-True
   case IsS. Trans: case Trans. EvT: case EvT.
     %E-If-True
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply transE_is to _ _ Trans. apply evalExpr_isCtx to _ _ _ Ev1.
      apply evalExpr_isCtx to _ _ _ EvT.
      C: apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply ctx_names_add_scope to C.
      SS': apply IH_S to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
      apply append_unique to Ev3 EvT2. search.
     %E-If-False
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
  %E-If-False
   case IsS. Trans: case Trans. EvT: case EvT.
     %E-If-True
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-If-False
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply transE_is to _ _ Trans. apply evalExpr_isCtx to _ _ _ Ev1.
      apply evalExpr_isCtx to _ _ _ EvT.
      C: apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply ctx_names_add_scope to C.
      SS': apply IH_S to _ _ _ _ _ _ _ _ _ Trans2 Ev2 EvT1.
      apply append_unique to Ev3 EvT2. search.
  %E-While-True
   case IsS. Trans: case Trans (keep). EvT: case EvT.
     %E-While-True
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev1 EvT.
      SS': apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans1 Ev1 EvT.
      apply transE_is to _ _ Trans1.
      apply evalExpr_isCtx to _ _ _ Ev1.
      apply evalExpr_isCtx to _ _ _ EvT.
      C: apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans1 Ev1.
      apply ctx_names_add_scope to C.
      apply IH_S to _ _ _ _ _ _ _ _ _ Trans2 Ev2 EvT1.
      SS'': apply IH_S_C to _ _ _ _ _ _ _ _ _ Trans2 Ev2 EvT1.
      case SS''. IsEE4+: apply evalStmt_isCtx to _ _ _ Ev2.
      case IsEE4+. apply transS_is to _ _ Trans2.
      IsEE3+: apply evalStmt_isCtx to _ _ _ EvT1. case IsEE3+.
      case Ctxs (keep). case C (keep). case SS' (keep).
      apply transS_old_scopes to _ _ Trans2.
      C'': apply evalStmt_trans_ctx_names to _ _ _ _ _ Trans2 Ev2.
      C'': case C''. case C''2 (keep).
      apply IH_S to _ _ _ _ _ _ _ _ _ Trans Ev3 EvT2.
      apply append_unique to Ev4 EvT3.
      apply append_unique to Ev5 EvT4. search.
     %E-While-False
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev1 EvT.
  %E-While-False
   case IsS. Trans: case Trans. EvT: case EvT.
     %E-While-True
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-While-False
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT. search.
  %E-ScopeStmt
   case IsS. Trans: case Trans. EvT: case EvT.
   apply ctx_names_add_scope to Ctxs.
   apply IH_S to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT. search.
  %E-Print-Int
   case IsS. Trans: case Trans. EvT: case EvT.
     %E-Print-Int
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply append_unique to Ev2 EvT1. search.
     %E-Print-True
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Print-False
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Print-String
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
  %E-Print-True
   case IsS. Trans: case Trans. EvT: case EvT.
     %E-Print-Int
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Print-True
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply append_unique to Ev2 EvT1. search.
     %E-Print-False
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Print-String
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
  %E-Print-False
   case IsS. Trans: case Trans. EvT: case EvT.
     %E-Print-Int
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Print-True
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Print-False
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply append_unique to Ev2 EvT1. search.
     %E-Print-String
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
  %E-Print-String
   case IsS. Trans: case Trans. EvT: case EvT.
     %E-Print-Int
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Print-True
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Print-False
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Print-String
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply append_unique to Ev2 EvT1. search.
  %E-Stmt-Q
   Trans: case Trans. apply names_is to _ Ev1.
   apply proj_stmt_is to Ev2 _ _.
   apply proj_stmt_unique_ctx_names to
      _ _ _ Ctxs Trans Ev1 Trans1 Ev2.
   apply IH_S to _ _ _ _ _ _ _ _ _ Trans2 Ev3 EvT.
   Ev': apply proj_evalStmt_forward to Ev2 Ev1 _ _ _ Ev.
   apply evalStmt_unique to _ _ _ Ev' Ev3. search.
 %trans_evalStmt_relCtxs
  %E-Noop
   case Trans. case EvT. search.
  %E-Seq
   case IsS. Trans: case Trans. EvT: case EvT.
   SS': apply IH_S_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply evalStmt_isCtx to _ _ _ Ev1. apply transS_is to _ _ Trans.
   apply transS_isNames to _ _ Trans.
   apply evalStmt_isCtx to _ _ _ EvT.
   C: apply evalStmt_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   case Ctxs. apply transS_old_scopes to _ _ Trans. case C (keep).
   apply IH_S_C to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1. search.
  %E-Declare
   case IsS. Trans: case Trans. EvT: case EvT.
   apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   SS': apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   SS': case SS'. unfold.
     %lookup ->
      intros L. L: case L.
        %Lkp-Here
         search.
        %Lkp-Later
         apply SS' to L1. search.
     %lookup <-
      intros L. L: case L.
        %Lkp-Here
         search.
        %Lkp-Later
         apply SS'1 to L1. search.
     %rest
      search.
  %E-Assign
   case IsS. Trans: case Trans. EvT: case EvT.
   apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvT.
   apply scopes_same_replaceScopes_scopes_same to _ _ _ _ Ev2 EvT1.
   search.
  %E-RecUpdate
   case IsS. Trans: case Trans. EvT: case EvT.
   apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvT.
   apply scopes_same_lookupScopes to _ _ _ Ev2 EvT1.
   apply updateRecFields_unique to Ev3 EvT2.
   apply scopes_same_replaceScopes_scopes_same to _ _ _ _ Ev4 EvT3.
   search.
  %E-If-True
   case IsS. Trans: case Trans. EvT: case EvT.
     %E-If-True
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply transE_is to _ _ Trans. apply evalExpr_isCtx to _ _ _ Ev1.
      apply evalExpr_isCtx to _ _ _ EvT.
      C: apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply ctx_names_add_scope to C.
      SS': apply IH_S_C to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
      case SS'. search.
     %E-If-False
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
  %E-If-False
   case IsS. Trans: case Trans. EvT: case EvT.
     %E-If-True
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-If-False
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
      apply transE_is to _ _ Trans. apply evalExpr_isCtx to _ _ _ Ev1.
      apply evalExpr_isCtx to _ _ _ EvT.
      C: apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
      apply ctx_names_add_scope to C.
      SS': apply IH_S_C to _ _ _ _ _ _ _ _ _ Trans2 Ev2 EvT1.
      case SS'. search.
  %E-While-True
   case IsS. Trans: case Trans (keep). EvT: case EvT.
     %E-While-True
      SS': apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans1 Ev1 EvT.
      apply transE_is to _ _ Trans1.
      apply evalExpr_isCtx to _ _ _ Ev1.
      apply evalExpr_isCtx to _ _ _ EvT.
      C: apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans1 Ev1.
      apply ctx_names_add_scope to C.
      apply IH_S to _ _ _ _ _ _ _ _ _ Trans2 Ev2 EvT1.
      SS'': apply IH_S_C to _ _ _ _ _ _ _ _ _ Trans2 Ev2 EvT1.
      case SS''. IsEE4+: apply evalStmt_isCtx to _ _ _ Ev2.
      case IsEE4+. apply transS_is to _ _ Trans2.
      IsEE3+: apply evalStmt_isCtx to _ _ _ EvT1. case IsEE3+.
      case Ctxs (keep). case C (keep). case SS' (keep).
      apply transS_old_scopes to _ _ Trans2.
      C'': apply evalStmt_trans_ctx_names to _ _ _ _ _ Trans2 Ev2.
      C'': case C''. case C''2 (keep).
      apply IH_S_C to _ _ _ _ _ _ _ _ _ Trans Ev3 EvT2. search.
     %E-While-False
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans1 Ev1 EvT.
  %E-While-False
   case IsS. Trans: case Trans. EvT: case EvT.
     %E-While-True
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-While-False
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT. search.
  %E-ScopeStmt
   case IsS. Trans: case Trans. EvT: case EvT.
   apply ctx_names_add_scope to Ctxs.
   SS': apply IH_S_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   case SS'. search.
  %E-Print-Int
   case IsS. Trans: case Trans. EvT: case EvT.
     %E-Print-Int
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT. search.
     %E-Print-True
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Print-False
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Print-String
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
  %E-Print-True
   case IsS. Trans: case Trans. EvT: case EvT.
     %E-Print-Int
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Print-True
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT. search.
     %E-Print-False
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Print-String
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
  %E-Print-False
   case IsS. Trans: case Trans. EvT: case EvT.
     %E-Print-Int
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Print-True
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Print-False
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT. search.
     %E-Print-String
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
  %E-Print-String
   case IsS. Trans: case Trans. EvT: case EvT.
     %E-Print-Int
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Print-True
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Print-False
      apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
     %E-Print-String
      apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT. search.
  %E-Stmt-Q
   Trans: case Trans. apply names_is to _ Ev1.
   apply proj_stmt_is to Ev2 _ _.
   apply proj_stmt_unique_ctx_names to
      _ _ _ Ctxs Trans Ev1 Trans1 Ev2.
   SS': apply IH_S_C to _ _ _ _ _ _ _ _ _ Trans2 Ev3 EvT.
   Ev': apply proj_evalStmt_forward to Ev2 Ev1 _ _ _ Ev.
   apply evalStmt_unique to _ _ _ Ev' Ev3.
   apply scopes_same_trans to Ev'1 SS'. search.
 %trans_evalArgs_same
  %EA-Nil
   case Trans. case EvT. search.
  %EA-Cons
   case IsA. Trans: case Trans. EvT: case EvT.
   apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvT.
   apply evalExpr_trans_ctx_names to _ _ _ _ _ Trans Ev1.
   apply IH_A to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
   apply append_unique to Ev3 EvT2. search.
  %unknown K evalArgs
   Or: apply is_args_nilArgs_or_consArgs to IsA. case Or.
 %trans_evalArgs_relCtxs
  %EA-Nil
   case Trans. case EvT. search.
  %EA-Cons
   case IsA. Trans: case Trans. EvT: case EvT.
   apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvT.
   apply evalExpr_trans_ctx_names to _ _ _ _ _ Trans Ev1.
   apply IH_A_C to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1. search.
  %unknown K evalArgs
   Or: apply is_args_nilArgs_or_consArgs to IsA. case Or.
 %trans_evalRecFields_same
  %ERF-Nil
   case Trans. case EvT. search.
  %ERF-Cons
   case IsRF. Trans: case Trans. EvT: case EvT.
   apply IH_E to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvT.
   apply evalExpr_trans_ctx_names to _ _ _ _ _ Trans Ev1.
   apply IH_RF to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1.
   apply append_unique to Ev3 EvT2. search.
  %unknown K evalRecFields
   Or: apply is_recFieldExprs_nilRecFieldExprs_or_consRecFieldExprs to
          IsRF. case Or.
 %trans_evalRecFields_relCtxs
  %ERF-Nil
   case Trans. case EvT. search.
  %ERF-Cons
   case IsRF. Trans: case Trans. EvT: case EvT.
   apply IH_E_C to _ _ _ _ _ _ _ _ _ Trans Ev1 EvT.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvT.
   apply evalExpr_trans_ctx_names to _ _ _ _ _ Trans Ev1.
   apply IH_RF_C to _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvT1. search.
  %unknown K evalRecFields
   Or: apply is_recFieldExprs_nilRecFieldExprs_or_consRecFieldExprs to
          IsRF. case Or.


Theorem paramTys_paramNames : forall Ps PTys D PNs,
  paramTys Ps PTys -> domain PTys D -> paramNames Ps PNs -> D = PNs.
induction on 1. intros PT D PN. PT: case PT.
  %PT-Nil
   case D. case PN. search.
  %PT-Cons
   D: case D. PN: case PN. apply IH to PT1 D PN1.
   apply paramTy_paramName_same to PT PN. search.


Extensible_Theorem
  trans_getFunEvalInfo_rel :
    forall F Name RetVar RVVal PNames Body
           F_T Name_T RetVar_T RVVal_T PNames_T Body_T,
      IsF : is_fun F ->
      Trans : transF F F_T ->
      GFEI : getFunEvalInfo F Name RetVar RVVal PNames Body ->
      GFEI_T : getFunEvalInfo F_T Name_T RetVar_T
                              RVVal_T PNames_T Body_T ->
      exists N,
        Name = Name_T /\ RetVar = RetVar_T /\ RVVal = RVVal_T /\
        PNames = PNames_T /\ transS [RetVar::PNames] Body Body_T N
  on Trans.
%TF-Fun
 case IsF. G: case GFEI. GT: case GFEI_T.
 apply paramNames_unique to _ G GT.
 apply paramTys_paramNames to Trans1 Trans2 G. search.
%TF-Default
 G': apply proj_getFunEvalInfo_forward to Trans1 _ GFEI.
 apply proj_fun_is to Trans1 _. apply IH to _ Trans2 G' GFEI_T.
 search.


Theorem trans_getFunEvalCtx_rel_FE : forall Fs Fs_T FE FE_T,
  is_list is_fun Fs -> transFuns Fs Fs_T -> getFunEvalCtx Fs FE ->
  getFunEvalCtx Fs_T FE_T -> rel_FE FE FE_T.
induction on 2. intros IsFs Trans GFEI GFEI_T. Trans: case Trans.
  %TFs-Nil
   case GFEI. case GFEI_T. unfold.
     %lookup forward
      intros L. case L.
     %lookup back
      intros L. case L.
  %TFs-Cons
   G: case GFEI. GT: case GFEI_T. case IsFs.
   apply trans_getFunEvalInfo_rel to _ Trans G GT.
   R: apply IH to _ Trans1 G1 GT1. unfold.
     %lookup forward
      intros L. L: case L.
        %Lkp-Here
         search.
        %Lkp-Later
         R: case R. apply R to L1. search.
     %lookup back
      intros L. L: case L.
        %Lkp-Here
         search.
        %Lkp-Later
         R: case R. apply R1 to L1. search.





/********************************************************************
 If the original evaluates, so does the translation
 ********************************************************************/
Extensible_Theorem
  trans_evalExpr_forward : forall E T Names EE EE_T FE FE_T V EE' O,
    IsE : is_expr E ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsFE_T : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE_T ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    IsEE_T : is_list (is_list (is_pair is_string is_value)) EE_T ->
    IsNames : is_list (is_list is_string) Names ->
    RFE : rel_FE FE FE_T ->
    SS : scopes_same EE EE_T ->
    Ctxs : ctx_names EE Names ->
    Trans : transE Names E T ->
    Ev : evalExpr FE EE E V EE' O ->
    exists EE_T', evalExpr FE_T EE_T T V EE_T' O
  on Ev as IH_E,
  trans_evalStmt_forward :
    forall S T Names Names' Scope EE EE_T FE FE_T EE' O,
      IsS : is_stmt S ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsFE_T : is_list
                  (is_pair is_string
                  (is_pair is_string
                  (is_pair is_value
                  (is_pair (is_list is_string) is_stmt)))) FE_T ->
      IsEE : is_list (is_list (is_pair is_string is_value))
                (Scope::EE) ->
      IsEE_T : is_list (is_list (is_pair is_string is_value)) EE_T ->
      IsNames : is_list (is_list is_string) Names ->
      RFE : rel_FE FE FE_T ->
      SS : scopes_same (Scope::EE) EE_T ->
      Ctxs : ctx_names (Scope::EE) Names ->
      Trans : transS Names S T Names' ->
      Ev : evalStmt FE (Scope::EE) S EE' O ->
      exists EE_T', evalStmt FE_T EE_T T EE_T' O
  on Ev as IH_S,
  trans_evalArgs_forward : forall A T Names EE EE_T FE FE_T V EE' O,
    IsA : is_args A ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsFE_T : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE_T ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    IsEE_T : is_list (is_list (is_pair is_string is_value)) EE_T ->
    IsNames : is_list (is_list is_string) Names ->
    RFE : rel_FE FE FE_T ->
    SS : scopes_same EE EE_T ->
    Ctxs : ctx_names EE Names ->
    Trans : transA Names A T ->
    Ev : evalArgs FE EE A V EE' O ->
    exists EE_T', evalArgs FE_T EE_T T V EE_T' O
  on Ev as IH_A,
  trans_evalRecFields_forward :
    forall RF T Names EE EE_T FE FE_T V EE' O,
      IsRF : is_recFieldExprs RF ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsFE_T : is_list
                  (is_pair is_string
                  (is_pair is_string
                  (is_pair is_value
                  (is_pair (is_list is_string) is_stmt)))) FE_T ->
      IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
      IsEE_T : is_list (is_list (is_pair is_string is_value)) EE_T ->
      IsNames : is_list (is_list is_string) Names ->
      RFE : rel_FE FE FE_T ->
      SS : scopes_same EE EE_T ->
      Ctxs : ctx_names EE Names ->
      Trans : transRF Names RF T ->
      Ev : evalRecFields FE EE RF V EE' O ->
      exists EE_T', evalRecFields FE_T EE_T T V EE_T' O
  on Ev as IH_RF.
%ExtInd validity
 %trans_evalExpr_forward
  search.
 %trans_evalStmt_forward
  search.
 %trans_evalArgs_forward
  search.
 %trans_evalRecFields_forward
  search.
%actual properties
 %trans_evalExpr_forward
  %E-Num
   case Trans. search.
  %E-Plus
   case IsE. Trans: case Trans.
   EvB1: apply IH_E to _ _ _ _ _ _ RFE SS Ctxs Trans Ev1.
   apply trans_evalExpr_relCtxs to _ _ _ _ _ _ _ _ _ Trans Ev1 EvB1.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvB1.
   EvB2: apply IH_E to _ _ _ _ _ _ RFE _ _ Trans1 Ev2. search.
  %E-Minus
   case IsE. Trans: case Trans.
   EvB1: apply IH_E to _ _ _ _ _ _ RFE SS Ctxs Trans Ev1.
   apply trans_evalExpr_relCtxs to _ _ _ _ _ _ _ _ _ Trans Ev1 EvB1.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvB1.
   EvB2: apply IH_E to _ _ _ _ _ _ RFE _ _ Trans1 Ev2. search.
  %E-Mult
   case IsE. Trans: case Trans.
   EvB1: apply IH_E to _ _ _ _ _ _ RFE SS Ctxs Trans Ev1.
   apply trans_evalExpr_relCtxs to _ _ _ _ _ _ _ _ _ Trans Ev1 EvB1.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvB1.
   EvB2: apply IH_E to _ _ _ _ _ _ RFE _ _ Trans1 Ev2. search.
  %E-Div
   case IsE. Trans: case Trans.
   EvB1: apply IH_E to _ _ _ _ _ _ RFE SS Ctxs Trans Ev1.
   apply trans_evalExpr_relCtxs to _ _ _ _ _ _ _ _ _ Trans Ev1 EvB1.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvB1.
   EvB2: apply IH_E to _ _ _ _ _ _ RFE _ _ Trans1 Ev2. search.
  %E-True
   case Trans. search.
  %E-False
   case Trans. search.
  %E-And-True
   case IsE. Trans: case Trans.
   EvB1: apply IH_E to _ _ _ _ _ _ RFE SS Ctxs Trans Ev1.
   apply trans_evalExpr_relCtxs to _ _ _ _ _ _ _ _ _ Trans Ev1 EvB1.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvB1.
   EvB2: apply IH_E to _ _ _ _ _ _ RFE _ _ Trans1 Ev2. search.
  %E-And-False1
   case IsE. Trans: case Trans.
   apply IH_E to _ _ _ _ _ _ RFE SS Ctxs Trans Ev1. search.
  %E-And-False2
   case IsE. Trans: case Trans.
   EvB1: apply IH_E to _ _ _ _ _ _ RFE SS Ctxs Trans Ev1.
   apply trans_evalExpr_relCtxs to _ _ _ _ _ _ _ _ _ Trans Ev1 EvB1.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvB1.
   EvB2: apply IH_E to _ _ _ _ _ _ RFE _ _ Trans1 Ev2. search.
  %E-Or-True1
   case IsE. Trans: case Trans.
   apply IH_E to _ _ _ _ _ _ RFE SS Ctxs Trans Ev1. search.
  %E-Or-True2
   case IsE. Trans: case Trans.
   EvB1: apply IH_E to _ _ _ _ _ _ RFE SS Ctxs Trans Ev1.
   apply trans_evalExpr_relCtxs to _ _ _ _ _ _ _ _ _ Trans Ev1 EvB1.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvB1.
   EvB2: apply IH_E to _ _ _ _ _ _ RFE _ _ Trans1 Ev2. search.
  %E-Or-False
   case IsE. Trans: case Trans.
   EvB1: apply IH_E to _ _ _ _ _ _ RFE SS Ctxs Trans Ev1.
   apply trans_evalExpr_relCtxs to _ _ _ _ _ _ _ _ _ Trans Ev1 EvB1.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvB1.
   EvB2: apply IH_E to _ _ _ _ _ _ RFE _ _ Trans1 Ev2. search.
  %E-Not-True
   case IsE. Trans: case Trans.
   apply IH_E to _ _ _ _ _ _ RFE SS Ctxs Trans Ev1. search.
  %E-Not-False
   case IsE. Trans: case Trans.
   apply IH_E to _ _ _ _ _ _ RFE SS Ctxs Trans Ev1. search.
  %E-Greater-True
   case IsE. Trans: case Trans.
   EvB1: apply IH_E to _ _ _ _ _ _ RFE SS Ctxs Trans Ev1.
   apply trans_evalExpr_relCtxs to _ _ _ _ _ _ _ _ _ Trans Ev1 EvB1.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvB1.
   EvB2: apply IH_E to _ _ _ _ _ _ RFE _ _ Trans1 Ev2. search.
  %E-Greater-False
   case IsE. Trans: case Trans.
   EvB1: apply IH_E to _ _ _ _ _ _ RFE SS Ctxs Trans Ev1.
   apply trans_evalExpr_relCtxs to _ _ _ _ _ _ _ _ _ Trans Ev1 EvB1.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvB1.
   EvB2: apply IH_E to _ _ _ _ _ _ RFE _ _ Trans1 Ev2. search.
  %E-Eq-True
   case IsE. Trans: case Trans.
   EvB1: apply IH_E to _ _ _ _ _ _ RFE SS Ctxs Trans Ev1.
   apply trans_evalExpr_relCtxs to _ _ _ _ _ _ _ _ _ Trans Ev1 EvB1.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvB1.
   EvB2: apply IH_E to _ _ _ _ _ _ RFE _ _ Trans1 Ev2. search.
  %E-Eq-False
   case IsE. Trans: case Trans.
   EvB1: apply IH_E to _ _ _ _ _ _ RFE SS Ctxs Trans Ev1.
   apply trans_evalExpr_relCtxs to _ _ _ _ _ _ _ _ _ Trans Ev1 EvB1.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvB1.
   EvB2: apply IH_E to _ _ _ _ _ _ RFE _ _ Trans1 Ev2. search.
  %E-String
   case Trans. search.
  %E-AppString
   case IsE. Trans: case Trans.
   EvB1: apply IH_E to _ _ _ _ _ _ RFE SS Ctxs Trans Ev1.
   apply trans_evalExpr_relCtxs to _ _ _ _ _ _ _ _ _ Trans Ev1 EvB1.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvB1.
   EvB2: apply IH_E to _ _ _ _ _ _ RFE _ _ Trans1 Ev2. search.
  %E-Name
   case IsE. case Trans.
   LT: apply scopes_same_lookupScopes_exists to _ _ SS Ev1. search.
  %E-Call
   case IsE. Trans: case Trans.
   %lookup function in FE_T
   R: case RFE (keep). LF: apply R to Ev1. clear R.
   %evaluate arguments
   EvB1: apply IH_A to _ _ _ _ _ _ RFE SS _ Trans Ev2.
   %evaluate body
   Z: assert zip (RetVar::ArgNames) (RVVal::ArgVals)
                 ((RetVar, RVVal)::InitEnv).
   apply zip_ctx_names to Z. apply evalArgs_isValue to _ _ _ Ev2.
   IsP: apply lookup_is_value_funCtx to _ Ev1. IsP: case IsP.
   IsP: case IsP1. IsP: case IsP2. IsInitEnv: apply zip_is to _ _ Z.
   IsIE: assert is_list (is_list (is_pair is_string is_value))
                   [(RetVar, RVVal)::InitEnv].
   SS_IE: apply scopes_same_reflexive to IsIE.
   EvB2: apply IH_S to _ _ _ _ _ _ RFE SS_IE _ LF1 Ev4.
   %lookup same value
   R: apply trans_evalStmt_relCtxs to _ _ _ _ _ _ _ _ _ LF1 Ev4 EvB2.
   apply transS_is to _ _ LF1. apply evalStmt_isCtx to _ _ _ EvB2.
   apply scopes_same_lookupScopes_exists to _ _ R Ev6.
   %done
   search.
  %E-StmtExpr
   case IsE. Trans: case Trans. apply ctx_names_add_scope to Ctxs.
   SS': apply scopes_same_add_scope to SS.
   EvB1: apply IH_S to _ _ _ _ _ _ RFE SS' _ Trans Ev1.
   %eval expression
   apply transS_is to _ _ Trans. apply evalStmt_isCtx to _ _ _ Ev1.
   apply evalStmt_isCtx to _ _ _ EvB1.
   apply transS_isNames to _ _ Trans.
   C: apply evalStmt_trans_ctx_names to _ _ _ _ _ Trans Ev1.
   SS'': apply trans_evalStmt_relCtxs to
            _ _ _ _ _ _ _ _ _ Trans Ev1 EvB1.
   EvB2: apply IH_E to _ _ _ _ _ _ RFE SS'' _ Trans1 Ev2.
   %drop a scope
   SS+: apply trans_evalExpr_relCtxs to
           _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvB2. case SS+. search.
  %E-RecBuild
   case IsE. Trans: case Trans.
   apply IH_RF to _ _ _ _ _ _ RFE SS _ Trans Ev1. search.
  %E-RecAccess
   case IsE. Trans: case Trans.
   apply IH_E to _ _ _ _ _ _ RFE SS _ Trans Ev1. search.
  %E-Expr-Q
   apply names_is to _ Ev1. apply proj_expr_is to Ev2 _ _.
   Trans: case Trans. apply proj_expr_unique_ctx_names to
                         _ _ _ Ctxs Trans Ev1 Trans1 Ev2.
   apply IH_E to _ _ _ _ _ _ RFE SS _ Trans2 Ev3.
   %projection result and original result are the same
   Ev': apply proj_evalExpr_forward to Ev2 Ev1 _ _ _ Ev.
   apply evalExpr_unique to _ _ _ Ev' Ev3. search.
 %trans_evalStmt_forward
  %E-Noop
   case Trans. search.
  %E-Seq
   case IsS. Trans: case Trans.
   EvB1: apply IH_S to _ _ _ _ _ _ RFE SS _ Trans Ev1.
   apply transS_is to _ _ Trans. apply transS_isNames to _ _ Trans.
   apply evalStmt_isCtx to _ _ _ EvB1.
   apply evalStmt_isCtx to _ _ _ Ev1.
   C: apply evalStmt_trans_ctx_names to _ _ _ _ _ Trans Ev1.
   case Ctxs. apply transS_old_scopes to _ _ Trans.
   SS': apply trans_evalStmt_relCtxs to
           _ _ _ _ _ _ _ _ _ Trans Ev1 EvB1. case C (keep).
   EvB2: apply IH_S to _ _ _ _ _ _ RFE SS' _ Trans1 Ev2. search.
  %E-Declare
   case IsS. Trans: case Trans.
   EvB: apply IH_E to _ _ _ _ _ _ RFE SS _ Trans Ev1.
   apply transE_is to _ _ Trans.
   SS': apply trans_evalExpr_relCtxs to
           _ _ _ _ _ _ _ _ _ Trans Ev1 EvB. case SS'. search.
  %E-Assign
   case IsS. Trans: case Trans.
   EvB: apply IH_E to _ _ _ _ _ _ RFE SS _ Trans Ev1.
   apply transE_is to _ _ Trans.
   SS': apply trans_evalExpr_relCtxs to
           _ _ _ _ _ _ _ _ _ Trans Ev1 EvB.
   apply evalExpr_isCtx to _ _ _ Ev1.
   apply evalExpr_isCtx to _ _ _ EvB.
   apply scopes_same_replaceScopes_exists to _ _ _ SS' Ev2. search.
  %E-RecUpdate
   case IsS. Trans: case Trans.
   EvB: apply IH_E to _ _ _ _ _ _ RFE SS _ Trans Ev1.
   apply transE_is to _ _ Trans.
   SS': apply trans_evalExpr_relCtxs to
           _ _ _ _ _ _ _ _ _ Trans Ev1 EvB.
   apply evalExpr_isCtx to _ _ _ Ev1.
   apply evalExpr_isCtx to _ _ _ EvB.
   apply scopes_same_replaceScopes_exists to _ _ _ SS' Ev4.
   apply scopes_same_lookupScopes_exists to _ _ SS Ev2. search.
  %E-If-True
   case IsS. Trans: case Trans.
   EvB1: apply IH_E to _ _ _ _ _ _ RFE SS _ Trans Ev1.
   apply transE_is to _ _ Trans.
   SS': apply trans_evalExpr_relCtxs to
           _ _ _ _ _ _ _ _ _ Trans Ev1 EvB1.
   apply evalExpr_isCtx to _ _ _ Ev1.
   apply evalExpr_isCtx to _ _ _ EvB1.
   C: apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply ctx_names_add_scope to C. apply scopes_same_add_scope to SS'.
   EvB2: apply IH_S to _ _ _ _ _ _ RFE _ _ Trans1 Ev2.
   SS+: apply trans_evalStmt_relCtxs to
           _ _ _ _ _ _ _ _ _ Trans1 Ev2 EvB2. case SS+. search.
  %E-If-False
   case IsS. Trans: case Trans.
   EvB1: apply IH_E to _ _ _ _ _ _ RFE SS _ Trans Ev1.
   apply transE_is to _ _ Trans.
   SS': apply trans_evalExpr_relCtxs to
           _ _ _ _ _ _ _ _ _ Trans Ev1 EvB1.
   apply evalExpr_isCtx to _ _ _ Ev1.
   apply evalExpr_isCtx to _ _ _ EvB1.
   C: apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply ctx_names_add_scope to C. apply scopes_same_add_scope to SS'.
   EvB2: apply IH_S to _ _ _ _ _ _ RFE _ _ Trans2 Ev2.
   SS+: apply trans_evalStmt_relCtxs to
           _ _ _ _ _ _ _ _ _ Trans2 Ev2 EvB2. case SS+. search.
  %E-While-True
   case IsS. Trans: case Trans (keep).
   EvB1: apply IH_E to _ _ _ _ _ _ RFE SS _ Trans1 Ev1.
   apply transE_is to _ _ Trans1.
   SS': apply trans_evalExpr_relCtxs to
           _ _ _ _ _ _ _ _ _ Trans1 Ev1 EvB1.
   apply evalExpr_isCtx to _ _ _ Ev1.
   apply evalExpr_isCtx to _ _ _ EvB1.
   C: apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans1 Ev1.
   apply ctx_names_add_scope to C. apply scopes_same_add_scope to SS'.
   EvB2: apply IH_S to _ _ _ _ _ _ RFE _ _ Trans2 Ev2.
   SS+: apply trans_evalStmt_relCtxs to
           _ _ _ _ _ _ _ _ _ Trans2 Ev2 EvB2. SS'': case SS+.
   apply transS_is to _ _ Trans2.
   IsEE4+: apply evalStmt_isCtx to _ _ _ Ev2. case IsEE4+.
   IsBR+: apply evalStmt_isCtx to _ _ _ EvB2. case IsBR+.
   C': apply evalStmt_trans_ctx_names to _ _ _ _ _ Trans2 Ev2.
   C': case C'. case Ctxs. case C.
   apply transS_old_scopes to _ _ Trans2. case C'2.
   apply IH_S to _ _ _ _ _ _ RFE SS''2 _ Trans Ev3. search.
  %E-While-False
   case IsS. Trans: case Trans.
   apply IH_E to _ _ _ _ _ _ RFE SS _ Trans Ev1. search.
  %E-ScopeStmt
   case IsS. Trans: case Trans.
   SS': apply scopes_same_add_scope to SS.
   Ctxs': apply ctx_names_add_scope to Ctxs.
   EvB: apply IH_S to _ _ _ _ _ _ RFE SS' Ctxs' Trans Ev1.
   SS+: apply trans_evalStmt_relCtxs to
           _ _ _ _ _ _ _ _ _ Trans Ev1 EvB. case SS+. search.
  %E-Print-Int
   case IsS. Trans: case Trans.
   apply IH_E to _ _ _ _ _ _ RFE SS _ Trans Ev1. search.
  %E-Print-True
   case IsS. Trans: case Trans.
   apply IH_E to _ _ _ _ _ _ RFE SS _ Trans Ev1. search.
  %E-Print-False
   case IsS. Trans: case Trans.
   apply IH_E to _ _ _ _ _ _ RFE SS _ Trans Ev1. search.
  %E-Print-String
   case IsS. Trans: case Trans.
   apply IH_E to _ _ _ _ _ _ RFE SS _ Trans Ev1. search.
  %E-Stmt-Q
   apply names_is to _ Ev1. apply proj_stmt_is to Ev2 _ _.
   Trans: case Trans. apply proj_stmt_unique_ctx_names to
                         _ _ _ Ctxs Trans Ev1 Trans1 Ev2.
   apply IH_S to _ _ _ _ _ _ RFE SS _ Trans2 Ev3.
   %projection result and original result are the same
   Ev': apply proj_evalStmt_forward to Ev2 Ev1 _ _ _ Ev.
   apply evalStmt_unique to _ _ _ Ev' Ev3. search.
 %trans_evalArgs_forward
  %EA-Nil
   case Trans. search.
  %EA-Cons
   case IsA. Trans: case Trans.
   EvB1: apply IH_E to _ _ _ _ _ _ RFE SS Ctxs Trans Ev1.
   apply trans_evalExpr_relCtxs to _ _ _ _ _ _ _ _ _ Trans Ev1 EvB1.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvB1.
   EvB2: apply IH_A to _ _ _ _ _ _ RFE _ _ Trans1 Ev2. search.
  %unknown K evalArgs
   Or: apply is_args_nilArgs_or_consArgs to IsA. case Or.
 %trans_evalRecFields_forward
  %ERF-Nil
   case Trans. search.
  %ERF-Cons
   case IsRF. Trans: case Trans.
   EvB1: apply IH_E to _ _ _ _ _ _ RFE SS Ctxs Trans Ev1.
   apply trans_evalExpr_relCtxs to _ _ _ _ _ _ _ _ _ Trans Ev1 EvB1.
   apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans Ev1.
   apply evalExpr_isCtx to _ _ _ Ev1. apply transE_is to _ _ Trans.
   apply evalExpr_isCtx to _ _ _ EvB1.
   EvB2: apply IH_RF to _ _ _ _ _ _ RFE _ _ Trans1 Ev2. search.
  %unknown K evalRecFields
   Or: apply is_recFieldExprs_nilRecFieldExprs_or_consRecFieldExprs to
          IsRF. case Or.


Extensible_Theorem
  trans_getFunEvalInfo_forward :
    forall F F_T Name RetVar RVVal PNames Body,
      IsF : is_fun F ->
      Trans : transF F F_T ->
      GFEI : getFunEvalInfo F Name RetVar RVVal PNames Body ->
      exists Body_T,
         getFunEvalInfo F_T Name RetVar RVVal PNames Body_T
  on Trans.
%TF-Fun
 case IsF. Trans: case Trans. case GFEI. search.
%TF-Default
 G: apply proj_getFunEvalInfo_forward to Trans1 _ GFEI.
 apply proj_fun_is to Trans1 _. apply IH to _ Trans2 G. search.


Theorem trans_getFunEvalCtx_forward : forall Fs Fs_T FE,
  is_list is_fun Fs -> transFuns Fs Fs_T -> getFunEvalCtx Fs FE ->
  exists FE_T, getFunEvalCtx Fs_T FE_T.
induction on 2. intros IsFs Trans GFEI. Trans: case Trans.
  %TFs-Nil
   case GFEI. search.
  %TFs-Cons
   case IsFs. G: case GFEI. apply IH to _ Trans1 G1.
   apply trans_getFunEvalInfo_forward to _ Trans G. search.


/*Programs evaluate the same with the same arguments*/
Extensible_Theorem
  trans_evalProgram_forward : forall P P_T A O,
    IsP : is_program P ->
    IsA : is_list is_value A ->
    Trans : transP P P_T ->
    Ev : evalProgram A P O ->
    evalProgram A P_T O
  on Trans.
%TP-Program
 case IsP. Ev: case Ev.
 G: apply trans_getFunEvalCtx_forward to _ Trans1 Ev.
 GM: apply trans_getFunEvalInfo_forward to _ Trans2 Ev1.
 RFE: apply trans_getFunEvalCtx_rel_FE to _ Trans1 Ev G.
 Tr: apply trans_getFunEvalInfo_rel to _ Trans2 Ev1 GM.
 RFE': assert rel_FE ((MainName, (RetVar,
                       (RetVal, (PNames, Body))))::FCtx)
                     ((MainName, (RetVar,
                       (RetVal, (PNames, Body_T))))::FE_T).
   unfold.
     %lookup forward
      intros L. L: case L.
        %Lkp-Here (main)
         search.
        %Lkp-Later
         R: case RFE. apply R to L1. search.
     %lookup back
      intros L. L: case L.
        %Lkp-Here (main)
         search.
        %Lkp-Later
         R: case RFE. apply R1 to L1. search.
 Is: apply getFunEvalInfo_is to _ Ev1.
 apply zip_is to _ _ Ev2.
 IsIE: assert is_list (is_list (is_pair is_string is_value))
                 [(RetVar, RetVal)::InitEnv].
 SS: apply scopes_same_reflexive to IsIE.
 Z: assert zip (RetVar::PNames) (RetVal::A)
                  ((RetVar, RetVal)::InitEnv).
 apply zip_ctx_names to Z. apply getFunEvalCtx_is to _ Ev.
 apply transFuns_is to _ Trans1. apply getFunEvalCtx_is to _ G.
 apply transF_is to _ Trans2. apply getFunEvalInfo_is to _ GM.
 apply trans_evalStmt_forward to _ _ _ _ _ _ RFE' SS _ Tr Ev3. search.
%TP-Default
 Ev': apply proj_evalProgram_forward to Trans1 _ _ Ev.
 apply proj_program_is to Trans1 _. apply IH to _ _ Trans2 Ev'.
 search.






/********************************************************************
 If the translation evaluates, so does the original
 ********************************************************************/

/*
  I don't think we can prove this with both function calls and the
  generic case.  If we have translation be the major induction
  measure, the generic case can be proven because the projection's
  translation is smaller and it doesn't matter what size the
  projection's translation's evaluation is because the major measure
  has decreased.  We can't prove the case for function calls, though,
  because the function body's translation may be, and almost certainly
  is, larger.  If we have evaluation as the major measure, the call
  case is fine because the evaluation of the function body is smaller
  even though the translation may be larger, but the generic case is a
  problem because the projection evaluation ...
  Maybe there isn't a problem if evaluation is the major measure,
  since we still have the same evaluation of the translation, even
  though the translation comes through projection?
*/

/*
  We need to know the original term has empty names in the generic
  cases below to lift the evaluation back across projection using
  proj_eval<Ty>_backward.  However, this is then required for function
  bodies as well, so we use this to state it is so.
*/
Define emptyNames_FE :
     list (pair string (pair string (pair value
                   (pair (list string) stmt)))) -> prop by
emptyNames_FE FE :=
  forall F RetVar RVVal Params Body,
    mem (F, RetVar, RVVal, Params, Body) FE ->
    exists EndNames, stmtNames [RetVar::Params] Body [] EndNames.


Theorem ctx_names_mems[K, I] :
  forall (EE : list (list (pair K I))) NA NB X,
    ctx_names EE NA -> ctx_names EE NB -> mems X NA -> mems X NB.
induction on 3. intros CNA CNB M. M: case M.
  %Mems-Here
   RA: case CNA. RB: case CNB. MA: apply RA1 to M. apply RB to MA.
   search.
  %Mems-Later
   CNA: case CNA. CNB: case CNB. apply IH to CNA2 CNB2 M. search.


Extensible_Theorem
  trans_evalExpr_backward : forall E T Names EE EE_T FE FE_T V EE_T' O,
    IsE : is_expr E ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsFE_T : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE_T ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    IsEE_T : is_list (is_list (is_pair is_string is_value)) EE_T ->
    IsNames : is_list (is_list is_string) Names ->
    RFE : rel_FE FE FE_T ->
    ENFE : emptyNames_FE FE ->
    SS : scopes_same EE EE_T ->
    Ctxs : ctx_names EE Names ->
    Trans : transE Names E T ->
    EN : exprNames Names E [] ->
    Ev : evalExpr FE_T EE_T T V EE_T' O ->
    exists EE', evalExpr FE EE E V EE' O
  on Ev as IH_E_E, Trans * as IH_E,
  trans_evalStmt_backward :
    forall S T Names Names' Names'' Scope EE EE_T FE FE_T EE_T' O,
      IsS : is_stmt S ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsFE_T : is_list (is_pair is_string
                       (is_pair is_string
                       (is_pair is_value
                       (is_pair (is_list is_string) is_stmt)))) FE_T ->
      IsEE : is_list (is_list (is_pair is_string is_value))
                (Scope::EE) ->
      IsEE_T : is_list (is_list (is_pair is_string is_value)) EE_T ->
      IsNames : is_list (is_list is_string) Names ->
      RFE : rel_FE FE FE_T ->
      ENFE : emptyNames_FE FE ->
      SS : scopes_same (Scope::EE) EE_T ->
      Ctxs : ctx_names (Scope::EE) Names ->
      Trans : transS Names S T Names' ->
      SN : stmtNames Names S [] Names'' ->
      Ev : evalStmt FE_T EE_T T EE_T' O ->
      exists EE', evalStmt FE (Scope::EE) S EE' O
  on Ev as IH_S_E, Trans * as IH_S
also
  trans_evalArgs_backward : forall A T Names EE EE_T FE FE_T V EE_T' O,
    IsA : is_args A ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsFE_T : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE_T ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    IsEE_T : is_list (is_list (is_pair is_string is_value)) EE_T ->
    IsNames : is_list (is_list is_string) Names ->
    RFE : rel_FE FE FE_T ->
    ENFE : emptyNames_FE FE ->
    SS : scopes_same EE EE_T ->
    Ctxs : ctx_names EE Names ->
    Trans : transA Names A T ->
    AN : argsNames Names A [] ->
    Ev : evalArgs FE_T EE_T T V EE_T' O ->
    exists EE', evalArgs FE EE A V EE' O
  on Ev as IH_A_E, Trans * as IH_A,
  trans_evalRecFields_backward :
    forall RF T Names EE EE_T FE FE_T V EE_T' O,
      IsRF : is_recFieldExprs RF ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsFE_T : is_list
                   (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE_T ->
      IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
      IsEE_T : is_list (is_list (is_pair is_string is_value)) EE_T ->
      IsNames : is_list (is_list is_string) Names ->
      RFE : rel_FE FE FE_T ->
      ENFE : emptyNames_FE FE ->
      SS : scopes_same EE EE_T ->
      Ctxs : ctx_names EE Names ->
      Trans : transRF Names RF T ->
      RFN : recFieldNames Names RF [] ->
      Ev : evalRecFields FE_T EE_T T V EE_T' O ->
      exists EE', evalRecFields FE EE RF V EE' O
  on Ev as IH_RF_E, Trans * as IH_RF.
%trans_evalExpr_backward
 %TE-Num
  case Ev. search.
 %TE-Plus
  case IsE. EN: case EN. case EN2. Ev: case Ev.
  EvA1: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 EN Ev.
  SS': apply trans_evalExpr_relCtxs to
          _ _ _ _ _ _ _ _ _ Trans1 EvA1 Ev.
  apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans1 EvA1.
  apply evalExpr_isCtx to _ _ _ EvA1. apply transE_is to _ _ Trans1.
  apply evalExpr_isCtx to _ _ _ Ev.
  EvA2: apply IH_E to _ _ _ _ _ _ RFE _ SS' _ Trans2 _ Ev1. search.
 %TE-Minus
  case IsE. EN: case EN. case EN2. Ev: case Ev.
  EvA1: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 EN Ev.
  SS': apply trans_evalExpr_relCtxs to
          _ _ _ _ _ _ _ _ _ Trans1 EvA1 Ev.
  apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans1 EvA1.
  apply evalExpr_isCtx to _ _ _ EvA1. apply transE_is to _ _ Trans1.
  apply evalExpr_isCtx to _ _ _ Ev.
  EvA2: apply IH_E to _ _ _ _ _ _ RFE _ SS' _ Trans2 _ Ev1. search.
 %TE-Mult
  case IsE. EN: case EN. case EN2. Ev: case Ev.
  EvA1: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 EN Ev.
  SS': apply trans_evalExpr_relCtxs to
          _ _ _ _ _ _ _ _ _ Trans1 EvA1 Ev.
  apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans1 EvA1.
  apply evalExpr_isCtx to _ _ _ EvA1. apply transE_is to _ _ Trans1.
  apply evalExpr_isCtx to _ _ _ Ev.
  EvA2: apply IH_E to _ _ _ _ _ _ RFE _ SS' _ Trans2 _ Ev1. search.
 %TE-Div
  case IsE. EN: case EN. case EN2. Ev: case Ev.
  EvA1: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 EN Ev.
  SS': apply trans_evalExpr_relCtxs to
          _ _ _ _ _ _ _ _ _ Trans1 EvA1 Ev.
  apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans1 EvA1.
  apply evalExpr_isCtx to _ _ _ EvA1. apply transE_is to _ _ Trans1.
  apply evalExpr_isCtx to _ _ _ Ev.
  EvA2: apply IH_E to _ _ _ _ _ _ RFE _ SS' _ Trans2 _ Ev1. search.
 %TE-True
  case Ev. search.
 %TE-False
  case Ev. search.
 %TE-And
  case IsE. EN: case EN. case EN2. Ev: case Ev.
    %E-And-True
     EvA1: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev.
     SS': apply trans_evalExpr_relCtxs to
             _ _ _ _ _ _ _ _ _ Trans1 EvA1 Ev.
     apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans1 EvA1.
     apply evalExpr_isCtx to _ _ _ EvA1.
     apply transE_is to _ _ Trans1.
     apply evalExpr_isCtx to _ _ _ Ev.
     EvA2: apply IH_E to _ _ _ _ _ _ RFE _ SS' _ Trans2 _ Ev1. search.
    %E-And-False1
     apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev. search.
    %E-And-False2
     EvA1: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev.
     SS': apply trans_evalExpr_relCtxs to
             _ _ _ _ _ _ _ _ _ Trans1 EvA1 Ev.
     apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans1 EvA1.
     apply evalExpr_isCtx to _ _ _ EvA1.
     apply transE_is to _ _ Trans1.
     apply evalExpr_isCtx to _ _ _ Ev.
     EvA2: apply IH_E to _ _ _ _ _ _ RFE _ SS' _ Trans2 _ Ev1. search.
 %TE-Or
  case IsE. EN: case EN. case EN2. Ev: case Ev.
    %E-Or-True
     apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev. search.
    %E-Or-True2
     EvA1: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev.
     SS': apply trans_evalExpr_relCtxs to
             _ _ _ _ _ _ _ _ _ Trans1 EvA1 Ev.
     apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans1 EvA1.
     apply evalExpr_isCtx to _ _ _ EvA1.
     apply transE_is to _ _ Trans1.
     apply evalExpr_isCtx to _ _ _ Ev.
     EvA2: apply IH_E to _ _ _ _ _ _ RFE _ SS' _ Trans2 _ Ev1. search.
    %E-Or-False
     EvA1: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev.
     SS': apply trans_evalExpr_relCtxs to
             _ _ _ _ _ _ _ _ _ Trans1 EvA1 Ev.
     apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans1 EvA1.
     apply evalExpr_isCtx to _ _ _ EvA1.
     apply transE_is to _ _ Trans1.
     apply evalExpr_isCtx to _ _ _ Ev.
     EvA2: apply IH_E to _ _ _ _ _ _ RFE _ SS' _ Trans2 _ Ev1. search.
 %TE-Not
  case IsE. EN: case EN. Ev: case Ev.
    %E-Not-True
     apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev. search.
    %E-Not-False
     apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev. search.
 %TE-Greater
  case IsE. EN: case EN. case EN2. Ev: case Ev.
    %E-Greater-True
     EvA1: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev.
     SS': apply trans_evalExpr_relCtxs to
             _ _ _ _ _ _ _ _ _ Trans1 EvA1 Ev.
     apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans1 EvA1.
     apply evalExpr_isCtx to _ _ _ EvA1.
     apply transE_is to _ _ Trans1.
     apply evalExpr_isCtx to _ _ _ Ev.
     EvA2: apply IH_E to _ _ _ _ _ _ RFE _ SS' _ Trans2 _ Ev1. search.
    %E-Greater-False
     EvA1: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev.
     SS': apply trans_evalExpr_relCtxs to
             _ _ _ _ _ _ _ _ _ Trans1 EvA1 Ev.
     apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans1 EvA1.
     apply evalExpr_isCtx to _ _ _ EvA1.
     apply transE_is to _ _ Trans1.
     apply evalExpr_isCtx to _ _ _ Ev.
     EvA2: apply IH_E to _ _ _ _ _ _ RFE _ SS' _ Trans2 _ Ev1. search.
 %TE-Eq
  case IsE. EN: case EN. case EN2. Ev: case Ev.
    %E-Eq-True
     EvA1: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev.
     SS': apply trans_evalExpr_relCtxs to
             _ _ _ _ _ _ _ _ _ Trans1 EvA1 Ev.
     apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans1 EvA1.
     apply evalExpr_isCtx to _ _ _ EvA1.
     apply transE_is to _ _ Trans1.
     apply evalExpr_isCtx to _ _ _ Ev.
     EvA2: apply IH_E to _ _ _ _ _ _ RFE _ SS' _ Trans2 _ Ev1. search.
    %E-Eq-False
     EvA1: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev.
     SS': apply trans_evalExpr_relCtxs to
             _ _ _ _ _ _ _ _ _ Trans1 EvA1 Ev.
     apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans1 EvA1.
     apply evalExpr_isCtx to _ _ _ EvA1.
     apply transE_is to _ _ Trans1.
     apply evalExpr_isCtx to _ _ _ Ev.
     EvA2: apply IH_E to _ _ _ _ _ _ RFE _ SS' _ Trans2 _ Ev1. search.
 %TE-String
  case Ev. search.
 %TE-StringApp
  case IsE. EN: case EN. case EN2. Ev: case Ev.
  EvA1: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 EN Ev.
  SS': apply trans_evalExpr_relCtxs to
          _ _ _ _ _ _ _ _ _ Trans1 EvA1 Ev.
  apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans1 EvA1.
  apply evalExpr_isCtx to _ _ _ EvA1. apply transE_is to _ _ Trans1.
  apply evalExpr_isCtx to _ _ _ Ev.
  EvA2: apply IH_E to _ _ _ _ _ _ RFE _ SS' _ Trans2 _ Ev1. search.
 %TE-Name
  case IsE. SS': apply scopes_same_symm to SS. Ev: case Ev.
  apply scopes_same_lookupScopes_exists to _ _ SS' Ev. search.
 %TE-Call
  case IsE. EN: case EN. Ev: case Ev.
  %lookup fun
  R: case RFE (keep). LF: apply R1 to Ev. clear R R1.
  %eval args
  EvA1: apply IH_A to _ _ _ _ _ _ RFE _ SS _ Trans1 _ Ev1.
  %eval function
  Z: assert zip (RetVar::ArgNames) (RVVal::ArgVals)
                ((RetVar, RVVal)::InitEnv).
  apply zip_ctx_names to Z. apply evalArgs_isValue to _ _ _ EvA1.
  IsP: apply lookup_is_value_funCtx to _ LF. IsP: case IsP.
  IsP: case IsP1. IsP: case IsP2. IsInitEnv: apply zip_is to _ _ Z.
  SS1: apply scopes_same_reflexive to _ with
          L = [(RetVar, RVVal)::InitEnv].
  ENFE: case ENFE. MF: apply lookup_mem to LF. SN: apply ENFE to MF.
  EvA2: apply IH_S_E to _ _ _ _ _ _ RFE _ SS1 _ LF1 _ Ev3.
  %lookup same value
  SS2: apply trans_evalStmt_relCtxs to
          _ _ _ _ _ _ _ _ _ LF1 EvA2 Ev3.
  SS2': apply scopes_same_symm to SS2. apply transS_is to _ _ LF1.
  apply evalStmt_isCtx to _ _ _ Ev3.
  apply evalStmt_isCtx to _ _ _ EvA2.
  apply scopes_same_lookupScopes_exists to _ _ SS2' Ev5. search.
 %TE-StmtExpr
  case IsE. EN: case EN. case EN2. Ev: case Ev.
  SS': apply scopes_same_add_scope to SS.
  C': apply ctx_names_add_scope to Ctxs.
  EvA1: apply IH_S to _ _ _ _ _ _ RFE _ SS' C' Trans1 _ Ev.
  SS2: apply trans_evalStmt_relCtxs to
          _ _ _ _ _ _ _ _ _ Trans1 EvA1 Ev.
  C2: apply evalStmt_trans_ctx_names to _ _ _ _ C' Trans1 EvA1.
  apply evalStmt_isCtx to _ _ _ EvA1. apply transS_is to _ _ Trans1.
  apply transS_isNames to _ _ Trans1.
  apply evalStmt_isCtx to _ _ _ Ev.
  C2': apply evalStmt_ctx_names to _ _ _ _ _ EN EvA1.
  apply stmtNames_isCtx to _ _ EN.
  assert exprNames Names2 E1 [].
    apply exprNames_relatedCtxs to _ _ _ _ _ EN1 with CtxB = Names2.
      %mems Names2 -> mems CtxS
       intros M. apply ctx_names_mems to C2 C2' M. search.
      %mems CtxS -> mems Names2
       intros M. apply ctx_names_mems to C2' C2 M. search.
    search.
  EvA2: apply IH_E to _ _ _ _ _ _ RFE _ SS2 C2 Trans2 _ Ev1.
  %exists a scope to drop
  apply transS_old_scopes to _ _ Trans1. case C2 (keep).
  C3: apply evalExpr_trans_ctx_names to _ _ _ _ C2 Trans2 EvA2.
  case C3. search.
 %TE-RecBuild
  case IsE. EN: case EN. Ev: case Ev.
  apply IH_RF to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev. search.
 %TE-RecFieldAccess
  case IsE. EN: case EN. Ev: case Ev.
  apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev. search.
 %TE-ErrorExpr
  case Ev.
 %TE-Default
  apply join_is to _ Trans1. IsE_P: apply proj_expr_is to Trans2 _ _.
  EN_P: apply exprNames_exists to IsE_P IsNames.
  Eq: assert N1 = [].
    IsN1: apply exprNames_is to _ _ EN_P. IsN1: case IsN1.
      %nil
       search.
      %cons
       M': apply proj_exprNames to Trans2 _ _ _ EN EN_P _ with X = H.
       case M'.
  case Eq. EvP: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans3 _ Ev.
  Names: apply names_exists to IsEE. IsN1: apply names_is to _ Names.
  Pr: apply proj_expr_other to Trans2 _ _ IsN1.
  apply proj_expr_unique_ctx_names to _ _ _ _ _ _ Trans2 Pr.
  apply proj_evalExpr_backward to Pr Names _ _ _ _ Ctxs _ EvP.
  search.
%trans_evalStmt_backward
 %TS-Noop
  case Ev. search.
 %TS-Seq
  case IsS. SN: case SN. case SN2. Ev: case Ev.
  EvA1: apply IH_S to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev.
  apply evalStmt_isCtx to _ _ _ EvA1. apply transS_is to _ _ Trans1.
  apply evalStmt_isCtx to _ _ _ Ev.
  SS': apply trans_evalStmt_relCtxs to
          _ _ _ _ _ _ _ _ _ Trans1 EvA1 Ev.
  C': apply evalStmt_trans_ctx_names to _ _ _ _ Ctxs Trans1 EvA1.
  apply transS_isNames to _ _ Trans1. case Ctxs (keep).
  apply transS_old_scopes to _ _ Trans1. case C' (keep).
  apply stmtNames_keep_older to _ _ SN.
  apply stmtNames_isCtx to _ _ SN.
  C'': apply evalStmt_ctx_names to _ _ _ _ Ctxs SN EvA1.
  SN2: apply stmtNames_relatedCtxs to _ _ _ _ _ SN1 with
           CtxB = BRest, ScopeB = Scope'.
    %mems Scope'::BRest -> Scope'1::BRest
     intros M. apply ctx_names_mems to C' C'' M. search.
    %mems Scope'1::BRest -> Scope'::BRest
     intros M. apply ctx_names_mems to C'' C' M. search.
  EvA2: apply IH_S to _ _ _ _ _ _ RFE _ SS' C' Trans2 SN2 Ev1. search.
 %TS-Declare
  case IsS. SN: case SN. Ev: case Ev.
  EvA: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev.
  apply transE_is to _ _ Trans1.
  C: apply evalExpr_ctx_names to _ _ _ _ Ctxs SN EvA. case C. search.
 %TS-Assign
  case IsS. SN: case SN. Ev: case Ev.
  EvA: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev.
  apply transE_is to _ _ Trans1. apply evalExpr_isCtx to _ _ _ Ev.
  apply evalExpr_isCtx to _ _ _ EvA.
  SS': apply trans_evalExpr_relCtxs to
          _ _ _ _ _ _ _ _ _ Trans1 EvA Ev.
  SS'': apply scopes_same_symm to SS'.
  apply scopes_same_replaceScopes_exists to _ _ _ SS'' Ev1. search.
 %TS-RecUpdate
  case IsS. SN: case SN. Ev: case Ev.
  EvA: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev.
  SS': apply scopes_same_symm to SS.
  L: apply scopes_same_lookupScopes_exists to _ _ SS' Ev1.
  apply transE_is to _ _ Trans1. apply evalExpr_isCtx to _ _ _ EvA.
  apply evalExpr_isCtx to _ _ _ Ev.
  SS2: apply trans_evalExpr_relCtxs to
          _ _ _ _ _ _ _ _ _ Trans1 EvA Ev.
  SS2': apply scopes_same_symm to SS2.
  apply scopes_same_replaceScopes_exists to _ _ _ SS2' Ev3. search.
 %TS-If
  case IsS. SN: case SN. case SN4. case SN3. Ev: case Ev.
    %E-If-True
     EvA1: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev.
     apply transE_is to _ _ Trans1. apply evalExpr_isCtx to _ _ _ Ev.
     apply evalExpr_isCtx to _ _ _ EvA1.
     SS1: apply trans_evalExpr_relCtxs to
             _ _ _ _ _ _ _ _ _ Trans1 EvA1 Ev.
     C1: apply evalExpr_ctx_names to _ _ _ _ Ctxs SN EvA1.
     SS1': apply scopes_same_add_scope to SS1.
     C1': apply ctx_names_add_scope to C1.
     EvA2: apply IH_S to _ _ _ _ _ _ RFE _ SS1' C1' Trans2 _ Ev1.
     C2: apply evalStmt_ctx_names to _ _ _ _ C1' SN1 EvA2.
     apply stmtNames_keep_older to _ _ SN1. case C2. search.
    %E-If-False
     EvA1: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev.
     apply transE_is to _ _ Trans1. apply evalExpr_isCtx to _ _ _ Ev.
     apply evalExpr_isCtx to _ _ _ EvA1.
     SS1: apply trans_evalExpr_relCtxs to
             _ _ _ _ _ _ _ _ _ Trans1 EvA1 Ev.
     C1: apply evalExpr_ctx_names to _ _ _ _ Ctxs SN EvA1.
     SS1': apply scopes_same_add_scope to SS1.
     C1': apply ctx_names_add_scope to C1.
     EvA2: apply IH_S to _ _ _ _ _ _ RFE _ SS1' C1' Trans3 _ Ev1.
     C2: apply evalStmt_ctx_names to _ _ _ _ C1' SN2 EvA2.
     apply stmtNames_keep_older to _ _ SN2. case C2. search.
 %TS-While
  case IsS. SN: case SN (keep). case SN3. Ev: case Ev.
    %E-While-True
     EvA1: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev.
     apply transE_is to _ _ Trans1. apply evalExpr_isCtx to _ _ _ Ev.
     apply evalExpr_isCtx to _ _ _ EvA1.
     SS1: apply trans_evalExpr_relCtxs to
             _ _ _ _ _ _ _ _ _ Trans1 EvA1 Ev.
     C1: apply evalExpr_ctx_names to _ _ _ _ Ctxs SN1 EvA1.
     SS1': apply scopes_same_add_scope to SS1.
     C1': apply ctx_names_add_scope to C1.
     %eval body
     EvA2: apply IH_S to _ _ _ _ _ _ RFE _ SS1' C1' Trans2 _ Ev1.
     C2: apply evalStmt_ctx_names to _ _ _ _ C1' SN2 EvA2.
     apply stmtNames_keep_older to _ _ SN2. C: case C2.
     %eval again
     apply transS_is to _ _ Trans2.
     IsEE4+: apply evalStmt_isCtx to _ _ _ Ev1. case IsEE4+.
     IsAR+: apply evalStmt_isCtx to _ _ _ EvA2. case IsAR+.
     SS2: apply trans_evalStmt_relCtxs to
             _ _ _ _ _ _ _ _ _ Trans2 EvA2 Ev1. SS2': case SS2.
     case Ctxs. apply transS_old_scopes to _ _ Trans2. C': case C1'.
     case C'2. case C3 (keep). case SS2'2 (keep).
     apply IH_S_E to _ _ _ _ _ _ RFE _ SS2'2 C3 Trans _ Ev2. search.
    %E-While-False
     apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev. search.
 %TS-ScopeStmt
  case IsS. SN: case SN. Ev: case Ev.
  SS': apply scopes_same_add_scope to SS.
  C': apply ctx_names_add_scope to Ctxs.
  EvA: apply IH_S to _ _ _ _ _ _ RFE _ SS' C' Trans1 _ Ev.
  SS1: apply trans_evalStmt_relCtxs to
          _ _ _ _ _ _ _ _ _ Trans1 EvA Ev. case SS1. search.
 %TS-Print
  case IsS. SN: case SN. Ev: case Ev.
    %E-Print-Int
     EvA: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev. search.
    %E-Print-True
     EvA: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev. search.
    %E-Print-False
     EvA: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev. search.
    %E-Print-String
     EvA: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev. search.
 %TS-Default
  apply join_is to _ Trans1. IsS_P: apply proj_stmt_is to Trans2 _ _.
  case Ctxs (keep). SN_P: apply stmtNames_exists to IsS_P IsNames.
  Eq: assert N1 = [].
    IsN1: apply stmtNames_is to _ _ SN_P. IsN1: case IsN1.
      %nil
       search.
      %cons
       M': apply proj_stmtNames to Trans2 _ _ _ SN SN_P _ with X = H.
       case M'.
  case Eq. EvP: apply IH_S to _ _ _ _ _ _ RFE _ SS Ctxs Trans3 _ Ev.
  Names: apply names_exists to IsEE. IsN1: apply names_is to _ Names.
  Pr: apply proj_stmt_other to Trans2 _ _ IsN1.
  apply proj_stmt_unique_ctx_names to _ _ _ _ _ _ Trans2 Pr.
  apply proj_evalStmt_backward to Pr Names _ _ _ _ Ctxs _ EvP.
  search.
%trans_evalArgs_backward
 Trans: case Trans (keep).
   %TA-Nil
    case Ev. search.
   %TA-Cons
    case IsA. AN: case AN. case AN2. Ev: case Ev.
    EvA1: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev.
    apply evalExpr_isCtx to _ _ _ EvA1.
    apply transE_is to _ _ Trans1. apply evalExpr_isCtx to _ _ _ Ev.
    SS': apply trans_evalExpr_relCtxs to
            _ _ _ _ _ _ _ _ _ Trans1 EvA1 Ev.
    apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans1 EvA1.
    EvA2: apply IH_A to _ _ _ _ _ _ RFE _ SS' _ Trans2 _ Ev1. search.
%trans_evalRecFields_backward
 Trans: case Trans (keep).
   %TRF-Nil
    case Ev. search.
   %TRF-Cons
    case IsRF. RFN: case RFN. case RFN2. Ev: case Ev.
    EvA1: apply IH_E to _ _ _ _ _ _ RFE _ SS Ctxs Trans1 _ Ev.
    apply evalExpr_isCtx to _ _ _ EvA1.
    apply transE_is to _ _ Trans1. apply evalExpr_isCtx to _ _ _ Ev.
    SS': apply trans_evalExpr_relCtxs to
            _ _ _ _ _ _ _ _ _ Trans1 EvA1 Ev.
    apply evalExpr_trans_ctx_names to _ _ _ _ Ctxs Trans1 EvA1.
    EvA2: apply IH_RF to _ _ _ _ _ _ RFE _ SS' _ Trans2 _ Ev1. search.


Extensible_Theorem
  trans_getFunEvalInfo_backward :
    forall F F_T Name RetVar RVVal PNames Body_T,
      IsF : is_fun F ->
      Trans : transF F F_T ->
      GFEI : getFunEvalInfo F_T Name RetVar RVVal PNames Body_T ->
      exists Body,
        getFunEvalInfo F Name RetVar RVVal PNames Body
  on Trans.
%TF-Fun
 GFEI: case GFEI. search.
%TF-Default
 apply proj_fun_is to Trans1 _. G: apply IH to _ Trans2 GFEI.
 apply proj_getFunEvalInfo_back to Trans1 _ G. search.


Theorem trans_getFunEvalCtx_backward : forall Fs Fs_T FE_T,
  is_list is_fun Fs -> transFuns Fs Fs_T -> getFunEvalCtx Fs_T FE_T ->
  exists FE, getFunEvalCtx Fs FE.
induction on 2. intros IsFs Trans GFEI. Trans: case Trans.
  %TFs-Nil
   case GFEI. search.
  %TFs-Cons
   case IsFs. G: case GFEI. apply IH to _ Trans1 G1.
   apply trans_getFunEvalInfo_backward to _ Trans G. search.


Theorem getFunEvalCtx_funsEmptyNames_emptyNames_FE : forall Fs FE,
  is_list is_fun Fs -> getFunEvalCtx Fs FE -> funsEmptyNames Fs ->
  emptyNames_FE FE.
induction on 2. intros IsFs GFEC FEN. GFEC: case GFEC.
  %GFEC-Empty
   unfold. intros M. case M.
  %GFEC-Cons
   FEN: case FEN. case IsFs. EN: apply IH to _ GFEC1 FEN1.
   EN: case EN. FEN: case FEN. unfold. intros M. M: case M.
     %Mem-Here
      apply getFunEvalInfo_unique to _ GFEC FEN. search.
     %Mem-Later
      apply EN to M. search.


/*Programs evaluate the same with the same arguments*/
Extensible_Theorem
  trans_evalProgram_backward : forall P P_T A O,
    IsP : is_program P ->
    IsA : is_list is_value A ->
    PEN : programEmptyNames P ->
    Trans : transP P P_T ->
    Ev : evalProgram A P_T O ->
    evalProgram A P O
  on Trans.
%TP-Program
 case IsP. Ev: case Ev. PEN: case PEN.
 apply transFuns_is to _ Trans1. apply transF_is to _ Trans2.
 %get function info back
 GFEC: apply trans_getFunEvalCtx_backward to _ Trans1 Ev.
 GFEI: apply trans_getFunEvalInfo_backward to _ Trans2 Ev1.
 %related function contexts
 RFE: apply trans_getFunEvalCtx_rel_FE to _ Trans1 GFEC Ev.
 Tr: apply trans_getFunEvalInfo_rel to _ Trans2 GFEI Ev1.
 RFE': assert rel_FE ((MainName, (RetVar,
                       (RetVal, (PNames, Body1))))::FE)
                     ((MainName, (RetVar,
                       (RetVal, (PNames, Body))))::FCtx).
   unfold.
     %lookup forward
      intros L. L: case L.
        %Lkp-Here (main)
         search.
        %Lkp-Later
         R: case RFE. apply R to L1. search.
     %lookup back
      intros L. L: case L.
        %Lkp-Here (main)
         search.
        %Lkp-Later
         R: case RFE. apply R1 to L1. search.
 %empty names for all original functions
 EN: apply getFunEvalCtx_funsEmptyNames_emptyNames_FE to _ GFEC PEN.
 EN': assert emptyNames_FE ((MainName, (RetVar, (RetVal,
                                              (PNames, Body1))))::FE).
   unfold. intros M. M: case M.
     %Mem-Here (main)
      FEN: case PEN1. apply getFunEvalInfo_unique to _ GFEI FEN.
      search.
     %Mem-Later
      EN: case EN. apply EN to M. search.
 %is for original eval ctxs
 apply getFunEvalInfo_is to _ Ev1.
 Z: assert zip (RetVar::PNames) (RetVal::A)
                ((RetVar, RetVal)::InitEnv).
 IsIE: apply zip_is to _ _ Z. apply getFunEvalCtx_is to _ Ev.
 %scopes_same and ctx_names
 IsInitEnv: assert is_list (is_list (is_pair is_string is_value))
                      [(RetVar, RetVal)::InitEnv].
 SS: apply scopes_same_reflexive to IsInitEnv.
 Ctxs: apply zip_ctx_names to Z.
 %stmtNames for main body
 FEN: case PEN1. apply getFunEvalInfo_unique to _ FEN GFEI.
 %is for functions
 apply getFunEvalCtx_is to _ GFEC. apply getFunEvalInfo_is to _ GFEI.
 %evaluate main body
 apply trans_evalStmt_backward to
    _ _ _ _ _ _ RFE' EN' SS Ctxs Tr FEN1 Ev3. search.
%TP-Default
 PEN: case PEN. apply proj_program_unique to PEN Trans1 _.
 apply proj_program_is to PEN _. EvP: apply IH to _ _ PEN1 Trans2 Ev.
 apply proj_evalProgram_back to PEN _ _ EvP. search.

/*
  The statement of trans_evalProgram_backward is not as pleasing as
  the statement of trans_evalProgram_forward because of the inclusion
  of the programEmptyNames premise.  A premise like this is necessary,
  telling us all the names in all the functions are bound, but it
  would be nice if we could put it in terms of something else, like
  typing.  Unfortunately, the host language did not specify a
  relationship between typing and stmtNames, so even though this
  connection probably exists, we do not have it to use here.
*/


/*
  Something we could prove here is that the translation is always
  built entirely from constructs from the host language.  We could do
  this by introducing a fixed relation is relation with rules only for
  constructs frem the host language.  However, since we might want to
  translate to an extensible language, we want to leave the set of
  possible constructs open, so we don't do this.
*/


/*
  Note something we might want to prove here but don't is that a term
  translates under certain circumstances.  We can prove any term built
  entirely by constructors introduced by the host language translates.
  However, we cannot prove this generically for constructors that
  might be introduced by other extensions.  Such constructors would
  translate via projection, and the host language has not required a
  projection exist for extension syntax in general under any
  circumstances.  It does require expressions and statements project
  if they evaluate, as part of the projection version of the
  evaluation relations, and thus we know any expression or statement
  that evaluates also translates.  However, we do not have this
  knowledge for functions or programs, and thus cannot say their
  translations exist.  Thus we must be satisfied with saying things
  about the behavior of the translation and the original only when we
  know the translation exists.
*/
