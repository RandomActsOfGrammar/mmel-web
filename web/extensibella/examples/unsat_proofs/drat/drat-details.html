<html>
<head>
<title>Extensibella:  Extensibella Example:  unsat_proofs:drat - Details</title>
<link href="../../../../style.css" rel="stylesheet" type="text/css">
<script src="../../../../actions.js"></script>
<link rel="icon" href="../../../images/favicon.png" type="image/x-icon">
</head>
<body class="extensibella">
<div id="header-logo">
<a href="../../../../index.html">
<img class="header-logo" src="../../../images/Extensibella.png" alt="Extensibella logo">
</a>
</div>
<h2>Reasoning Details</h2>
<div class="section">
<pre class="code extensibella">
 < <b>Module unsat_proofs:drat.</b>
</pre>
<pre class="code extensibella"id="1">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:trans_lit_unique.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="2">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:trans_lit_is.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="3">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:trans_clause_unique.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="4">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:trans_clause_is.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="5">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:trans_formula_unique.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="6">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:trans_formula_is.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="7">
 &lt; <b>Prove_Ext_Ind unsat_proofs:lrat:is_clause.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="8">
 &lt; <b>Prove unsat_proofs:lrat:is_lit_eq_or_not__pos.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="9">
 &lt; <b>Prove unsat_proofs:lrat:is_lit_eq_or_not__neg.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="10">
 &lt; <b>Prove unsat_proofs:lrat:is_lit_eq_or_not.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="11">
 &lt; <b>Prove unsat_proofs:lrat:is_clause_empty_or_not.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="12">
 &lt; <b>Prove unsat_proofs:lrat:is_clause_or_or_not.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="13">
 &lt; <b>Prove unsat_proofs:lrat:is_clause_eq_or_not.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="14">
 &lt; <b>Prove unsat_proofs:lrat:negate_lit_unique.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="15">
 &lt; <b>Prove unsat_proofs:lrat:negate_lit_reverse.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="16">
 &lt; <b>Prove unsat_proofs:lrat:negate_lit_not_same.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="17">
 &lt; <b>Prove unsat_proofs:lrat:negate_lit_is_lit.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="18">
 &lt; <b>Prove unsat_proofs:lrat:negate_lit_is_lit_back.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="19">
 &lt; <b>Prove unsat_proofs:lrat:negate_lit_exists.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="20">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:sat_clause_ext_to_trans.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="21">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:sat_clause_trans_to_ext.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="22">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:unsat_clause_ext_to_trans.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="23">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:unsat_clause_trans_to_ext.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="24">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:sat_formula_ext_to_trans.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="25">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:sat_formula_trans_to_ext.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="26">
 &lt; <b>Prove unsat_proofs:lrat:unsat_sat_clause.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="27">
 &lt; <b>Prove unsat_proofs:lrat:sat_clause_orderless.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="28">
 &lt; <b>Prove unsat_proofs:lrat:sat_formula_orderless.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="29">
 &lt; <b>Prove unsat_proofs:lrat:unsat_clause_orderless.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="30">
 &lt; <b>Prove unsat_proofs:lrat:unit_clause_is.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="31">
 &lt; <b>Prove unsat_proofs:lrat:unit_clause_unique.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="32">
 &lt; <b>Prove unsat_proofs:lrat:unit_clause_not_assigned.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="33">
 &lt; <b>Prove unsat_proofs:lrat:unit_clause_not_assigned_negate.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="34">
 &lt; <b>Prove unsat_proofs:lrat:unit_clause_expand.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="35">
 &lt; <b>Prove unsat_proofs:lrat:unit_clause_add.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="36">
 &lt; <b>Prove unsat_proofs:lrat:gatherLits_is.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="37">
 &lt; <b>Prove unsat_proofs:lrat:gatherLits_exists.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="38">
 &lt; <b>Prove unsat_proofs:lrat:gatherLits_permutation.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="39">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:trans_gatherLits.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="40">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:trans_gatherLits_permutation.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="41">
 &lt; <b>Prove unsat_proofs:lrat:gatherLits_sat.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="42">
 &lt; <b>Prove unsat_proofs:lrat:gatherLits_mem_sat.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="43">
 &lt; <b>Prove unsat_proofs:lrat:gatherLits_unsat.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="44">
 &lt; <b>Prove unsat_proofs:lrat:negate_lits_unsat.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="45">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:trans_proof_is.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="46">
 &lt; <b>Prove unsat_proofs:lrat:check_proof_correct.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="47">
 &lt; <b>Prove unsat_proofs:lrat:checkProof_orderless.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="48">
 &lt; <b>Prove_Ext_Ind unsat_proofs:lrat:checkProof.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="49">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:trans_checkProof.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="50">
 &lt; <b>Prove unsat_proofs:lrat:formulaToKnown_all_greater.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="51">
 &lt; <b>Prove unsat_proofs:lrat:formulaToKnown_all_unique.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="52">
 &lt; <b>Prove unsat_proofs:lrat:formulaToKnown_sat_formula.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="53">
 &lt; <b>Prove unsat_proofs:lrat:formulaToKnown_is.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="54">
 &lt; <b>Theorem rupProof_help__drup_help :
     forall KnownL KnownD A Prf,
       rupProof_help KnownL A Prf -&gt; values KnownL KnownD -&gt; drup_help KnownD A.</b>

============================
 forall KnownL KnownD A Prf,
   rupProof_help KnownL A Prf -&gt; values KnownL KnownD -&gt; drup_help KnownD A
</pre>
<pre class="code extensibella"id="55">
 &lt; <b>induction on 1.</b>

IH : forall KnownL KnownD A Prf,
       rupProof_help KnownL A Prf * -&gt; values KnownL KnownD -&gt; drup_help KnownD A
============================
 forall KnownL KnownD A Prf,
   rupProof_help KnownL A Prf @ -&gt; values KnownL KnownD -&gt; drup_help KnownD A
</pre>
<pre class="code extensibella"id="56">
 &lt; <b>intros RUP V.</b>

Variables: KnownL KnownD A Prf
IH : forall KnownL KnownD A Prf,
       rupProof_help KnownL A Prf * -&gt; values KnownL KnownD -&gt; drup_help KnownD A
RUP : rupProof_help KnownL A Prf @
V : values KnownL KnownD
============================
 drup_help KnownD A
</pre>
<pre class="code extensibella"id="57">
 &lt; <b>RUP: case RUP.</b>

Subgoal 1:

Variables: KnownL KnownD A C ID
IH : forall KnownL KnownD A Prf,
       rupProof_help KnownL A Prf * -&gt; values KnownL KnownD -&gt; drup_help KnownD A
V : values KnownL KnownD
RUP : lookup KnownL ID C
RUP1 : unsat_clause A C
============================
 drup_help KnownD A
</pre>
<pre class="code extensibella"id="58">
 &lt; <b>MemL: apply lookup_mem to RUP.</b>

Subgoal 1:

Variables: KnownL KnownD A C ID
IH : forall KnownL KnownD A Prf,
       rupProof_help KnownL A Prf * -&gt; values KnownL KnownD -&gt; drup_help KnownD A
V : values KnownL KnownD
RUP : lookup KnownL ID C
RUP1 : unsat_clause A C
MemL : mem (ID, C) KnownL
============================
 drup_help KnownD A
</pre>
<pre class="code extensibella"id="59">
 &lt; <b>MemD: apply values_mem to MemL V.</b>

Subgoal 1:

Variables: KnownL KnownD A C ID
IH : forall KnownL KnownD A Prf,
       rupProof_help KnownL A Prf * -&gt; values KnownL KnownD -&gt; drup_help KnownD A
V : values KnownL KnownD
RUP : lookup KnownL ID C
RUP1 : unsat_clause A C
MemL : mem (ID, C) KnownL
MemD : mem C KnownD
============================
 drup_help KnownD A
</pre>
<pre class="code extensibella"id="60">
 &lt; <b>search.</b>

Subgoal 2:

Variables: KnownL KnownD A C L Prf1 ID
IH : forall KnownL KnownD A Prf,
       rupProof_help KnownL A Prf * -&gt; values KnownL KnownD -&gt; drup_help KnownD A
V : values KnownL KnownD
RUP : lookup KnownL ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help KnownL (L::A) Prf1 *
============================
 drup_help KnownD A
</pre>
<pre class="code extensibella"id="61">
 &lt; <b>MemL: apply lookup_mem to RUP.</b>

Subgoal 2:

Variables: KnownL KnownD A C L Prf1 ID
IH : forall KnownL KnownD A Prf,
       rupProof_help KnownL A Prf * -&gt; values KnownL KnownD -&gt; drup_help KnownD A
V : values KnownL KnownD
RUP : lookup KnownL ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help KnownL (L::A) Prf1 *
MemL : mem (ID, C) KnownL
============================
 drup_help KnownD A
</pre>
<pre class="code extensibella"id="62">
 &lt; <b>MemD: apply values_mem to MemL V.</b>

Subgoal 2:

Variables: KnownL KnownD A C L Prf1 ID
IH : forall KnownL KnownD A Prf,
       rupProof_help KnownL A Prf * -&gt; values KnownL KnownD -&gt; drup_help KnownD A
V : values KnownL KnownD
RUP : lookup KnownL ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help KnownL (L::A) Prf1 *
MemL : mem (ID, C) KnownL
MemD : mem C KnownD
============================
 drup_help KnownD A
</pre>
<pre class="code extensibella"id="63">
 &lt; <b>apply IH to RUP2 _.</b>

Subgoal 2:

Variables: KnownL KnownD A C L Prf1 ID
IH : forall KnownL KnownD A Prf,
       rupProof_help KnownL A Prf * -&gt; values KnownL KnownD -&gt; drup_help KnownD A
V : values KnownL KnownD
RUP : lookup KnownL ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help KnownL (L::A) Prf1 *
MemL : mem (ID, C) KnownL
MemD : mem C KnownD
H1 : drup_help KnownD (L::A)
============================
 drup_help KnownD A
</pre>
<pre class="code extensibella"id="64">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="65">
 &lt; <b>Theorem rupProof__drup :
     forall KnownL KnownD C Prf,
       rupProof KnownL C Prf -&gt; values KnownL KnownD -&gt; drup KnownD C.</b>

============================
 forall KnownL KnownD C Prf,
   rupProof KnownL C Prf -&gt; values KnownL KnownD -&gt; drup KnownD C
</pre>
<pre class="code extensibella"id="66">
 &lt; <b>intros R Vals.</b>

Variables: KnownL KnownD C Prf
R : rupProof KnownL C Prf
Vals : values KnownL KnownD
============================
 drup KnownD C
</pre>
<pre class="code extensibella"id="67">
 &lt; <b>R: case R.</b>

Variables: KnownL KnownD C Prf Lits A
Vals : values KnownL KnownD
R : gatherLits C Lits
R1 : negateLitList Lits A
R2 : rupProof_help KnownL A Prf
============================
 drup KnownD C
</pre>
<pre class="code extensibella"id="68">
 &lt; <b>apply rupProof_help__drup_help to R2 Vals.</b>

Variables: KnownL KnownD C Prf Lits A
Vals : values KnownL KnownD
R : gatherLits C Lits
R1 : negateLitList Lits A
R2 : rupProof_help KnownL A Prf
H1 : drup_help KnownD A
============================
 drup KnownD C
</pre>
<pre class="code extensibella"id="69">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="70">
 &lt; <b>Theorem remove_all_no_mem_same :
     forall K ID KRest,
       remove_all K ID KRest -&gt; ((exists C, mem (ID, C) K) -&gt; false) -&gt; K = KRest.</b>

============================
 forall K ID KRest,
   remove_all K ID KRest -&gt; ((exists C, mem (ID, C) K) -&gt; false) -&gt; K = KRest
</pre>
<pre class="code extensibella"id="71">
 &lt; <b>induction on 1.</b>

IH : forall K ID KRest,
       remove_all K ID KRest * -&gt; ((exists C, mem (ID, C) K) -&gt; false) -&gt; K = KRest
============================
 forall K ID KRest,
   remove_all K ID KRest @ -&gt; ((exists C, mem (ID, C) K) -&gt; false) -&gt; K = KRest
</pre>
<pre class="code extensibella"id="72">
 &lt; <b>intros RA NEq.</b>

Variables: K ID KRest
IH : forall K ID KRest,
       remove_all K ID KRest * -&gt; ((exists C, mem (ID, C) K) -&gt; false) -&gt; K = KRest
RA : remove_all K ID KRest @
NEq : (exists C, mem (ID, C) K) -&gt; false
============================
 K = KRest
</pre>
<pre class="code extensibella"id="73">
 &lt; <b>RA: case RA.</b>

Subgoal 1:

Variables: ID
IH : forall K ID KRest,
       remove_all K ID KRest * -&gt; ((exists C, mem (ID, C) K) -&gt; false) -&gt; K = KRest
NEq : (exists C, mem (ID, C) []) -&gt; false
============================
 [] = []
</pre>
<pre class="code extensibella"id="74">
 &lt; <b>search.</b>

Subgoal 2:

Variables: ID KRest IRest C
IH : forall K ID KRest,
       remove_all K ID KRest * -&gt; ((exists C, mem (ID, C) K) -&gt; false) -&gt; K = KRest
NEq : (exists C1, mem (ID, C1) ((ID, C)::IRest)) -&gt; false
RA : remove_all IRest ID KRest *
============================
 (ID, C)::IRest = KRest
</pre>
<pre class="code extensibella"id="75">
 &lt; <b>apply NEq to _.</b>

Subgoal 3:

Variables: ID Rest C A IRest
IH : forall K ID KRest,
       remove_all K ID KRest * -&gt; ((exists C, mem (ID, C) K) -&gt; false) -&gt; K = KRest
NEq : (exists C1, mem (ID, C1) ((A, C)::IRest)) -&gt; false
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
============================
 (A, C)::IRest = (A, C)::Rest
</pre>
<pre class="code extensibella"id="76">
 &lt; <b>assert (exists C, mem (ID, C) IRest) -&gt; false.</b>

Subgoal 3.1:

Variables: ID Rest C A IRest
IH : forall K ID KRest,
       remove_all K ID KRest * -&gt; ((exists C, mem (ID, C) K) -&gt; false) -&gt; K = KRest
NEq : (exists C1, mem (ID, C1) ((A, C)::IRest)) -&gt; false
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
============================
 (exists C1, mem (ID, C1) IRest) -&gt; false
</pre>
<pre class="code extensibella"id="77">
 &lt; <b>intros Ex.</b>

Subgoal 3.1:

Variables: ID Rest C A IRest
IH : forall K ID KRest,
       remove_all K ID KRest * -&gt; ((exists C, mem (ID, C) K) -&gt; false) -&gt; K = KRest
NEq : (exists C1, mem (ID, C1) ((A, C)::IRest)) -&gt; false
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
Ex : exists C1, mem (ID, C1) IRest
============================
 false
</pre>
<pre class="code extensibella"id="78">
 &lt; <b>case Ex.</b>

Subgoal 3.1:

Variables: ID Rest C A IRest C1
IH : forall K ID KRest,
       remove_all K ID KRest * -&gt; ((exists C, mem (ID, C) K) -&gt; false) -&gt; K = KRest
NEq : (exists C1, mem (ID, C1) ((A, C)::IRest)) -&gt; false
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
H1 : mem (ID, C1) IRest
============================
 false
</pre>
<pre class="code extensibella"id="79">
 &lt; <b>backchain NEq.</b>

Subgoal 3:

Variables: ID Rest C A IRest
IH : forall K ID KRest,
       remove_all K ID KRest * -&gt; ((exists C, mem (ID, C) K) -&gt; false) -&gt; K = KRest
NEq : (exists C1, mem (ID, C1) ((A, C)::IRest)) -&gt; false
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
H1 : (exists C1, mem (ID, C1) IRest) -&gt; false
============================
 (A, C)::IRest = (A, C)::Rest
</pre>
<pre class="code extensibella"id="80">
 &lt; <b>apply IH to RA1 _.</b>

Subgoal 3:

Variables: ID Rest C A
IH : forall K ID KRest,
       remove_all K ID KRest * -&gt; ((exists C, mem (ID, C) K) -&gt; false) -&gt; K = KRest
NEq : (exists C1, mem (ID, C1) ((A, C)::Rest)) -&gt; false
RA : A = ID -&gt; false
RA1 : remove_all Rest ID Rest *
H1 : (exists C1, mem (ID, C1) Rest) -&gt; false
============================
 (A, C)::Rest = (A, C)::Rest
</pre>
<pre class="code extensibella"id="81">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="82">
 &lt; <b>Theorem remove_all_good_clause_list_select :
     forall K ID KRA C KS,
       good_clause_list K -&gt; remove_all K ID KRA -&gt; select (ID, C) KS K -&gt; KRA = KS.</b>

============================
 forall K ID KRA C KS,
   good_clause_list K -&gt; remove_all K ID KRA -&gt; select (ID, C) KS K -&gt; KRA = KS
</pre>
<pre class="code extensibella"id="83">
 &lt; <b>induction on 2.</b>

IH : forall K ID KRA C KS,
       good_clause_list K -&gt; remove_all K ID KRA * -&gt; select (ID, C) KS K -&gt; KRA = KS
============================
 forall K ID KRA C KS,
   good_clause_list K -&gt; remove_all K ID KRA @ -&gt; select (ID, C) KS K -&gt; KRA = KS
</pre>
<pre class="code extensibella"id="84">
 &lt; <b>intros GCL RA Slct.</b>

Variables: K ID KRA C KS
IH : forall K ID KRA C KS,
       good_clause_list K -&gt; remove_all K ID KRA * -&gt; select (ID, C) KS K -&gt; KRA = KS
GCL : good_clause_list K
RA : remove_all K ID KRA @
Slct : select (ID, C) KS K
============================
 KRA = KS
</pre>
<pre class="code extensibella"id="85">
 &lt; <b>RA: case RA.</b>

Subgoal 1:

Variables: ID C KS
IH : forall K ID KRA C KS,
       good_clause_list K -&gt; remove_all K ID KRA * -&gt; select (ID, C) KS K -&gt; KRA = KS
GCL : good_clause_list []
Slct : select (ID, C) KS []
============================
 [] = KS
</pre>
<pre class="code extensibella"id="86">
 &lt; <b>case Slct.</b>

Subgoal 2:

Variables: ID KRA C KS IRest C1
IH : forall K ID KRA C KS,
       good_clause_list K -&gt; remove_all K ID KRA * -&gt; select (ID, C) KS K -&gt; KRA = KS
GCL : good_clause_list ((ID, C1)::IRest)
Slct : select (ID, C) KS ((ID, C1)::IRest)
RA : remove_all IRest ID KRA *
============================
 KRA = KS
</pre>
<pre class="code extensibella"id="87">
 &lt; <b>Slct: case Slct.</b>

Subgoal 2.1:

Variables: ID KRA IRest C1
IH : forall K ID KRA C KS,
       good_clause_list K -&gt; remove_all K ID KRA * -&gt; select (ID, C) KS K -&gt; KRA = KS
GCL : good_clause_list ((ID, C1)::IRest)
RA : remove_all IRest ID KRA *
============================
 KRA = IRest
</pre>
<pre class="code extensibella"id="88">
 &lt; <b>assert (exists C', mem (ID, C') IRest) -&gt; false.</b>

Subgoal 2.1.1:

Variables: ID KRA IRest C1
IH : forall K ID KRA C KS,
       good_clause_list K -&gt; remove_all K ID KRA * -&gt; select (ID, C) KS K -&gt; KRA = KS
GCL : good_clause_list ((ID, C1)::IRest)
RA : remove_all IRest ID KRA *
============================
 (exists C', mem (ID, C') IRest) -&gt; false
</pre>
<pre class="code extensibella"id="89">
 &lt; <b>intros Ex.</b>

Subgoal 2.1.1:

Variables: ID KRA IRest C1
IH : forall K ID KRA C KS,
       good_clause_list K -&gt; remove_all K ID KRA * -&gt; select (ID, C) KS K -&gt; KRA = KS
GCL : good_clause_list ((ID, C1)::IRest)
RA : remove_all IRest ID KRA *
Ex : exists C', mem (ID, C') IRest
============================
 false
</pre>
<pre class="code extensibella"id="90">
 &lt; <b>M: case Ex.</b>

Subgoal 2.1.1:

Variables: ID KRA IRest C1 C'
IH : forall K ID KRA C KS,
       good_clause_list K -&gt; remove_all K ID KRA * -&gt; select (ID, C) KS K -&gt; KRA = KS
GCL : good_clause_list ((ID, C1)::IRest)
RA : remove_all IRest ID KRA *
M : mem (ID, C') IRest
============================
 false
</pre>
<pre class="code extensibella"id="91">
 &lt; <b>GCL: case GCL.</b>

Subgoal 2.1.1:

Variables: ID KRA IRest C1 C'
IH : forall K ID KRA C KS,
       good_clause_list K -&gt; remove_all K ID KRA * -&gt; select (ID, C) KS K -&gt; KRA = KS
RA : remove_all IRest ID KRA *
M : mem (ID, C') IRest
GCL : forall ID1 C2 KRest C3,
        select (ID1, C2) KRest ((ID, C1)::IRest) -&gt; mem (ID1, C3) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="92">
 &lt; <b>backchain GCL.</b>

Subgoal 2.1:

Variables: ID KRA IRest C1
IH : forall K ID KRA C KS,
       good_clause_list K -&gt; remove_all K ID KRA * -&gt; select (ID, C) KS K -&gt; KRA = KS
GCL : good_clause_list ((ID, C1)::IRest)
RA : remove_all IRest ID KRA *
H1 : (exists C', mem (ID, C') IRest) -&gt; false
============================
 KRA = IRest
</pre>
<pre class="code extensibella"id="93">
 &lt; <b>apply remove_all_no_mem_same to RA _.</b>

Subgoal 2.1:

Variables: ID KRA C1
IH : forall K ID KRA C KS,
       good_clause_list K -&gt; remove_all K ID KRA * -&gt; select (ID, C) KS K -&gt; KRA = KS
GCL : good_clause_list ((ID, C1)::KRA)
RA : remove_all KRA ID KRA *
H1 : (exists C', mem (ID, C') KRA) -&gt; false
============================
 KRA = KRA
</pre>
<pre class="code extensibella"id="94">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: ID KRA C IRest C1 L1
IH : forall K ID KRA C KS,
       good_clause_list K -&gt; remove_all K ID KRA * -&gt; select (ID, C) KS K -&gt; KRA = KS
GCL : good_clause_list ((ID, C1)::IRest)
RA : remove_all IRest ID KRA *
Slct : select (ID, C) L1 IRest
============================
 KRA = (ID, C1)::L1
</pre>
<pre class="code extensibella"id="95">
 &lt; <b>M: apply select_mem to Slct.</b>

Subgoal 2.2:

Variables: ID KRA C IRest C1 L1
IH : forall K ID KRA C KS,
       good_clause_list K -&gt; remove_all K ID KRA * -&gt; select (ID, C) KS K -&gt; KRA = KS
GCL : good_clause_list ((ID, C1)::IRest)
RA : remove_all IRest ID KRA *
Slct : select (ID, C) L1 IRest
M : mem (ID, C) IRest
============================
 KRA = (ID, C1)::L1
</pre>
<pre class="code extensibella"id="96">
 &lt; <b>GCL: case GCL.</b>

Subgoal 2.2:

Variables: ID KRA C IRest C1 L1
IH : forall K ID KRA C KS,
       good_clause_list K -&gt; remove_all K ID KRA * -&gt; select (ID, C) KS K -&gt; KRA = KS
RA : remove_all IRest ID KRA *
Slct : select (ID, C) L1 IRest
M : mem (ID, C) IRest
GCL : forall ID1 C2 KRest C3,
        select (ID1, C2) KRest ((ID, C1)::IRest) -&gt; mem (ID1, C3) KRest -&gt; false
============================
 KRA = (ID, C1)::L1
</pre>
<pre class="code extensibella"id="97">
 &lt; <b>apply GCL to _ M.</b>

Subgoal 3:

Variables: ID C KS Rest C1 A IRest
IH : forall K ID KRA C KS,
       good_clause_list K -&gt; remove_all K ID KRA * -&gt; select (ID, C) KS K -&gt; KRA = KS
GCL : good_clause_list ((A, C1)::IRest)
Slct : select (ID, C) KS ((A, C1)::IRest)
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
============================
 (A, C1)::Rest = KS
</pre>
<pre class="code extensibella"id="98">
 &lt; <b>Slct: case Slct.</b>

Subgoal 3.1:

Variables: Rest C1 A IRest
IH : forall K ID KRA C KS,
       good_clause_list K -&gt; remove_all K ID KRA * -&gt; select (ID, C) KS K -&gt; KRA = KS
GCL : good_clause_list ((A, C1)::IRest)
RA : A = A -&gt; false
RA1 : remove_all IRest A Rest *
============================
 (A, C1)::Rest = IRest
</pre>
<pre class="code extensibella"id="99">
 &lt; <b>apply RA to _.</b>

Subgoal 3.2:

Variables: ID C Rest C1 A IRest L1
IH : forall K ID KRA C KS,
       good_clause_list K -&gt; remove_all K ID KRA * -&gt; select (ID, C) KS K -&gt; KRA = KS
GCL : good_clause_list ((A, C1)::IRest)
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
Slct : select (ID, C) L1 IRest
============================
 (A, C1)::Rest = (A, C1)::L1
</pre>
<pre class="code extensibella"id="100">
 &lt; <b>apply good_clause_list_drop to GCL.</b>

Subgoal 3.2:

Variables: ID C Rest C1 A IRest L1
IH : forall K ID KRA C KS,
       good_clause_list K -&gt; remove_all K ID KRA * -&gt; select (ID, C) KS K -&gt; KRA = KS
GCL : good_clause_list ((A, C1)::IRest)
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
Slct : select (ID, C) L1 IRest
H1 : good_clause_list IRest
============================
 (A, C1)::Rest = (A, C1)::L1
</pre>
<pre class="code extensibella"id="101">
 &lt; <b>apply IH to _ RA1 Slct.</b>

Subgoal 3.2:

Variables: ID C C1 A IRest L1
IH : forall K ID KRA C KS,
       good_clause_list K -&gt; remove_all K ID KRA * -&gt; select (ID, C) KS K -&gt; KRA = KS
GCL : good_clause_list ((A, C1)::IRest)
RA : A = ID -&gt; false
RA1 : remove_all IRest ID L1 *
Slct : select (ID, C) L1 IRest
H1 : good_clause_list IRest
============================
 (A, C1)::L1 = (A, C1)::L1
</pre>
<pre class="code extensibella"id="102">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="103">
 &lt; <b>Theorem remove_all_subset :
     forall K ID KRest, remove_all K ID KRest -&gt; subset KRest K.</b>

============================
 forall K ID KRest, remove_all K ID KRest -&gt; subset KRest K
</pre>
<pre class="code extensibella"id="104">
 &lt; <b>induction on 1.</b>

IH : forall K ID KRest, remove_all K ID KRest * -&gt; subset KRest K
============================
 forall K ID KRest, remove_all K ID KRest @ -&gt; subset KRest K
</pre>
<pre class="code extensibella"id="105">
 &lt; <b>intros RA.</b>

Variables: K ID KRest
IH : forall K ID KRest, remove_all K ID KRest * -&gt; subset KRest K
RA : remove_all K ID KRest @
============================
 subset KRest K
</pre>
<pre class="code extensibella"id="106">
 &lt; <b>RA: case RA.</b>

Subgoal 1:

Variables: ID
IH : forall K ID KRest, remove_all K ID KRest * -&gt; subset KRest K
============================
 subset [] []
</pre>
<pre class="code extensibella"id="107">
 &lt; <b>search.</b>

Subgoal 2:

Variables: ID KRest IRest C
IH : forall K ID KRest, remove_all K ID KRest * -&gt; subset KRest K
RA : remove_all IRest ID KRest *
============================
 subset KRest ((ID, C)::IRest)
</pre>
<pre class="code extensibella"id="108">
 &lt; <b>S: apply IH to RA.</b>

Subgoal 2:

Variables: ID KRest IRest C
IH : forall K ID KRest, remove_all K ID KRest * -&gt; subset KRest K
RA : remove_all IRest ID KRest *
S : subset KRest IRest
============================
 subset KRest ((ID, C)::IRest)
</pre>
<pre class="code extensibella"id="109">
 &lt; <b>backchain subset_add_right.</b>

Subgoal 3:

Variables: ID Rest C A IRest
IH : forall K ID KRest, remove_all K ID KRest * -&gt; subset KRest K
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
============================
 subset ((A, C)::Rest) ((A, C)::IRest)
</pre>
<pre class="code extensibella"id="110">
 &lt; <b>S: apply IH to RA1.</b>

Subgoal 3:

Variables: ID Rest C A IRest
IH : forall K ID KRest, remove_all K ID KRest * -&gt; subset KRest K
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
S : subset Rest IRest
============================
 subset ((A, C)::Rest) ((A, C)::IRest)
</pre>
<pre class="code extensibella"id="111">
 &lt; <b>apply subset_add_right to S with
     A = (A, C).</b>

Subgoal 3:

Variables: ID Rest C A IRest
IH : forall K ID KRest, remove_all K ID KRest * -&gt; subset KRest K
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
S : subset Rest IRest
H1 : subset Rest ((A, C)::IRest)
============================
 subset ((A, C)::Rest) ((A, C)::IRest)
</pre>
<pre class="code extensibella"id="112">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="113">
 &lt; <b>Theorem subset_values  [A, B] :
     forall (A : list (pair A B)) (B : list (pair A B)) VA VB,
       subset A B -&gt; values A VA -&gt; values B VB -&gt; subset VA VB.</b>

============================
 forall A B VA VB, subset A B -&gt; values A VA -&gt; values B VB -&gt; subset VA VB
</pre>
<pre class="code extensibella"id="114">
 &lt; <b>induction on 1.</b>

IH : forall A B VA VB,
       subset A B * -&gt; values A VA -&gt; values B VB -&gt; subset VA VB
============================
 forall A B VA VB, subset A B @ -&gt; values A VA -&gt; values B VB -&gt; subset VA VB
</pre>
<pre class="code extensibella"id="115">
 &lt; <b>intros S VA VB.</b>

Variables: A B VA VB
IH : forall A B VA VB,
       subset A B * -&gt; values A VA -&gt; values B VB -&gt; subset VA VB
S : subset A B @
VA : values A VA
VB : values B VB
============================
 subset VA VB
</pre>
<pre class="code extensibella"id="116">
 &lt; <b>S: case S.</b>

Subgoal 1:

Variables: B VA VB
IH : forall A B VA VB,
       subset A B * -&gt; values A VA -&gt; values B VB -&gt; subset VA VB
VA : values [] VA
VB : values B VB
============================
 subset VA VB
</pre>
<pre class="code extensibella"id="117">
 &lt; <b>case VA.</b>

Subgoal 1:

Variables: B VB
IH : forall A B VA VB,
       subset A B * -&gt; values A VA -&gt; values B VB -&gt; subset VA VB
VB : values B VB
============================
 subset [] VB
</pre>
<pre class="code extensibella"id="118">
 &lt; <b>search.</b>

Subgoal 2:

Variables: B VA VB Rest X
IH : forall A B VA VB,
       subset A B * -&gt; values A VA -&gt; values B VB -&gt; subset VA VB
VA : values (X::Rest) VA
VB : values B VB
S : mem X B
S1 : subset Rest B *
============================
 subset VA VB
</pre>
<pre class="code extensibella"id="119">
 &lt; <b>VA: case VA.</b>

Subgoal 2:

Variables: B VB Rest VRest B1 A1
IH : forall A B VA VB,
       subset A B * -&gt; values A VA -&gt; values B VB -&gt; subset VA VB
VB : values B VB
S : mem (A1, B1) B
S1 : subset Rest B *
VA : values Rest VRest
============================
 subset (B1::VRest) VB
</pre>
<pre class="code extensibella"id="120">
 &lt; <b>apply IH to S1 VA VB.</b>

Subgoal 2:

Variables: B VB Rest VRest B1 A1
IH : forall A B VA VB,
       subset A B * -&gt; values A VA -&gt; values B VB -&gt; subset VA VB
VB : values B VB
S : mem (A1, B1) B
S1 : subset Rest B *
VA : values Rest VRest
H1 : subset VRest VB
============================
 subset (B1::VRest) VB
</pre>
<pre class="code extensibella"id="121">
 &lt; <b>apply values_mem to S VB.</b>

Subgoal 2:

Variables: B VB Rest VRest B1 A1
IH : forall A B VA VB,
       subset A B * -&gt; values A VA -&gt; values B VB -&gt; subset VA VB
VB : values B VB
S : mem (A1, B1) B
S1 : subset Rest B *
VA : values Rest VRest
H1 : subset VRest VB
H2 : mem B1 VB
============================
 subset (B1::VRest) VB
</pre>
<pre class="code extensibella"id="122">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="123">
 &lt; <b>Theorem values_exist :
     forall K, is_list (is_pair is_integer is_clause) K -&gt; exists V, values K V.</b>

============================
 forall K, is_list (is_pair is_integer is_clause) K -&gt; exists V, values K V
</pre>
<pre class="code extensibella"id="124">
 &lt; <b>induction on 1.</b>

IH : forall K,
       is_list (is_pair is_integer is_clause) K * -&gt; exists V, values K V
============================
 forall K, is_list (is_pair is_integer is_clause) K @ -&gt; exists V, values K V
</pre>
<pre class="code extensibella"id="125">
 &lt; <b>intros Is.</b>

Variables: K
IH : forall K,
       is_list (is_pair is_integer is_clause) K * -&gt; exists V, values K V
Is : is_list (is_pair is_integer is_clause) K @
============================
 exists V, values K V
</pre>
<pre class="code extensibella"id="126">
 &lt; <b>Is: case Is.</b>

Subgoal 1:

IH : forall K,
       is_list (is_pair is_integer is_clause) K * -&gt; exists V, values K V
============================
 exists V, values [] V
</pre>
<pre class="code extensibella"id="127">
 &lt; <b>search.</b>

Subgoal 2:

Variables: T H
IH : forall K,
       is_list (is_pair is_integer is_clause) K * -&gt; exists V, values K V
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
============================
 exists V, values (H::T) V
</pre>
<pre class="code extensibella"id="128">
 &lt; <b>case Is.</b>

Subgoal 2:

Variables: T B A
IH : forall K,
       is_list (is_pair is_integer is_clause) K * -&gt; exists V, values K V
Is1 : is_list (is_pair is_integer is_clause) T *
H1 : is_integer A
H2 : is_clause B
============================
 exists V, values ((A, B)::T) V
</pre>
<pre class="code extensibella"id="129">
 &lt; <b>apply IH to Is1.</b>

Subgoal 2:

Variables: T B A V
IH : forall K,
       is_list (is_pair is_integer is_clause) K * -&gt; exists V, values K V
Is1 : is_list (is_pair is_integer is_clause) T *
H1 : is_integer A
H2 : is_clause B
H3 : values T V
============================
 exists V, values ((A, B)::T) V
</pre>
<pre class="code extensibella"id="130">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="131">
 &lt; <b>Theorem remove_all_unique :
     forall K ID KA KB, remove_all K ID KA -&gt; remove_all K ID KB -&gt; KA = KB.</b>

============================
 forall K ID KA KB, remove_all K ID KA -&gt; remove_all K ID KB -&gt; KA = KB
</pre>
<pre class="code extensibella"id="132">
 &lt; <b>induction on 1.</b>

IH : forall K ID KA KB, remove_all K ID KA * -&gt; remove_all K ID KB -&gt; KA = KB
============================
 forall K ID KA KB, remove_all K ID KA @ -&gt; remove_all K ID KB -&gt; KA = KB
</pre>
<pre class="code extensibella"id="133">
 &lt; <b>intros RAA RAB.</b>

Variables: K ID KA KB
IH : forall K ID KA KB, remove_all K ID KA * -&gt; remove_all K ID KB -&gt; KA = KB
RAA : remove_all K ID KA @
RAB : remove_all K ID KB
============================
 KA = KB
</pre>
<pre class="code extensibella"id="134">
 &lt; <b>RAA: case RAA.</b>

Subgoal 1:

Variables: ID KB
IH : forall K ID KA KB, remove_all K ID KA * -&gt; remove_all K ID KB -&gt; KA = KB
RAB : remove_all [] ID KB
============================
 [] = KB
</pre>
<pre class="code extensibella"id="135">
 &lt; <b>case RAB.</b>

Subgoal 1:

Variables: ID
IH : forall K ID KA KB, remove_all K ID KA * -&gt; remove_all K ID KB -&gt; KA = KB
============================
 [] = []
</pre>
<pre class="code extensibella"id="136">
 &lt; <b>search.</b>

Subgoal 2:

Variables: ID KA KB IRest C
IH : forall K ID KA KB, remove_all K ID KA * -&gt; remove_all K ID KB -&gt; KA = KB
RAB : remove_all ((ID, C)::IRest) ID KB
RAA : remove_all IRest ID KA *
============================
 KA = KB
</pre>
<pre class="code extensibella"id="137">
 &lt; <b>RAB: case RAB.</b>

Subgoal 2.1:

Variables: ID KA KB IRest C
IH : forall K ID KA KB, remove_all K ID KA * -&gt; remove_all K ID KB -&gt; KA = KB
RAA : remove_all IRest ID KA *
RAB : remove_all IRest ID KB
============================
 KA = KB
</pre>
<pre class="code extensibella"id="138">
 &lt; <b>apply IH to RAA RAB.</b>

Subgoal 2.1:

Variables: ID KB IRest C
IH : forall K ID KA KB, remove_all K ID KA * -&gt; remove_all K ID KB -&gt; KA = KB
RAA : remove_all IRest ID KB *
RAB : remove_all IRest ID KB
============================
 KB = KB
</pre>
<pre class="code extensibella"id="139">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: ID KA IRest C Rest
IH : forall K ID KA KB, remove_all K ID KA * -&gt; remove_all K ID KB -&gt; KA = KB
RAA : remove_all IRest ID KA *
RAB : ID = ID -&gt; false
RAB1 : remove_all IRest ID Rest
============================
 KA = (ID, C)::Rest
</pre>
<pre class="code extensibella"id="140">
 &lt; <b>apply RAB to _.</b>

Subgoal 3:

Variables: ID KB Rest C A IRest
IH : forall K ID KA KB, remove_all K ID KA * -&gt; remove_all K ID KB -&gt; KA = KB
RAB : remove_all ((A, C)::IRest) ID KB
RAA : A = ID -&gt; false
RAA1 : remove_all IRest ID Rest *
============================
 (A, C)::Rest = KB
</pre>
<pre class="code extensibella"id="141">
 &lt; <b>RAB: case RAB.</b>

Subgoal 3.1:

Variables: ID KB Rest C IRest
IH : forall K ID KA KB, remove_all K ID KA * -&gt; remove_all K ID KB -&gt; KA = KB
RAA : ID = ID -&gt; false
RAA1 : remove_all IRest ID Rest *
RAB : remove_all IRest ID KB
============================
 (ID, C)::Rest = KB
</pre>
<pre class="code extensibella"id="142">
 &lt; <b>apply RAA to _.</b>

Subgoal 3.2:

Variables: ID Rest C A IRest Rest1
IH : forall K ID KA KB, remove_all K ID KA * -&gt; remove_all K ID KB -&gt; KA = KB
RAA : A = ID -&gt; false
RAA1 : remove_all IRest ID Rest *
RAB : A = ID -&gt; false
RAB1 : remove_all IRest ID Rest1
============================
 (A, C)::Rest = (A, C)::Rest1
</pre>
<pre class="code extensibella"id="143">
 &lt; <b>apply IH to RAA1 RAB1.</b>

Subgoal 3.2:

Variables: ID C A IRest Rest1
IH : forall K ID KA KB, remove_all K ID KA * -&gt; remove_all K ID KB -&gt; KA = KB
RAA : A = ID -&gt; false
RAA1 : remove_all IRest ID Rest1 *
RAB : A = ID -&gt; false
RAB1 : remove_all IRest ID Rest1
============================
 (A, C)::Rest1 = (A, C)::Rest1
</pre>
<pre class="code extensibella"id="144">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="145">
 &lt; <b>Theorem drup_help_subset :
     forall KA C KB, drup_help KA C -&gt; subset KA KB -&gt; drup_help KB C.</b>

============================
 forall KA C KB, drup_help KA C -&gt; subset KA KB -&gt; drup_help KB C
</pre>
<pre class="code extensibella"id="146">
 &lt; <b>induction on 1.</b>

IH : forall KA C KB, drup_help KA C * -&gt; subset KA KB -&gt; drup_help KB C
============================
 forall KA C KB, drup_help KA C @ -&gt; subset KA KB -&gt; drup_help KB C
</pre>
<pre class="code extensibella"id="147">
 &lt; <b>intros D S.</b>

Variables: KA C KB
IH : forall KA C KB, drup_help KA C * -&gt; subset KA KB -&gt; drup_help KB C
D : drup_help KA C @
S : subset KA KB
============================
 drup_help KB C
</pre>
<pre class="code extensibella"id="148">
 &lt; <b>D: case D.</b>

Subgoal 1:

Variables: KA C KB C1
IH : forall KA C KB, drup_help KA C * -&gt; subset KA KB -&gt; drup_help KB C
S : subset KA KB
D : mem C1 KA
D1 : unsat_clause C C1
============================
 drup_help KB C
</pre>
<pre class="code extensibella"id="149">
 &lt; <b>apply subset_mem to S D.</b>

Subgoal 1:

Variables: KA C KB C1
IH : forall KA C KB, drup_help KA C * -&gt; subset KA KB -&gt; drup_help KB C
S : subset KA KB
D : mem C1 KA
D1 : unsat_clause C C1
H1 : mem C1 KB
============================
 drup_help KB C
</pre>
<pre class="code extensibella"id="150">
 &lt; <b>search.</b>

Subgoal 2:

Variables: KA C KB C1 L
IH : forall KA C KB, drup_help KA C * -&gt; subset KA KB -&gt; drup_help KB C
S : subset KA KB
D : mem C1 KA
D1 : unit_clause C C1 L
D2 : drup_help KA (L::C) *
============================
 drup_help KB C
</pre>
<pre class="code extensibella"id="151">
 &lt; <b>apply IH to D2 S.</b>

Subgoal 2:

Variables: KA C KB C1 L
IH : forall KA C KB, drup_help KA C * -&gt; subset KA KB -&gt; drup_help KB C
S : subset KA KB
D : mem C1 KA
D1 : unit_clause C C1 L
D2 : drup_help KA (L::C) *
H1 : drup_help KB (L::C)
============================
 drup_help KB C
</pre>
<pre class="code extensibella"id="152">
 &lt; <b>apply subset_mem to S D.</b>

Subgoal 2:

Variables: KA C KB C1 L
IH : forall KA C KB, drup_help KA C * -&gt; subset KA KB -&gt; drup_help KB C
S : subset KA KB
D : mem C1 KA
D1 : unit_clause C C1 L
D2 : drup_help KA (L::C) *
H1 : drup_help KB (L::C)
H2 : mem C1 KB
============================
 drup_help KB C
</pre>
<pre class="code extensibella"id="153">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="154">
 &lt; <b>Theorem drup_subset :
     forall KA C KB, drup KA C -&gt; subset KA KB -&gt; drup KB C.</b>

============================
 forall KA C KB, drup KA C -&gt; subset KA KB -&gt; drup KB C
</pre>
<pre class="code extensibella"id="155">
 &lt; <b>intros D S.</b>

Variables: KA C KB
D : drup KA C
S : subset KA KB
============================
 drup KB C
</pre>
<pre class="code extensibella"id="156">
 &lt; <b>D: case D.</b>

Variables: KA C KB L NL
S : subset KA KB
D : gatherLits C L
D1 : negateLitList L NL
D2 : drup_help KA NL
============================
 drup KB C
</pre>
<pre class="code extensibella"id="157">
 &lt; <b>apply drup_help_subset to D2 S.</b>

Variables: KA C KB L NL
S : subset KA KB
D : gatherLits C L
D1 : negateLitList L NL
D2 : drup_help KA NL
H1 : drup_help KB NL
============================
 drup KB C
</pre>
<pre class="code extensibella"id="158">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="159">
 &lt; <b>Theorem good_clause_list_selects :
     forall K ID CA KA CB KB,
       good_clause_list K -&gt; select (ID, CA) KA K -&gt; select (ID, CB) KB K -&gt; KA = KB.</b>

============================
 forall K ID CA KA CB KB,
   good_clause_list K -&gt; select (ID, CA) KA K -&gt; select (ID, CB) KB K -&gt; KA = KB
</pre>
<pre class="code extensibella"id="160">
 &lt; <b>induction on 2.</b>

IH : forall K ID CA KA CB KB,
       good_clause_list K -&gt; select (ID, CA) KA K * -&gt; select (ID, CB) KB K -&gt; KA = KB
============================
 forall K ID CA KA CB KB,
   good_clause_list K -&gt; select (ID, CA) KA K @ -&gt; select (ID, CB) KB K -&gt; KA = KB
</pre>
<pre class="code extensibella"id="161">
 &lt; <b>intros GCL SA SB.</b>

Variables: K ID CA KA CB KB
IH : forall K ID CA KA CB KB,
       good_clause_list K -&gt; select (ID, CA) KA K * -&gt; select (ID, CB) KB K -&gt; KA = KB
GCL : good_clause_list K
SA : select (ID, CA) KA K @
SB : select (ID, CB) KB K
============================
 KA = KB
</pre>
<pre class="code extensibella"id="162">
 &lt; <b>SA: case SA.</b>

Subgoal 1:

Variables: ID CA KA CB KB
IH : forall K ID CA KA CB KB,
       good_clause_list K -&gt; select (ID, CA) KA K * -&gt; select (ID, CB) KB K -&gt; KA = KB
GCL : good_clause_list ((ID, CA)::KA)
SB : select (ID, CB) KB ((ID, CA)::KA)
============================
 KA = KB
</pre>
<pre class="code extensibella"id="163">
 &lt; <b>SB: case SB.</b>

Subgoal 1.1:

Variables: ID CA KA
IH : forall K ID CA KA CB KB,
       good_clause_list K -&gt; select (ID, CA) KA K * -&gt; select (ID, CB) KB K -&gt; KA = KB
GCL : good_clause_list ((ID, CA)::KA)
============================
 KA = KA
</pre>
<pre class="code extensibella"id="164">
 &lt; <b>search.</b>

Subgoal 1.2:

Variables: ID CA KA CB L1
IH : forall K ID CA KA CB KB,
       good_clause_list K -&gt; select (ID, CA) KA K * -&gt; select (ID, CB) KB K -&gt; KA = KB
GCL : good_clause_list ((ID, CA)::KA)
SB : select (ID, CB) L1 KA
============================
 KA = (ID, CA)::L1
</pre>
<pre class="code extensibella"id="165">
 &lt; <b>GCL: case GCL.</b>

Subgoal 1.2:

Variables: ID CA KA CB L1
IH : forall K ID CA KA CB KB,
       good_clause_list K -&gt; select (ID, CA) KA K * -&gt; select (ID, CB) KB K -&gt; KA = KB
SB : select (ID, CB) L1 KA
GCL : forall ID1 C1 KRest C2,
        select (ID1, C1) KRest ((ID, CA)::KA) -&gt; mem (ID1, C2) KRest -&gt; false
============================
 KA = (ID, CA)::L1
</pre>
<pre class="code extensibella"id="166">
 &lt; <b>M: apply select_mem to SB.</b>

Subgoal 1.2:

Variables: ID CA KA CB L1
IH : forall K ID CA KA CB KB,
       good_clause_list K -&gt; select (ID, CA) KA K * -&gt; select (ID, CB) KB K -&gt; KA = KB
SB : select (ID, CB) L1 KA
GCL : forall ID1 C1 KRest C2,
        select (ID1, C1) KRest ((ID, CA)::KA) -&gt; mem (ID1, C2) KRest -&gt; false
M : mem (ID, CB) KA
============================
 KA = (ID, CA)::L1
</pre>
<pre class="code extensibella"id="167">
 &lt; <b>apply GCL to _ M.</b>

Subgoal 2:

Variables: ID CA CB KB L2 I L1
IH : forall K ID CA KA CB KB,
       good_clause_list K -&gt; select (ID, CA) KA K * -&gt; select (ID, CB) KB K -&gt; KA = KB
GCL : good_clause_list (I::L2)
SB : select (ID, CB) KB (I::L2)
SA : select (ID, CA) L1 L2 *
============================
 I::L1 = KB
</pre>
<pre class="code extensibella"id="168">
 &lt; <b>SB: case SB.</b>

Subgoal 2.1:

Variables: ID CA CB L2 L1
IH : forall K ID CA KA CB KB,
       good_clause_list K -&gt; select (ID, CA) KA K * -&gt; select (ID, CB) KB K -&gt; KA = KB
GCL : good_clause_list ((ID, CB)::L2)
SA : select (ID, CA) L1 L2 *
============================
 (ID, CB)::L1 = L2
</pre>
<pre class="code extensibella"id="169">
 &lt; <b>GCL: case GCL.</b>

Subgoal 2.1:

Variables: ID CA CB L2 L1
IH : forall K ID CA KA CB KB,
       good_clause_list K -&gt; select (ID, CA) KA K * -&gt; select (ID, CB) KB K -&gt; KA = KB
SA : select (ID, CA) L1 L2 *
GCL : forall ID1 C1 KRest C2,
        select (ID1, C1) KRest ((ID, CB)::L2) -&gt; mem (ID1, C2) KRest -&gt; false
============================
 (ID, CB)::L1 = L2
</pre>
<pre class="code extensibella"id="170">
 &lt; <b>M: apply select_mem to SA.</b>

Subgoal 2.1:

Variables: ID CA CB L2 L1
IH : forall K ID CA KA CB KB,
       good_clause_list K -&gt; select (ID, CA) KA K * -&gt; select (ID, CB) KB K -&gt; KA = KB
SA : select (ID, CA) L1 L2 *
GCL : forall ID1 C1 KRest C2,
        select (ID1, C1) KRest ((ID, CB)::L2) -&gt; mem (ID1, C2) KRest -&gt; false
M : mem (ID, CA) L2
============================
 (ID, CB)::L1 = L2
</pre>
<pre class="code extensibella"id="171">
 &lt; <b>apply GCL to _ M.</b>

Subgoal 2.2:

Variables: ID CA CB L2 I L1 L3
IH : forall K ID CA KA CB KB,
       good_clause_list K -&gt; select (ID, CA) KA K * -&gt; select (ID, CB) KB K -&gt; KA = KB
GCL : good_clause_list (I::L2)
SA : select (ID, CA) L1 L2 *
SB : select (ID, CB) L3 L2
============================
 I::L1 = I::L3
</pre>
<pre class="code extensibella"id="172">
 &lt; <b>apply good_clause_list_drop to GCL.</b>

Subgoal 2.2:

Variables: ID CA CB L2 I L1 L3
IH : forall K ID CA KA CB KB,
       good_clause_list K -&gt; select (ID, CA) KA K * -&gt; select (ID, CB) KB K -&gt; KA = KB
GCL : good_clause_list (I::L2)
SA : select (ID, CA) L1 L2 *
SB : select (ID, CB) L3 L2
H1 : good_clause_list L2
============================
 I::L1 = I::L3
</pre>
<pre class="code extensibella"id="173">
 &lt; <b>apply IH to _ SA SB.</b>

Subgoal 2.2:

Variables: ID CA CB L2 I L3
IH : forall K ID CA KA CB KB,
       good_clause_list K -&gt; select (ID, CA) KA K * -&gt; select (ID, CB) KB K -&gt; KA = KB
GCL : good_clause_list (I::L2)
SA : select (ID, CA) L3 L2 *
SB : select (ID, CB) L3 L2
H1 : good_clause_list L2
============================
 I::L3 = I::L3
</pre>
<pre class="code extensibella"id="174">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="175">
 &lt; <b>Theorem values_is :
     forall K V,
       is_list (is_pair is_integer is_clause) K -&gt; values K V -&gt; is_list is_clause V.</b>

============================
 forall K V,
   is_list (is_pair is_integer is_clause) K -&gt; values K V -&gt; is_list is_clause V
</pre>
<pre class="code extensibella"id="176">
 &lt; <b>induction on 2.</b>

IH : forall K V,
       is_list (is_pair is_integer is_clause) K -&gt; values K V * -&gt; is_list is_clause V
============================
 forall K V,
   is_list (is_pair is_integer is_clause) K -&gt; values K V @ -&gt; is_list is_clause V
</pre>
<pre class="code extensibella"id="177">
 &lt; <b>intros IsK V.</b>

Variables: K V
IH : forall K V,
       is_list (is_pair is_integer is_clause) K -&gt; values K V * -&gt; is_list is_clause V
IsK : is_list (is_pair is_integer is_clause) K
V : values K V @
============================
 is_list is_clause V
</pre>
<pre class="code extensibella"id="178">
 &lt; <b>V: case V.</b>

Subgoal 1:

IH : forall K V,
       is_list (is_pair is_integer is_clause) K -&gt; values K V * -&gt; is_list is_clause V
IsK : is_list (is_pair is_integer is_clause) []
============================
 is_list is_clause []
</pre>
<pre class="code extensibella"id="179">
 &lt; <b>search.</b>

Subgoal 2:

Variables: VRest B Rest A
IH : forall K V,
       is_list (is_pair is_integer is_clause) K -&gt; values K V * -&gt; is_list is_clause V
IsK : is_list (is_pair is_integer is_clause) ((A, B)::Rest)
V : values Rest VRest *
============================
 is_list is_clause (B::VRest)
</pre>
<pre class="code extensibella"id="180">
 &lt; <b>Is: case IsK.</b>

Subgoal 2:

Variables: VRest B Rest A
IH : forall K V,
       is_list (is_pair is_integer is_clause) K -&gt; values K V * -&gt; is_list is_clause V
V : values Rest VRest *
Is : is_pair is_integer is_clause (A, B)
Is1 : is_list (is_pair is_integer is_clause) Rest
============================
 is_list is_clause (B::VRest)
</pre>
<pre class="code extensibella"id="181">
 &lt; <b>apply IH to Is1 V.</b>

Subgoal 2:

Variables: VRest B Rest A
IH : forall K V,
       is_list (is_pair is_integer is_clause) K -&gt; values K V * -&gt; is_list is_clause V
V : values Rest VRest *
Is : is_pair is_integer is_clause (A, B)
Is1 : is_list (is_pair is_integer is_clause) Rest
H1 : is_list is_clause VRest
============================
 is_list is_clause (B::VRest)
</pre>
<pre class="code extensibella"id="182">
 &lt; <b>case Is.</b>

Subgoal 2:

Variables: VRest B Rest A
IH : forall K V,
       is_list (is_pair is_integer is_clause) K -&gt; values K V * -&gt; is_list is_clause V
V : values Rest VRest *
Is1 : is_list (is_pair is_integer is_clause) Rest
H1 : is_list is_clause VRest
H2 : is_integer A
H3 : is_clause B
============================
 is_list is_clause (B::VRest)
</pre>
<pre class="code extensibella"id="183">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="184">
 &lt; <b>Theorem select_is_clause :
     forall Known KRest IDC,
       is_list is_clause Known -&gt; select IDC KRest Known -&gt; is_list is_clause KRest.</b>

============================
 forall Known KRest IDC,
   is_list is_clause Known -&gt; select IDC KRest Known -&gt; is_list is_clause KRest
</pre>
<pre class="code extensibella"id="185">
 &lt; <b>induction on 2.</b>

IH : forall Known KRest IDC,
       is_list is_clause Known -&gt; select IDC KRest Known * -&gt; is_list is_clause KRest
============================
 forall Known KRest IDC,
   is_list is_clause Known -&gt; select IDC KRest Known @ -&gt; is_list is_clause KRest
</pre>
<pre class="code extensibella"id="186">
 &lt; <b>intros Is Slct.</b>

Variables: Known KRest IDC
IH : forall Known KRest IDC,
       is_list is_clause Known -&gt; select IDC KRest Known * -&gt; is_list is_clause KRest
Is : is_list is_clause Known
Slct : select IDC KRest Known @
============================
 is_list is_clause KRest
</pre>
<pre class="code extensibella"id="187">
 &lt; <b>Slct: case Slct.</b>

Subgoal 1:

Variables: KRest IDC
IH : forall Known KRest IDC,
       is_list is_clause Known -&gt; select IDC KRest Known * -&gt; is_list is_clause KRest
Is : is_list is_clause (IDC::KRest)
============================
 is_list is_clause KRest
</pre>
<pre class="code extensibella"id="188">
 &lt; <b>case Is.</b>

Subgoal 1:

Variables: KRest IDC
IH : forall Known KRest IDC,
       is_list is_clause Known -&gt; select IDC KRest Known * -&gt; is_list is_clause KRest
H1 : is_clause IDC
H2 : is_list is_clause KRest
============================
 is_list is_clause KRest
</pre>
<pre class="code extensibella"id="189">
 &lt; <b>search.</b>

Subgoal 2:

Variables: IDC L2 I L1
IH : forall Known KRest IDC,
       is_list is_clause Known -&gt; select IDC KRest Known * -&gt; is_list is_clause KRest
Is : is_list is_clause (I::L2)
Slct : select IDC L1 L2 *
============================
 is_list is_clause (I::L1)
</pre>
<pre class="code extensibella"id="190">
 &lt; <b>Is: case Is.</b>

Subgoal 2:

Variables: IDC L2 I L1
IH : forall Known KRest IDC,
       is_list is_clause Known -&gt; select IDC KRest Known * -&gt; is_list is_clause KRest
Slct : select IDC L1 L2 *
Is : is_clause I
Is1 : is_list is_clause L2
============================
 is_list is_clause (I::L1)
</pre>
<pre class="code extensibella"id="191">
 &lt; <b>apply IH to _ Slct.</b>

Subgoal 2:

Variables: IDC L2 I L1
IH : forall Known KRest IDC,
       is_list is_clause Known -&gt; select IDC KRest Known * -&gt; is_list is_clause KRest
Slct : select IDC L1 L2 *
Is : is_clause I
Is1 : is_list is_clause L2
H1 : is_list is_clause L1
============================
 is_list is_clause (I::L1)
</pre>
<pre class="code extensibella"id="192">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="193">
 &lt; <b>Theorem mem_is_clause :
     forall Known C, is_list is_clause Known -&gt; mem C Known -&gt; is_clause C.</b>

============================
 forall Known C, is_list is_clause Known -&gt; mem C Known -&gt; is_clause C
</pre>
<pre class="code extensibella"id="194">
 &lt; <b>induction on 2.</b>

IH : forall Known C, is_list is_clause Known -&gt; mem C Known * -&gt; is_clause C
============================
 forall Known C, is_list is_clause Known -&gt; mem C Known @ -&gt; is_clause C
</pre>
<pre class="code extensibella"id="195">
 &lt; <b>intros Is Mem.</b>

Variables: Known C
IH : forall Known C, is_list is_clause Known -&gt; mem C Known * -&gt; is_clause C
Is : is_list is_clause Known
Mem : mem C Known @
============================
 is_clause C
</pre>
<pre class="code extensibella"id="196">
 &lt; <b>Mem: case Mem.</b>

Subgoal 1:

Variables: C Rest
IH : forall Known C, is_list is_clause Known -&gt; mem C Known * -&gt; is_clause C
Is : is_list is_clause (C::Rest)
============================
 is_clause C
</pre>
<pre class="code extensibella"id="197">
 &lt; <b>Is: case Is.</b>

Subgoal 1:

Variables: C Rest
IH : forall Known C, is_list is_clause Known -&gt; mem C Known * -&gt; is_clause C
Is : is_clause C
Is1 : is_list is_clause Rest
============================
 is_clause C
</pre>
<pre class="code extensibella"id="198">
 &lt; <b>search.</b>

Subgoal 2:

Variables: C Rest I
IH : forall Known C, is_list is_clause Known -&gt; mem C Known * -&gt; is_clause C
Is : is_list is_clause (I::Rest)
Mem : mem C Rest *
============================
 is_clause C
</pre>
<pre class="code extensibella"id="199">
 &lt; <b>Is: case Is.</b>

Subgoal 2:

Variables: C Rest I
IH : forall Known C, is_list is_clause Known -&gt; mem C Known * -&gt; is_clause C
Mem : mem C Rest *
Is : is_clause I
Is1 : is_list is_clause Rest
============================
 is_clause C
</pre>
<pre class="code extensibella"id="200">
 &lt; <b>apply IH to _ Mem.</b>

Subgoal 2:

Variables: C Rest I
IH : forall Known C, is_list is_clause Known -&gt; mem C Known * -&gt; is_clause C
Mem : mem C Rest *
Is : is_clause I
Is1 : is_list is_clause Rest
H1 : is_clause C
============================
 is_clause C
</pre>
<pre class="code extensibella"id="201">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="202">
 &lt; <b>Theorem is_count_exists_clause :
     forall L C, is_list is_clause L -&gt; is_clause C -&gt; exists N, count C L N.</b>

============================
 forall L C, is_list is_clause L -&gt; is_clause C -&gt; exists N, count C L N
</pre>
<pre class="code extensibella"id="203">
 &lt; <b>induction on 1.</b>

IH : forall L C, is_list is_clause L * -&gt; is_clause C -&gt; exists N, count C L N
============================
 forall L C, is_list is_clause L @ -&gt; is_clause C -&gt; exists N, count C L N
</pre>
<pre class="code extensibella"id="204">
 &lt; <b>intros IsL IsC.</b>

Variables: L C
IH : forall L C, is_list is_clause L * -&gt; is_clause C -&gt; exists N, count C L N
IsL : is_list is_clause L @
IsC : is_clause C
============================
 exists N, count C L N
</pre>
<pre class="code extensibella"id="205">
 &lt; <b>Is: case IsL.</b>

Subgoal 1:

Variables: C
IH : forall L C, is_list is_clause L * -&gt; is_clause C -&gt; exists N, count C L N
IsC : is_clause C
============================
 exists N, count C [] N
</pre>
<pre class="code extensibella"id="206">
 &lt; <b>search.</b>

Subgoal 2:

Variables: C T H
IH : forall L C, is_list is_clause L * -&gt; is_clause C -&gt; exists N, count C L N
IsC : is_clause C
Is : is_clause H
Is1 : is_list is_clause T *
============================
 exists N, count C (H::T) N
</pre>
<pre class="code extensibella"id="207">
 &lt; <b>Or: apply is_clause_eq_or_not to IsC Is.</b>

Subgoal 2:

Variables: C T H
IH : forall L C, is_list is_clause L * -&gt; is_clause C -&gt; exists N, count C L N
IsC : is_clause C
Is : is_clause H
Is1 : is_list is_clause T *
Or : C = H \/ (C = H -&gt; false)
============================
 exists N, count C (H::T) N
</pre>
<pre class="code extensibella"id="208">
 &lt; <b>C: apply IH to Is1 IsC.</b>

Subgoal 2:

Variables: C T H N
IH : forall L C, is_list is_clause L * -&gt; is_clause C -&gt; exists N, count C L N
IsC : is_clause C
Is : is_clause H
Is1 : is_list is_clause T *
Or : C = H \/ (C = H -&gt; false)
C : count C T N
============================
 exists N, count C (H::T) N
</pre>
<pre class="code extensibella"id="209">
 &lt; <b>Eq: case Or.</b>

Subgoal 2.1:

Variables: T H N
IH : forall L C, is_list is_clause L * -&gt; is_clause C -&gt; exists N, count C L N
IsC : is_clause H
Is : is_clause H
Is1 : is_list is_clause T *
C : count H T N
============================
 exists N, count H (H::T) N
</pre>
<pre class="code extensibella"id="210">
 &lt; <b>IsN: apply count_is_integer to C.</b>

Subgoal 2.1:

Variables: T H N
IH : forall L C, is_list is_clause L * -&gt; is_clause C -&gt; exists N, count C L N
IsC : is_clause H
Is : is_clause H
Is1 : is_list is_clause T *
C : count H T N
IsN : is_integer N
============================
 exists N, count H (H::T) N
</pre>
<pre class="code extensibella"id="211">
 &lt; <b>apply plus_integer_total to _ IsN with
     N1 = 1.</b>

Subgoal 2.1:

Variables: T H N N3
IH : forall L C, is_list is_clause L * -&gt; is_clause C -&gt; exists N, count C L N
IsC : is_clause H
Is : is_clause H
Is1 : is_list is_clause T *
C : count H T N
IsN : is_integer N
H1 : 1 + N = N3
============================
 exists N, count H (H::T) N
</pre>
<pre class="code extensibella"id="212">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: C T H N
IH : forall L C, is_list is_clause L * -&gt; is_clause C -&gt; exists N, count C L N
IsC : is_clause C
Is : is_clause H
Is1 : is_list is_clause T *
C : count C T N
Eq : C = H -&gt; false
============================
 exists N, count C (H::T) N
</pre>
<pre class="code extensibella"id="213">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="214">
 &lt; <b>Theorem counts_drop_head  [A] :
     forall (H : A) T X N N', count X (H::T) N -&gt; count X T N' -&gt; N &gt;= N'.</b>

============================
 forall H T X N N', count X (H::T) N -&gt; count X T N' -&gt; N &gt;= N'
</pre>
<pre class="code extensibella"id="215">
 &lt; <b>intros C CT.</b>

Variables: H T X N N'
C : count X (H::T) N
CT : count X T N'
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="216">
 &lt; <b>C: case C.</b>

Subgoal 1:

Variables: H T N N' N1
CT : count H T N'
C : count H T N1
C1 : 1 + N1 = N
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="217">
 &lt; <b>apply count_unique to C CT.</b>

Subgoal 1:

Variables: H T N N'
CT : count H T N'
C : count H T N'
C1 : 1 + N' = N
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="218">
 &lt; <b>apply count_is_integer to C.</b>

Subgoal 1:

Variables: H T N N'
CT : count H T N'
C : count H T N'
C1 : 1 + N' = N
H1 : is_integer N'
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="219">
 &lt; <b>L: apply lt_plus_one to C1 _.</b>

Subgoal 1:

Variables: H T N N'
CT : count H T N'
C : count H T N'
C1 : 1 + N' = N
H1 : is_integer N'
L : N' &lt; N
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="220">
 &lt; <b>apply less_integer_lesseq to L.</b>

Subgoal 1:

Variables: H T N N'
CT : count H T N'
C : count H T N'
C1 : 1 + N' = N
H1 : is_integer N'
L : N' &lt; N
H2 : N' &lt;= N
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="221">
 &lt; <b>search.</b>

Subgoal 2:

Variables: H T X N N'
CT : count X T N'
C : X = H -&gt; false
C1 : count X T N
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="222">
 &lt; <b>apply count_unique to CT C1.</b>

Subgoal 2:

Variables: H T X N
CT : count X T N
C : X = H -&gt; false
C1 : count X T N
============================
 N &gt;= N
</pre>
<pre class="code extensibella"id="223">
 &lt; <b>apply count_is_integer to CT.</b>

Subgoal 2:

Variables: H T X N
CT : count X T N
C : X = H -&gt; false
C1 : count X T N
H1 : is_integer N
============================
 N &gt;= N
</pre>
<pre class="code extensibella"id="224">
 &lt; <b>backchain is_integer_greatereq.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="225">
 &lt; <b>Theorem counts_subset :
     forall A B,
       is_list is_clause A -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B.</b>

============================
 forall A B,
   is_list is_clause A -&gt; is_list is_clause B -&gt; (forall C NA NB,
     count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
</pre>
<pre class="code extensibella"id="226">
 &lt; <b>induction on 1.</b>

IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
============================
 forall A B,
   is_list is_clause A @ -&gt; is_list is_clause B -&gt; (forall C NA NB,
     count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
</pre>
<pre class="code extensibella"id="227">
 &lt; <b>intros IsA IsB Counts.</b>

Variables: A B
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsA : is_list is_clause A @
IsB : is_list is_clause B
Counts : forall C NA NB, count C A NA -&gt; count C B NB -&gt; NB &gt;= NA
============================
 subset A B
</pre>
<pre class="code extensibella"id="228">
 &lt; <b>IsA: case IsA.</b>

Subgoal 1:

Variables: B
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C [] NA -&gt; count C B NB -&gt; NB &gt;= NA
============================
 subset [] B
</pre>
<pre class="code extensibella"id="229">
 &lt; <b>search.</b>

Subgoal 2:

Variables: B T H
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
============================
 subset (H::T) B
</pre>
<pre class="code extensibella"id="230">
 &lt; <b>CA: apply is_count_exists_clause to IsA1 IsA.</b>

Subgoal 2:

Variables: B T H N
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
============================
 subset (H::T) B
</pre>
<pre class="code extensibella"id="231">
 &lt; <b>IsN: apply count_is_integer to CA.</b>

Subgoal 2:

Variables: B T H N
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
============================
 subset (H::T) B
</pre>
<pre class="code extensibella"id="232">
 &lt; <b>P: apply plus_integer_total to _ IsN with
        N1 = 1.</b>

Subgoal 2:

Variables: B T H N N3
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
============================
 subset (H::T) B
</pre>
<pre class="code extensibella"id="233">
 &lt; <b>CB: apply is_count_exists_clause to IsB IsA.</b>

Subgoal 2:

Variables: B T H N N3 N1
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
============================
 subset (H::T) B
</pre>
<pre class="code extensibella"id="234">
 &lt; <b>CAA: assert count H (H::T) N3.</b>

Subgoal 2:

Variables: B T H N N3 N1
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
============================
 subset (H::T) B
</pre>
<pre class="code extensibella"id="235">
 &lt; <b>GEq: apply Counts to CAA CB.</b>

Subgoal 2:

Variables: B T H N N3 N1
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
============================
 subset (H::T) B
</pre>
<pre class="code extensibella"id="236">
 &lt; <b>IsN: apply count_is_integer to CA.</b>

Subgoal 2:

Variables: B T H N N3 N1
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
============================
 subset (H::T) B
</pre>
<pre class="code extensibella"id="237">
 &lt; <b>N0: apply count_geq_0 to CA.</b>

Subgoal 2:

Variables: B T H N N3 N1
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
============================
 subset (H::T) B
</pre>
<pre class="code extensibella"id="238">
 &lt; <b>NN3: apply lt_plus_one to P _.</b>

Subgoal 2:

Variables: B T H N N3 N1
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
============================
 subset (H::T) B
</pre>
<pre class="code extensibella"id="239">
 &lt; <b>G: assert N3 &gt; 0.</b>

Subgoal 2.1:

Variables: B T H N N3 N1
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
============================
 N3 &gt; 0
</pre>
<pre class="code extensibella"id="240">
 &lt; <b>Or: apply greatereq_integer_greater_or_eq to N0.</b>

Subgoal 2.1:

Variables: B T H N N3 N1
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
Or : N &gt; 0 \/ N = 0
============================
 N3 &gt; 0
</pre>
<pre class="code extensibella"id="241">
 &lt; <b>G: case Or.</b>

Subgoal 2.1.1:

Variables: B T H N N3 N1
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N &gt; 0
============================
 N3 &gt; 0
</pre>
<pre class="code extensibella"id="242">
 &lt; <b>G2: apply less_integer_flip_greater to NN3.</b>

Subgoal 2.1.1:

Variables: B T H N N3 N1
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N &gt; 0
G2 : N3 &gt; N
============================
 N3 &gt; 0
</pre>
<pre class="code extensibella"id="243">
 &lt; <b>apply greater_integer_transitive to G2 G.</b>

Subgoal 2.1.1:

Variables: B T H N N3 N1
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N &gt; 0
G2 : N3 &gt; N
H1 : N3 &gt; 0
============================
 N3 &gt; 0
</pre>
<pre class="code extensibella"id="244">
 &lt; <b>search.</b>

Subgoal 2.1.2:

Variables: B T H N3 N1
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T 0
IsN : is_integer 0
P : 1 + 0 = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer 0
N0 : 0 &gt;= 0
NN3 : 0 &lt; N3
============================
 N3 &gt; 0
</pre>
<pre class="code extensibella"id="245">
 &lt; <b>apply less_integer_flip_greater to NN3.</b>

Subgoal 2.1.2:

Variables: B T H N3 N1
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T 0
IsN : is_integer 0
P : 1 + 0 = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer 0
N0 : 0 &gt;= 0
NN3 : 0 &lt; N3
H1 : N3 &gt; 0
============================
 N3 &gt; 0
</pre>
<pre class="code extensibella"id="246">
 &lt; <b>search.</b>

Subgoal 2:

Variables: B T H N N3 N1
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N3 &gt; 0
============================
 subset (H::T) B
</pre>
<pre class="code extensibella"id="247">
 &lt; <b>N10: assert N1 &gt; 0.</b>

Subgoal 2.2:

Variables: B T H N N3 N1
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N3 &gt; 0
============================
 N1 &gt; 0
</pre>
<pre class="code extensibella"id="248">
 &lt; <b>Or: apply greatereq_integer_greater_or_eq to GEq.</b>

Subgoal 2.2:

Variables: B T H N N3 N1
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N3 &gt; 0
Or : N1 &gt; N3 \/ N1 = N3
============================
 N1 &gt; 0
</pre>
<pre class="code extensibella"id="249">
 &lt; <b>E: case Or.</b>

Subgoal 2.2.1:

Variables: B T H N N3 N1
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N3 &gt; 0
E : N1 &gt; N3
============================
 N1 &gt; 0
</pre>
<pre class="code extensibella"id="250">
 &lt; <b>apply greater_integer_transitive to E G.</b>

Subgoal 2.2.1:

Variables: B T H N N3 N1
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N3 &gt; 0
E : N1 &gt; N3
H1 : N1 &gt; 0
============================
 N1 &gt; 0
</pre>
<pre class="code extensibella"id="251">
 &lt; <b>search.</b>

Subgoal 2.2.2:

Variables: B T H N N3
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N3
CAA : count H (H::T) N3
GEq : N3 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N3 &gt; 0
============================
 N3 &gt; 0
</pre>
<pre class="code extensibella"id="252">
 &lt; <b>search.</b>

Subgoal 2:

Variables: B T H N N3 N1
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N3 &gt; 0
N10 : N1 &gt; 0
============================
 subset (H::T) B
</pre>
<pre class="code extensibella"id="253">
 &lt; <b>MHB: apply count_mem to CB N10.</b>

Subgoal 2:

Variables: B T H N N3 N1
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N3 &gt; 0
N10 : N1 &gt; 0
MHB : mem H B
============================
 subset (H::T) B
</pre>
<pre class="code extensibella"id="254">
 &lt; <b>assert forall C NA NB,
     count C T NA -&gt; count C B NB -&gt; NB &gt;= NA.</b>

Subgoal 2.3:

Variables: B T H N N3 N1
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N3 &gt; 0
N10 : N1 &gt; 0
MHB : mem H B
============================
 forall C NA NB, count C T NA -&gt; count C B NB -&gt; NB &gt;= NA
</pre>
<pre class="code extensibella"id="255">
 &lt; <b>intros CT CB'.</b>

Subgoal 2.3:

Variables: B T H N N3 N1 C NA NB
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N3 &gt; 0
N10 : N1 &gt; 0
MHB : mem H B
CT : count C T NA
CB' : count C B NB
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="256">
 &lt; <b>GEqNA: apply count_geq_0 to CT.</b>

Subgoal 2.3:

Variables: B T H N N3 N1 C NA NB
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N3 &gt; 0
N10 : N1 &gt; 0
MHB : mem H B
CT : count C T NA
CB' : count C B NB
GEqNA : NA &gt;= 0
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="257">
 &lt; <b>Or: apply greatereq_integer_greater_or_eq to GEqNA.</b>

Subgoal 2.3:

Variables: B T H N N3 N1 C NA NB
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N3 &gt; 0
N10 : N1 &gt; 0
MHB : mem H B
CT : count C T NA
CB' : count C B NB
GEqNA : NA &gt;= 0
Or : NA &gt; 0 \/ NA = 0
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="258">
 &lt; <b>E: case Or.</b>

Subgoal 2.3.1:

Variables: B T H N N3 N1 C NA NB
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N3 &gt; 0
N10 : N1 &gt; 0
MHB : mem H B
CT : count C T NA
CB' : count C B NB
GEqNA : NA &gt;= 0
E : NA &gt; 0
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="259">
 &lt; <b>M: apply count_mem to CT E.</b>

Subgoal 2.3.1:

Variables: B T H N N3 N1 C NA NB
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N3 &gt; 0
N10 : N1 &gt; 0
MHB : mem H B
CT : count C T NA
CB' : count C B NB
GEqNA : NA &gt;= 0
E : NA &gt; 0
M : mem C T
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="260">
 &lt; <b>IsC: apply mem_is_clause to _ M.</b>

Subgoal 2.3.1:

Variables: B T H N N3 N1 C NA NB
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N3 &gt; 0
N10 : N1 &gt; 0
MHB : mem H B
CT : count C T NA
CB' : count C B NB
GEqNA : NA &gt;= 0
E : NA &gt; 0
M : mem C T
IsC : is_clause C
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="261">
 &lt; <b>Or: apply is_clause_eq_or_not to IsC IsA.</b>

Subgoal 2.3.1:

Variables: B T H N N3 N1 C NA NB
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N3 &gt; 0
N10 : N1 &gt; 0
MHB : mem H B
CT : count C T NA
CB' : count C B NB
GEqNA : NA &gt;= 0
E : NA &gt; 0
M : mem C T
IsC : is_clause C
Or : C = H \/ (C = H -&gt; false)
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="262">
 &lt; <b>Eq: case Or.</b>

Subgoal 2.3.1.1:

Variables: B T H N N3 N1 NA NB
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N3 &gt; 0
N10 : N1 &gt; 0
MHB : mem H B
CT : count H T NA
CB' : count H B NB
GEqNA : NA &gt;= 0
E : NA &gt; 0
M : mem H T
IsC : is_clause H
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="263">
 &lt; <b>apply count_unique to CA CT.</b>

Subgoal 2.3.1.1:

Variables: B T H N3 N1 NA NB
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T NA
IsN : is_integer NA
P : 1 + NA = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer NA
N0 : NA &gt;= 0
NN3 : NA &lt; N3
G : N3 &gt; 0
N10 : N1 &gt; 0
MHB : mem H B
CT : count H T NA
CB' : count H B NB
GEqNA : NA &gt;= 0
E : NA &gt; 0
M : mem H T
IsC : is_clause H
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="264">
 &lt; <b>apply count_unique to CB CB'.</b>

Subgoal 2.3.1.1:

Variables: B T H N3 NA NB
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T NA
IsN : is_integer NA
P : 1 + NA = N3
CB : count H B NB
CAA : count H (H::T) N3
GEq : NB &gt;= N3
IsN1 : is_integer NA
N0 : NA &gt;= 0
NN3 : NA &lt; N3
G : N3 &gt; 0
N10 : NB &gt; 0
MHB : mem H B
CT : count H T NA
CB' : count H B NB
GEqNA : NA &gt;= 0
E : NA &gt; 0
M : mem H T
IsC : is_clause H
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="265">
 &lt; <b>Or: apply greatereq_integer_greater_or_eq to GEq.</b>

Subgoal 2.3.1.1:

Variables: B T H N3 NA NB
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T NA
IsN : is_integer NA
P : 1 + NA = N3
CB : count H B NB
CAA : count H (H::T) N3
GEq : NB &gt;= N3
IsN1 : is_integer NA
N0 : NA &gt;= 0
NN3 : NA &lt; N3
G : N3 &gt; 0
N10 : NB &gt; 0
MHB : mem H B
CT : count H T NA
CB' : count H B NB
GEqNA : NA &gt;= 0
E : NA &gt; 0
M : mem H T
IsC : is_clause H
Or : NB &gt; N3 \/ NB = N3
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="266">
 &lt; <b>C: case Or.</b>

Subgoal 2.3.1.1.1:

Variables: B T H N3 NA NB
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T NA
IsN : is_integer NA
P : 1 + NA = N3
CB : count H B NB
CAA : count H (H::T) N3
GEq : NB &gt;= N3
IsN1 : is_integer NA
N0 : NA &gt;= 0
NN3 : NA &lt; N3
G : N3 &gt; 0
N10 : NB &gt; 0
MHB : mem H B
CT : count H T NA
CB' : count H B NB
GEqNA : NA &gt;= 0
E : NA &gt; 0
M : mem H T
IsC : is_clause H
C : NB &gt; N3
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="267">
 &lt; <b>L: apply greater_integer_flip_less to C.</b>

Subgoal 2.3.1.1.1:

Variables: B T H N3 NA NB
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T NA
IsN : is_integer NA
P : 1 + NA = N3
CB : count H B NB
CAA : count H (H::T) N3
GEq : NB &gt;= N3
IsN1 : is_integer NA
N0 : NA &gt;= 0
NN3 : NA &lt; N3
G : N3 &gt; 0
N10 : NB &gt; 0
MHB : mem H B
CT : count H T NA
CB' : count H B NB
GEqNA : NA &gt;= 0
E : NA &gt; 0
M : mem H T
IsC : is_clause H
C : NB &gt; N3
L : N3 &lt; NB
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="268">
 &lt; <b>L': apply less_integer_transitive to NN3 L.</b>

Subgoal 2.3.1.1.1:

Variables: B T H N3 NA NB
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T NA
IsN : is_integer NA
P : 1 + NA = N3
CB : count H B NB
CAA : count H (H::T) N3
GEq : NB &gt;= N3
IsN1 : is_integer NA
N0 : NA &gt;= 0
NN3 : NA &lt; N3
G : N3 &gt; 0
N10 : NB &gt; 0
MHB : mem H B
CT : count H T NA
CB' : count H B NB
GEqNA : NA &gt;= 0
E : NA &gt; 0
M : mem H T
IsC : is_clause H
C : NB &gt; N3
L : N3 &lt; NB
L' : NA &lt; NB
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="269">
 &lt; <b>apply less_integer_lesseq to L'.</b>

Subgoal 2.3.1.1.1:

Variables: B T H N3 NA NB
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T NA
IsN : is_integer NA
P : 1 + NA = N3
CB : count H B NB
CAA : count H (H::T) N3
GEq : NB &gt;= N3
IsN1 : is_integer NA
N0 : NA &gt;= 0
NN3 : NA &lt; N3
G : N3 &gt; 0
N10 : NB &gt; 0
MHB : mem H B
CT : count H T NA
CB' : count H B NB
GEqNA : NA &gt;= 0
E : NA &gt; 0
M : mem H T
IsC : is_clause H
C : NB &gt; N3
L : N3 &lt; NB
L' : NA &lt; NB
H1 : NA &lt;= NB
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="270">
 &lt; <b>search.</b>

Subgoal 2.3.1.1.2:

Variables: B T H N3 NA
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T NA
IsN : is_integer NA
P : 1 + NA = N3
CB : count H B N3
CAA : count H (H::T) N3
GEq : N3 &gt;= N3
IsN1 : is_integer NA
N0 : NA &gt;= 0
NN3 : NA &lt; N3
G : N3 &gt; 0
N10 : N3 &gt; 0
MHB : mem H B
CT : count H T NA
CB' : count H B N3
GEqNA : NA &gt;= 0
E : NA &gt; 0
M : mem H T
IsC : is_clause H
============================
 N3 &gt;= NA
</pre>
<pre class="code extensibella"id="271">
 &lt; <b>apply less_integer_lesseq to NN3.</b>

Subgoal 2.3.1.1.2:

Variables: B T H N3 NA
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T NA
IsN : is_integer NA
P : 1 + NA = N3
CB : count H B N3
CAA : count H (H::T) N3
GEq : N3 &gt;= N3
IsN1 : is_integer NA
N0 : NA &gt;= 0
NN3 : NA &lt; N3
G : N3 &gt; 0
N10 : N3 &gt; 0
MHB : mem H B
CT : count H T NA
CB' : count H B N3
GEqNA : NA &gt;= 0
E : NA &gt; 0
M : mem H T
IsC : is_clause H
H1 : NA &lt;= N3
============================
 N3 &gt;= NA
</pre>
<pre class="code extensibella"id="272">
 &lt; <b>search.</b>

Subgoal 2.3.1.2:

Variables: B T H N N3 N1 C NA NB
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N3 &gt; 0
N10 : N1 &gt; 0
MHB : mem H B
CT : count C T NA
CB' : count C B NB
GEqNA : NA &gt;= 0
E : NA &gt; 0
M : mem C T
IsC : is_clause C
Eq : C = H -&gt; false
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="273">
 &lt; <b>backchain Counts.</b>

Subgoal 2.3.2:

Variables: B T H N N3 N1 C NB
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N3 &gt; 0
N10 : N1 &gt; 0
MHB : mem H B
CT : count C T 0
CB' : count C B NB
GEqNA : 0 &gt;= 0
============================
 NB &gt;= 0
</pre>
<pre class="code extensibella"id="274">
 &lt; <b>apply count_geq_0 to CB'.</b>

Subgoal 2.3.2:

Variables: B T H N N3 N1 C NB
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N3 &gt; 0
N10 : N1 &gt; 0
MHB : mem H B
CT : count C T 0
CB' : count C B NB
GEqNA : 0 &gt;= 0
H1 : NB &gt;= 0
============================
 NB &gt;= 0
</pre>
<pre class="code extensibella"id="275">
 &lt; <b>search.</b>

Subgoal 2:

Variables: B T H N N3 N1
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N3 &gt; 0
N10 : N1 &gt; 0
MHB : mem H B
H1 : forall C NA NB, count C T NA -&gt; count C B NB -&gt; NB &gt;= NA
============================
 subset (H::T) B
</pre>
<pre class="code extensibella"id="276">
 &lt; <b>apply IH to IsA1 IsB _.</b>

Subgoal 2:

Variables: B T H N N3 N1
IH : forall A B,
       is_list is_clause A * -&gt; is_list is_clause B -&gt; (forall C NA NB,
         count C A NA -&gt; count C B NB -&gt; NB &gt;= NA) -&gt; subset A B
IsB : is_list is_clause B
Counts : forall C NA NB, count C (H::T) NA -&gt; count C B NB -&gt; NB &gt;= NA
IsA : is_clause H
IsA1 : is_list is_clause T *
CA : count H T N
IsN : is_integer N
P : 1 + N = N3
CB : count H B N1
CAA : count H (H::T) N3
GEq : N1 &gt;= N3
IsN1 : is_integer N
N0 : N &gt;= 0
NN3 : N &lt; N3
G : N3 &gt; 0
N10 : N1 &gt; 0
MHB : mem H B
H1 : forall C NA NB, count C T NA -&gt; count C B NB -&gt; NB &gt;= NA
H2 : subset T B
============================
 subset (H::T) B
</pre>
<pre class="code extensibella"id="277">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="278">
 &lt; <b>Theorem remove_all_reduce_counts :
     forall K ID KRest V VR X N N',
       remove_all K ID KRest -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt; count X VR N' -&gt;
       N &gt;= N'.</b>

============================
 forall K ID KRest V VR X N N',
   remove_all K ID KRest -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt; count X VR N' -&gt;
   N &gt;= N'
</pre>
<pre class="code extensibella"id="279">
 &lt; <b>induction on 1.</b>

IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
============================
 forall K ID KRest V VR X N N',
   remove_all K ID KRest @ -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt; count X VR N' -&gt;
   N &gt;= N'
</pre>
<pre class="code extensibella"id="280">
 &lt; <b>intros RA VK VKR CV CVR.</b>

Variables: K ID KRest V VR X N N'
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
RA : remove_all K ID KRest @
VK : values K V
VKR : values KRest VR
CV : count X V N
CVR : count X VR N'
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="281">
 &lt; <b>RA: case RA.</b>

Subgoal 1:

Variables: ID V VR X N N'
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
VK : values [] V
VKR : values [] VR
CV : count X V N
CVR : count X VR N'
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="282">
 &lt; <b>case VK.</b>

Subgoal 1:

Variables: ID VR X N N'
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
VKR : values [] VR
CV : count X [] N
CVR : count X VR N'
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="283">
 &lt; <b>case VKR.</b>

Subgoal 1:

Variables: ID X N N'
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
CV : count X [] N
CVR : count X [] N'
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="284">
 &lt; <b>case CV.</b>

Subgoal 1:

Variables: ID X N'
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
CVR : count X [] N'
============================
 0 &gt;= N'
</pre>
<pre class="code extensibella"id="285">
 &lt; <b>case CVR.</b>

Subgoal 1:

Variables: ID X
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
============================
 0 &gt;= 0
</pre>
<pre class="code extensibella"id="286">
 &lt; <b>search.</b>

Subgoal 2:

Variables: ID KRest V VR X N N' IRest C
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
VK : values ((ID, C)::IRest) V
VKR : values KRest VR
CV : count X V N
CVR : count X VR N'
RA : remove_all IRest ID KRest *
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="287">
 &lt; <b>VK: case VK.</b>

Subgoal 2:

Variables: ID KRest VR X N N' IRest C VRest
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
VKR : values KRest VR
CV : count X (C::VRest) N
CVR : count X VR N'
RA : remove_all IRest ID KRest *
VK : values IRest VRest
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="288">
 &lt; <b>CV: case CV.</b>

Subgoal 2.1:

Variables: ID KRest VR N N' IRest C VRest N1
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
VKR : values KRest VR
CVR : count C VR N'
RA : remove_all IRest ID KRest *
VK : values IRest VRest
CV : count C VRest N1
CV1 : 1 + N1 = N
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="289">
 &lt; <b>GEq: apply IH to RA VK VKR CV CVR.</b>

Subgoal 2.1:

Variables: ID KRest VR N N' IRest C VRest N1
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
VKR : values KRest VR
CVR : count C VR N'
RA : remove_all IRest ID KRest *
VK : values IRest VRest
CV : count C VRest N1
CV1 : 1 + N1 = N
GEq : N1 &gt;= N'
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="290">
 &lt; <b>apply count_is_integer to CV.</b>

Subgoal 2.1:

Variables: ID KRest VR N N' IRest C VRest N1
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
VKR : values KRest VR
CVR : count C VR N'
RA : remove_all IRest ID KRest *
VK : values IRest VRest
CV : count C VRest N1
CV1 : 1 + N1 = N
GEq : N1 &gt;= N'
H1 : is_integer N1
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="291">
 &lt; <b>L: apply lt_plus_one to CV1 _.</b>

Subgoal 2.1:

Variables: ID KRest VR N N' IRest C VRest N1
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
VKR : values KRest VR
CVR : count C VR N'
RA : remove_all IRest ID KRest *
VK : values IRest VRest
CV : count C VRest N1
CV1 : 1 + N1 = N
GEq : N1 &gt;= N'
H1 : is_integer N1
L : N1 &lt; N
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="292">
 &lt; <b>Or: apply greatereq_integer_greater_or_eq to GEq.</b>

Subgoal 2.1:

Variables: ID KRest VR N N' IRest C VRest N1
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
VKR : values KRest VR
CVR : count C VR N'
RA : remove_all IRest ID KRest *
VK : values IRest VRest
CV : count C VRest N1
CV1 : 1 + N1 = N
GEq : N1 &gt;= N'
H1 : is_integer N1
L : N1 &lt; N
Or : N1 &gt; N' \/ N1 = N'
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="293">
 &lt; <b>E: case Or.</b>

Subgoal 2.1.1:

Variables: ID KRest VR N N' IRest C VRest N1
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
VKR : values KRest VR
CVR : count C VR N'
RA : remove_all IRest ID KRest *
VK : values IRest VRest
CV : count C VRest N1
CV1 : 1 + N1 = N
GEq : N1 &gt;= N'
H1 : is_integer N1
L : N1 &lt; N
E : N1 &gt; N'
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="294">
 &lt; <b>L': apply greater_integer_flip_less to E.</b>

Subgoal 2.1.1:

Variables: ID KRest VR N N' IRest C VRest N1
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
VKR : values KRest VR
CVR : count C VR N'
RA : remove_all IRest ID KRest *
VK : values IRest VRest
CV : count C VRest N1
CV1 : 1 + N1 = N
GEq : N1 &gt;= N'
H1 : is_integer N1
L : N1 &lt; N
E : N1 &gt; N'
L' : N' &lt; N1
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="295">
 &lt; <b>L2: apply less_integer_transitive to L' L.</b>

Subgoal 2.1.1:

Variables: ID KRest VR N N' IRest C VRest N1
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
VKR : values KRest VR
CVR : count C VR N'
RA : remove_all IRest ID KRest *
VK : values IRest VRest
CV : count C VRest N1
CV1 : 1 + N1 = N
GEq : N1 &gt;= N'
H1 : is_integer N1
L : N1 &lt; N
E : N1 &gt; N'
L' : N' &lt; N1
L2 : N' &lt; N
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="296">
 &lt; <b>apply less_integer_lesseq to L2.</b>

Subgoal 2.1.1:

Variables: ID KRest VR N N' IRest C VRest N1
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
VKR : values KRest VR
CVR : count C VR N'
RA : remove_all IRest ID KRest *
VK : values IRest VRest
CV : count C VRest N1
CV1 : 1 + N1 = N
GEq : N1 &gt;= N'
H1 : is_integer N1
L : N1 &lt; N
E : N1 &gt; N'
L' : N' &lt; N1
L2 : N' &lt; N
H2 : N' &lt;= N
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="297">
 &lt; <b>search.</b>

Subgoal 2.1.2:

Variables: ID KRest VR N N' IRest C VRest
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
VKR : values KRest VR
CVR : count C VR N'
RA : remove_all IRest ID KRest *
VK : values IRest VRest
CV : count C VRest N'
CV1 : 1 + N' = N
GEq : N' &gt;= N'
H1 : is_integer N'
L : N' &lt; N
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="298">
 &lt; <b>apply less_integer_lesseq to L.</b>

Subgoal 2.1.2:

Variables: ID KRest VR N N' IRest C VRest
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
VKR : values KRest VR
CVR : count C VR N'
RA : remove_all IRest ID KRest *
VK : values IRest VRest
CV : count C VRest N'
CV1 : 1 + N' = N
GEq : N' &gt;= N'
H1 : is_integer N'
L : N' &lt; N
H2 : N' &lt;= N
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="299">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: ID KRest VR X N N' IRest C VRest
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
VKR : values KRest VR
CVR : count X VR N'
RA : remove_all IRest ID KRest *
VK : values IRest VRest
CV : X = C -&gt; false
CV1 : count X VRest N
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="300">
 &lt; <b>apply IH to RA VK VKR CV1 CVR.</b>

Subgoal 2.2:

Variables: ID KRest VR X N N' IRest C VRest
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
VKR : values KRest VR
CVR : count X VR N'
RA : remove_all IRest ID KRest *
VK : values IRest VRest
CV : X = C -&gt; false
CV1 : count X VRest N
H1 : N &gt;= N'
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="301">
 &lt; <b>search.</b>

Subgoal 3:

Variables: ID V VR X N N' Rest C A IRest
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
VK : values ((A, C)::IRest) V
VKR : values ((A, C)::Rest) VR
CV : count X V N
CVR : count X VR N'
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="302">
 &lt; <b>VK: case VK.</b>

Subgoal 3:

Variables: ID VR X N N' Rest C A IRest VRest
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
VKR : values ((A, C)::Rest) VR
CV : count X (C::VRest) N
CVR : count X VR N'
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
VK : values IRest VRest
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="303">
 &lt; <b>VKR: case VKR.</b>

Subgoal 3:

Variables: ID X N N' Rest C A IRest VRest VRest1
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
CV : count X (C::VRest) N
CVR : count X (C::VRest1) N'
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
VK : values IRest VRest
VKR : values Rest VRest1
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="304">
 &lt; <b>CV: case CV.</b>

Subgoal 3.1:

Variables: ID N N' Rest C A IRest VRest VRest1 N1
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
CVR : count C (C::VRest1) N'
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
VK : values IRest VRest
VKR : values Rest VRest1
CV : count C VRest N1
CV1 : 1 + N1 = N
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="305">
 &lt; <b>CVR: case CVR.</b>

Subgoal 3.1.1:

Variables: ID N N' Rest C A IRest VRest VRest1 N1 N2
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
VK : values IRest VRest
VKR : values Rest VRest1
CV : count C VRest N1
CV1 : 1 + N1 = N
CVR : count C VRest1 N2
CVR1 : 1 + N2 = N'
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="306">
 &lt; <b>GEq: apply IH to RA1 VK VKR CV CVR.</b>

Subgoal 3.1.1:

Variables: ID N N' Rest C A IRest VRest VRest1 N1 N2
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
VK : values IRest VRest
VKR : values Rest VRest1
CV : count C VRest N1
CV1 : 1 + N1 = N
CVR : count C VRest1 N2
CVR1 : 1 + N2 = N'
GEq : N1 &gt;= N2
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="307">
 &lt; <b>Or: apply greatereq_integer_greater_or_eq to GEq.</b>

Subgoal 3.1.1:

Variables: ID N N' Rest C A IRest VRest VRest1 N1 N2
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
VK : values IRest VRest
VKR : values Rest VRest1
CV : count C VRest N1
CV1 : 1 + N1 = N
CVR : count C VRest1 N2
CVR1 : 1 + N2 = N'
GEq : N1 &gt;= N2
Or : N1 &gt; N2 \/ N1 = N2
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="308">
 &lt; <b>E: case Or.</b>

Subgoal 3.1.1.1:

Variables: ID N N' Rest C A IRest VRest VRest1 N1 N2
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
VK : values IRest VRest
VKR : values Rest VRest1
CV : count C VRest N1
CV1 : 1 + N1 = N
CVR : count C VRest1 N2
CVR1 : 1 + N2 = N'
GEq : N1 &gt;= N2
E : N1 &gt; N2
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="309">
 &lt; <b>L: apply greater_integer_flip_less to E.</b>

Subgoal 3.1.1.1:

Variables: ID N N' Rest C A IRest VRest VRest1 N1 N2
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
VK : values IRest VRest
VKR : values Rest VRest1
CV : count C VRest N1
CV1 : 1 + N1 = N
CVR : count C VRest1 N2
CVR1 : 1 + N2 = N'
GEq : N1 &gt;= N2
E : N1 &gt; N2
L : N2 &lt; N1
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="310">
 &lt; <b>L': apply less_sums to CVR1 CV1 _ _.</b>

Subgoal 3.1.1.1:

Variables: ID N N' Rest C A IRest VRest VRest1 N1 N2
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
VK : values IRest VRest
VKR : values Rest VRest1
CV : count C VRest N1
CV1 : 1 + N1 = N
CVR : count C VRest1 N2
CVR1 : 1 + N2 = N'
GEq : N1 &gt;= N2
E : N1 &gt; N2
L : N2 &lt; N1
L' : N' &lt; N
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="311">
 &lt; <b>apply less_integer_lesseq to L'.</b>

Subgoal 3.1.1.1:

Variables: ID N N' Rest C A IRest VRest VRest1 N1 N2
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
VK : values IRest VRest
VKR : values Rest VRest1
CV : count C VRest N1
CV1 : 1 + N1 = N
CVR : count C VRest1 N2
CVR1 : 1 + N2 = N'
GEq : N1 &gt;= N2
E : N1 &gt; N2
L : N2 &lt; N1
L' : N' &lt; N
H1 : N' &lt;= N
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="312">
 &lt; <b>search.</b>

Subgoal 3.1.1.2:

Variables: ID N N' Rest C A IRest VRest VRest1 N2
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
VK : values IRest VRest
VKR : values Rest VRest1
CV : count C VRest N2
CV1 : 1 + N2 = N
CVR : count C VRest1 N2
CVR1 : 1 + N2 = N'
GEq : N2 &gt;= N2
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="313">
 &lt; <b>apply plus_integer_unique to CV1 CVR1.</b>

Subgoal 3.1.1.2:

Variables: ID N' Rest C A IRest VRest VRest1 N2
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
VK : values IRest VRest
VKR : values Rest VRest1
CV : count C VRest N2
CV1 : 1 + N2 = N'
CVR : count C VRest1 N2
CVR1 : 1 + N2 = N'
GEq : N2 &gt;= N2
============================
 N' &gt;= N'
</pre>
<pre class="code extensibella"id="314">
 &lt; <b>apply count_is_integer to CV.</b>

Subgoal 3.1.1.2:

Variables: ID N' Rest C A IRest VRest VRest1 N2
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
VK : values IRest VRest
VKR : values Rest VRest1
CV : count C VRest N2
CV1 : 1 + N2 = N'
CVR : count C VRest1 N2
CVR1 : 1 + N2 = N'
GEq : N2 &gt;= N2
H1 : is_integer N2
============================
 N' &gt;= N'
</pre>
<pre class="code extensibella"id="315">
 &lt; <b>apply plus_integer_is_integer to _ _ CV1.</b>

Subgoal 3.1.1.2:

Variables: ID N' Rest C A IRest VRest VRest1 N2
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
VK : values IRest VRest
VKR : values Rest VRest1
CV : count C VRest N2
CV1 : 1 + N2 = N'
CVR : count C VRest1 N2
CVR1 : 1 + N2 = N'
GEq : N2 &gt;= N2
H1 : is_integer N2
H2 : is_integer N'
============================
 N' &gt;= N'
</pre>
<pre class="code extensibella"id="316">
 &lt; <b>backchain is_integer_greatereq.</b>

Subgoal 3.1.2:

Variables: ID N N' Rest C A IRest VRest VRest1 N1
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
VK : values IRest VRest
VKR : values Rest VRest1
CV : count C VRest N1
CV1 : 1 + N1 = N
CVR : C = C -&gt; false
CVR1 : count C VRest1 N'
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="317">
 &lt; <b>apply CVR to _.</b>

Subgoal 3.2:

Variables: ID X N N' Rest C A IRest VRest VRest1
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
CVR : count X (C::VRest1) N'
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
VK : values IRest VRest
VKR : values Rest VRest1
CV : X = C -&gt; false
CV1 : count X VRest N
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="318">
 &lt; <b>CVR: case CVR.</b>

Subgoal 3.2.1:

Variables: ID N N' Rest C A IRest VRest VRest1 N1
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
VK : values IRest VRest
VKR : values Rest VRest1
CV : C = C -&gt; false
CV1 : count C VRest N
CVR : count C VRest1 N1
CVR1 : 1 + N1 = N'
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="319">
 &lt; <b>apply CV to _.</b>

Subgoal 3.2.2:

Variables: ID X N N' Rest C A IRest VRest VRest1
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
VK : values IRest VRest
VKR : values Rest VRest1
CV : X = C -&gt; false
CV1 : count X VRest N
CVR : X = C -&gt; false
CVR1 : count X VRest1 N'
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="320">
 &lt; <b>apply IH to RA1 VK VKR CV1 CVR1.</b>

Subgoal 3.2.2:

Variables: ID X N N' Rest C A IRest VRest VRest1
IH : forall K ID KRest V VR X N N',
       remove_all K ID KRest * -&gt; values K V -&gt; values KRest VR -&gt; count X V N -&gt;
       count X VR N' -&gt; N &gt;= N'
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
VK : values IRest VRest
VKR : values Rest VRest1
CV : X = C -&gt; false
CV1 : count X VRest N
CVR : X = C -&gt; false
CVR1 : count X VRest1 N'
H1 : N &gt;= N'
============================
 N &gt;= N'
</pre>
<pre class="code extensibella"id="321">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="322">
 &lt; <b>Extensible_Theorem
      toDrat_maintains_proof : forall P D KnownL KnownD V,
         IsKnownL : is_list (is_pair is_integer is_clause) KnownL -&gt;
         IsKnownD : is_list is_clause KnownD -&gt;
         IsP : is_proof P -&gt;
         CP : checkProof KnownL P -&gt;
         GCL : good_clause_list KnownL -&gt;
         TD : toDrat KnownL P D -&gt;
         Vals : values KnownL V -&gt;
         Counts : (forall C NA NB,
           count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt;
         checkDrat KnownD D
      on TD.</b>

Subgoal 1:

Variables: KnownL KnownD V Prf ID
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
IsP : is_proof (emptyLrat ID Prf)
CP : checkProof KnownL (emptyLrat ID Prf)
GCL : good_clause_list KnownL
TD : toDrat KnownL (emptyLrat ID Prf) addDratEmpty @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
============================
 checkDrat KnownD addDratEmpty
</pre>
<pre class="code extensibella"id="323">
 &lt; <b>CP: case CP.</b>

Subgoal 1:

Variables: KnownL KnownD V Prf ID
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
IsP : is_proof (emptyLrat ID Prf)
GCL : good_clause_list KnownL
TD : toDrat KnownL (emptyLrat ID Prf) addDratEmpty @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
CP : rupProof KnownL emptyClause Prf
============================
 checkDrat KnownD addDratEmpty
</pre>
<pre class="code extensibella"id="324">
 &lt; <b>IsV: apply values_is to _ Vals.</b>

Subgoal 1:

Variables: KnownL KnownD V Prf ID
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
IsP : is_proof (emptyLrat ID Prf)
GCL : good_clause_list KnownL
TD : toDrat KnownL (emptyLrat ID Prf) addDratEmpty @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
CP : rupProof KnownL emptyClause Prf
IsV : is_list is_clause V
============================
 checkDrat KnownD addDratEmpty
</pre>
<pre class="code extensibella"id="325">
 &lt; <b>S: apply counts_subset to IsV IsKnownD Counts.</b>

Subgoal 1:

Variables: KnownL KnownD V Prf ID
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
IsP : is_proof (emptyLrat ID Prf)
GCL : good_clause_list KnownL
TD : toDrat KnownL (emptyLrat ID Prf) addDratEmpty @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
CP : rupProof KnownL emptyClause Prf
IsV : is_list is_clause V
S : subset V KnownD
============================
 checkDrat KnownD addDratEmpty
</pre>
<pre class="code extensibella"id="326">
 &lt; <b>D: apply rupProof__drup to CP Vals.</b>

Subgoal 1:

Variables: KnownL KnownD V Prf ID
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
IsP : is_proof (emptyLrat ID Prf)
GCL : good_clause_list KnownL
TD : toDrat KnownL (emptyLrat ID Prf) addDratEmpty @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
CP : rupProof KnownL emptyClause Prf
IsV : is_list is_clause V
S : subset V KnownD
D : drup V emptyClause
============================
 checkDrat KnownD addDratEmpty
</pre>
<pre class="code extensibella"id="327">
 &lt; <b>D': apply drup_subset to D S.</b>

Subgoal 1:

Variables: KnownL KnownD V Prf ID
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
IsP : is_proof (emptyLrat ID Prf)
GCL : good_clause_list KnownL
TD : toDrat KnownL (emptyLrat ID Prf) addDratEmpty @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
CP : rupProof KnownL emptyClause Prf
IsV : is_list is_clause V
S : subset V KnownD
D : drup V emptyClause
D' : drup KnownD emptyClause
============================
 checkDrat KnownD addDratEmpty
</pre>
<pre class="code extensibella"id="328">
 &lt; <b>search.</b>

Subgoal 2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
IsP : is_proof (addLrupProof ID C Prf Rest)
CP : checkProof KnownL (addLrupProof ID C Prf Rest)
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
============================
 checkDrat KnownD (addDratClause C DRest)
</pre>
<pre class="code extensibella"id="329">
 &lt; <b>CP: case CP.</b>

Subgoal 2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID KRest1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
IsP : is_proof (addLrupProof ID C Prf Rest)
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest1
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest1) Rest
============================
 checkDrat KnownD (addDratClause C DRest)
</pre>
<pre class="code extensibella"id="330">
 &lt; <b>Is: case IsP.</b>

Subgoal 2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID KRest1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest1
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest1) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
============================
 checkDrat KnownD (addDratClause C DRest)
</pre>
<pre class="code extensibella"id="331">
 &lt; <b>IsV: apply values_is to _ Vals.</b>

Subgoal 2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID KRest1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest1
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest1) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
============================
 checkDrat KnownD (addDratClause C DRest)
</pre>
<pre class="code extensibella"id="332">
 &lt; <b>S: apply counts_subset to IsV IsKnownD Counts.</b>

Subgoal 2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID KRest1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest1
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest1) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
============================
 checkDrat KnownD (addDratClause C DRest)
</pre>
<pre class="code extensibella"id="333">
 &lt; <b>D: apply rupProof__drup to CP1 Vals.</b>

Subgoal 2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID KRest1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest1
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest1) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
============================
 checkDrat KnownD (addDratClause C DRest)
</pre>
<pre class="code extensibella"id="334">
 &lt; <b>D': apply drup_subset to D S.</b>

Subgoal 2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID KRest1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest1
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest1) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
============================
 checkDrat KnownD (addDratClause C DRest)
</pre>
<pre class="code extensibella"id="335">
 &lt; <b>apply remove_all_unique to CP TD1.</b>

Subgoal 2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
============================
 checkDrat KnownD (addDratClause C DRest)
</pre>
<pre class="code extensibella"id="336">
 &lt; <b>GCL_KR: apply good_clause_list_remove_all_add to _ TD1 with
             C = C.</b>

Subgoal 2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
============================
 checkDrat KnownD (addDratClause C DRest)
</pre>
<pre class="code extensibella"id="337">
 &lt; <b>IsKR: apply remove_all_is to _ TD1.</b>

Subgoal 2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
============================
 checkDrat KnownD (addDratClause C DRest)
</pre>
<pre class="code extensibella"id="338">
 &lt; <b>VKR: apply values_exist to IsKR.</b>

Subgoal 2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
============================
 checkDrat KnownD (addDratClause C DRest)
</pre>
<pre class="code extensibella"id="339">
 &lt; <b>VKR+: assert values ((ID, C)::KRest) (C::V1).</b>

Subgoal 2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
============================
 checkDrat KnownD (addDratClause C DRest)
</pre>
<pre class="code extensibella"id="340">
 &lt; <b>assert forall C1 NA NB,
     count C1 (C::V1) NA -&gt; count C1 (C::KnownD) NB -&gt; NB &gt;= NA.</b>

Subgoal 2.1:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
============================
 forall C1 NA NB, count C1 (C::V1) NA -&gt; count C1 (C::KnownD) NB -&gt; NB &gt;= NA
</pre>
<pre class="code extensibella"id="341">
 &lt; <b>intros CA CB.</b>

Subgoal 2.1:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 C1 NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : count C1 (C::V1) NA
CB : count C1 (C::KnownD) NB
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="342">
 &lt; <b>CA: case CA.</b>

Subgoal 2.1.1:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 NA NB N
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CB : count C (C::KnownD) NB
CA : count C V1 N
CA1 : 1 + N = NA
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="343">
 &lt; <b>CB: case CB.</b>

Subgoal 2.1.1.1:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 NA NB N N1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : count C V1 N
CA1 : 1 + N = NA
CB : count C KnownD N1
CB1 : 1 + N1 = NB
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="344">
 &lt; <b>CV: apply is_count_exists_clause to IsV Is1.</b>

Subgoal 2.1.1.1:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 NA NB N N1 N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : count C V1 N
CA1 : 1 + N = NA
CB : count C KnownD N1
CB1 : 1 + N1 = NB
CV : count C V N2
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="345">
 &lt; <b>GEq: apply Counts to CV CB.</b>

Subgoal 2.1.1.1:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 NA NB N N1 N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : count C V1 N
CA1 : 1 + N = NA
CB : count C KnownD N1
CB1 : 1 + N1 = NB
CV : count C V N2
GEq : N1 &gt;= N2
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="346">
 &lt; <b>GEq': apply remove_all_reduce_counts to TD1 Vals VKR CV CA.</b>

Subgoal 2.1.1.1:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 NA NB N N1 N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : count C V1 N
CA1 : 1 + N = NA
CB : count C KnownD N1
CB1 : 1 + N1 = NB
CV : count C V N2
GEq : N1 &gt;= N2
GEq' : N2 &gt;= N
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="347">
 &lt; <b>GEq'': apply greatereq_integer_transitive to GEq GEq'.</b>

Subgoal 2.1.1.1:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 NA NB N N1 N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : count C V1 N
CA1 : 1 + N = NA
CB : count C KnownD N1
CB1 : 1 + N1 = NB
CV : count C V N2
GEq : N1 &gt;= N2
GEq' : N2 &gt;= N
GEq'' : N1 &gt;= N
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="348">
 &lt; <b>Or: apply greatereq_integer_greater_or_eq to GEq''.</b>

Subgoal 2.1.1.1:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 NA NB N N1 N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : count C V1 N
CA1 : 1 + N = NA
CB : count C KnownD N1
CB1 : 1 + N1 = NB
CV : count C V N2
GEq : N1 &gt;= N2
GEq' : N2 &gt;= N
GEq'' : N1 &gt;= N
Or : N1 &gt; N \/ N1 = N
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="349">
 &lt; <b>E: case Or.</b>

Subgoal 2.1.1.1.1:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 NA NB N N1 N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : count C V1 N
CA1 : 1 + N = NA
CB : count C KnownD N1
CB1 : 1 + N1 = NB
CV : count C V N2
GEq : N1 &gt;= N2
GEq' : N2 &gt;= N
GEq'' : N1 &gt;= N
E : N1 &gt; N
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="350">
 &lt; <b>L: apply greater_integer_flip_less to E.</b>

Subgoal 2.1.1.1.1:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 NA NB N N1 N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : count C V1 N
CA1 : 1 + N = NA
CB : count C KnownD N1
CB1 : 1 + N1 = NB
CV : count C V N2
GEq : N1 &gt;= N2
GEq' : N2 &gt;= N
GEq'' : N1 &gt;= N
E : N1 &gt; N
L : N &lt; N1
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="351">
 &lt; <b>L': apply less_sums to CA1 CB1 _ _.</b>

Subgoal 2.1.1.1.1:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 NA NB N N1 N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : count C V1 N
CA1 : 1 + N = NA
CB : count C KnownD N1
CB1 : 1 + N1 = NB
CV : count C V N2
GEq : N1 &gt;= N2
GEq' : N2 &gt;= N
GEq'' : N1 &gt;= N
E : N1 &gt; N
L : N &lt; N1
L' : NA &lt; NB
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="352">
 &lt; <b>apply less_integer_lesseq to L'.</b>

Subgoal 2.1.1.1.1:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 NA NB N N1 N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : count C V1 N
CA1 : 1 + N = NA
CB : count C KnownD N1
CB1 : 1 + N1 = NB
CV : count C V N2
GEq : N1 &gt;= N2
GEq' : N2 &gt;= N
GEq'' : N1 &gt;= N
E : N1 &gt; N
L : N &lt; N1
L' : NA &lt; NB
H1 : NA &lt;= NB
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="353">
 &lt; <b>search.</b>

Subgoal 2.1.1.1.2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 NA NB N N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : count C V1 N
CA1 : 1 + N = NA
CB : count C KnownD N
CB1 : 1 + N = NB
CV : count C V N2
GEq : N &gt;= N2
GEq' : N2 &gt;= N
GEq'' : N &gt;= N
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="354">
 &lt; <b>apply plus_integer_unique to CA1 CB1.</b>

Subgoal 2.1.1.1.2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 NB N N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : count C V1 N
CA1 : 1 + N = NB
CB : count C KnownD N
CB1 : 1 + N = NB
CV : count C V N2
GEq : N &gt;= N2
GEq' : N2 &gt;= N
GEq'' : N &gt;= N
============================
 NB &gt;= NB
</pre>
<pre class="code extensibella"id="355">
 &lt; <b>apply count_is_integer to CA.</b>

Subgoal 2.1.1.1.2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 NB N N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : count C V1 N
CA1 : 1 + N = NB
CB : count C KnownD N
CB1 : 1 + N = NB
CV : count C V N2
GEq : N &gt;= N2
GEq' : N2 &gt;= N
GEq'' : N &gt;= N
H1 : is_integer N
============================
 NB &gt;= NB
</pre>
<pre class="code extensibella"id="356">
 &lt; <b>apply plus_integer_is_integer to _ _ CB1.</b>

Subgoal 2.1.1.1.2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 NB N N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : count C V1 N
CA1 : 1 + N = NB
CB : count C KnownD N
CB1 : 1 + N = NB
CV : count C V N2
GEq : N &gt;= N2
GEq' : N2 &gt;= N
GEq'' : N &gt;= N
H1 : is_integer N
H2 : is_integer NB
============================
 NB &gt;= NB
</pre>
<pre class="code extensibella"id="357">
 &lt; <b>backchain is_integer_greatereq.</b>

Subgoal 2.1.1.2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 NA NB N
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : count C V1 N
CA1 : 1 + N = NA
CB : C = C -&gt; false
CB1 : count C KnownD NB
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="358">
 &lt; <b>apply CB to _.</b>

Subgoal 2.1.2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 C1 NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CB : count C1 (C::KnownD) NB
CA : C1 = C -&gt; false
CA1 : count C1 V1 NA
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="359">
 &lt; <b>CB: case CB.</b>

Subgoal 2.1.2.1:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 NA NB N
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : C = C -&gt; false
CA1 : count C V1 NA
CB : count C KnownD N
CB1 : 1 + N = NB
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="360">
 &lt; <b>apply CA to _.</b>

Subgoal 2.1.2.2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 C1 NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : C1 = C -&gt; false
CA1 : count C1 V1 NA
CB : C1 = C -&gt; false
CB1 : count C1 KnownD NB
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="361">
 &lt; <b>GEq: apply count_geq_0 to CB1.</b>

Subgoal 2.1.2.2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 C1 NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : C1 = C -&gt; false
CA1 : count C1 V1 NA
CB : C1 = C -&gt; false
CB1 : count C1 KnownD NB
GEq : NB &gt;= 0
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="362">
 &lt; <b>GEq': apply count_geq_0 to CA1.</b>

Subgoal 2.1.2.2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 C1 NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : C1 = C -&gt; false
CA1 : count C1 V1 NA
CB : C1 = C -&gt; false
CB1 : count C1 KnownD NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="363">
 &lt; <b>Or: apply greatereq_integer_greater_or_eq to GEq.</b>

Subgoal 2.1.2.2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 C1 NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : C1 = C -&gt; false
CA1 : count C1 V1 NA
CB : C1 = C -&gt; false
CB1 : count C1 KnownD NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="364">
 &lt; <b>Or': apply greatereq_integer_greater_or_eq to GEq'.</b>

Subgoal 2.1.2.2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 C1 NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : C1 = C -&gt; false
CA1 : count C1 V1 NA
CB : C1 = C -&gt; false
CB1 : count C1 KnownD NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
Or' : NA &gt; 0 \/ NA = 0
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="365">
 &lt; <b>E: case Or'.</b>

Subgoal 2.1.2.2.1:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 C1 NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : C1 = C -&gt; false
CA1 : count C1 V1 NA
CB : C1 = C -&gt; false
CB1 : count C1 KnownD NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="366">
 &lt; <b>M: apply count_mem to CA1 E.</b>

Subgoal 2.1.2.2.1:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 C1 NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : C1 = C -&gt; false
CA1 : count C1 V1 NA
CB : C1 = C -&gt; false
CB1 : count C1 KnownD NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M : mem C1 V1
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="367">
 &lt; <b>IsV1: apply values_is to _ VKR.</b>

Subgoal 2.1.2.2.1:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 C1 NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : C1 = C -&gt; false
CA1 : count C1 V1 NA
CB : C1 = C -&gt; false
CB1 : count C1 KnownD NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M : mem C1 V1
IsV1 : is_list is_clause V1
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="368">
 &lt; <b>IsC1: apply mem_is_clause to _ M.</b>

Subgoal 2.1.2.2.1:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 C1 NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : C1 = C -&gt; false
CA1 : count C1 V1 NA
CB : C1 = C -&gt; false
CB1 : count C1 KnownD NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M : mem C1 V1
IsV1 : is_list is_clause V1
IsC1 : is_clause C1
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="369">
 &lt; <b>CV: apply is_count_exists_clause to IsV IsC1.</b>

Subgoal 2.1.2.2.1:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 C1 NA NB N
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : C1 = C -&gt; false
CA1 : count C1 V1 NA
CB : C1 = C -&gt; false
CB1 : count C1 KnownD NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M : mem C1 V1
IsV1 : is_list is_clause V1
IsC1 : is_clause C1
CV : count C1 V N
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="370">
 &lt; <b>GEq2: apply Counts to CV CB1.</b>

Subgoal 2.1.2.2.1:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 C1 NA NB N
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : C1 = C -&gt; false
CA1 : count C1 V1 NA
CB : C1 = C -&gt; false
CB1 : count C1 KnownD NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M : mem C1 V1
IsV1 : is_list is_clause V1
IsC1 : is_clause C1
CV : count C1 V N
GEq2 : NB &gt;= N
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="371">
 &lt; <b>GEq3: apply remove_all_reduce_counts to TD1 Vals VKR CV CA1.</b>

Subgoal 2.1.2.2.1:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 C1 NA NB N
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : C1 = C -&gt; false
CA1 : count C1 V1 NA
CB : C1 = C -&gt; false
CB1 : count C1 KnownD NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M : mem C1 V1
IsV1 : is_list is_clause V1
IsC1 : is_clause C1
CV : count C1 V N
GEq2 : NB &gt;= N
GEq3 : N &gt;= NA
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="372">
 &lt; <b>apply greatereq_integer_transitive to GEq2 GEq3.</b>

Subgoal 2.1.2.2.1:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 C1 NA NB N
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : C1 = C -&gt; false
CA1 : count C1 V1 NA
CB : C1 = C -&gt; false
CB1 : count C1 KnownD NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M : mem C1 V1
IsV1 : is_list is_clause V1
IsC1 : is_clause C1
CV : count C1 V N
GEq2 : NB &gt;= N
GEq3 : N &gt;= NA
H1 : NB &gt;= NA
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="373">
 &lt; <b>search.</b>

Subgoal 2.1.2.2.2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 C1 NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : C1 = C -&gt; false
CA1 : count C1 V1 0
CB : C1 = C -&gt; false
CB1 : count C1 KnownD NB
GEq : NB &gt;= 0
GEq' : 0 &gt;= 0
Or : NB &gt; 0 \/ NB = 0
============================
 NB &gt;= 0
</pre>
<pre class="code extensibella"id="374">
 &lt; <b>E: case Or.</b>

Subgoal 2.1.2.2.2.1:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 C1 NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : C1 = C -&gt; false
CA1 : count C1 V1 0
CB : C1 = C -&gt; false
CB1 : count C1 KnownD NB
GEq : NB &gt;= 0
GEq' : 0 &gt;= 0
E : NB &gt; 0
============================
 NB &gt;= 0
</pre>
<pre class="code extensibella"id="375">
 &lt; <b>search.</b>

Subgoal 2.1.2.2.2.2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1 C1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
CA : C1 = C -&gt; false
CA1 : count C1 V1 0
CB : C1 = C -&gt; false
CB1 : count C1 KnownD 0
GEq : 0 &gt;= 0
GEq' : 0 &gt;= 0
============================
 0 &gt;= 0
</pre>
<pre class="code extensibella"id="376">
 &lt; <b>search.</b>

Subgoal 2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
H1 : forall C1 NA NB, count C1 (C::V1) NA -&gt; count C1 (C::KnownD) NB -&gt; NB &gt;= NA
============================
 checkDrat KnownD (addDratClause C DRest)
</pre>
<pre class="code extensibella"id="377">
 &lt; <b>apply IH to _ _ Is3 CP2 GCL_KR TD2 VKR+ _ with
     KnownD = C::KnownD.</b>

Subgoal 2:

Variables: KnownL KnownD V KRest DRest C Rest Prf ID V1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (addLrupProof ID C Prf Rest) (addDratClause C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : remove_all KnownL ID KRest
TD2 : toDrat ((ID, C)::KRest) Rest DRest *
CP : remove_all KnownL ID KRest
CP1 : rupProof KnownL C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
IsV : is_list is_clause V
S : subset V KnownD
D : drup V C
D' : drup KnownD C
GCL_KR : good_clause_list ((ID, C)::KRest)
IsKR : is_list (is_pair is_integer is_clause) KRest
VKR : values KRest V1
VKR+ : values ((ID, C)::KRest) (C::V1)
H1 : forall C1 NA NB, count C1 (C::V1) NA -&gt; count C1 (C::KnownD) NB -&gt; NB &gt;= NA
H2 : checkDrat (C::KnownD) DRest
============================
 checkDrat KnownD (addDratClause C DRest)
</pre>
<pre class="code extensibella"id="378">
 &lt; <b>search.</b>

Subgoal 3:

Variables: KnownL KnownD V KRest DRest C Rest ID
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
IsP : is_proof (deleteLratProof ID Rest)
CP : checkProof KnownL (deleteLratProof ID Rest)
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID Rest) (deleteDrat C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID, C) KRest KnownL
TD2 : toDrat KRest Rest DRest *
============================
 checkDrat KnownD (deleteDrat C DRest)
</pre>
<pre class="code extensibella"id="379">
 &lt; <b>CP: case CP.</b>

Subgoal 3:

Variables: KnownL KnownD V KRest DRest C Rest ID C1 KRest1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
IsP : is_proof (deleteLratProof ID Rest)
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID Rest) (deleteDrat C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID, C) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID, C1) KRest1 KnownL
CP1 : checkProof KRest1 Rest
============================
 checkDrat KnownD (deleteDrat C DRest)
</pre>
<pre class="code extensibella"id="380">
 &lt; <b>Is: case IsP.</b>

Subgoal 3:

Variables: KnownL KnownD V KRest DRest C Rest ID C1 KRest1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID Rest) (deleteDrat C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID, C) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID, C1) KRest1 KnownL
CP1 : checkProof KRest1 Rest
Is : is_integer ID
Is1 : is_proof Rest
============================
 checkDrat KnownD (deleteDrat C DRest)
</pre>
<pre class="code extensibella"id="381">
 &lt; <b>IsKR: apply select_is to _ TD1.</b>

Subgoal 3:

Variables: KnownL KnownD V KRest DRest C Rest ID C1 KRest1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID Rest) (deleteDrat C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID, C) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID, C1) KRest1 KnownL
CP1 : checkProof KRest1 Rest
Is : is_integer ID
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
============================
 checkDrat KnownD (deleteDrat C DRest)
</pre>
<pre class="code extensibella"id="382">
 &lt; <b>apply good_clause_list_selects to _ CP TD1.</b>

Subgoal 3:

Variables: KnownL KnownD V KRest DRest C Rest ID C1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID Rest) (deleteDrat C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID, C) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
============================
 checkDrat KnownD (deleteDrat C DRest)
</pre>
<pre class="code extensibella"id="383">
 &lt; <b>VS: apply values_select to _ TD1.</b>

Subgoal 3:

Variables: KnownL KnownD V KRest DRest C Rest ID C1 VRest
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID Rest) (deleteDrat C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID, C) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C VRest V
VS1 : values KRest VRest
============================
 checkDrat KnownD (deleteDrat C DRest)
</pre>
<pre class="code extensibella"id="384">
 &lt; <b>M: apply select_mem to TD1.</b>

Subgoal 3:

Variables: KnownL KnownD V KRest DRest C Rest ID C1 VRest
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID Rest) (deleteDrat C DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID, C) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C VRest V
VS1 : values KRest VRest
M : mem (ID, C) KnownL
============================
 checkDrat KnownD (deleteDrat C DRest)
</pre>
<pre class="code extensibella"id="385">
 &lt; <b>Is: apply mem_is to _ M.</b>

Subgoal 3:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
============================
 checkDrat KnownD (deleteDrat C2 DRest)
</pre>
<pre class="code extensibella"id="386">
 &lt; <b>IsV: apply values_is to _ Vals.</b>

Subgoal 3:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
============================
 checkDrat KnownD (deleteDrat C2 DRest)
</pre>
<pre class="code extensibella"id="387">
 &lt; <b>CV: apply is_count_exists_clause to IsV Is3.</b>

Subgoal 3:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
============================
 checkDrat KnownD (deleteDrat C2 DRest)
</pre>
<pre class="code extensibella"id="388">
 &lt; <b>CKD: apply is_count_exists_clause to IsKnownD Is3.</b>

Subgoal 3:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
============================
 checkDrat KnownD (deleteDrat C2 DRest)
</pre>
<pre class="code extensibella"id="389">
 &lt; <b>NPos: assert N &gt; 0.</b>

Subgoal 3.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
============================
 N &gt; 0
</pre>
<pre class="code extensibella"id="390">
 &lt; <b>GEq: apply count_geq_0 to CV.</b>

Subgoal 3.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
GEq : N &gt;= 0
============================
 N &gt; 0
</pre>
<pre class="code extensibella"id="391">
 &lt; <b>Or: apply greatereq_integer_greater_or_eq to GEq.</b>

Subgoal 3.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
GEq : N &gt;= 0
Or : N &gt; 0 \/ N = 0
============================
 N &gt; 0
</pre>
<pre class="code extensibella"id="392">
 &lt; <b>L: case Or.</b>

Subgoal 3.1.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
GEq : N &gt;= 0
L : N &gt; 0
============================
 N &gt; 0
</pre>
<pre class="code extensibella"id="393">
 &lt; <b>search.</b>

Subgoal 3.1.2:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V 0
CKD : count C2 KnownD N1
GEq : 0 &gt;= 0
============================
 0 &gt; 0
</pre>
<pre class="code extensibella"id="394">
 &lt; <b>MV: apply select_mem to VS.</b>

Subgoal 3.1.2:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V 0
CKD : count C2 KnownD N1
GEq : 0 &gt;= 0
MV : mem C2 V
============================
 0 &gt; 0
</pre>
<pre class="code extensibella"id="395">
 &lt; <b>apply count_not_mem to CV MV.</b>

Subgoal 3:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
============================
 checkDrat KnownD (deleteDrat C2 DRest)
</pre>
<pre class="code extensibella"id="396">
 &lt; <b>N1N: apply Counts to CV CKD.</b>

Subgoal 3:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1N : N1 &gt;= N
============================
 checkDrat KnownD (deleteDrat C2 DRest)
</pre>
<pre class="code extensibella"id="397">
 &lt; <b>N1Pos: assert N1 &gt; 0.</b>

Subgoal 3.2:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1N : N1 &gt;= N
============================
 N1 &gt; 0
</pre>
<pre class="code extensibella"id="398">
 &lt; <b>Or: apply greatereq_integer_greater_or_eq to N1N.</b>

Subgoal 3.2:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1N : N1 &gt;= N
Or : N1 &gt; N \/ N1 = N
============================
 N1 &gt; 0
</pre>
<pre class="code extensibella"id="399">
 &lt; <b>G: case Or.</b>

Subgoal 3.2.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1N : N1 &gt;= N
G : N1 &gt; N
============================
 N1 &gt; 0
</pre>
<pre class="code extensibella"id="400">
 &lt; <b>apply greater_integer_transitive to G NPos.</b>

Subgoal 3.2.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1N : N1 &gt;= N
G : N1 &gt; N
H1 : N1 &gt; 0
============================
 N1 &gt; 0
</pre>
<pre class="code extensibella"id="401">
 &lt; <b>search.</b>

Subgoal 3.2.2:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N
NPos : N &gt; 0
N1N : N &gt;= N
============================
 N &gt; 0
</pre>
<pre class="code extensibella"id="402">
 &lt; <b>search.</b>

Subgoal 3:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1N : N1 &gt;= N
N1Pos : N1 &gt; 0
============================
 checkDrat KnownD (deleteDrat C2 DRest)
</pre>
<pre class="code extensibella"id="403">
 &lt; <b>clear N1N.</b>

Subgoal 3:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
============================
 checkDrat KnownD (deleteDrat C2 DRest)
</pre>
<pre class="code extensibella"id="404">
 &lt; <b>MKD: apply count_mem to CKD N1Pos.</b>

Subgoal 3:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
============================
 checkDrat KnownD (deleteDrat C2 DRest)
</pre>
<pre class="code extensibella"id="405">
 &lt; <b>SKD: apply mem_select to MKD.</b>

Subgoal 3:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L'
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
============================
 checkDrat KnownD (deleteDrat C2 DRest)
</pre>
<pre class="code extensibella"id="406">
 &lt; <b>IsL': apply select_is_clause to _ SKD.</b>

Subgoal 3:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L'
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
============================
 checkDrat KnownD (deleteDrat C2 DRest)
</pre>
<pre class="code extensibella"id="407">
 &lt; <b>GCL_KR: apply good_clause_list_select to _ TD1.</b>

Subgoal 3:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L'
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
============================
 checkDrat KnownD (deleteDrat C2 DRest)
</pre>
<pre class="code extensibella"id="408">
 &lt; <b>assert forall C NA NB,
     count C VRest NA -&gt; count C L' NB -&gt; NB &gt;= NA.</b>

Subgoal 3.3:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L'
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
============================
 forall C NA NB, count C VRest NA -&gt; count C L' NB -&gt; NB &gt;= NA
</pre>
<pre class="code extensibella"id="409">
 &lt; <b>intros CA CB.</b>

Subgoal 3.3:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' C3 NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C3 VRest NA
CB : count C3 L' NB
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="410">
 &lt; <b>GEq: apply count_geq_0 to CB.</b>

Subgoal 3.3:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' C3 NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C3 VRest NA
CB : count C3 L' NB
GEq : NB &gt;= 0
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="411">
 &lt; <b>GEq': apply count_geq_0 to CA.</b>

Subgoal 3.3:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' C3 NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C3 VRest NA
CB : count C3 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="412">
 &lt; <b>Or: apply greatereq_integer_greater_or_eq to GEq.</b>

Subgoal 3.3:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' C3 NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C3 VRest NA
CB : count C3 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="413">
 &lt; <b>Or': apply greatereq_integer_greater_or_eq to GEq'.</b>

Subgoal 3.3:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' C3 NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C3 VRest NA
CB : count C3 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
Or' : NA &gt; 0 \/ NA = 0
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="414">
 &lt; <b>E: case Or'.</b>

Subgoal 3.3.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' C3 NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C3 VRest NA
CB : count C3 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="415">
 &lt; <b>M': apply count_mem to CA E.</b>

Subgoal 3.3.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' C3 NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C3 VRest NA
CB : count C3 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C3 VRest
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="416">
 &lt; <b>IsVRest: apply values_is to _ VS1.</b>

Subgoal 3.3.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' C3 NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C3 VRest NA
CB : count C3 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C3 VRest
IsVRest : is_list is_clause VRest
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="417">
 &lt; <b>IsC3: apply mem_is_clause to _ M'.</b>

Subgoal 3.3.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' C3 NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C3 VRest NA
CB : count C3 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C3 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C3
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="418">
 &lt; <b>CV: apply is_count_exists_clause to IsV IsC3.</b>

Subgoal 3.3.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' C3 NA NB N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C3 VRest NA
CB : count C3 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C3 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C3
CV1 : count C3 V N2
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="419">
 &lt; <b>IsC2: apply mem_is_clause to _ MKD.</b>

Subgoal 3.3.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' C3 NA NB N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C3 VRest NA
CB : count C3 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C3 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C3
CV1 : count C3 V N2
IsC2 : is_clause C2
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="420">
 &lt; <b>Or'': apply is_clause_eq_or_not to IsC3 IsC2.</b>

Subgoal 3.3.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' C3 NA NB N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C3 VRest NA
CB : count C3 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C3 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C3
CV1 : count C3 V N2
IsC2 : is_clause C2
Or'' : C3 = C2 \/ (C3 = C2 -&gt; false)
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="421">
 &lt; <b>CE: case Or''.</b>

Subgoal 3.3.1.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N2
IsC2 : is_clause C2
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="422">
 &lt; <b>IsN2: apply count_is_integer to CV1.</b>

Subgoal 3.3.1.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N2
IsC2 : is_clause C2
IsN2 : is_integer N2
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="423">
 &lt; <b>Minus: apply minus_integer_total to IsN2 _ with
            N2 = 1.</b>

Subgoal 3.3.1.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB N2 N3
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N2
IsC2 : is_clause C2
IsN2 : is_integer N2
Minus : N2 - 1 = N3
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="424">
 &lt; <b>P: apply minus_plus_same_integer to _ _ Minus.</b>

Subgoal 3.3.1.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB N2 N3
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N2
IsC2 : is_clause C2
IsN2 : is_integer N2
Minus : N2 - 1 = N3
P : N3 + 1 = N2
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="425">
 &lt; <b>IsN3: apply minus_integer_is_integer to _ _ Minus.</b>

Subgoal 3.3.1.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB N2 N3
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N2
IsC2 : is_clause C2
IsN2 : is_integer N2
Minus : N2 - 1 = N3
P : N3 + 1 = N2
IsN3 : is_integer N3
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="426">
 &lt; <b>P': apply plus_integer_comm to _ _ P.</b>

Subgoal 3.3.1.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB N2 N3
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N2
IsC2 : is_clause C2
IsN2 : is_integer N2
Minus : N2 - 1 = N3
P : N3 + 1 = N2
IsN3 : is_integer N3
P' : 1 + N3 = N2
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="427">
 &lt; <b>CVRest: apply select_count to CV1 VS _.</b>

Subgoal 3.3.1.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB N2 N3
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N2
IsC2 : is_clause C2
IsN2 : is_integer N2
Minus : N2 - 1 = N3
P : N3 + 1 = N2
IsN3 : is_integer N3
P' : 1 + N3 = N2
CVRest : count C2 VRest N3
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="428">
 &lt; <b>apply count_unique to CVRest CA.</b>

Subgoal 3.3.1.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N2
IsC2 : is_clause C2
IsN2 : is_integer N2
Minus : N2 - 1 = NA
P : NA + 1 = N2
IsN3 : is_integer NA
P' : 1 + NA = N2
CVRest : count C2 VRest NA
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="429">
 &lt; <b>IsN1: apply count_is_integer to CKD.</b>

Subgoal 3.3.1.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N2
IsC2 : is_clause C2
IsN2 : is_integer N2
Minus : N2 - 1 = NA
P : NA + 1 = N2
IsN3 : is_integer NA
P' : 1 + NA = N2
CVRest : count C2 VRest NA
IsN1 : is_integer N1
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="430">
 &lt; <b>Minus': apply minus_integer_total to IsN1 _ with
             N2 = 1.</b>

Subgoal 3.3.1.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB N2 N4
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N2
IsC2 : is_clause C2
IsN2 : is_integer N2
Minus : N2 - 1 = NA
P : NA + 1 = N2
IsN3 : is_integer NA
P' : 1 + NA = N2
CVRest : count C2 VRest NA
IsN1 : is_integer N1
Minus' : N1 - 1 = N4
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="431">
 &lt; <b>P1: apply minus_plus_same_integer to _ _ Minus'.</b>

Subgoal 3.3.1.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB N2 N4
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N2
IsC2 : is_clause C2
IsN2 : is_integer N2
Minus : N2 - 1 = NA
P : NA + 1 = N2
IsN3 : is_integer NA
P' : 1 + NA = N2
CVRest : count C2 VRest NA
IsN1 : is_integer N1
Minus' : N1 - 1 = N4
P1 : N4 + 1 = N1
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="432">
 &lt; <b>IsN4: apply minus_integer_is_integer to _ _ Minus'.</b>

Subgoal 3.3.1.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB N2 N4
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N2
IsC2 : is_clause C2
IsN2 : is_integer N2
Minus : N2 - 1 = NA
P : NA + 1 = N2
IsN3 : is_integer NA
P' : 1 + NA = N2
CVRest : count C2 VRest NA
IsN1 : is_integer N1
Minus' : N1 - 1 = N4
P1 : N4 + 1 = N1
IsN4 : is_integer N4
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="433">
 &lt; <b>P2: apply plus_integer_comm to _ _ P1.</b>

Subgoal 3.3.1.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB N2 N4
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N2
IsC2 : is_clause C2
IsN2 : is_integer N2
Minus : N2 - 1 = NA
P : NA + 1 = N2
IsN3 : is_integer NA
P' : 1 + NA = N2
CVRest : count C2 VRest NA
IsN1 : is_integer N1
Minus' : N1 - 1 = N4
P1 : N4 + 1 = N1
IsN4 : is_integer N4
P2 : 1 + N4 = N1
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="434">
 &lt; <b>CDRest: apply select_count to CKD SKD Minus'.</b>

Subgoal 3.3.1.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB N2 N4
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N2
IsC2 : is_clause C2
IsN2 : is_integer N2
Minus : N2 - 1 = NA
P : NA + 1 = N2
IsN3 : is_integer NA
P' : 1 + NA = N2
CVRest : count C2 VRest NA
IsN1 : is_integer N1
Minus' : N1 - 1 = N4
P1 : N4 + 1 = N1
IsN4 : is_integer N4
P2 : 1 + N4 = N1
CDRest : count C2 L' N4
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="435">
 &lt; <b>apply count_unique to CDRest CB.</b>

Subgoal 3.3.1.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N2
IsC2 : is_clause C2
IsN2 : is_integer N2
Minus : N2 - 1 = NA
P : NA + 1 = N2
IsN3 : is_integer NA
P' : 1 + NA = N2
CVRest : count C2 VRest NA
IsN1 : is_integer N1
Minus' : N1 - 1 = NB
P1 : NB + 1 = N1
IsN4 : is_integer NB
P2 : 1 + NB = N1
CDRest : count C2 L' NB
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="436">
 &lt; <b>GEq1: apply Counts to CV CKD.</b>

Subgoal 3.3.1.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N2
IsC2 : is_clause C2
IsN2 : is_integer N2
Minus : N2 - 1 = NA
P : NA + 1 = N2
IsN3 : is_integer NA
P' : 1 + NA = N2
CVRest : count C2 VRest NA
IsN1 : is_integer N1
Minus' : N1 - 1 = NB
P1 : NB + 1 = N1
IsN4 : is_integer NB
P2 : 1 + NB = N1
CDRest : count C2 L' NB
GEq1 : N1 &gt;= N
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="437">
 &lt; <b>apply count_unique to CV1 CV.</b>

Subgoal 3.3.1.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N
IsC2 : is_clause C2
IsN2 : is_integer N
Minus : N - 1 = NA
P : NA + 1 = N
IsN3 : is_integer NA
P' : 1 + NA = N
CVRest : count C2 VRest NA
IsN1 : is_integer N1
Minus' : N1 - 1 = NB
P1 : NB + 1 = N1
IsN4 : is_integer NB
P2 : 1 + NB = N1
CDRest : count C2 L' NB
GEq1 : N1 &gt;= N
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="438">
 &lt; <b>Or1: apply greatereq_integer_greater_or_eq to GEq1.</b>

Subgoal 3.3.1.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N
IsC2 : is_clause C2
IsN2 : is_integer N
Minus : N - 1 = NA
P : NA + 1 = N
IsN3 : is_integer NA
P' : 1 + NA = N
CVRest : count C2 VRest NA
IsN1 : is_integer N1
Minus' : N1 - 1 = NB
P1 : NB + 1 = N1
IsN4 : is_integer NB
P2 : 1 + NB = N1
CDRest : count C2 L' NB
GEq1 : N1 &gt;= N
Or1 : N1 &gt; N \/ N1 = N
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="439">
 &lt; <b>G: case Or1.</b>

Subgoal 3.3.1.1.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N
IsC2 : is_clause C2
IsN2 : is_integer N
Minus : N - 1 = NA
P : NA + 1 = N
IsN3 : is_integer NA
P' : 1 + NA = N
CVRest : count C2 VRest NA
IsN1 : is_integer N1
Minus' : N1 - 1 = NB
P1 : NB + 1 = N1
IsN4 : is_integer NB
P2 : 1 + NB = N1
CDRest : count C2 L' NB
GEq1 : N1 &gt;= N
G : N1 &gt; N
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="440">
 &lt; <b>L: apply greater_integer_flip_less to G.</b>

Subgoal 3.3.1.1.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N
IsC2 : is_clause C2
IsN2 : is_integer N
Minus : N - 1 = NA
P : NA + 1 = N
IsN3 : is_integer NA
P' : 1 + NA = N
CVRest : count C2 VRest NA
IsN1 : is_integer N1
Minus' : N1 - 1 = NB
P1 : NB + 1 = N1
IsN4 : is_integer NB
P2 : 1 + NB = N1
CDRest : count C2 L' NB
GEq1 : N1 &gt;= N
G : N1 &gt; N
L : N &lt; N1
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="441">
 &lt; <b>OrRel: apply is_integer_related to IsN3 IsN4.</b>

Subgoal 3.3.1.1.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N
IsC2 : is_clause C2
IsN2 : is_integer N
Minus : N - 1 = NA
P : NA + 1 = N
IsN3 : is_integer NA
P' : 1 + NA = N
CVRest : count C2 VRest NA
IsN1 : is_integer N1
Minus' : N1 - 1 = NB
P1 : NB + 1 = N1
IsN4 : is_integer NB
P2 : 1 + NB = N1
CDRest : count C2 L' NB
GEq1 : N1 &gt;= N
G : N1 &gt; N
L : N &lt; N1
OrRel : (NA = NB \/ NA &lt; NB) \/ NA &gt; NB
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="442">
 &lt; <b>C: case OrRel.</b>

Subgoal 3.3.1.1.1.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NB
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NB &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NB &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N
IsC2 : is_clause C2
IsN2 : is_integer N
Minus : N - 1 = NB
P : NB + 1 = N
IsN3 : is_integer NB
P' : 1 + NB = N
CVRest : count C2 VRest NB
IsN1 : is_integer N1
Minus' : N1 - 1 = NB
P1 : NB + 1 = N1
IsN4 : is_integer NB
P2 : 1 + NB = N1
CDRest : count C2 L' NB
GEq1 : N1 &gt;= N
G : N1 &gt; N
L : N &lt; N1
============================
 NB &gt;= NB
</pre>
<pre class="code extensibella"id="443">
 &lt; <b>backchain is_integer_greatereq.</b>

Subgoal 3.3.1.1.1.2:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N
IsC2 : is_clause C2
IsN2 : is_integer N
Minus : N - 1 = NA
P : NA + 1 = N
IsN3 : is_integer NA
P' : 1 + NA = N
CVRest : count C2 VRest NA
IsN1 : is_integer N1
Minus' : N1 - 1 = NB
P1 : NB + 1 = N1
IsN4 : is_integer NB
P2 : 1 + NB = N1
CDRest : count C2 L' NB
GEq1 : N1 &gt;= N
G : N1 &gt; N
L : N &lt; N1
C : NA &lt; NB
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="444">
 &lt; <b>G': apply less_integer_flip_greater to C.</b>

Subgoal 3.3.1.1.1.2:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N
IsC2 : is_clause C2
IsN2 : is_integer N
Minus : N - 1 = NA
P : NA + 1 = N
IsN3 : is_integer NA
P' : 1 + NA = N
CVRest : count C2 VRest NA
IsN1 : is_integer N1
Minus' : N1 - 1 = NB
P1 : NB + 1 = N1
IsN4 : is_integer NB
P2 : 1 + NB = N1
CDRest : count C2 L' NB
GEq1 : N1 &gt;= N
G : N1 &gt; N
L : N &lt; N1
C : NA &lt; NB
G' : NB &gt; NA
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="445">
 &lt; <b>backchain greater_integer_greatereq.</b>

Subgoal 3.3.1.1.1.3:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N
IsC2 : is_clause C2
IsN2 : is_integer N
Minus : N - 1 = NA
P : NA + 1 = N
IsN3 : is_integer NA
P' : 1 + NA = N
CVRest : count C2 VRest NA
IsN1 : is_integer N1
Minus' : N1 - 1 = NB
P1 : NB + 1 = N1
IsN4 : is_integer NB
P2 : 1 + NB = N1
CDRest : count C2 L' NB
GEq1 : N1 &gt;= N
G : N1 &gt; N
L : N &lt; N1
C : NA &gt; NB
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="446">
 &lt; <b>apply greater_integer_flip_less to C.</b>

Subgoal 3.3.1.1.1.3:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N
IsC2 : is_clause C2
IsN2 : is_integer N
Minus : N - 1 = NA
P : NA + 1 = N
IsN3 : is_integer NA
P' : 1 + NA = N
CVRest : count C2 VRest NA
IsN1 : is_integer N1
Minus' : N1 - 1 = NB
P1 : NB + 1 = N1
IsN4 : is_integer NB
P2 : 1 + NB = N1
CDRest : count C2 L' NB
GEq1 : N1 &gt;= N
G : N1 &gt; N
L : N &lt; N1
C : NA &gt; NB
H1 : NB &lt; NA
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="447">
 &lt; <b>L': apply less_sums to P2 P' _ _.</b>

Subgoal 3.3.1.1.1.3:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N
IsC2 : is_clause C2
IsN2 : is_integer N
Minus : N - 1 = NA
P : NA + 1 = N
IsN3 : is_integer NA
P' : 1 + NA = N
CVRest : count C2 VRest NA
IsN1 : is_integer N1
Minus' : N1 - 1 = NB
P1 : NB + 1 = N1
IsN4 : is_integer NB
P2 : 1 + NB = N1
CDRest : count C2 L' NB
GEq1 : N1 &gt;= N
G : N1 &gt; N
L : N &lt; N1
C : NA &gt; NB
H1 : NB &lt; NA
L' : N1 &lt; N
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="448">
 &lt; <b>G': assert N &gt; N1.</b>

Subgoal 3.3.1.1.1.3:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N
IsC2 : is_clause C2
IsN2 : is_integer N
Minus : N - 1 = NA
P : NA + 1 = N
IsN3 : is_integer NA
P' : 1 + NA = N
CVRest : count C2 VRest NA
IsN1 : is_integer N1
Minus' : N1 - 1 = NB
P1 : NB + 1 = N1
IsN4 : is_integer NB
P2 : 1 + NB = N1
CDRest : count C2 L' NB
GEq1 : N1 &gt;= N
G : N1 &gt; N
L : N &lt; N1
C : NA &gt; NB
H1 : NB &lt; NA
L' : N1 &lt; N
G' : N &gt; N1
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="449">
 &lt; <b>apply greater_less_impossible to G' L.</b>

Subgoal 3.3.1.1.2:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N L' NA NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N
NPos : N &gt; 0
N1Pos : N &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NA
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N
IsC2 : is_clause C2
IsN2 : is_integer N
Minus : N - 1 = NA
P : NA + 1 = N
IsN3 : is_integer NA
P' : 1 + NA = N
CVRest : count C2 VRest NA
IsN1 : is_integer N
Minus' : N - 1 = NB
P1 : NB + 1 = N
IsN4 : is_integer NB
P2 : 1 + NB = N
CDRest : count C2 L' NB
GEq1 : N &gt;= N
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="450">
 &lt; <b>apply minus_integer_unique to Minus Minus'.</b>

Subgoal 3.3.1.1.2:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N L' NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N
NPos : N &gt; 0
N1Pos : N &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C2 VRest NB
CB : count C2 L' NB
GEq : NB &gt;= 0
GEq' : NB &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NB &gt; 0
M' : mem C2 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C2
CV1 : count C2 V N
IsC2 : is_clause C2
IsN2 : is_integer N
Minus : N - 1 = NB
P : NB + 1 = N
IsN3 : is_integer NB
P' : 1 + NB = N
CVRest : count C2 VRest NB
IsN1 : is_integer N
Minus' : N - 1 = NB
P1 : NB + 1 = N
IsN4 : is_integer NB
P2 : 1 + NB = N
CDRest : count C2 L' NB
GEq1 : N &gt;= N
============================
 NB &gt;= NB
</pre>
<pre class="code extensibella"id="451">
 &lt; <b>backchain is_integer_greatereq.</b>

Subgoal 3.3.1.2:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' C3 NA NB N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C3 VRest NA
CB : count C3 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C3 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C3
CV1 : count C3 V N2
IsC2 : is_clause C2
CE : C3 = C2 -&gt; false
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="452">
 &lt; <b>CV: apply count_select_neq to CA VS _.</b>

Subgoal 3.3.1.2:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' C3 NA NB N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C3 VRest NA
CB : count C3 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C3 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C3
CV1 : count C3 V N2
IsC2 : is_clause C2
CE : C3 = C2 -&gt; false
CV2 : count C3 V NA
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="453">
 &lt; <b>CKD': apply count_select_neq to CB SKD _.</b>

Subgoal 3.3.1.2:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' C3 NA NB N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C3 VRest NA
CB : count C3 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C3 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C3
CV1 : count C3 V N2
IsC2 : is_clause C2
CE : C3 = C2 -&gt; false
CV2 : count C3 V NA
CKD' : count C3 KnownD NB
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="454">
 &lt; <b>apply Counts to CV2 CKD'.</b>

Subgoal 3.3.1.2:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' C3 NA NB N2
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C3 VRest NA
CB : count C3 L' NB
GEq : NB &gt;= 0
GEq' : NA &gt;= 0
Or : NB &gt; 0 \/ NB = 0
E : NA &gt; 0
M' : mem C3 VRest
IsVRest : is_list is_clause VRest
IsC3 : is_clause C3
CV1 : count C3 V N2
IsC2 : is_clause C2
CE : C3 = C2 -&gt; false
CV2 : count C3 V NA
CKD' : count C3 KnownD NB
H1 : NB &gt;= NA
============================
 NB &gt;= NA
</pre>
<pre class="code extensibella"id="455">
 &lt; <b>search.</b>

Subgoal 3.3.2:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' C3 NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C3 VRest 0
CB : count C3 L' NB
GEq : NB &gt;= 0
GEq' : 0 &gt;= 0
Or : NB &gt; 0 \/ NB = 0
============================
 NB &gt;= 0
</pre>
<pre class="code extensibella"id="456">
 &lt; <b>E: case Or.</b>

Subgoal 3.3.2.1:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' C3 NB
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C3 VRest 0
CB : count C3 L' NB
GEq : NB &gt;= 0
GEq' : 0 &gt;= 0
E : NB &gt; 0
============================
 NB &gt;= 0
</pre>
<pre class="code extensibella"id="457">
 &lt; <b>search.</b>

Subgoal 3.3.2.2:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L' C3
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
CA : count C3 VRest 0
CB : count C3 L' 0
GEq : 0 &gt;= 0
GEq' : 0 &gt;= 0
============================
 0 &gt;= 0
</pre>
<pre class="code extensibella"id="458">
 &lt; <b>search.</b>

Subgoal 3:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L'
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
H1 : forall C NA NB, count C VRest NA -&gt; count C L' NB -&gt; NB &gt;= NA
============================
 checkDrat KnownD (deleteDrat C2 DRest)
</pre>
<pre class="code extensibella"id="459">
 &lt; <b>apply IH to _ IsL' Is1 CP1 _ TD2 VS1 _.</b>

Subgoal 3:

Variables: KnownL KnownD V KRest DRest Rest C1 VRest ID1 C2 N N1 L'
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
GCL : good_clause_list KnownL
TD : toDrat KnownL (deleteLratProof ID1 Rest) (deleteDrat C2 DRest) @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : select (ID1, C2) KRest KnownL
TD2 : toDrat KRest Rest DRest *
CP : select (ID1, C1) KRest KnownL
CP1 : checkProof KRest Rest
Is : is_integer ID1
Is1 : is_proof Rest
IsKR : is_list (is_pair is_integer is_clause) KRest
VS : select C2 VRest V
VS1 : values KRest VRest
M : mem (ID1, C2) KnownL
Is2 : is_integer ID1
Is3 : is_clause C2
IsV : is_list is_clause V
CV : count C2 V N
CKD : count C2 KnownD N1
NPos : N &gt; 0
N1Pos : N1 &gt; 0
MKD : mem C2 KnownD
SKD : select C2 L' KnownD
IsL' : is_list is_clause L'
GCL_KR : good_clause_list KRest
H1 : forall C NA NB, count C VRest NA -&gt; count C L' NB -&gt; NB &gt;= NA
H2 : checkDrat L' DRest
============================
 checkDrat KnownD (deleteDrat C2 DRest)
</pre>
<pre class="code extensibella"id="460">
 &lt; <b>search.</b>

Subgoal 4:

Variables: D KnownL KnownD V PT
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
IsP : is_proof &lt;unknown proof&gt;
CP : checkProof KnownL &lt;unknown proof&gt;
GCL : good_clause_list KnownL
TD : toDrat KnownL &lt;unknown proof&gt; D @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : KnownL |{proof}- &lt;unknown proof&gt; ~~&gt; PT
TD2 : toDrat KnownL PT D *
============================
 checkDrat KnownD D
</pre>
<pre class="code extensibella"id="461">
 &lt; <b>CP': apply trans_checkProof to TD1 CP _ _.</b>

Subgoal 4:

Variables: D KnownL KnownD V PT
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
IsP : is_proof &lt;unknown proof&gt;
CP : checkProof KnownL &lt;unknown proof&gt;
GCL : good_clause_list KnownL
TD : toDrat KnownL &lt;unknown proof&gt; D @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : KnownL |{proof}- &lt;unknown proof&gt; ~~&gt; PT
TD2 : toDrat KnownL PT D *
CP' : checkProof KnownL PT
============================
 checkDrat KnownD D
</pre>
<pre class="code extensibella"id="462">
 &lt; <b>apply trans_proof_is to TD1 IsP _.</b>

Subgoal 4:

Variables: D KnownL KnownD V PT
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
IsP : is_proof &lt;unknown proof&gt;
CP : checkProof KnownL &lt;unknown proof&gt;
GCL : good_clause_list KnownL
TD : toDrat KnownL &lt;unknown proof&gt; D @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : KnownL |{proof}- &lt;unknown proof&gt; ~~&gt; PT
TD2 : toDrat KnownL PT D *
CP' : checkProof KnownL PT
H1 : is_proof PT
============================
 checkDrat KnownD D
</pre>
<pre class="code extensibella"id="463">
 &lt; <b>apply IH to _ _ _ CP' _ TD2 _ _.</b>

Subgoal 4:

Variables: D KnownL KnownD V PT
IH : forall P D KnownL KnownD V,
       is_list (is_pair is_integer is_clause) KnownL -&gt; is_list is_clause KnownD -&gt;
       is_proof P -&gt; checkProof KnownL P -&gt; good_clause_list KnownL -&gt; toDrat KnownL P D * -&gt;
       values KnownL V -&gt; (forall C NA NB,
         count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA) -&gt; checkDrat KnownD D
IsKnownL : is_list (is_pair is_integer is_clause) KnownL
IsKnownD : is_list is_clause KnownD
IsP : is_proof &lt;unknown proof&gt;
CP : checkProof KnownL &lt;unknown proof&gt;
GCL : good_clause_list KnownL
TD : toDrat KnownL &lt;unknown proof&gt; D @
Vals : values KnownL V
Counts : forall C NA NB, count C V NA -&gt; count C KnownD NB -&gt; NB &gt;= NA
TD1 : KnownL |{proof}- &lt;unknown proof&gt; ~~&gt; PT
TD2 : toDrat KnownL PT D *
CP' : checkProof KnownL PT
H1 : is_proof PT
H2 : checkDrat KnownD D
============================
 checkDrat KnownD D
</pre>
<pre class="code extensibella"id="464">
 &lt; <b>search.</b>

Proof completed.
</pre>
</div>
<div class="section">
<a class="navlink" href="../description.html">Back to example home</a>
</div>
</body>
</html>
