<html>
<head>
<title>Extensibella:  Extensibella Example:  unsat_proofs:lrat - Details</title>
<link href="../../../../style.css" rel="stylesheet" type="text/css">
<script src="../../../../actions.js"></script>
<link rel="icon" href="../../../images/favicon.png" type="image/x-icon">
</head>
<body class="extensibella">
<div id="header-logo">
<a href="../../../index.html">
<img class="header-logo" src="../../../images/Extensibella.png" alt="Extensibella logo">
</a>
</div>
<h2>Reasoning Details</h2>
<div class="section">
<pre class="code extensibella">
 < <b>Module unsat_proofs:lrat.</b>
</pre>
<pre class="code extensibella"id="1">
 &lt; <b>Translation_Constraint trans_lit_unique :
   forall L LA LB,
   TransA : |{lit}- L ~~&gt; LA -&gt;
   TransB : |{lit}- L ~~&gt; LB -&gt;
   LA = LB.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="2">
 &lt; <b>Translation_Constraint trans_lit_is :
   forall L LT,
   Trans : |{lit}- L ~~&gt; LT -&gt;
   IsL : is_lit L -&gt;
   is_lit LT.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="3">
 &lt; <b>Translation_Constraint trans_clause_unique :
   forall C CA CB,
   TransA : |{clause}- C ~~&gt; CA -&gt;
   TransB : |{clause}- C ~~&gt; CB -&gt;
   CA = CB.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="4">
 &lt; <b>Translation_Constraint trans_clause_is :
   forall C CT,
   Trans : |{clause}- C ~~&gt; CT -&gt;
   IsC : is_clause C -&gt;
   is_clause CT.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="5">
 &lt; <b>Translation_Constraint trans_formula_unique :
   forall F FA FB,
   TransA : |{formula}- F ~~&gt; FA -&gt;
   TransB : |{formula}- F ~~&gt; FB -&gt;
   FA = FB.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="6">
 &lt; <b>Translation_Constraint trans_formula_is :
   forall F FT,
   Trans : |{formula}- F ~~&gt; FT -&gt;
   IsF : is_formula F -&gt;
   is_formula FT.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="7">
 &lt; <b>Ext_Ind is_clause C with  |{clause}- C ~~&gt; C'.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="8">
 &lt; <b>Extensible_Theorem
      is_lit_eq_or_not__pos : forall L I,
         IsL : is_lit L -&gt;
         IsI : is_integer I -&gt;
         L = pos I \/
         (L = pos I -&gt; false)
      on IsL.</b>

Subgoal 1:

Variables: I I1
IH : forall L I, is_lit L * -&gt; is_integer I -&gt; L = pos I \/ (L = pos I -&gt; false)
IsL : is_lit (pos I1) @
IsI : is_integer I
IsL1 : is_integer I1
============================
 pos I1 = pos I \/ (pos I1 = pos I -&gt; false)
</pre>
<pre class="code extensibella"id="9">
 &lt; <b>Or: apply is_integer_eq_or_not to IsI IsL1.</b>

Subgoal 1:

Variables: I I1
IH : forall L I, is_lit L * -&gt; is_integer I -&gt; L = pos I \/ (L = pos I -&gt; false)
IsL : is_lit (pos I1) @
IsI : is_integer I
IsL1 : is_integer I1
Or : I = I1 \/ (I = I1 -&gt; false)
============================
 pos I1 = pos I \/ (pos I1 = pos I -&gt; false)
</pre>
<pre class="code extensibella"id="10">
 &lt; <b>Eq: case Or.</b>

Subgoal 1.1:

Variables: I1
IH : forall L I, is_lit L * -&gt; is_integer I -&gt; L = pos I \/ (L = pos I -&gt; false)
IsL : is_lit (pos I1) @
IsI : is_integer I1
IsL1 : is_integer I1
============================
 pos I1 = pos I1 \/ (pos I1 = pos I1 -&gt; false)
</pre>
<pre class="code extensibella"id="11">
 &lt; <b>search.</b>

Subgoal 1.2:

Variables: I I1
IH : forall L I, is_lit L * -&gt; is_integer I -&gt; L = pos I \/ (L = pos I -&gt; false)
IsL : is_lit (pos I1) @
IsI : is_integer I
IsL1 : is_integer I1
Eq : I = I1 -&gt; false
============================
 pos I1 = pos I \/ (pos I1 = pos I -&gt; false)
</pre>
<pre class="code extensibella"id="12">
 &lt; <b>right.</b>

Subgoal 1.2:

Variables: I I1
IH : forall L I, is_lit L * -&gt; is_integer I -&gt; L = pos I \/ (L = pos I -&gt; false)
IsL : is_lit (pos I1) @
IsI : is_integer I
IsL1 : is_integer I1
Eq : I = I1 -&gt; false
============================
 pos I1 = pos I -&gt; false
</pre>
<pre class="code extensibella"id="13">
 &lt; <b>intros E.</b>

Subgoal 1.2:

Variables: I I1
IH : forall L I, is_lit L * -&gt; is_integer I -&gt; L = pos I \/ (L = pos I -&gt; false)
IsL : is_lit (pos I1) @
IsI : is_integer I
IsL1 : is_integer I1
Eq : I = I1 -&gt; false
E : pos I1 = pos I
============================
 false
</pre>
<pre class="code extensibella"id="14">
 &lt; <b>case E.</b>

Subgoal 1.2:

Variables: I
IH : forall L I, is_lit L * -&gt; is_integer I -&gt; L = pos I \/ (L = pos I -&gt; false)
IsL : is_lit (pos I) @
IsI : is_integer I
IsL1 : is_integer I
Eq : I = I -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="15">
 &lt; <b>backchain Eq.</b>

Subgoal 2:

Variables: I I1
IH : forall L I, is_lit L * -&gt; is_integer I -&gt; L = pos I \/ (L = pos I -&gt; false)
IsL : is_lit (neg I1) @
IsI : is_integer I
IsL1 : is_integer I1
============================
 neg I1 = pos I \/ (neg I1 = pos I -&gt; false)
</pre>
<pre class="code extensibella"id="16">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="17">
 &lt; <b>Extensible_Theorem
      is_lit_eq_or_not__neg : forall L I,
         IsL : is_lit L -&gt;
         IsI : is_integer I -&gt;
         L = neg I \/
         (L = neg I -&gt; false)
      on IsL.</b>

Subgoal 1:

Variables: I I1
IH : forall L I, is_lit L * -&gt; is_integer I -&gt; L = neg I \/ (L = neg I -&gt; false)
IsL : is_lit (pos I1) @
IsI : is_integer I
IsL1 : is_integer I1
============================
 pos I1 = neg I \/ (pos I1 = neg I -&gt; false)
</pre>
<pre class="code extensibella"id="18">
 &lt; <b>search.</b>

Subgoal 2:

Variables: I I1
IH : forall L I, is_lit L * -&gt; is_integer I -&gt; L = neg I \/ (L = neg I -&gt; false)
IsL : is_lit (neg I1) @
IsI : is_integer I
IsL1 : is_integer I1
============================
 neg I1 = neg I \/ (neg I1 = neg I -&gt; false)
</pre>
<pre class="code extensibella"id="19">
 &lt; <b>Or: apply is_integer_eq_or_not to IsI IsL1.</b>

Subgoal 2:

Variables: I I1
IH : forall L I, is_lit L * -&gt; is_integer I -&gt; L = neg I \/ (L = neg I -&gt; false)
IsL : is_lit (neg I1) @
IsI : is_integer I
IsL1 : is_integer I1
Or : I = I1 \/ (I = I1 -&gt; false)
============================
 neg I1 = neg I \/ (neg I1 = neg I -&gt; false)
</pre>
<pre class="code extensibella"id="20">
 &lt; <b>Eq: case Or.</b>

Subgoal 2.1:

Variables: I1
IH : forall L I, is_lit L * -&gt; is_integer I -&gt; L = neg I \/ (L = neg I -&gt; false)
IsL : is_lit (neg I1) @
IsI : is_integer I1
IsL1 : is_integer I1
============================
 neg I1 = neg I1 \/ (neg I1 = neg I1 -&gt; false)
</pre>
<pre class="code extensibella"id="21">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: I I1
IH : forall L I, is_lit L * -&gt; is_integer I -&gt; L = neg I \/ (L = neg I -&gt; false)
IsL : is_lit (neg I1) @
IsI : is_integer I
IsL1 : is_integer I1
Eq : I = I1 -&gt; false
============================
 neg I1 = neg I \/ (neg I1 = neg I -&gt; false)
</pre>
<pre class="code extensibella"id="22">
 &lt; <b>right.</b>

Subgoal 2.2:

Variables: I I1
IH : forall L I, is_lit L * -&gt; is_integer I -&gt; L = neg I \/ (L = neg I -&gt; false)
IsL : is_lit (neg I1) @
IsI : is_integer I
IsL1 : is_integer I1
Eq : I = I1 -&gt; false
============================
 neg I1 = neg I -&gt; false
</pre>
<pre class="code extensibella"id="23">
 &lt; <b>intros E.</b>

Subgoal 2.2:

Variables: I I1
IH : forall L I, is_lit L * -&gt; is_integer I -&gt; L = neg I \/ (L = neg I -&gt; false)
IsL : is_lit (neg I1) @
IsI : is_integer I
IsL1 : is_integer I1
Eq : I = I1 -&gt; false
E : neg I1 = neg I
============================
 false
</pre>
<pre class="code extensibella"id="24">
 &lt; <b>case E.</b>

Subgoal 2.2:

Variables: I
IH : forall L I, is_lit L * -&gt; is_integer I -&gt; L = neg I \/ (L = neg I -&gt; false)
IsL : is_lit (neg I) @
IsI : is_integer I
IsL1 : is_integer I
Eq : I = I -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="25">
 &lt; <b>backchain Eq.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="26">
 &lt; <b>Extensible_Theorem
      is_lit_eq_or_not : forall L1 L2,
         IsL1 : is_lit L1 -&gt;
         IsL2 : is_lit L2 -&gt;
         L1 = L2 \/
         (L1 = L2 -&gt; false)
      on IsL1.</b>

Subgoal 1:

Variables: L2 I
IH : forall L1 L2, is_lit L1 * -&gt; is_lit L2 -&gt; L1 = L2 \/ (L1 = L2 -&gt; false)
IsL1 : is_lit (pos I) @
IsL2 : is_lit L2
IsL3 : is_integer I
============================
 pos I = L2 \/ (pos I = L2 -&gt; false)
</pre>
<pre class="code extensibella"id="27">
 &lt; <b>Or: apply is_lit_eq_or_not__pos to IsL2 IsL3.</b>

Subgoal 1:

Variables: L2 I
IH : forall L1 L2, is_lit L1 * -&gt; is_lit L2 -&gt; L1 = L2 \/ (L1 = L2 -&gt; false)
IsL1 : is_lit (pos I) @
IsL2 : is_lit L2
IsL3 : is_integer I
Or : L2 = pos I \/ (L2 = pos I -&gt; false)
============================
 pos I = L2 \/ (pos I = L2 -&gt; false)
</pre>
<pre class="code extensibella"id="28">
 &lt; <b>E: case Or.</b>

Subgoal 1.1:

Variables: I
IH : forall L1 L2, is_lit L1 * -&gt; is_lit L2 -&gt; L1 = L2 \/ (L1 = L2 -&gt; false)
IsL1 : is_lit (pos I) @
IsL2 : is_lit (pos I)
IsL3 : is_integer I
============================
 pos I = pos I \/ (pos I = pos I -&gt; false)
</pre>
<pre class="code extensibella"id="29">
 &lt; <b>search.</b>

Subgoal 1.2:

Variables: L2 I
IH : forall L1 L2, is_lit L1 * -&gt; is_lit L2 -&gt; L1 = L2 \/ (L1 = L2 -&gt; false)
IsL1 : is_lit (pos I) @
IsL2 : is_lit L2
IsL3 : is_integer I
E : L2 = pos I -&gt; false
============================
 pos I = L2 \/ (pos I = L2 -&gt; false)
</pre>
<pre class="code extensibella"id="30">
 &lt; <b>right.</b>

Subgoal 1.2:

Variables: L2 I
IH : forall L1 L2, is_lit L1 * -&gt; is_lit L2 -&gt; L1 = L2 \/ (L1 = L2 -&gt; false)
IsL1 : is_lit (pos I) @
IsL2 : is_lit L2
IsL3 : is_integer I
E : L2 = pos I -&gt; false
============================
 pos I = L2 -&gt; false
</pre>
<pre class="code extensibella"id="31">
 &lt; <b>intros Eq.</b>

Subgoal 1.2:

Variables: L2 I
IH : forall L1 L2, is_lit L1 * -&gt; is_lit L2 -&gt; L1 = L2 \/ (L1 = L2 -&gt; false)
IsL1 : is_lit (pos I) @
IsL2 : is_lit L2
IsL3 : is_integer I
E : L2 = pos I -&gt; false
Eq : pos I = L2
============================
 false
</pre>
<pre class="code extensibella"id="32">
 &lt; <b>case Eq.</b>

Subgoal 1.2:

Variables: I
IH : forall L1 L2, is_lit L1 * -&gt; is_lit L2 -&gt; L1 = L2 \/ (L1 = L2 -&gt; false)
IsL1 : is_lit (pos I) @
IsL2 : is_lit (pos I)
IsL3 : is_integer I
E : pos I = pos I -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="33">
 &lt; <b>backchain E.</b>

Subgoal 2:

Variables: L2 I
IH : forall L1 L2, is_lit L1 * -&gt; is_lit L2 -&gt; L1 = L2 \/ (L1 = L2 -&gt; false)
IsL1 : is_lit (neg I) @
IsL2 : is_lit L2
IsL3 : is_integer I
============================
 neg I = L2 \/ (neg I = L2 -&gt; false)
</pre>
<pre class="code extensibella"id="34">
 &lt; <b>Or: apply is_lit_eq_or_not__neg to IsL2 IsL3.</b>

Subgoal 2:

Variables: L2 I
IH : forall L1 L2, is_lit L1 * -&gt; is_lit L2 -&gt; L1 = L2 \/ (L1 = L2 -&gt; false)
IsL1 : is_lit (neg I) @
IsL2 : is_lit L2
IsL3 : is_integer I
Or : L2 = neg I \/ (L2 = neg I -&gt; false)
============================
 neg I = L2 \/ (neg I = L2 -&gt; false)
</pre>
<pre class="code extensibella"id="35">
 &lt; <b>E: case Or.</b>

Subgoal 2.1:

Variables: I
IH : forall L1 L2, is_lit L1 * -&gt; is_lit L2 -&gt; L1 = L2 \/ (L1 = L2 -&gt; false)
IsL1 : is_lit (neg I) @
IsL2 : is_lit (neg I)
IsL3 : is_integer I
============================
 neg I = neg I \/ (neg I = neg I -&gt; false)
</pre>
<pre class="code extensibella"id="36">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: L2 I
IH : forall L1 L2, is_lit L1 * -&gt; is_lit L2 -&gt; L1 = L2 \/ (L1 = L2 -&gt; false)
IsL1 : is_lit (neg I) @
IsL2 : is_lit L2
IsL3 : is_integer I
E : L2 = neg I -&gt; false
============================
 neg I = L2 \/ (neg I = L2 -&gt; false)
</pre>
<pre class="code extensibella"id="37">
 &lt; <b>right.</b>

Subgoal 2.2:

Variables: L2 I
IH : forall L1 L2, is_lit L1 * -&gt; is_lit L2 -&gt; L1 = L2 \/ (L1 = L2 -&gt; false)
IsL1 : is_lit (neg I) @
IsL2 : is_lit L2
IsL3 : is_integer I
E : L2 = neg I -&gt; false
============================
 neg I = L2 -&gt; false
</pre>
<pre class="code extensibella"id="38">
 &lt; <b>intros Eq.</b>

Subgoal 2.2:

Variables: L2 I
IH : forall L1 L2, is_lit L1 * -&gt; is_lit L2 -&gt; L1 = L2 \/ (L1 = L2 -&gt; false)
IsL1 : is_lit (neg I) @
IsL2 : is_lit L2
IsL3 : is_integer I
E : L2 = neg I -&gt; false
Eq : neg I = L2
============================
 false
</pre>
<pre class="code extensibella"id="39">
 &lt; <b>case Eq.</b>

Subgoal 2.2:

Variables: I
IH : forall L1 L2, is_lit L1 * -&gt; is_lit L2 -&gt; L1 = L2 \/ (L1 = L2 -&gt; false)
IsL1 : is_lit (neg I) @
IsL2 : is_lit (neg I)
IsL3 : is_integer I
E : neg I = neg I -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="40">
 &lt; <b>backchain E.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="41">
 &lt; <b>Extensible_Theorem
      is_clause_empty_or_not : forall C,
         IsC : is_clause C -&gt;
         emptyClause = C \/
         (emptyClause = C -&gt; false)
      on IsC.</b>

Subgoal 1:

IH : forall C, is_clause C * -&gt; emptyClause = C \/ (emptyClause = C -&gt; false)
IsC : is_clause emptyClause @
============================
 emptyClause = emptyClause \/ (emptyClause = emptyClause -&gt; false)
</pre>
<pre class="code extensibella"id="42">
 &lt; <b>search.</b>

Subgoal 2:

Variables: Clause Lit
IH : forall C, is_clause C * -&gt; emptyClause = C \/ (emptyClause = C -&gt; false)
IsC : is_clause (or Lit Clause) @
IsC1 : is_lit Lit
IsC2 : is_clause Clause *
============================
 emptyClause = or Lit Clause \/ (emptyClause = or Lit Clause -&gt; false)
</pre>
<pre class="code extensibella"id="43">
 &lt; <b>right.</b>

Subgoal 2:

Variables: Clause Lit
IH : forall C, is_clause C * -&gt; emptyClause = C \/ (emptyClause = C -&gt; false)
IsC : is_clause (or Lit Clause) @
IsC1 : is_lit Lit
IsC2 : is_clause Clause *
============================
 emptyClause = or Lit Clause -&gt; false
</pre>
<pre class="code extensibella"id="44">
 &lt; <b>intros E.</b>

Subgoal 2:

Variables: Clause Lit
IH : forall C, is_clause C * -&gt; emptyClause = C \/ (emptyClause = C -&gt; false)
IsC : is_clause (or Lit Clause) @
IsC1 : is_lit Lit
IsC2 : is_clause Clause *
E : emptyClause = or Lit Clause
============================
 false
</pre>
<pre class="code extensibella"id="45">
 &lt; <b>case E.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="46">
 &lt; <b>Extensible_Theorem
      is_clause_or_or_not : forall C,
         IsC : is_clause C -&gt;
         (exists L R, or L R = C) \/
         ((exists L R, or L R = C) -&gt; false)
      on IsC.</b>

Subgoal 1:

IH : forall C,
       is_clause C * -&gt; (exists L R, or L R = C) \/
       ((exists L R, or L R = C) -&gt; false)
IsC : is_clause emptyClause @
============================
 (exists L R, or L R = emptyClause) \/
 ((exists L R, or L R = emptyClause) -&gt; false)
</pre>
<pre class="code extensibella"id="47">
 &lt; <b>right.</b>

Subgoal 1:

IH : forall C,
       is_clause C * -&gt; (exists L R, or L R = C) \/
       ((exists L R, or L R = C) -&gt; false)
IsC : is_clause emptyClause @
============================
 (exists L R, or L R = emptyClause) -&gt; false
</pre>
<pre class="code extensibella"id="48">
 &lt; <b>intros E.</b>

Subgoal 1:

IH : forall C,
       is_clause C * -&gt; (exists L R, or L R = C) \/
       ((exists L R, or L R = C) -&gt; false)
IsC : is_clause emptyClause @
E : exists L R, or L R = emptyClause
============================
 false
</pre>
<pre class="code extensibella"id="49">
 &lt; <b>case E.</b>

Subgoal 2:

Variables: Clause Lit
IH : forall C,
       is_clause C * -&gt; (exists L R, or L R = C) \/
       ((exists L R, or L R = C) -&gt; false)
IsC : is_clause (or Lit Clause) @
IsC1 : is_lit Lit
IsC2 : is_clause Clause *
============================
 (exists L R, or L R = or Lit Clause) \/
 ((exists L R, or L R = or Lit Clause) -&gt; false)
</pre>
<pre class="code extensibella"id="50">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="51">
 &lt; <b>Extensible_Theorem
      is_clause_eq_or_not : forall C1 C2,
         IsC1 : is_clause C1 -&gt;
         IsC2 : is_clause C2 -&gt;
         C1 = C2 \/
         (C1 = C2 -&gt; false)
      on IsC1.</b>

Subgoal 1:

Variables: C2
IH : forall C1 C2,
       is_clause C1 * -&gt; is_clause C2 -&gt; C1 = C2 \/ (C1 = C2 -&gt; false)
IsC1 : is_clause emptyClause @
IsC2 : is_clause C2
============================
 emptyClause = C2 \/ (emptyClause = C2 -&gt; false)
</pre>
<pre class="code extensibella"id="52">
 &lt; <b>Or: apply is_clause_empty_or_not to IsC2.</b>

Subgoal 1:

Variables: C2
IH : forall C1 C2,
       is_clause C1 * -&gt; is_clause C2 -&gt; C1 = C2 \/ (C1 = C2 -&gt; false)
IsC1 : is_clause emptyClause @
IsC2 : is_clause C2
Or : emptyClause = C2 \/ (emptyClause = C2 -&gt; false)
============================
 emptyClause = C2 \/ (emptyClause = C2 -&gt; false)
</pre>
<pre class="code extensibella"id="53">
 &lt; <b>Eq: case Or.</b>

Subgoal 1.1:

IH : forall C1 C2,
       is_clause C1 * -&gt; is_clause C2 -&gt; C1 = C2 \/ (C1 = C2 -&gt; false)
IsC1 : is_clause emptyClause @
IsC2 : is_clause emptyClause
============================
 emptyClause = emptyClause \/ (emptyClause = emptyClause -&gt; false)
</pre>
<pre class="code extensibella"id="54">
 &lt; <b>search.</b>

Subgoal 1.2:

Variables: C2
IH : forall C1 C2,
       is_clause C1 * -&gt; is_clause C2 -&gt; C1 = C2 \/ (C1 = C2 -&gt; false)
IsC1 : is_clause emptyClause @
IsC2 : is_clause C2
Eq : emptyClause = C2 -&gt; false
============================
 emptyClause = C2 \/ (emptyClause = C2 -&gt; false)
</pre>
<pre class="code extensibella"id="55">
 &lt; <b>search.</b>

Subgoal 2:

Variables: C2 Clause Lit
IH : forall C1 C2,
       is_clause C1 * -&gt; is_clause C2 -&gt; C1 = C2 \/ (C1 = C2 -&gt; false)
IsC1 : is_clause (or Lit Clause) @
IsC2 : is_clause C2
IsC3 : is_lit Lit
IsC4 : is_clause Clause *
============================
 or Lit Clause = C2 \/ (or Lit Clause = C2 -&gt; false)
</pre>
<pre class="code extensibella"id="56">
 &lt; <b>Or: apply is_clause_or_or_not to IsC2.</b>

Subgoal 2:

Variables: C2 Clause Lit
IH : forall C1 C2,
       is_clause C1 * -&gt; is_clause C2 -&gt; C1 = C2 \/ (C1 = C2 -&gt; false)
IsC1 : is_clause (or Lit Clause) @
IsC2 : is_clause C2
IsC3 : is_lit Lit
IsC4 : is_clause Clause *
Or : (exists L R, or L R = C2) \/ ((exists L R, or L R = C2) -&gt; false)
============================
 or Lit Clause = C2 \/ (or Lit Clause = C2 -&gt; false)
</pre>
<pre class="code extensibella"id="57">
 &lt; <b>Form: case Or.</b>

Subgoal 2.1:

Variables: Clause Lit L R
IH : forall C1 C2,
       is_clause C1 * -&gt; is_clause C2 -&gt; C1 = C2 \/ (C1 = C2 -&gt; false)
IsC1 : is_clause (or Lit Clause) @
IsC2 : is_clause (or L R)
IsC3 : is_lit Lit
IsC4 : is_clause Clause *
============================
 or Lit Clause = or L R \/ (or Lit Clause = or L R -&gt; false)
</pre>
<pre class="code extensibella"id="58">
 &lt; <b>Is: case IsC2.</b>

Subgoal 2.1:

Variables: Clause Lit L R
IH : forall C1 C2,
       is_clause C1 * -&gt; is_clause C2 -&gt; C1 = C2 \/ (C1 = C2 -&gt; false)
IsC1 : is_clause (or Lit Clause) @
IsC3 : is_lit Lit
IsC4 : is_clause Clause *
Is : is_lit L
Is1 : is_clause R
============================
 or Lit Clause = or L R \/ (or Lit Clause = or L R -&gt; false)
</pre>
<pre class="code extensibella"id="59">
 &lt; <b>Or: apply is_lit_eq_or_not to Is IsC3.</b>

Subgoal 2.1:

Variables: Clause Lit L R
IH : forall C1 C2,
       is_clause C1 * -&gt; is_clause C2 -&gt; C1 = C2 \/ (C1 = C2 -&gt; false)
IsC1 : is_clause (or Lit Clause) @
IsC3 : is_lit Lit
IsC4 : is_clause Clause *
Is : is_lit L
Is1 : is_clause R
Or : L = Lit \/ (L = Lit -&gt; false)
============================
 or Lit Clause = or L R \/ (or Lit Clause = or L R -&gt; false)
</pre>
<pre class="code extensibella"id="60">
 &lt; <b>NEq: case Or.</b>

Subgoal 2.1.1:

Variables: Clause Lit R
IH : forall C1 C2,
       is_clause C1 * -&gt; is_clause C2 -&gt; C1 = C2 \/ (C1 = C2 -&gt; false)
IsC1 : is_clause (or Lit Clause) @
IsC3 : is_lit Lit
IsC4 : is_clause Clause *
Is : is_lit Lit
Is1 : is_clause R
============================
 or Lit Clause = or Lit R \/ (or Lit Clause = or Lit R -&gt; false)
</pre>
<pre class="code extensibella"id="61">
 &lt; <b>Or: apply IH to IsC4 Is1.</b>

Subgoal 2.1.1:

Variables: Clause Lit R
IH : forall C1 C2,
       is_clause C1 * -&gt; is_clause C2 -&gt; C1 = C2 \/ (C1 = C2 -&gt; false)
IsC1 : is_clause (or Lit Clause) @
IsC3 : is_lit Lit
IsC4 : is_clause Clause *
Is : is_lit Lit
Is1 : is_clause R
Or : Clause = R \/ (Clause = R -&gt; false)
============================
 or Lit Clause = or Lit R \/ (or Lit Clause = or Lit R -&gt; false)
</pre>
<pre class="code extensibella"id="62">
 &lt; <b>NEq: case Or.</b>

Subgoal 2.1.1.1:

Variables: Lit R
IH : forall C1 C2,
       is_clause C1 * -&gt; is_clause C2 -&gt; C1 = C2 \/ (C1 = C2 -&gt; false)
IsC1 : is_clause (or Lit R) @
IsC3 : is_lit Lit
IsC4 : is_clause R *
Is : is_lit Lit
Is1 : is_clause R
============================
 or Lit R = or Lit R \/ (or Lit R = or Lit R -&gt; false)
</pre>
<pre class="code extensibella"id="63">
 &lt; <b>search.</b>

Subgoal 2.1.1.2:

Variables: Clause Lit R
IH : forall C1 C2,
       is_clause C1 * -&gt; is_clause C2 -&gt; C1 = C2 \/ (C1 = C2 -&gt; false)
IsC1 : is_clause (or Lit Clause) @
IsC3 : is_lit Lit
IsC4 : is_clause Clause *
Is : is_lit Lit
Is1 : is_clause R
NEq : Clause = R -&gt; false
============================
 or Lit Clause = or Lit R \/ (or Lit Clause = or Lit R -&gt; false)
</pre>
<pre class="code extensibella"id="64">
 &lt; <b>right.</b>

Subgoal 2.1.1.2:

Variables: Clause Lit R
IH : forall C1 C2,
       is_clause C1 * -&gt; is_clause C2 -&gt; C1 = C2 \/ (C1 = C2 -&gt; false)
IsC1 : is_clause (or Lit Clause) @
IsC3 : is_lit Lit
IsC4 : is_clause Clause *
Is : is_lit Lit
Is1 : is_clause R
NEq : Clause = R -&gt; false
============================
 or Lit Clause = or Lit R -&gt; false
</pre>
<pre class="code extensibella"id="65">
 &lt; <b>intros E.</b>

Subgoal 2.1.1.2:

Variables: Clause Lit R
IH : forall C1 C2,
       is_clause C1 * -&gt; is_clause C2 -&gt; C1 = C2 \/ (C1 = C2 -&gt; false)
IsC1 : is_clause (or Lit Clause) @
IsC3 : is_lit Lit
IsC4 : is_clause Clause *
Is : is_lit Lit
Is1 : is_clause R
NEq : Clause = R -&gt; false
E : or Lit Clause = or Lit R
============================
 false
</pre>
<pre class="code extensibella"id="66">
 &lt; <b>case E.</b>

Subgoal 2.1.1.2:

Variables: Lit R
IH : forall C1 C2,
       is_clause C1 * -&gt; is_clause C2 -&gt; C1 = C2 \/ (C1 = C2 -&gt; false)
IsC1 : is_clause (or Lit R) @
IsC3 : is_lit Lit
IsC4 : is_clause R *
Is : is_lit Lit
Is1 : is_clause R
NEq : R = R -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="67">
 &lt; <b>backchain NEq.</b>

Subgoal 2.1.2:

Variables: Clause Lit L R
IH : forall C1 C2,
       is_clause C1 * -&gt; is_clause C2 -&gt; C1 = C2 \/ (C1 = C2 -&gt; false)
IsC1 : is_clause (or Lit Clause) @
IsC3 : is_lit Lit
IsC4 : is_clause Clause *
Is : is_lit L
Is1 : is_clause R
NEq : L = Lit -&gt; false
============================
 or Lit Clause = or L R \/ (or Lit Clause = or L R -&gt; false)
</pre>
<pre class="code extensibella"id="68">
 &lt; <b>right.</b>

Subgoal 2.1.2:

Variables: Clause Lit L R
IH : forall C1 C2,
       is_clause C1 * -&gt; is_clause C2 -&gt; C1 = C2 \/ (C1 = C2 -&gt; false)
IsC1 : is_clause (or Lit Clause) @
IsC3 : is_lit Lit
IsC4 : is_clause Clause *
Is : is_lit L
Is1 : is_clause R
NEq : L = Lit -&gt; false
============================
 or Lit Clause = or L R -&gt; false
</pre>
<pre class="code extensibella"id="69">
 &lt; <b>intros E.</b>

Subgoal 2.1.2:

Variables: Clause Lit L R
IH : forall C1 C2,
       is_clause C1 * -&gt; is_clause C2 -&gt; C1 = C2 \/ (C1 = C2 -&gt; false)
IsC1 : is_clause (or Lit Clause) @
IsC3 : is_lit Lit
IsC4 : is_clause Clause *
Is : is_lit L
Is1 : is_clause R
NEq : L = Lit -&gt; false
E : or Lit Clause = or L R
============================
 false
</pre>
<pre class="code extensibella"id="70">
 &lt; <b>case E.</b>

Subgoal 2.1.2:

Variables: L R
IH : forall C1 C2,
       is_clause C1 * -&gt; is_clause C2 -&gt; C1 = C2 \/ (C1 = C2 -&gt; false)
IsC1 : is_clause (or L R) @
IsC3 : is_lit L
IsC4 : is_clause R *
Is : is_lit L
Is1 : is_clause R
NEq : L = L -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="71">
 &lt; <b>backchain NEq.</b>

Subgoal 2.2:

Variables: C2 Clause Lit
IH : forall C1 C2,
       is_clause C1 * -&gt; is_clause C2 -&gt; C1 = C2 \/ (C1 = C2 -&gt; false)
IsC1 : is_clause (or Lit Clause) @
IsC2 : is_clause C2
IsC3 : is_lit Lit
IsC4 : is_clause Clause *
Form : (exists L R, or L R = C2) -&gt; false
============================
 or Lit Clause = C2 \/ (or Lit Clause = C2 -&gt; false)
</pre>
<pre class="code extensibella"id="72">
 &lt; <b>right.</b>

Subgoal 2.2:

Variables: C2 Clause Lit
IH : forall C1 C2,
       is_clause C1 * -&gt; is_clause C2 -&gt; C1 = C2 \/ (C1 = C2 -&gt; false)
IsC1 : is_clause (or Lit Clause) @
IsC2 : is_clause C2
IsC3 : is_lit Lit
IsC4 : is_clause Clause *
Form : (exists L R, or L R = C2) -&gt; false
============================
 or Lit Clause = C2 -&gt; false
</pre>
<pre class="code extensibella"id="73">
 &lt; <b>intros E.</b>

Subgoal 2.2:

Variables: C2 Clause Lit
IH : forall C1 C2,
       is_clause C1 * -&gt; is_clause C2 -&gt; C1 = C2 \/ (C1 = C2 -&gt; false)
IsC1 : is_clause (or Lit Clause) @
IsC2 : is_clause C2
IsC3 : is_lit Lit
IsC4 : is_clause Clause *
Form : (exists L R, or L R = C2) -&gt; false
E : or Lit Clause = C2
============================
 false
</pre>
<pre class="code extensibella"id="74">
 &lt; <b>case E.</b>

Subgoal 2.2:

Variables: Clause Lit
IH : forall C1 C2,
       is_clause C1 * -&gt; is_clause C2 -&gt; C1 = C2 \/ (C1 = C2 -&gt; false)
IsC1 : is_clause (or Lit Clause) @
IsC2 : is_clause (or Lit Clause)
IsC3 : is_lit Lit
IsC4 : is_clause Clause *
Form : (exists L R, or L R = or Lit Clause) -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="75">
 &lt; <b>backchain Form.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="76">
 &lt; <b>Theorem lookup_after_select :
     forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'.</b>

============================
 forall Known ID ID' C C' KRest,
   is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
     mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known -&gt;
   lookup KRest ID' C' -&gt; lookup Known ID' C'
</pre>
<pre class="code extensibella"id="77">
 &lt; <b>induction on 4.</b>

IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
============================
 forall Known ID ID' C C' KRest,
   is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
     mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known @ -&gt;
   lookup KRest ID' C' -&gt; lookup Known ID' C'
</pre>
<pre class="code extensibella"id="78">
 &lt; <b>intros IsK IsID' GCL Slct Lkp.</b>

Variables: Known ID ID' C C' KRest
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsK : is_list (is_pair is_integer is_clause) Known
IsID' : is_integer ID'
GCL : forall I C1 C2, mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2
Slct : select (ID, C) KRest Known @
Lkp : lookup KRest ID' C'
============================
 lookup Known ID' C'
</pre>
<pre class="code extensibella"id="79">
 &lt; <b>Slct: case Slct.</b>

Subgoal 1:

Variables: ID ID' C C' KRest
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsK : is_list (is_pair is_integer is_clause) ((ID, C)::KRest)
IsID' : is_integer ID'
GCL : forall I C1 C2,
        mem (I, C1) ((ID, C)::KRest) -&gt; mem (I, C2) ((ID, C)::KRest) -&gt; C1 = C2
Lkp : lookup KRest ID' C'
============================
 lookup ((ID, C)::KRest) ID' C'
</pre>
<pre class="code extensibella"id="80">
 &lt; <b>Is: case IsK.</b>

Subgoal 1:

Variables: ID ID' C C' KRest
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsID' : is_integer ID'
GCL : forall I C1 C2,
        mem (I, C1) ((ID, C)::KRest) -&gt; mem (I, C2) ((ID, C)::KRest) -&gt; C1 = C2
Lkp : lookup KRest ID' C'
Is : is_pair is_integer is_clause (ID, C)
Is1 : is_list (is_pair is_integer is_clause) KRest
============================
 lookup ((ID, C)::KRest) ID' C'
</pre>
<pre class="code extensibella"id="81">
 &lt; <b>Is: case Is.</b>

Subgoal 1:

Variables: ID ID' C C' KRest
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsID' : is_integer ID'
GCL : forall I C1 C2,
        mem (I, C1) ((ID, C)::KRest) -&gt; mem (I, C2) ((ID, C)::KRest) -&gt; C1 = C2
Lkp : lookup KRest ID' C'
Is1 : is_list (is_pair is_integer is_clause) KRest
Is : is_integer ID
Is2 : is_clause C
============================
 lookup ((ID, C)::KRest) ID' C'
</pre>
<pre class="code extensibella"id="82">
 &lt; <b>Or: apply is_integer_eq_or_not to IsID' Is.</b>

Subgoal 1:

Variables: ID ID' C C' KRest
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsID' : is_integer ID'
GCL : forall I C1 C2,
        mem (I, C1) ((ID, C)::KRest) -&gt; mem (I, C2) ((ID, C)::KRest) -&gt; C1 = C2
Lkp : lookup KRest ID' C'
Is1 : is_list (is_pair is_integer is_clause) KRest
Is : is_integer ID
Is2 : is_clause C
Or : ID' = ID \/ (ID' = ID -&gt; false)
============================
 lookup ((ID, C)::KRest) ID' C'
</pre>
<pre class="code extensibella"id="83">
 &lt; <b>Eq: case Or.</b>

Subgoal 1.1:

Variables: ID C C' KRest
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsID' : is_integer ID
GCL : forall I C1 C2,
        mem (I, C1) ((ID, C)::KRest) -&gt; mem (I, C2) ((ID, C)::KRest) -&gt; C1 = C2
Lkp : lookup KRest ID C'
Is1 : is_list (is_pair is_integer is_clause) KRest
Is : is_integer ID
Is2 : is_clause C
============================
 lookup ((ID, C)::KRest) ID C'
</pre>
<pre class="code extensibella"id="84">
 &lt; <b>M1: apply lookup_mem to Lkp.</b>

Subgoal 1.1:

Variables: ID C C' KRest
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsID' : is_integer ID
GCL : forall I C1 C2,
        mem (I, C1) ((ID, C)::KRest) -&gt; mem (I, C2) ((ID, C)::KRest) -&gt; C1 = C2
Lkp : lookup KRest ID C'
Is1 : is_list (is_pair is_integer is_clause) KRest
Is : is_integer ID
Is2 : is_clause C
M1 : mem (ID, C') KRest
============================
 lookup ((ID, C)::KRest) ID C'
</pre>
<pre class="code extensibella"id="85">
 &lt; <b>M2: assert mem (ID, C') ((ID, C)::KRest).</b>

Subgoal 1.1:

Variables: ID C C' KRest
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsID' : is_integer ID
GCL : forall I C1 C2,
        mem (I, C1) ((ID, C)::KRest) -&gt; mem (I, C2) ((ID, C)::KRest) -&gt; C1 = C2
Lkp : lookup KRest ID C'
Is1 : is_list (is_pair is_integer is_clause) KRest
Is : is_integer ID
Is2 : is_clause C
M1 : mem (ID, C') KRest
M2 : mem (ID, C') ((ID, C)::KRest)
============================
 lookup ((ID, C)::KRest) ID C'
</pre>
<pre class="code extensibella"id="86">
 &lt; <b>M3: assert mem (ID, C) ((ID, C)::KRest).</b>

Subgoal 1.1:

Variables: ID C C' KRest
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsID' : is_integer ID
GCL : forall I C1 C2,
        mem (I, C1) ((ID, C)::KRest) -&gt; mem (I, C2) ((ID, C)::KRest) -&gt; C1 = C2
Lkp : lookup KRest ID C'
Is1 : is_list (is_pair is_integer is_clause) KRest
Is : is_integer ID
Is2 : is_clause C
M1 : mem (ID, C') KRest
M2 : mem (ID, C') ((ID, C)::KRest)
M3 : mem (ID, C) ((ID, C)::KRest)
============================
 lookup ((ID, C)::KRest) ID C'
</pre>
<pre class="code extensibella"id="87">
 &lt; <b>apply GCL to M2 M3.</b>

Subgoal 1.1:

Variables: ID C KRest
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsID' : is_integer ID
GCL : forall I C1 C2,
        mem (I, C1) ((ID, C)::KRest) -&gt; mem (I, C2) ((ID, C)::KRest) -&gt; C1 = C2
Lkp : lookup KRest ID C
Is1 : is_list (is_pair is_integer is_clause) KRest
Is : is_integer ID
Is2 : is_clause C
M1 : mem (ID, C) KRest
M2 : mem (ID, C) ((ID, C)::KRest)
M3 : mem (ID, C) ((ID, C)::KRest)
============================
 lookup ((ID, C)::KRest) ID C
</pre>
<pre class="code extensibella"id="88">
 &lt; <b>search.</b>

Subgoal 1.2:

Variables: ID ID' C C' KRest
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsID' : is_integer ID'
GCL : forall I C1 C2,
        mem (I, C1) ((ID, C)::KRest) -&gt; mem (I, C2) ((ID, C)::KRest) -&gt; C1 = C2
Lkp : lookup KRest ID' C'
Is1 : is_list (is_pair is_integer is_clause) KRest
Is : is_integer ID
Is2 : is_clause C
Eq : ID' = ID -&gt; false
============================
 lookup ((ID, C)::KRest) ID' C'
</pre>
<pre class="code extensibella"id="89">
 &lt; <b>unfold .</b>

Subgoal 1.2.1:

Variables: ID ID' C C' KRest
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsID' : is_integer ID'
GCL : forall I C1 C2,
        mem (I, C1) ((ID, C)::KRest) -&gt; mem (I, C2) ((ID, C)::KRest) -&gt; C1 = C2
Lkp : lookup KRest ID' C'
Is1 : is_list (is_pair is_integer is_clause) KRest
Is : is_integer ID
Is2 : is_clause C
Eq : ID' = ID -&gt; false
============================
 ID = ID' -&gt; false
</pre>
<pre class="code extensibella"id="90">
 &lt; <b>intros E.</b>

Subgoal 1.2.1:

Variables: ID ID' C C' KRest
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsID' : is_integer ID'
GCL : forall I C1 C2,
        mem (I, C1) ((ID, C)::KRest) -&gt; mem (I, C2) ((ID, C)::KRest) -&gt; C1 = C2
Lkp : lookup KRest ID' C'
Is1 : is_list (is_pair is_integer is_clause) KRest
Is : is_integer ID
Is2 : is_clause C
Eq : ID' = ID -&gt; false
E : ID = ID'
============================
 false
</pre>
<pre class="code extensibella"id="91">
 &lt; <b>case E.</b>

Subgoal 1.2.1:

Variables: ID' C C' KRest
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsID' : is_integer ID'
GCL : forall I C1 C2,
        mem (I, C1) ((ID', C)::KRest) -&gt; mem (I, C2) ((ID', C)::KRest) -&gt; C1 = C2
Lkp : lookup KRest ID' C'
Is1 : is_list (is_pair is_integer is_clause) KRest
Is : is_integer ID'
Is2 : is_clause C
Eq : ID' = ID' -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="92">
 &lt; <b>backchain Eq.</b>

Subgoal 1.2.2:

Variables: ID ID' C C' KRest
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsID' : is_integer ID'
GCL : forall I C1 C2,
        mem (I, C1) ((ID, C)::KRest) -&gt; mem (I, C2) ((ID, C)::KRest) -&gt; C1 = C2
Lkp : lookup KRest ID' C'
Is1 : is_list (is_pair is_integer is_clause) KRest
Is : is_integer ID
Is2 : is_clause C
Eq : ID' = ID -&gt; false
============================
 lookup KRest ID' C'
</pre>
<pre class="code extensibella"id="93">
 &lt; <b>search.</b>

Subgoal 2:

Variables: ID ID' C C' L2 I L1
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsK : is_list (is_pair is_integer is_clause) (I::L2)
IsID' : is_integer ID'
GCL : forall I1 C1 C2, mem (I1, C1) (I::L2) -&gt; mem (I1, C2) (I::L2) -&gt; C1 = C2
Lkp : lookup (I::L1) ID' C'
Slct : select (ID, C) L1 L2 *
============================
 lookup (I::L2) ID' C'
</pre>
<pre class="code extensibella"id="94">
 &lt; <b>Is: case IsK.</b>

Subgoal 2:

Variables: ID ID' C C' L2 I L1
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsID' : is_integer ID'
GCL : forall I1 C1 C2, mem (I1, C1) (I::L2) -&gt; mem (I1, C2) (I::L2) -&gt; C1 = C2
Lkp : lookup (I::L1) ID' C'
Slct : select (ID, C) L1 L2 *
Is : is_pair is_integer is_clause I
Is1 : is_list (is_pair is_integer is_clause) L2
============================
 lookup (I::L2) ID' C'
</pre>
<pre class="code extensibella"id="95">
 &lt; <b>Lkp: case Lkp.</b>

Subgoal 2.1:

Variables: ID ID' C C' L2 L1
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsID' : is_integer ID'
GCL : forall I1 C1 C2,
        mem (I1, C1) ((ID', C')::L2) -&gt; mem (I1, C2) ((ID', C')::L2) -&gt; C1 = C2
Slct : select (ID, C) L1 L2 *
Is : is_pair is_integer is_clause (ID', C')
Is1 : is_list (is_pair is_integer is_clause) L2
============================
 lookup ((ID', C')::L2) ID' C'
</pre>
<pre class="code extensibella"id="96">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: ID ID' C C' L2 L1 V K
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsID' : is_integer ID'
GCL : forall I1 C1 C2,
        mem (I1, C1) ((K, V)::L2) -&gt; mem (I1, C2) ((K, V)::L2) -&gt; C1 = C2
Slct : select (ID, C) L1 L2 *
Is : is_pair is_integer is_clause (K, V)
Is1 : is_list (is_pair is_integer is_clause) L2
Lkp : K = ID' -&gt; false
Lkp1 : lookup L1 ID' C'
============================
 lookup ((K, V)::L2) ID' C'
</pre>
<pre class="code extensibella"id="97">
 &lt; <b>assert forall I C1 C2,
     mem (I, C1) L2 -&gt; mem (I, C2) L2 -&gt; C1 = C2.</b>

Subgoal 2.2.1:

Variables: ID ID' C C' L2 L1 V K
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsID' : is_integer ID'
GCL : forall I1 C1 C2,
        mem (I1, C1) ((K, V)::L2) -&gt; mem (I1, C2) ((K, V)::L2) -&gt; C1 = C2
Slct : select (ID, C) L1 L2 *
Is : is_pair is_integer is_clause (K, V)
Is1 : is_list (is_pair is_integer is_clause) L2
Lkp : K = ID' -&gt; false
Lkp1 : lookup L1 ID' C'
============================
 forall I C1 C2, mem (I, C1) L2 -&gt; mem (I, C2) L2 -&gt; C1 = C2
</pre>
<pre class="code extensibella"id="98">
 &lt; <b>intros MA MB.</b>

Subgoal 2.2.1:

Variables: ID ID' C C' L2 L1 V K I1 C1 C2
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsID' : is_integer ID'
GCL : forall I1 C1 C2,
        mem (I1, C1) ((K, V)::L2) -&gt; mem (I1, C2) ((K, V)::L2) -&gt; C1 = C2
Slct : select (ID, C) L1 L2 *
Is : is_pair is_integer is_clause (K, V)
Is1 : is_list (is_pair is_integer is_clause) L2
Lkp : K = ID' -&gt; false
Lkp1 : lookup L1 ID' C'
MA : mem (I1, C1) L2
MB : mem (I1, C2) L2
============================
 C1 = C2
</pre>
<pre class="code extensibella"id="99">
 &lt; <b>MA': assert mem (I1, C1) ((K, V)::L2).</b>

Subgoal 2.2.1:

Variables: ID ID' C C' L2 L1 V K I1 C1 C2
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsID' : is_integer ID'
GCL : forall I1 C1 C2,
        mem (I1, C1) ((K, V)::L2) -&gt; mem (I1, C2) ((K, V)::L2) -&gt; C1 = C2
Slct : select (ID, C) L1 L2 *
Is : is_pair is_integer is_clause (K, V)
Is1 : is_list (is_pair is_integer is_clause) L2
Lkp : K = ID' -&gt; false
Lkp1 : lookup L1 ID' C'
MA : mem (I1, C1) L2
MB : mem (I1, C2) L2
MA' : mem (I1, C1) ((K, V)::L2)
============================
 C1 = C2
</pre>
<pre class="code extensibella"id="100">
 &lt; <b>MB': assert mem (I1, C2) ((K, V)::L2).</b>

Subgoal 2.2.1:

Variables: ID ID' C C' L2 L1 V K I1 C1 C2
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsID' : is_integer ID'
GCL : forall I1 C1 C2,
        mem (I1, C1) ((K, V)::L2) -&gt; mem (I1, C2) ((K, V)::L2) -&gt; C1 = C2
Slct : select (ID, C) L1 L2 *
Is : is_pair is_integer is_clause (K, V)
Is1 : is_list (is_pair is_integer is_clause) L2
Lkp : K = ID' -&gt; false
Lkp1 : lookup L1 ID' C'
MA : mem (I1, C1) L2
MB : mem (I1, C2) L2
MA' : mem (I1, C1) ((K, V)::L2)
MB' : mem (I1, C2) ((K, V)::L2)
============================
 C1 = C2
</pre>
<pre class="code extensibella"id="101">
 &lt; <b>apply GCL to MA' MB'.</b>

Subgoal 2.2.1:

Variables: ID ID' C C' L2 L1 V K I1 C2
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsID' : is_integer ID'
GCL : forall I1 C1 C2,
        mem (I1, C1) ((K, V)::L2) -&gt; mem (I1, C2) ((K, V)::L2) -&gt; C1 = C2
Slct : select (ID, C) L1 L2 *
Is : is_pair is_integer is_clause (K, V)
Is1 : is_list (is_pair is_integer is_clause) L2
Lkp : K = ID' -&gt; false
Lkp1 : lookup L1 ID' C'
MA : mem (I1, C2) L2
MB : mem (I1, C2) L2
MA' : mem (I1, C2) ((K, V)::L2)
MB' : mem (I1, C2) ((K, V)::L2)
============================
 C2 = C2
</pre>
<pre class="code extensibella"id="102">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: ID ID' C C' L2 L1 V K
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsID' : is_integer ID'
GCL : forall I1 C1 C2,
        mem (I1, C1) ((K, V)::L2) -&gt; mem (I1, C2) ((K, V)::L2) -&gt; C1 = C2
Slct : select (ID, C) L1 L2 *
Is : is_pair is_integer is_clause (K, V)
Is1 : is_list (is_pair is_integer is_clause) L2
Lkp : K = ID' -&gt; false
Lkp1 : lookup L1 ID' C'
H1 : forall I C1 C2, mem (I, C1) L2 -&gt; mem (I, C2) L2 -&gt; C1 = C2
============================
 lookup ((K, V)::L2) ID' C'
</pre>
<pre class="code extensibella"id="103">
 &lt; <b>apply IH to Is1 IsID' _ Slct Lkp1.</b>

Subgoal 2.2:

Variables: ID ID' C C' L2 L1 V K
IH : forall Known ID ID' C C' KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID' -&gt; (forall I C1 C2,
         mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2) -&gt; select (ID, C) KRest Known * -&gt;
       lookup KRest ID' C' -&gt; lookup Known ID' C'
IsID' : is_integer ID'
GCL : forall I1 C1 C2,
        mem (I1, C1) ((K, V)::L2) -&gt; mem (I1, C2) ((K, V)::L2) -&gt; C1 = C2
Slct : select (ID, C) L1 L2 *
Is : is_pair is_integer is_clause (K, V)
Is1 : is_list (is_pair is_integer is_clause) L2
Lkp : K = ID' -&gt; false
Lkp1 : lookup L1 ID' C'
H1 : forall I C1 C2, mem (I, C1) L2 -&gt; mem (I, C2) L2 -&gt; C1 = C2
H2 : lookup L2 ID' C'
============================
 lookup ((K, V)::L2) ID' C'
</pre>
<pre class="code extensibella"id="104">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="105">
 &lt; <b>Theorem mem_is :
     forall Known (IDC : pair integer clause),
       is_list (is_pair is_integer is_clause) Known -&gt; mem IDC Known -&gt; exists ID C,
         (IDC = (ID, C) /\ is_integer ID) /\ is_clause C.</b>

============================
 forall Known IDC,
   is_list (is_pair is_integer is_clause) Known -&gt; mem IDC Known -&gt; exists ID C,
     (IDC = (ID, C) /\ is_integer ID) /\ is_clause C
</pre>
<pre class="code extensibella"id="106">
 &lt; <b>induction on 2.</b>

IH : forall Known IDC,
       is_list (is_pair is_integer is_clause) Known -&gt; mem IDC Known * -&gt; exists ID C,
         (IDC = (ID, C) /\ is_integer ID) /\ is_clause C
============================
 forall Known IDC,
   is_list (is_pair is_integer is_clause) Known -&gt; mem IDC Known @ -&gt; exists ID C,
     (IDC = (ID, C) /\ is_integer ID) /\ is_clause C
</pre>
<pre class="code extensibella"id="107">
 &lt; <b>intros Is Mem.</b>

Variables: Known IDC
IH : forall Known IDC,
       is_list (is_pair is_integer is_clause) Known -&gt; mem IDC Known * -&gt; exists ID C,
         (IDC = (ID, C) /\ is_integer ID) /\ is_clause C
Is : is_list (is_pair is_integer is_clause) Known
Mem : mem IDC Known @
============================
 exists ID C, (IDC = (ID, C) /\ is_integer ID) /\ is_clause C
</pre>
<pre class="code extensibella"id="108">
 &lt; <b>Mem: case Mem.</b>

Subgoal 1:

Variables: IDC Rest
IH : forall Known IDC,
       is_list (is_pair is_integer is_clause) Known -&gt; mem IDC Known * -&gt; exists ID C,
         (IDC = (ID, C) /\ is_integer ID) /\ is_clause C
Is : is_list (is_pair is_integer is_clause) (IDC::Rest)
============================
 exists ID C, (IDC = (ID, C) /\ is_integer ID) /\ is_clause C
</pre>
<pre class="code extensibella"id="109">
 &lt; <b>Is: case Is.</b>

Subgoal 1:

Variables: IDC Rest
IH : forall Known IDC,
       is_list (is_pair is_integer is_clause) Known -&gt; mem IDC Known * -&gt; exists ID C,
         (IDC = (ID, C) /\ is_integer ID) /\ is_clause C
Is : is_pair is_integer is_clause IDC
Is1 : is_list (is_pair is_integer is_clause) Rest
============================
 exists ID C, (IDC = (ID, C) /\ is_integer ID) /\ is_clause C
</pre>
<pre class="code extensibella"id="110">
 &lt; <b>case Is.</b>

Subgoal 1:

Variables: Rest B A
IH : forall Known IDC,
       is_list (is_pair is_integer is_clause) Known -&gt; mem IDC Known * -&gt; exists ID C,
         (IDC = (ID, C) /\ is_integer ID) /\ is_clause C
Is1 : is_list (is_pair is_integer is_clause) Rest
H1 : is_integer A
H2 : is_clause B
============================
 exists ID C, ((A, B) = (ID, C) /\ is_integer ID) /\ is_clause C
</pre>
<pre class="code extensibella"id="111">
 &lt; <b>search.</b>

Subgoal 2:

Variables: IDC Rest I
IH : forall Known IDC,
       is_list (is_pair is_integer is_clause) Known -&gt; mem IDC Known * -&gt; exists ID C,
         (IDC = (ID, C) /\ is_integer ID) /\ is_clause C
Is : is_list (is_pair is_integer is_clause) (I::Rest)
Mem : mem IDC Rest *
============================
 exists ID C, (IDC = (ID, C) /\ is_integer ID) /\ is_clause C
</pre>
<pre class="code extensibella"id="112">
 &lt; <b>Is: case Is.</b>

Subgoal 2:

Variables: IDC Rest I
IH : forall Known IDC,
       is_list (is_pair is_integer is_clause) Known -&gt; mem IDC Known * -&gt; exists ID C,
         (IDC = (ID, C) /\ is_integer ID) /\ is_clause C
Mem : mem IDC Rest *
Is : is_pair is_integer is_clause I
Is1 : is_list (is_pair is_integer is_clause) Rest
============================
 exists ID C, (IDC = (ID, C) /\ is_integer ID) /\ is_clause C
</pre>
<pre class="code extensibella"id="113">
 &lt; <b>apply IH to _ Mem.</b>

Subgoal 2:

Variables: Rest I ID C
IH : forall Known IDC,
       is_list (is_pair is_integer is_clause) Known -&gt; mem IDC Known * -&gt; exists ID C,
         (IDC = (ID, C) /\ is_integer ID) /\ is_clause C
Mem : mem (ID, C) Rest *
Is : is_pair is_integer is_clause I
Is1 : is_list (is_pair is_integer is_clause) Rest
H1 : is_integer ID
H2 : is_clause C
============================
 exists ID1 C1, ((ID, C) = (ID1, C1) /\ is_integer ID1) /\ is_clause C1
</pre>
<pre class="code extensibella"id="114">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="115">
 &lt; <b>Theorem mem_is_lit :
     forall Assignment L,
       is_list is_lit Assignment -&gt; mem L Assignment -&gt; is_lit L.</b>

============================
 forall Assignment L, is_list is_lit Assignment -&gt; mem L Assignment -&gt; is_lit L
</pre>
<pre class="code extensibella"id="116">
 &lt; <b>induction on 2.</b>

IH : forall Assignment L,
       is_list is_lit Assignment -&gt; mem L Assignment * -&gt; is_lit L
============================
 forall Assignment L,
   is_list is_lit Assignment -&gt; mem L Assignment @ -&gt; is_lit L
</pre>
<pre class="code extensibella"id="117">
 &lt; <b>intros Is Mem.</b>

Variables: Assignment L
IH : forall Assignment L,
       is_list is_lit Assignment -&gt; mem L Assignment * -&gt; is_lit L
Is : is_list is_lit Assignment
Mem : mem L Assignment @
============================
 is_lit L
</pre>
<pre class="code extensibella"id="118">
 &lt; <b>Mem: case Mem.</b>

Subgoal 1:

Variables: L Rest
IH : forall Assignment L,
       is_list is_lit Assignment -&gt; mem L Assignment * -&gt; is_lit L
Is : is_list is_lit (L::Rest)
============================
 is_lit L
</pre>
<pre class="code extensibella"id="119">
 &lt; <b>Is: case Is.</b>

Subgoal 1:

Variables: L Rest
IH : forall Assignment L,
       is_list is_lit Assignment -&gt; mem L Assignment * -&gt; is_lit L
Is : is_lit L
Is1 : is_list is_lit Rest
============================
 is_lit L
</pre>
<pre class="code extensibella"id="120">
 &lt; <b>search.</b>

Subgoal 2:

Variables: L Rest I
IH : forall Assignment L,
       is_list is_lit Assignment -&gt; mem L Assignment * -&gt; is_lit L
Is : is_list is_lit (I::Rest)
Mem : mem L Rest *
============================
 is_lit L
</pre>
<pre class="code extensibella"id="121">
 &lt; <b>Is: case Is.</b>

Subgoal 2:

Variables: L Rest I
IH : forall Assignment L,
       is_list is_lit Assignment -&gt; mem L Assignment * -&gt; is_lit L
Mem : mem L Rest *
Is : is_lit I
Is1 : is_list is_lit Rest
============================
 is_lit L
</pre>
<pre class="code extensibella"id="122">
 &lt; <b>apply IH to _ Mem.</b>

Subgoal 2:

Variables: L Rest I
IH : forall Assignment L,
       is_list is_lit Assignment -&gt; mem L Assignment * -&gt; is_lit L
Mem : mem L Rest *
Is : is_lit I
Is1 : is_list is_lit Rest
H1 : is_lit L
============================
 is_lit L
</pre>
<pre class="code extensibella"id="123">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="124">
 &lt; <b>Theorem select_is :
     forall Known KRest IDC,
       is_list (is_pair is_integer is_clause) Known -&gt; select IDC KRest Known -&gt;
       is_list (is_pair is_integer is_clause) KRest.</b>

============================
 forall Known KRest IDC,
   is_list (is_pair is_integer is_clause) Known -&gt; select IDC KRest Known -&gt; is_list (is_pair is_integer is_clause) KRest
</pre>
<pre class="code extensibella"id="125">
 &lt; <b>induction on 2.</b>

IH : forall Known KRest IDC,
       is_list (is_pair is_integer is_clause) Known -&gt; select IDC KRest Known * -&gt;
       is_list (is_pair is_integer is_clause) KRest
============================
 forall Known KRest IDC,
   is_list (is_pair is_integer is_clause) Known -&gt; select IDC KRest Known @ -&gt; is_list (is_pair is_integer is_clause) KRest
</pre>
<pre class="code extensibella"id="126">
 &lt; <b>intros Is Slct.</b>

Variables: Known KRest IDC
IH : forall Known KRest IDC,
       is_list (is_pair is_integer is_clause) Known -&gt; select IDC KRest Known * -&gt;
       is_list (is_pair is_integer is_clause) KRest
Is : is_list (is_pair is_integer is_clause) Known
Slct : select IDC KRest Known @
============================
 is_list (is_pair is_integer is_clause) KRest
</pre>
<pre class="code extensibella"id="127">
 &lt; <b>Slct: case Slct.</b>

Subgoal 1:

Variables: KRest IDC
IH : forall Known KRest IDC,
       is_list (is_pair is_integer is_clause) Known -&gt; select IDC KRest Known * -&gt;
       is_list (is_pair is_integer is_clause) KRest
Is : is_list (is_pair is_integer is_clause) (IDC::KRest)
============================
 is_list (is_pair is_integer is_clause) KRest
</pre>
<pre class="code extensibella"id="128">
 &lt; <b>case Is.</b>

Subgoal 1:

Variables: KRest IDC
IH : forall Known KRest IDC,
       is_list (is_pair is_integer is_clause) Known -&gt; select IDC KRest Known * -&gt;
       is_list (is_pair is_integer is_clause) KRest
H1 : is_pair is_integer is_clause IDC
H2 : is_list (is_pair is_integer is_clause) KRest
============================
 is_list (is_pair is_integer is_clause) KRest
</pre>
<pre class="code extensibella"id="129">
 &lt; <b>search.</b>

Subgoal 2:

Variables: IDC L2 I L1
IH : forall Known KRest IDC,
       is_list (is_pair is_integer is_clause) Known -&gt; select IDC KRest Known * -&gt;
       is_list (is_pair is_integer is_clause) KRest
Is : is_list (is_pair is_integer is_clause) (I::L2)
Slct : select IDC L1 L2 *
============================
 is_list (is_pair is_integer is_clause) (I::L1)
</pre>
<pre class="code extensibella"id="130">
 &lt; <b>Is: case Is.</b>

Subgoal 2:

Variables: IDC L2 I L1
IH : forall Known KRest IDC,
       is_list (is_pair is_integer is_clause) Known -&gt; select IDC KRest Known * -&gt;
       is_list (is_pair is_integer is_clause) KRest
Slct : select IDC L1 L2 *
Is : is_pair is_integer is_clause I
Is1 : is_list (is_pair is_integer is_clause) L2
============================
 is_list (is_pair is_integer is_clause) (I::L1)
</pre>
<pre class="code extensibella"id="131">
 &lt; <b>apply IH to _ Slct.</b>

Subgoal 2:

Variables: IDC L2 I L1
IH : forall Known KRest IDC,
       is_list (is_pair is_integer is_clause) Known -&gt; select IDC KRest Known * -&gt;
       is_list (is_pair is_integer is_clause) KRest
Slct : select IDC L1 L2 *
Is : is_pair is_integer is_clause I
Is1 : is_list (is_pair is_integer is_clause) L2
H1 : is_list (is_pair is_integer is_clause) L1
============================
 is_list (is_pair is_integer is_clause) (I::L1)
</pre>
<pre class="code extensibella"id="132">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="133">
 &lt; <b>Theorem select_is_picked :
     forall Known IDC KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; select IDC KRest Known -&gt;
       is_pair is_integer is_clause IDC.</b>

============================
 forall Known IDC KRest,
   is_list (is_pair is_integer is_clause) Known -&gt; select IDC KRest Known -&gt; is_pair is_integer is_clause IDC
</pre>
<pre class="code extensibella"id="134">
 &lt; <b>induction on 2.</b>

IH : forall Known IDC KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; select IDC KRest Known * -&gt;
       is_pair is_integer is_clause IDC
============================
 forall Known IDC KRest,
   is_list (is_pair is_integer is_clause) Known -&gt; select IDC KRest Known @ -&gt; is_pair is_integer is_clause IDC
</pre>
<pre class="code extensibella"id="135">
 &lt; <b>intros Is Slct.</b>

Variables: Known IDC KRest
IH : forall Known IDC KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; select IDC KRest Known * -&gt;
       is_pair is_integer is_clause IDC
Is : is_list (is_pair is_integer is_clause) Known
Slct : select IDC KRest Known @
============================
 is_pair is_integer is_clause IDC
</pre>
<pre class="code extensibella"id="136">
 &lt; <b>Slct: case Slct.</b>

Subgoal 1:

Variables: IDC KRest
IH : forall Known IDC KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; select IDC KRest Known * -&gt;
       is_pair is_integer is_clause IDC
Is : is_list (is_pair is_integer is_clause) (IDC::KRest)
============================
 is_pair is_integer is_clause IDC
</pre>
<pre class="code extensibella"id="137">
 &lt; <b>case Is.</b>

Subgoal 1:

Variables: IDC KRest
IH : forall Known IDC KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; select IDC KRest Known * -&gt;
       is_pair is_integer is_clause IDC
H1 : is_pair is_integer is_clause IDC
H2 : is_list (is_pair is_integer is_clause) KRest
============================
 is_pair is_integer is_clause IDC
</pre>
<pre class="code extensibella"id="138">
 &lt; <b>search.</b>

Subgoal 2:

Variables: IDC L2 I L1
IH : forall Known IDC KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; select IDC KRest Known * -&gt;
       is_pair is_integer is_clause IDC
Is : is_list (is_pair is_integer is_clause) (I::L2)
Slct : select IDC L1 L2 *
============================
 is_pair is_integer is_clause IDC
</pre>
<pre class="code extensibella"id="139">
 &lt; <b>case Is.</b>

Subgoal 2:

Variables: IDC L2 I L1
IH : forall Known IDC KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; select IDC KRest Known * -&gt;
       is_pair is_integer is_clause IDC
Slct : select IDC L1 L2 *
H1 : is_pair is_integer is_clause I
H2 : is_list (is_pair is_integer is_clause) L2
============================
 is_pair is_integer is_clause IDC
</pre>
<pre class="code extensibella"id="140">
 &lt; <b>apply IH to _ Slct.</b>

Subgoal 2:

Variables: IDC L2 I L1
IH : forall Known IDC KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; select IDC KRest Known * -&gt;
       is_pair is_integer is_clause IDC
Slct : select IDC L1 L2 *
H1 : is_pair is_integer is_clause I
H2 : is_list (is_pair is_integer is_clause) L2
H3 : is_pair is_integer is_clause IDC
============================
 is_pair is_integer is_clause IDC
</pre>
<pre class="code extensibella"id="141">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="142">
 &lt; <b>Theorem is_list_lit_mem_or_not :
     forall A L, is_list is_lit A -&gt; is_lit L -&gt; mem L A \/ (mem L A -&gt; false).</b>

============================
 forall A L, is_list is_lit A -&gt; is_lit L -&gt; mem L A \/ (mem L A -&gt; false)
</pre>
<pre class="code extensibella"id="143">
 &lt; <b>induction on 1.</b>

IH : forall A L, is_list is_lit A * -&gt; is_lit L -&gt; mem L A \/ (mem L A -&gt; false)
============================
 forall A L, is_list is_lit A @ -&gt; is_lit L -&gt; mem L A \/ (mem L A -&gt; false)
</pre>
<pre class="code extensibella"id="144">
 &lt; <b>intros IsA IsL.</b>

Variables: A L
IH : forall A L, is_list is_lit A * -&gt; is_lit L -&gt; mem L A \/ (mem L A -&gt; false)
IsA : is_list is_lit A @
IsL : is_lit L
============================
 mem L A \/ (mem L A -&gt; false)
</pre>
<pre class="code extensibella"id="145">
 &lt; <b>IsA: case IsA.</b>

Subgoal 1:

Variables: L
IH : forall A L, is_list is_lit A * -&gt; is_lit L -&gt; mem L A \/ (mem L A -&gt; false)
IsL : is_lit L
============================
 mem L [] \/ (mem L [] -&gt; false)
</pre>
<pre class="code extensibella"id="146">
 &lt; <b>right.</b>

Subgoal 1:

Variables: L
IH : forall A L, is_list is_lit A * -&gt; is_lit L -&gt; mem L A \/ (mem L A -&gt; false)
IsL : is_lit L
============================
 mem L [] -&gt; false
</pre>
<pre class="code extensibella"id="147">
 &lt; <b>intros M.</b>

Subgoal 1:

Variables: L
IH : forall A L, is_list is_lit A * -&gt; is_lit L -&gt; mem L A \/ (mem L A -&gt; false)
IsL : is_lit L
M : mem L []
============================
 false
</pre>
<pre class="code extensibella"id="148">
 &lt; <b>case M.</b>

Subgoal 2:

Variables: L T H
IH : forall A L, is_list is_lit A * -&gt; is_lit L -&gt; mem L A \/ (mem L A -&gt; false)
IsL : is_lit L
IsA : is_lit H
IsA1 : is_list is_lit T *
============================
 mem L (H::T) \/ (mem L (H::T) -&gt; false)
</pre>
<pre class="code extensibella"id="149">
 &lt; <b>Or: apply is_lit_eq_or_not to IsL IsA.</b>

Subgoal 2:

Variables: L T H
IH : forall A L, is_list is_lit A * -&gt; is_lit L -&gt; mem L A \/ (mem L A -&gt; false)
IsL : is_lit L
IsA : is_lit H
IsA1 : is_list is_lit T *
Or : L = H \/ (L = H -&gt; false)
============================
 mem L (H::T) \/ (mem L (H::T) -&gt; false)
</pre>
<pre class="code extensibella"id="150">
 &lt; <b>EqL: case Or.</b>

Subgoal 2.1:

Variables: T H
IH : forall A L, is_list is_lit A * -&gt; is_lit L -&gt; mem L A \/ (mem L A -&gt; false)
IsL : is_lit H
IsA : is_lit H
IsA1 : is_list is_lit T *
============================
 mem H (H::T) \/ (mem H (H::T) -&gt; false)
</pre>
<pre class="code extensibella"id="151">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: L T H
IH : forall A L, is_list is_lit A * -&gt; is_lit L -&gt; mem L A \/ (mem L A -&gt; false)
IsL : is_lit L
IsA : is_lit H
IsA1 : is_list is_lit T *
EqL : L = H -&gt; false
============================
 mem L (H::T) \/ (mem L (H::T) -&gt; false)
</pre>
<pre class="code extensibella"id="152">
 &lt; <b>Or: apply IH to IsA1 IsL.</b>

Subgoal 2.2:

Variables: L T H
IH : forall A L, is_list is_lit A * -&gt; is_lit L -&gt; mem L A \/ (mem L A -&gt; false)
IsL : is_lit L
IsA : is_lit H
IsA1 : is_list is_lit T *
EqL : L = H -&gt; false
Or : mem L T \/ (mem L T -&gt; false)
============================
 mem L (H::T) \/ (mem L (H::T) -&gt; false)
</pre>
<pre class="code extensibella"id="153">
 &lt; <b>MemRest: case Or.</b>

Subgoal 2.2.1:

Variables: L T H
IH : forall A L, is_list is_lit A * -&gt; is_lit L -&gt; mem L A \/ (mem L A -&gt; false)
IsL : is_lit L
IsA : is_lit H
IsA1 : is_list is_lit T *
EqL : L = H -&gt; false
MemRest : mem L T
============================
 mem L (H::T) \/ (mem L (H::T) -&gt; false)
</pre>
<pre class="code extensibella"id="154">
 &lt; <b>search.</b>

Subgoal 2.2.2:

Variables: L T H
IH : forall A L, is_list is_lit A * -&gt; is_lit L -&gt; mem L A \/ (mem L A -&gt; false)
IsL : is_lit L
IsA : is_lit H
IsA1 : is_list is_lit T *
EqL : L = H -&gt; false
MemRest : mem L T -&gt; false
============================
 mem L (H::T) \/ (mem L (H::T) -&gt; false)
</pre>
<pre class="code extensibella"id="155">
 &lt; <b>right.</b>

Subgoal 2.2.2:

Variables: L T H
IH : forall A L, is_list is_lit A * -&gt; is_lit L -&gt; mem L A \/ (mem L A -&gt; false)
IsL : is_lit L
IsA : is_lit H
IsA1 : is_list is_lit T *
EqL : L = H -&gt; false
MemRest : mem L T -&gt; false
============================
 mem L (H::T) -&gt; false
</pre>
<pre class="code extensibella"id="156">
 &lt; <b>intros Mem.</b>

Subgoal 2.2.2:

Variables: L T H
IH : forall A L, is_list is_lit A * -&gt; is_lit L -&gt; mem L A \/ (mem L A -&gt; false)
IsL : is_lit L
IsA : is_lit H
IsA1 : is_list is_lit T *
EqL : L = H -&gt; false
MemRest : mem L T -&gt; false
Mem : mem L (H::T)
============================
 false
</pre>
<pre class="code extensibella"id="157">
 &lt; <b>Mem: case Mem.</b>

Subgoal 2.2.2.1:

Variables: T H
IH : forall A L, is_list is_lit A * -&gt; is_lit L -&gt; mem L A \/ (mem L A -&gt; false)
IsL : is_lit H
IsA : is_lit H
IsA1 : is_list is_lit T *
EqL : H = H -&gt; false
MemRest : mem H T -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="158">
 &lt; <b>backchain EqL.</b>

Subgoal 2.2.2.2:

Variables: L T H
IH : forall A L, is_list is_lit A * -&gt; is_lit L -&gt; mem L A \/ (mem L A -&gt; false)
IsL : is_lit L
IsA : is_lit H
IsA1 : is_list is_lit T *
EqL : L = H -&gt; false
MemRest : mem L T -&gt; false
Mem : mem L T
============================
 false
</pre>
<pre class="code extensibella"id="159">
 &lt; <b>backchain MemRest.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="160">
 &lt; <b>Theorem is_list_lit_subset_or_not :
     forall A B,
       is_list is_lit A -&gt; is_list is_lit B -&gt; (forall X, mem X A -&gt; mem X B) \/
       (exists X, mem X A /\ (mem X B -&gt; false)).</b>

============================
 forall A B,
   is_list is_lit A -&gt; is_list is_lit B -&gt; (forall X, mem X A -&gt; mem X B) \/
   (exists X, mem X A /\ (mem X B -&gt; false))
</pre>
<pre class="code extensibella"id="161">
 &lt; <b>induction on 1.</b>

IH : forall A B,
       is_list is_lit A * -&gt; is_list is_lit B -&gt; (forall X, mem X A -&gt; mem X B) \/
       (exists X, mem X A /\ (mem X B -&gt; false))
============================
 forall A B,
   is_list is_lit A @ -&gt; is_list is_lit B -&gt; (forall X, mem X A -&gt; mem X B) \/
   (exists X, mem X A /\ (mem X B -&gt; false))
</pre>
<pre class="code extensibella"id="162">
 &lt; <b>intros IsA IsB.</b>

Variables: A B
IH : forall A B,
       is_list is_lit A * -&gt; is_list is_lit B -&gt; (forall X, mem X A -&gt; mem X B) \/
       (exists X, mem X A /\ (mem X B -&gt; false))
IsA : is_list is_lit A @
IsB : is_list is_lit B
============================
 (forall X, mem X A -&gt; mem X B) \/ (exists X, mem X A /\ (mem X B -&gt; false))
</pre>
<pre class="code extensibella"id="163">
 &lt; <b>IsA: case IsA.</b>

Subgoal 1:

Variables: B
IH : forall A B,
       is_list is_lit A * -&gt; is_list is_lit B -&gt; (forall X, mem X A -&gt; mem X B) \/
       (exists X, mem X A /\ (mem X B -&gt; false))
IsB : is_list is_lit B
============================
 (forall X, mem X [] -&gt; mem X B) \/ (exists X, mem X [] /\ (mem X B -&gt; false))
</pre>
<pre class="code extensibella"id="164">
 &lt; <b>left.</b>

Subgoal 1:

Variables: B
IH : forall A B,
       is_list is_lit A * -&gt; is_list is_lit B -&gt; (forall X, mem X A -&gt; mem X B) \/
       (exists X, mem X A /\ (mem X B -&gt; false))
IsB : is_list is_lit B
============================
 forall X, mem X [] -&gt; mem X B
</pre>
<pre class="code extensibella"id="165">
 &lt; <b>intros M.</b>

Subgoal 1:

Variables: B X
IH : forall A B,
       is_list is_lit A * -&gt; is_list is_lit B -&gt; (forall X, mem X A -&gt; mem X B) \/
       (exists X, mem X A /\ (mem X B -&gt; false))
IsB : is_list is_lit B
M : mem X []
============================
 mem X B
</pre>
<pre class="code extensibella"id="166">
 &lt; <b>case M.</b>

Subgoal 2:

Variables: B T H
IH : forall A B,
       is_list is_lit A * -&gt; is_list is_lit B -&gt; (forall X, mem X A -&gt; mem X B) \/
       (exists X, mem X A /\ (mem X B -&gt; false))
IsB : is_list is_lit B
IsA : is_lit H
IsA1 : is_list is_lit T *
============================
 (forall X, mem X (H::T) -&gt; mem X B) \/
 (exists X, mem X (H::T) /\ (mem X B -&gt; false))
</pre>
<pre class="code extensibella"id="167">
 &lt; <b>Or: apply is_list_lit_mem_or_not to IsB IsA.</b>

Subgoal 2:

Variables: B T H
IH : forall A B,
       is_list is_lit A * -&gt; is_list is_lit B -&gt; (forall X, mem X A -&gt; mem X B) \/
       (exists X, mem X A /\ (mem X B -&gt; false))
IsB : is_list is_lit B
IsA : is_lit H
IsA1 : is_list is_lit T *
Or : mem H B \/ (mem H B -&gt; false)
============================
 (forall X, mem X (H::T) -&gt; mem X B) \/
 (exists X, mem X (H::T) /\ (mem X B -&gt; false))
</pre>
<pre class="code extensibella"id="168">
 &lt; <b>M: case Or.</b>

Subgoal 2.1:

Variables: B T H
IH : forall A B,
       is_list is_lit A * -&gt; is_list is_lit B -&gt; (forall X, mem X A -&gt; mem X B) \/
       (exists X, mem X A /\ (mem X B -&gt; false))
IsB : is_list is_lit B
IsA : is_lit H
IsA1 : is_list is_lit T *
M : mem H B
============================
 (forall X, mem X (H::T) -&gt; mem X B) \/
 (exists X, mem X (H::T) /\ (mem X B -&gt; false))
</pre>
<pre class="code extensibella"id="169">
 &lt; <b>Or: apply IH to IsA1 IsB.</b>

Subgoal 2.1:

Variables: B T H
IH : forall A B,
       is_list is_lit A * -&gt; is_list is_lit B -&gt; (forall X, mem X A -&gt; mem X B) \/
       (exists X, mem X A /\ (mem X B -&gt; false))
IsB : is_list is_lit B
IsA : is_lit H
IsA1 : is_list is_lit T *
M : mem H B
Or : (forall X, mem X T -&gt; mem X B) \/ (exists X, mem X T /\ (mem X B -&gt; false))
============================
 (forall X, mem X (H::T) -&gt; mem X B) \/
 (exists X, mem X (H::T) /\ (mem X B -&gt; false))
</pre>
<pre class="code extensibella"id="170">
 &lt; <b>Sub: case Or.</b>

Subgoal 2.1.1:

Variables: B T H
IH : forall A B,
       is_list is_lit A * -&gt; is_list is_lit B -&gt; (forall X, mem X A -&gt; mem X B) \/
       (exists X, mem X A /\ (mem X B -&gt; false))
IsB : is_list is_lit B
IsA : is_lit H
IsA1 : is_list is_lit T *
M : mem H B
Sub : forall X, mem X T -&gt; mem X B
============================
 (forall X, mem X (H::T) -&gt; mem X B) \/
 (exists X, mem X (H::T) /\ (mem X B -&gt; false))
</pre>
<pre class="code extensibella"id="171">
 &lt; <b>left.</b>

Subgoal 2.1.1:

Variables: B T H
IH : forall A B,
       is_list is_lit A * -&gt; is_list is_lit B -&gt; (forall X, mem X A -&gt; mem X B) \/
       (exists X, mem X A /\ (mem X B -&gt; false))
IsB : is_list is_lit B
IsA : is_lit H
IsA1 : is_list is_lit T *
M : mem H B
Sub : forall X, mem X T -&gt; mem X B
============================
 forall X, mem X (H::T) -&gt; mem X B
</pre>
<pre class="code extensibella"id="172">
 &lt; <b>intros Mem.</b>

Subgoal 2.1.1:

Variables: B T H X
IH : forall A B,
       is_list is_lit A * -&gt; is_list is_lit B -&gt; (forall X, mem X A -&gt; mem X B) \/
       (exists X, mem X A /\ (mem X B -&gt; false))
IsB : is_list is_lit B
IsA : is_lit H
IsA1 : is_list is_lit T *
M : mem H B
Sub : forall X, mem X T -&gt; mem X B
Mem : mem X (H::T)
============================
 mem X B
</pre>
<pre class="code extensibella"id="173">
 &lt; <b>Mem: case Mem.</b>

Subgoal 2.1.1.1:

Variables: B T H
IH : forall A B,
       is_list is_lit A * -&gt; is_list is_lit B -&gt; (forall X, mem X A -&gt; mem X B) \/
       (exists X, mem X A /\ (mem X B -&gt; false))
IsB : is_list is_lit B
IsA : is_lit H
IsA1 : is_list is_lit T *
M : mem H B
Sub : forall X, mem X T -&gt; mem X B
============================
 mem H B
</pre>
<pre class="code extensibella"id="174">
 &lt; <b>search.</b>

Subgoal 2.1.1.2:

Variables: B T H X
IH : forall A B,
       is_list is_lit A * -&gt; is_list is_lit B -&gt; (forall X, mem X A -&gt; mem X B) \/
       (exists X, mem X A /\ (mem X B -&gt; false))
IsB : is_list is_lit B
IsA : is_lit H
IsA1 : is_list is_lit T *
M : mem H B
Sub : forall X, mem X T -&gt; mem X B
Mem : mem X T
============================
 mem X B
</pre>
<pre class="code extensibella"id="175">
 &lt; <b>backchain Sub.</b>

Subgoal 2.1.2:

Variables: B T H X
IH : forall A B,
       is_list is_lit A * -&gt; is_list is_lit B -&gt; (forall X, mem X A -&gt; mem X B) \/
       (exists X, mem X A /\ (mem X B -&gt; false))
IsB : is_list is_lit B
IsA : is_lit H
IsA1 : is_list is_lit T *
M : mem H B
Sub : mem X T
Sub1 : mem X B -&gt; false
============================
 (forall X, mem X (H::T) -&gt; mem X B) \/
 (exists X, mem X (H::T) /\ (mem X B -&gt; false))
</pre>
<pre class="code extensibella"id="176">
 &lt; <b>right.</b>

Subgoal 2.1.2:

Variables: B T H X
IH : forall A B,
       is_list is_lit A * -&gt; is_list is_lit B -&gt; (forall X, mem X A -&gt; mem X B) \/
       (exists X, mem X A /\ (mem X B -&gt; false))
IsB : is_list is_lit B
IsA : is_lit H
IsA1 : is_list is_lit T *
M : mem H B
Sub : mem X T
Sub1 : mem X B -&gt; false
============================
 exists X, mem X (H::T) /\ (mem X B -&gt; false)
</pre>
<pre class="code extensibella"id="177">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: B T H
IH : forall A B,
       is_list is_lit A * -&gt; is_list is_lit B -&gt; (forall X, mem X A -&gt; mem X B) \/
       (exists X, mem X A /\ (mem X B -&gt; false))
IsB : is_list is_lit B
IsA : is_lit H
IsA1 : is_list is_lit T *
M : mem H B -&gt; false
============================
 (forall X, mem X (H::T) -&gt; mem X B) \/
 (exists X, mem X (H::T) /\ (mem X B -&gt; false))
</pre>
<pre class="code extensibella"id="178">
 &lt; <b>right.</b>

Subgoal 2.2:

Variables: B T H
IH : forall A B,
       is_list is_lit A * -&gt; is_list is_lit B -&gt; (forall X, mem X A -&gt; mem X B) \/
       (exists X, mem X A /\ (mem X B -&gt; false))
IsB : is_list is_lit B
IsA : is_lit H
IsA1 : is_list is_lit T *
M : mem H B -&gt; false
============================
 exists X, mem X (H::T) /\ (mem X B -&gt; false)
</pre>
<pre class="code extensibella"id="179">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="180">
 &lt; <b>Theorem is_list_mem_lookup :
     forall Known ID C,
       is_list (is_pair is_integer is_clause) Known -&gt; mem (ID, C) Known -&gt; is_integer ID -&gt;
       exists C', lookup Known ID C'.</b>

============================
 forall Known ID C,
   is_list (is_pair is_integer is_clause) Known -&gt; mem (ID, C) Known -&gt; is_integer ID -&gt;
   exists C', lookup Known ID C'
</pre>
<pre class="code extensibella"id="181">
 &lt; <b>induction on 2.</b>

IH : forall Known ID C,
       is_list (is_pair is_integer is_clause) Known -&gt; mem (ID, C) Known * -&gt; is_integer ID -&gt;
       exists C', lookup Known ID C'
============================
 forall Known ID C,
   is_list (is_pair is_integer is_clause) Known -&gt; mem (ID, C) Known @ -&gt; is_integer ID -&gt;
   exists C', lookup Known ID C'
</pre>
<pre class="code extensibella"id="182">
 &lt; <b>intros IsK Mem IsID.</b>

Variables: Known ID C
IH : forall Known ID C,
       is_list (is_pair is_integer is_clause) Known -&gt; mem (ID, C) Known * -&gt; is_integer ID -&gt;
       exists C', lookup Known ID C'
IsK : is_list (is_pair is_integer is_clause) Known
Mem : mem (ID, C) Known @
IsID : is_integer ID
============================
 exists C', lookup Known ID C'
</pre>
<pre class="code extensibella"id="183">
 &lt; <b>Mem: case Mem.</b>

Subgoal 1:

Variables: ID C Rest
IH : forall Known ID C,
       is_list (is_pair is_integer is_clause) Known -&gt; mem (ID, C) Known * -&gt; is_integer ID -&gt;
       exists C', lookup Known ID C'
IsK : is_list (is_pair is_integer is_clause) ((ID, C)::Rest)
IsID : is_integer ID
============================
 exists C', lookup ((ID, C)::Rest) ID C'
</pre>
<pre class="code extensibella"id="184">
 &lt; <b>search.</b>

Subgoal 2:

Variables: ID C Rest I
IH : forall Known ID C,
       is_list (is_pair is_integer is_clause) Known -&gt; mem (ID, C) Known * -&gt; is_integer ID -&gt;
       exists C', lookup Known ID C'
IsK : is_list (is_pair is_integer is_clause) (I::Rest)
IsID : is_integer ID
Mem : mem (ID, C) Rest *
============================
 exists C', lookup (I::Rest) ID C'
</pre>
<pre class="code extensibella"id="185">
 &lt; <b>Is: case IsK.</b>

Subgoal 2:

Variables: ID C Rest I
IH : forall Known ID C,
       is_list (is_pair is_integer is_clause) Known -&gt; mem (ID, C) Known * -&gt; is_integer ID -&gt;
       exists C', lookup Known ID C'
IsID : is_integer ID
Mem : mem (ID, C) Rest *
Is : is_pair is_integer is_clause I
Is1 : is_list (is_pair is_integer is_clause) Rest
============================
 exists C', lookup (I::Rest) ID C'
</pre>
<pre class="code extensibella"id="186">
 &lt; <b>Is: case Is.</b>

Subgoal 2:

Variables: ID C Rest B A
IH : forall Known ID C,
       is_list (is_pair is_integer is_clause) Known -&gt; mem (ID, C) Known * -&gt; is_integer ID -&gt;
       exists C', lookup Known ID C'
IsID : is_integer ID
Mem : mem (ID, C) Rest *
Is1 : is_list (is_pair is_integer is_clause) Rest
Is : is_integer A
Is2 : is_clause B
============================
 exists C', lookup ((A, B)::Rest) ID C'
</pre>
<pre class="code extensibella"id="187">
 &lt; <b>Or: apply is_integer_eq_or_not to Is IsID.</b>

Subgoal 2:

Variables: ID C Rest B A
IH : forall Known ID C,
       is_list (is_pair is_integer is_clause) Known -&gt; mem (ID, C) Known * -&gt; is_integer ID -&gt;
       exists C', lookup Known ID C'
IsID : is_integer ID
Mem : mem (ID, C) Rest *
Is1 : is_list (is_pair is_integer is_clause) Rest
Is : is_integer A
Is2 : is_clause B
Or : A = ID \/ (A = ID -&gt; false)
============================
 exists C', lookup ((A, B)::Rest) ID C'
</pre>
<pre class="code extensibella"id="188">
 &lt; <b>Eq: case Or.</b>

Subgoal 2.1:

Variables: ID C Rest B
IH : forall Known ID C,
       is_list (is_pair is_integer is_clause) Known -&gt; mem (ID, C) Known * -&gt; is_integer ID -&gt;
       exists C', lookup Known ID C'
IsID : is_integer ID
Mem : mem (ID, C) Rest *
Is1 : is_list (is_pair is_integer is_clause) Rest
Is : is_integer ID
Is2 : is_clause B
============================
 exists C', lookup ((ID, B)::Rest) ID C'
</pre>
<pre class="code extensibella"id="189">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: ID C Rest B A
IH : forall Known ID C,
       is_list (is_pair is_integer is_clause) Known -&gt; mem (ID, C) Known * -&gt; is_integer ID -&gt;
       exists C', lookup Known ID C'
IsID : is_integer ID
Mem : mem (ID, C) Rest *
Is1 : is_list (is_pair is_integer is_clause) Rest
Is : is_integer A
Is2 : is_clause B
Eq : A = ID -&gt; false
============================
 exists C', lookup ((A, B)::Rest) ID C'
</pre>
<pre class="code extensibella"id="190">
 &lt; <b>apply IH to Is1 Mem IsID.</b>

Subgoal 2.2:

Variables: ID C Rest B A C'
IH : forall Known ID C,
       is_list (is_pair is_integer is_clause) Known -&gt; mem (ID, C) Known * -&gt; is_integer ID -&gt;
       exists C', lookup Known ID C'
IsID : is_integer ID
Mem : mem (ID, C) Rest *
Is1 : is_list (is_pair is_integer is_clause) Rest
Is : is_integer A
Is2 : is_clause B
Eq : A = ID -&gt; false
H1 : lookup Rest ID C'
============================
 exists C', lookup ((A, B)::Rest) ID C'
</pre>
<pre class="code extensibella"id="191">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="192">
 &lt; <b>Theorem lookup_is_value :
     forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; lookup K ID C -&gt; is_clause C.</b>

============================
 forall K ID C,
   is_list (is_pair is_integer is_clause) K -&gt; lookup K ID C -&gt; is_clause C
</pre>
<pre class="code extensibella"id="193">
 &lt; <b>induction on 2.</b>

IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; lookup K ID C * -&gt; is_clause C
============================
 forall K ID C,
   is_list (is_pair is_integer is_clause) K -&gt; lookup K ID C @ -&gt; is_clause C
</pre>
<pre class="code extensibella"id="194">
 &lt; <b>intros IsK Lkp.</b>

Variables: K ID C
IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; lookup K ID C * -&gt; is_clause C
IsK : is_list (is_pair is_integer is_clause) K
Lkp : lookup K ID C @
============================
 is_clause C
</pre>
<pre class="code extensibella"id="195">
 &lt; <b>Lkp: case Lkp.</b>

Subgoal 1:

Variables: ID C Rest
IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; lookup K ID C * -&gt; is_clause C
IsK : is_list (is_pair is_integer is_clause) ((ID, C)::Rest)
============================
 is_clause C
</pre>
<pre class="code extensibella"id="196">
 &lt; <b>Is: case IsK.</b>

Subgoal 1:

Variables: ID C Rest
IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; lookup K ID C * -&gt; is_clause C
Is : is_pair is_integer is_clause (ID, C)
Is1 : is_list (is_pair is_integer is_clause) Rest
============================
 is_clause C
</pre>
<pre class="code extensibella"id="197">
 &lt; <b>case Is.</b>

Subgoal 1:

Variables: ID C Rest
IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; lookup K ID C * -&gt; is_clause C
Is1 : is_list (is_pair is_integer is_clause) Rest
H1 : is_integer ID
H2 : is_clause C
============================
 is_clause C
</pre>
<pre class="code extensibella"id="198">
 &lt; <b>search.</b>

Subgoal 2:

Variables: ID C Rest V K1
IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; lookup K ID C * -&gt; is_clause C
IsK : is_list (is_pair is_integer is_clause) ((K1, V)::Rest)
Lkp : K1 = ID -&gt; false
Lkp1 : lookup Rest ID C *
============================
 is_clause C
</pre>
<pre class="code extensibella"id="199">
 &lt; <b>Is: case IsK.</b>

Subgoal 2:

Variables: ID C Rest V K1
IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; lookup K ID C * -&gt; is_clause C
Lkp : K1 = ID -&gt; false
Lkp1 : lookup Rest ID C *
Is : is_pair is_integer is_clause (K1, V)
Is1 : is_list (is_pair is_integer is_clause) Rest
============================
 is_clause C
</pre>
<pre class="code extensibella"id="200">
 &lt; <b>apply IH to Is1 Lkp1.</b>

Subgoal 2:

Variables: ID C Rest V K1
IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; lookup K ID C * -&gt; is_clause C
Lkp : K1 = ID -&gt; false
Lkp1 : lookup Rest ID C *
Is : is_pair is_integer is_clause (K1, V)
Is1 : is_list (is_pair is_integer is_clause) Rest
H1 : is_clause C
============================
 is_clause C
</pre>
<pre class="code extensibella"id="201">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="202">
 &lt; <b>Theorem lookup_is_key :
     forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; lookup K ID C -&gt; is_integer ID.</b>

============================
 forall K ID C,
   is_list (is_pair is_integer is_clause) K -&gt; lookup K ID C -&gt; is_integer ID
</pre>
<pre class="code extensibella"id="203">
 &lt; <b>induction on 2.</b>

IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; lookup K ID C * -&gt; is_integer ID
============================
 forall K ID C,
   is_list (is_pair is_integer is_clause) K -&gt; lookup K ID C @ -&gt; is_integer ID
</pre>
<pre class="code extensibella"id="204">
 &lt; <b>intros IsK Lkp.</b>

Variables: K ID C
IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; lookup K ID C * -&gt; is_integer ID
IsK : is_list (is_pair is_integer is_clause) K
Lkp : lookup K ID C @
============================
 is_integer ID
</pre>
<pre class="code extensibella"id="205">
 &lt; <b>Lkp: case Lkp.</b>

Subgoal 1:

Variables: ID C Rest
IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; lookup K ID C * -&gt; is_integer ID
IsK : is_list (is_pair is_integer is_clause) ((ID, C)::Rest)
============================
 is_integer ID
</pre>
<pre class="code extensibella"id="206">
 &lt; <b>Is: case IsK.</b>

Subgoal 1:

Variables: ID C Rest
IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; lookup K ID C * -&gt; is_integer ID
Is : is_pair is_integer is_clause (ID, C)
Is1 : is_list (is_pair is_integer is_clause) Rest
============================
 is_integer ID
</pre>
<pre class="code extensibella"id="207">
 &lt; <b>case Is.</b>

Subgoal 1:

Variables: ID C Rest
IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; lookup K ID C * -&gt; is_integer ID
Is1 : is_list (is_pair is_integer is_clause) Rest
H1 : is_integer ID
H2 : is_clause C
============================
 is_integer ID
</pre>
<pre class="code extensibella"id="208">
 &lt; <b>search.</b>

Subgoal 2:

Variables: ID C Rest V K1
IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; lookup K ID C * -&gt; is_integer ID
IsK : is_list (is_pair is_integer is_clause) ((K1, V)::Rest)
Lkp : K1 = ID -&gt; false
Lkp1 : lookup Rest ID C *
============================
 is_integer ID
</pre>
<pre class="code extensibella"id="209">
 &lt; <b>Is: case IsK.</b>

Subgoal 2:

Variables: ID C Rest V K1
IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; lookup K ID C * -&gt; is_integer ID
Lkp : K1 = ID -&gt; false
Lkp1 : lookup Rest ID C *
Is : is_pair is_integer is_clause (K1, V)
Is1 : is_list (is_pair is_integer is_clause) Rest
============================
 is_integer ID
</pre>
<pre class="code extensibella"id="210">
 &lt; <b>apply IH to Is1 Lkp1.</b>

Subgoal 2:

Variables: ID C Rest V K1
IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; lookup K ID C * -&gt; is_integer ID
Lkp : K1 = ID -&gt; false
Lkp1 : lookup Rest ID C *
Is : is_pair is_integer is_clause (K1, V)
Is1 : is_list (is_pair is_integer is_clause) Rest
H1 : is_integer ID
============================
 is_integer ID
</pre>
<pre class="code extensibella"id="211">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="212">
 &lt; <b>Theorem is_pair_eq_or_not :
     forall (PB : pair integer clause) (PA : pair integer clause),
       is_pair is_integer is_clause PA -&gt; is_pair is_integer is_clause PB -&gt; PA = PB \/
       (PA = PB -&gt; false).</b>

============================
 forall PB PA,
   is_pair is_integer is_clause PA -&gt; is_pair is_integer is_clause PB -&gt; PA = PB \/
   (PA = PB -&gt; false)
</pre>
<pre class="code extensibella"id="213">
 &lt; <b>intros IsPA IsPB.</b>

Variables: PB PA
IsPA : is_pair is_integer is_clause PA
IsPB : is_pair is_integer is_clause PB
============================
 PA = PB \/ (PA = PB -&gt; false)
</pre>
<pre class="code extensibella"id="214">
 &lt; <b>IsA: case IsPA.</b>

Variables: PB B A
IsPB : is_pair is_integer is_clause PB
IsA : is_integer A
IsA1 : is_clause B
============================
 (A, B) = PB \/ ((A, B) = PB -&gt; false)
</pre>
<pre class="code extensibella"id="215">
 &lt; <b>IsB: case IsPB.</b>

Variables: B A B1 A1
IsA : is_integer A
IsA1 : is_clause B
IsB : is_integer A1
IsB1 : is_clause B1
============================
 (A, B) = (A1, B1) \/ ((A, B) = (A1, B1) -&gt; false)
</pre>
<pre class="code extensibella"id="216">
 &lt; <b>Or: apply is_integer_eq_or_not to IsA IsB.</b>

Variables: B A B1 A1
IsA : is_integer A
IsA1 : is_clause B
IsB : is_integer A1
IsB1 : is_clause B1
Or : A = A1 \/ (A = A1 -&gt; false)
============================
 (A, B) = (A1, B1) \/ ((A, B) = (A1, B1) -&gt; false)
</pre>
<pre class="code extensibella"id="217">
 &lt; <b>Eq: case Or.</b>

Subgoal 1:

Variables: B B1 A1
IsA : is_integer A1
IsA1 : is_clause B
IsB : is_integer A1
IsB1 : is_clause B1
============================
 (A1, B) = (A1, B1) \/ ((A1, B) = (A1, B1) -&gt; false)
</pre>
<pre class="code extensibella"id="218">
 &lt; <b>Or: apply is_clause_eq_or_not to IsA1 IsB1.</b>

Subgoal 1:

Variables: B B1 A1
IsA : is_integer A1
IsA1 : is_clause B
IsB : is_integer A1
IsB1 : is_clause B1
Or : B = B1 \/ (B = B1 -&gt; false)
============================
 (A1, B) = (A1, B1) \/ ((A1, B) = (A1, B1) -&gt; false)
</pre>
<pre class="code extensibella"id="219">
 &lt; <b>Eq: case Or.</b>

Subgoal 1.1:

Variables: B1 A1
IsA : is_integer A1
IsA1 : is_clause B1
IsB : is_integer A1
IsB1 : is_clause B1
============================
 (A1, B1) = (A1, B1) \/ ((A1, B1) = (A1, B1) -&gt; false)
</pre>
<pre class="code extensibella"id="220">
 &lt; <b>search.</b>

Subgoal 1.2:

Variables: B B1 A1
IsA : is_integer A1
IsA1 : is_clause B
IsB : is_integer A1
IsB1 : is_clause B1
Eq : B = B1 -&gt; false
============================
 (A1, B) = (A1, B1) \/ ((A1, B) = (A1, B1) -&gt; false)
</pre>
<pre class="code extensibella"id="221">
 &lt; <b>right.</b>

Subgoal 1.2:

Variables: B B1 A1
IsA : is_integer A1
IsA1 : is_clause B
IsB : is_integer A1
IsB1 : is_clause B1
Eq : B = B1 -&gt; false
============================
 (A1, B) = (A1, B1) -&gt; false
</pre>
<pre class="code extensibella"id="222">
 &lt; <b>intros E.</b>

Subgoal 1.2:

Variables: B B1 A1
IsA : is_integer A1
IsA1 : is_clause B
IsB : is_integer A1
IsB1 : is_clause B1
Eq : B = B1 -&gt; false
E : (A1, B) = (A1, B1)
============================
 false
</pre>
<pre class="code extensibella"id="223">
 &lt; <b>case E.</b>

Subgoal 1.2:

Variables: B1 A1
IsA : is_integer A1
IsA1 : is_clause B1
IsB : is_integer A1
IsB1 : is_clause B1
Eq : B1 = B1 -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="224">
 &lt; <b>backchain Eq.</b>

Subgoal 2:

Variables: B A B1 A1
IsA : is_integer A
IsA1 : is_clause B
IsB : is_integer A1
IsB1 : is_clause B1
Eq : A = A1 -&gt; false
============================
 (A, B) = (A1, B1) \/ ((A, B) = (A1, B1) -&gt; false)
</pre>
<pre class="code extensibella"id="225">
 &lt; <b>right.</b>

Subgoal 2:

Variables: B A B1 A1
IsA : is_integer A
IsA1 : is_clause B
IsB : is_integer A1
IsB1 : is_clause B1
Eq : A = A1 -&gt; false
============================
 (A, B) = (A1, B1) -&gt; false
</pre>
<pre class="code extensibella"id="226">
 &lt; <b>intros E.</b>

Subgoal 2:

Variables: B A B1 A1
IsA : is_integer A
IsA1 : is_clause B
IsB : is_integer A1
IsB1 : is_clause B1
Eq : A = A1 -&gt; false
E : (A, B) = (A1, B1)
============================
 false
</pre>
<pre class="code extensibella"id="227">
 &lt; <b>case E.</b>

Subgoal 2:

Variables: B1 A1
IsA : is_integer A1
IsA1 : is_clause B1
IsB : is_integer A1
IsB1 : is_clause B1
Eq : A1 = A1 -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="228">
 &lt; <b>backchain Eq.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="229">
 &lt; <b>Theorem is_count_exists :
     forall L IDC,
       is_list (is_pair is_integer is_clause) L -&gt; is_pair is_integer is_clause IDC -&gt;
       exists N, count IDC L N.</b>

============================
 forall L IDC,
   is_list (is_pair is_integer is_clause) L -&gt; is_pair is_integer is_clause IDC -&gt;
   exists N, count IDC L N
</pre>
<pre class="code extensibella"id="230">
 &lt; <b>induction on 1.</b>

IH : forall L IDC,
       is_list (is_pair is_integer is_clause) L * -&gt; is_pair is_integer is_clause IDC -&gt;
       exists N, count IDC L N
============================
 forall L IDC,
   is_list (is_pair is_integer is_clause) L @ -&gt; is_pair is_integer is_clause IDC -&gt;
   exists N, count IDC L N
</pre>
<pre class="code extensibella"id="231">
 &lt; <b>intros IsL IsIDC.</b>

Variables: L IDC
IH : forall L IDC,
       is_list (is_pair is_integer is_clause) L * -&gt; is_pair is_integer is_clause IDC -&gt;
       exists N, count IDC L N
IsL : is_list (is_pair is_integer is_clause) L @
IsIDC : is_pair is_integer is_clause IDC
============================
 exists N, count IDC L N
</pre>
<pre class="code extensibella"id="232">
 &lt; <b>Is: case IsL.</b>

Subgoal 1:

Variables: IDC
IH : forall L IDC,
       is_list (is_pair is_integer is_clause) L * -&gt; is_pair is_integer is_clause IDC -&gt;
       exists N, count IDC L N
IsIDC : is_pair is_integer is_clause IDC
============================
 exists N, count IDC [] N
</pre>
<pre class="code extensibella"id="233">
 &lt; <b>search.</b>

Subgoal 2:

Variables: IDC T H
IH : forall L IDC,
       is_list (is_pair is_integer is_clause) L * -&gt; is_pair is_integer is_clause IDC -&gt;
       exists N, count IDC L N
IsIDC : is_pair is_integer is_clause IDC
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
============================
 exists N, count IDC (H::T) N
</pre>
<pre class="code extensibella"id="234">
 &lt; <b>Or: apply is_pair_eq_or_not to IsIDC Is.</b>

Subgoal 2:

Variables: IDC T H
IH : forall L IDC,
       is_list (is_pair is_integer is_clause) L * -&gt; is_pair is_integer is_clause IDC -&gt;
       exists N, count IDC L N
IsIDC : is_pair is_integer is_clause IDC
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
Or : IDC = H \/ (IDC = H -&gt; false)
============================
 exists N, count IDC (H::T) N
</pre>
<pre class="code extensibella"id="235">
 &lt; <b>C: apply IH to Is1 IsIDC.</b>

Subgoal 2:

Variables: IDC T H N
IH : forall L IDC,
       is_list (is_pair is_integer is_clause) L * -&gt; is_pair is_integer is_clause IDC -&gt;
       exists N, count IDC L N
IsIDC : is_pair is_integer is_clause IDC
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
Or : IDC = H \/ (IDC = H -&gt; false)
C : count IDC T N
============================
 exists N, count IDC (H::T) N
</pre>
<pre class="code extensibella"id="236">
 &lt; <b>Eq: case Or.</b>

Subgoal 2.1:

Variables: T H N
IH : forall L IDC,
       is_list (is_pair is_integer is_clause) L * -&gt; is_pair is_integer is_clause IDC -&gt;
       exists N, count IDC L N
IsIDC : is_pair is_integer is_clause H
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
C : count H T N
============================
 exists N, count H (H::T) N
</pre>
<pre class="code extensibella"id="237">
 &lt; <b>IsN: apply count_is_integer to C.</b>

Subgoal 2.1:

Variables: T H N
IH : forall L IDC,
       is_list (is_pair is_integer is_clause) L * -&gt; is_pair is_integer is_clause IDC -&gt;
       exists N, count IDC L N
IsIDC : is_pair is_integer is_clause H
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
C : count H T N
IsN : is_integer N
============================
 exists N, count H (H::T) N
</pre>
<pre class="code extensibella"id="238">
 &lt; <b>apply plus_integer_total to _ IsN with
     N1 = 1.</b>

Subgoal 2.1:

Variables: T H N N3
IH : forall L IDC,
       is_list (is_pair is_integer is_clause) L * -&gt; is_pair is_integer is_clause IDC -&gt;
       exists N, count IDC L N
IsIDC : is_pair is_integer is_clause H
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
C : count H T N
IsN : is_integer N
H1 : 1 + N = N3
============================
 exists N, count H (H::T) N
</pre>
<pre class="code extensibella"id="239">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: IDC T H N
IH : forall L IDC,
       is_list (is_pair is_integer is_clause) L * -&gt; is_pair is_integer is_clause IDC -&gt;
       exists N, count IDC L N
IsIDC : is_pair is_integer is_clause IDC
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
C : count IDC T N
Eq : IDC = H -&gt; false
============================
 exists N, count IDC (H::T) N
</pre>
<pre class="code extensibella"id="240">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="241">
 &lt; <b>Theorem all_count_0_nil :
     forall L,
       is_list (is_pair is_integer is_clause) L -&gt; (forall X N,
         count X L N -&gt; N = 0) -&gt; L = [].</b>

============================
 forall L,
   is_list (is_pair is_integer is_clause) L -&gt; (forall X N,
     count X L N -&gt; N = 0) -&gt; L = []
</pre>
<pre class="code extensibella"id="242">
 &lt; <b>intros IsL Count0.</b>

Variables: L
IsL : is_list (is_pair is_integer is_clause) L
Count0 : forall X N, count X L N -&gt; N = 0
============================
 L = []
</pre>
<pre class="code extensibella"id="243">
 &lt; <b>Is: case IsL.</b>

Subgoal 1:

Count0 : forall X N, count X [] N -&gt; N = 0
============================
 [] = []
</pre>
<pre class="code extensibella"id="244">
 &lt; <b>search.</b>

Subgoal 2:

Variables: T H
Count0 : forall X N, count X (H::T) N -&gt; N = 0
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T
============================
 H::T = []
</pre>
<pre class="code extensibella"id="245">
 &lt; <b>C: apply is_count_exists to Is1 Is.</b>

Subgoal 2:

Variables: T H N
Count0 : forall X N, count X (H::T) N -&gt; N = 0
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T
C : count H T N
============================
 H::T = []
</pre>
<pre class="code extensibella"id="246">
 &lt; <b>IsN: apply count_is_integer to C.</b>

Subgoal 2:

Variables: T H N
Count0 : forall X N, count X (H::T) N -&gt; N = 0
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T
C : count H T N
IsN : is_integer N
============================
 H::T = []
</pre>
<pre class="code extensibella"id="247">
 &lt; <b>P: apply plus_integer_total to _ IsN with
        N1 = 1.</b>

Subgoal 2:

Variables: T H N N3
Count0 : forall X N, count X (H::T) N -&gt; N = 0
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T
C : count H T N
IsN : is_integer N
P : 1 + N = N3
============================
 H::T = []
</pre>
<pre class="code extensibella"id="248">
 &lt; <b>C': assert count H (H::T) N3.</b>

Subgoal 2:

Variables: T H N N3
Count0 : forall X N, count X (H::T) N -&gt; N = 0
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T
C : count H T N
IsN : is_integer N
P : 1 + N = N3
C' : count H (H::T) N3
============================
 H::T = []
</pre>
<pre class="code extensibella"id="249">
 &lt; <b>apply Count0 to C'.</b>

Subgoal 2:

Variables: T H N
Count0 : forall X N, count X (H::T) N -&gt; N = 0
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T
C : count H T N
IsN : is_integer N
P : 1 + N = 0
C' : count H (H::T) 0
============================
 H::T = []
</pre>
<pre class="code extensibella"id="250">
 &lt; <b>GEq: apply count_geq_0 to C.</b>

Subgoal 2:

Variables: T H N
Count0 : forall X N, count X (H::T) N -&gt; N = 0
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T
C : count H T N
IsN : is_integer N
P : 1 + N = 0
C' : count H (H::T) 0
GEq : N &gt;= 0
============================
 H::T = []
</pre>
<pre class="code extensibella"id="251">
 &lt; <b>Or: apply greatereq_integer_greater_or_eq to GEq.</b>

Subgoal 2:

Variables: T H N
Count0 : forall X N, count X (H::T) N -&gt; N = 0
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T
C : count H T N
IsN : is_integer N
P : 1 + N = 0
C' : count H (H::T) 0
GEq : N &gt;= 0
Or : N &gt; 0 \/ N = 0
============================
 H::T = []
</pre>
<pre class="code extensibella"id="252">
 &lt; <b>L: case Or.</b>

Subgoal 2.1:

Variables: T H N
Count0 : forall X N, count X (H::T) N -&gt; N = 0
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T
C : count H T N
IsN : is_integer N
P : 1 + N = 0
C' : count H (H::T) 0
GEq : N &gt;= 0
L : N &gt; 0
============================
 H::T = []
</pre>
<pre class="code extensibella"id="253">
 &lt; <b>G: apply greater_plus_positive to _ _ P _.</b>

Subgoal 2.1:

Variables: T H N
Count0 : forall X N, count X (H::T) N -&gt; N = 0
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T
C : count H T N
IsN : is_integer N
P : 1 + N = 0
C' : count H (H::T) 0
GEq : N &gt;= 0
L : N &gt; 0
G : 0 &gt; 1
============================
 H::T = []
</pre>
<pre class="code extensibella"id="254">
 &lt; <b>L': assert 0 &lt; 1.</b>

Subgoal 2.1:

Variables: T H N
Count0 : forall X N, count X (H::T) N -&gt; N = 0
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T
C : count H T N
IsN : is_integer N
P : 1 + N = 0
C' : count H (H::T) 0
GEq : N &gt;= 0
L : N &gt; 0
G : 0 &gt; 1
L' : 0 &lt; 1
============================
 H::T = []
</pre>
<pre class="code extensibella"id="255">
 &lt; <b>apply greater_less_impossible to G L'.</b>

Subgoal 2.2:

Variables: T H
Count0 : forall X N, count X (H::T) N -&gt; N = 0
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T
C : count H T 0
IsN : is_integer 0
P : 1 + 0 = 0
C' : count H (H::T) 0
GEq : 0 &gt;= 0
============================
 H::T = []
</pre>
<pre class="code extensibella"id="256">
 &lt; <b>case P.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="257">
 &lt; <b>Theorem counts_permutation :
     forall L P,
       is_list (is_pair is_integer is_clause) L -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P.</b>

============================
 forall L P,
   is_list (is_pair is_integer is_clause) L -&gt; is_list (is_pair is_integer is_clause) P -&gt;
   (forall X NL NP,
     is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
   permutation L P
</pre>
<pre class="code extensibella"id="258">
 &lt; <b>induction on 1.</b>

IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
============================
 forall L P,
   is_list (is_pair is_integer is_clause) L @ -&gt; is_list (is_pair is_integer is_clause) P -&gt;
   (forall X NL NP,
     is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
   permutation L P
</pre>
<pre class="code extensibella"id="259">
 &lt; <b>intros IsL IsP Same.</b>

Variables: L P
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) L @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP
============================
 permutation L P
</pre>
<pre class="code extensibella"id="260">
 &lt; <b>Is: case IsL (keep).</b>

Subgoal 1:

Variables: P
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) [] @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X [] NL -&gt; count X P NP -&gt; NL = NP
============================
 permutation [] P
</pre>
<pre class="code extensibella"id="261">
 &lt; <b>IsP': case IsP (keep).</b>

Subgoal 1.1:

IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) [] @
IsP : is_list (is_pair is_integer is_clause) []
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X [] NL -&gt; count X [] NP -&gt; NL = NP
============================
 permutation [] []
</pre>
<pre class="code extensibella"id="262">
 &lt; <b>search.</b>

Subgoal 1.2:

Variables: T H
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) [] @
IsP : is_list (is_pair is_integer is_clause) (H::T)
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X [] NL -&gt; count X (H::T) NP -&gt;
         NL = NP
IsP' : is_pair is_integer is_clause H
IsP'1 : is_list (is_pair is_integer is_clause) T
============================
 permutation [] (H::T)
</pre>
<pre class="code extensibella"id="263">
 &lt; <b>CL: assert count H [] 0.</b>

Subgoal 1.2:

Variables: T H
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) [] @
IsP : is_list (is_pair is_integer is_clause) (H::T)
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X [] NL -&gt; count X (H::T) NP -&gt;
         NL = NP
IsP' : is_pair is_integer is_clause H
IsP'1 : is_list (is_pair is_integer is_clause) T
CL : count H [] 0
============================
 permutation [] (H::T)
</pre>
<pre class="code extensibella"id="264">
 &lt; <b>CP: apply is_count_exists to IsP IsP'.</b>

Subgoal 1.2:

Variables: T H N
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) [] @
IsP : is_list (is_pair is_integer is_clause) (H::T)
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X [] NL -&gt; count X (H::T) NP -&gt;
         NL = NP
IsP' : is_pair is_integer is_clause H
IsP'1 : is_list (is_pair is_integer is_clause) T
CL : count H [] 0
CP : count H (H::T) N
============================
 permutation [] (H::T)
</pre>
<pre class="code extensibella"id="265">
 &lt; <b>apply Same to _ CL CP.</b>

Subgoal 1.2:

Variables: T H
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) [] @
IsP : is_list (is_pair is_integer is_clause) (H::T)
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X [] NL -&gt; count X (H::T) NP -&gt;
         NL = NP
IsP' : is_pair is_integer is_clause H
IsP'1 : is_list (is_pair is_integer is_clause) T
CL : count H [] 0
CP : count H (H::T) 0
============================
 permutation [] (H::T)
</pre>
<pre class="code extensibella"id="266">
 &lt; <b>CP: case CP.</b>

Subgoal 1.2.1:

Variables: T H N1
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) [] @
IsP : is_list (is_pair is_integer is_clause) (H::T)
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X [] NL -&gt; count X (H::T) NP -&gt;
         NL = NP
IsP' : is_pair is_integer is_clause H
IsP'1 : is_list (is_pair is_integer is_clause) T
CL : count H [] 0
CP : count H T N1
CP1 : 1 + N1 = 0
============================
 permutation [] (H::T)
</pre>
<pre class="code extensibella"id="267">
 &lt; <b>GEq: apply count_geq_0 to CP.</b>

Subgoal 1.2.1:

Variables: T H N1
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) [] @
IsP : is_list (is_pair is_integer is_clause) (H::T)
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X [] NL -&gt; count X (H::T) NP -&gt;
         NL = NP
IsP' : is_pair is_integer is_clause H
IsP'1 : is_list (is_pair is_integer is_clause) T
CL : count H [] 0
CP : count H T N1
CP1 : 1 + N1 = 0
GEq : N1 &gt;= 0
============================
 permutation [] (H::T)
</pre>
<pre class="code extensibella"id="268">
 &lt; <b>Or: apply greatereq_integer_greater_or_eq to GEq.</b>

Subgoal 1.2.1:

Variables: T H N1
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) [] @
IsP : is_list (is_pair is_integer is_clause) (H::T)
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X [] NL -&gt; count X (H::T) NP -&gt;
         NL = NP
IsP' : is_pair is_integer is_clause H
IsP'1 : is_list (is_pair is_integer is_clause) T
CL : count H [] 0
CP : count H T N1
CP1 : 1 + N1 = 0
GEq : N1 &gt;= 0
Or : N1 &gt; 0 \/ N1 = 0
============================
 permutation [] (H::T)
</pre>
<pre class="code extensibella"id="269">
 &lt; <b>E: case Or.</b>

Subgoal 1.2.1.1:

Variables: T H N1
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) [] @
IsP : is_list (is_pair is_integer is_clause) (H::T)
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X [] NL -&gt; count X (H::T) NP -&gt;
         NL = NP
IsP' : is_pair is_integer is_clause H
IsP'1 : is_list (is_pair is_integer is_clause) T
CL : count H [] 0
CP : count H T N1
CP1 : 1 + N1 = 0
GEq : N1 &gt;= 0
E : N1 &gt; 0
============================
 permutation [] (H::T)
</pre>
<pre class="code extensibella"id="270">
 &lt; <b>IsN1: apply count_is_integer to CP.</b>

Subgoal 1.2.1.1:

Variables: T H N1
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) [] @
IsP : is_list (is_pair is_integer is_clause) (H::T)
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X [] NL -&gt; count X (H::T) NP -&gt;
         NL = NP
IsP' : is_pair is_integer is_clause H
IsP'1 : is_list (is_pair is_integer is_clause) T
CL : count H [] 0
CP : count H T N1
CP1 : 1 + N1 = 0
GEq : N1 &gt;= 0
E : N1 &gt; 0
IsN1 : is_integer N1
============================
 permutation [] (H::T)
</pre>
<pre class="code extensibella"id="271">
 &lt; <b>G: apply greater_plus_positive to _ _ CP1 _.</b>

Subgoal 1.2.1.1:

Variables: T H N1
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) [] @
IsP : is_list (is_pair is_integer is_clause) (H::T)
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X [] NL -&gt; count X (H::T) NP -&gt;
         NL = NP
IsP' : is_pair is_integer is_clause H
IsP'1 : is_list (is_pair is_integer is_clause) T
CL : count H [] 0
CP : count H T N1
CP1 : 1 + N1 = 0
GEq : N1 &gt;= 0
E : N1 &gt; 0
IsN1 : is_integer N1
G : 0 &gt; 1
============================
 permutation [] (H::T)
</pre>
<pre class="code extensibella"id="272">
 &lt; <b>L: assert 0 &lt; 1.</b>

Subgoal 1.2.1.1:

Variables: T H N1
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) [] @
IsP : is_list (is_pair is_integer is_clause) (H::T)
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X [] NL -&gt; count X (H::T) NP -&gt;
         NL = NP
IsP' : is_pair is_integer is_clause H
IsP'1 : is_list (is_pair is_integer is_clause) T
CL : count H [] 0
CP : count H T N1
CP1 : 1 + N1 = 0
GEq : N1 &gt;= 0
E : N1 &gt; 0
IsN1 : is_integer N1
G : 0 &gt; 1
L : 0 &lt; 1
============================
 permutation [] (H::T)
</pre>
<pre class="code extensibella"id="273">
 &lt; <b>apply greater_less_impossible to G L.</b>

Subgoal 1.2.1.2:

Variables: T H
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) [] @
IsP : is_list (is_pair is_integer is_clause) (H::T)
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X [] NL -&gt; count X (H::T) NP -&gt;
         NL = NP
IsP' : is_pair is_integer is_clause H
IsP'1 : is_list (is_pair is_integer is_clause) T
CL : count H [] 0
CP : count H T 0
CP1 : 1 + 0 = 0
GEq : 0 &gt;= 0
============================
 permutation [] (H::T)
</pre>
<pre class="code extensibella"id="274">
 &lt; <b>case CP1.</b>

Subgoal 1.2.2:

Variables: T H
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) [] @
IsP : is_list (is_pair is_integer is_clause) (H::T)
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X [] NL -&gt; count X (H::T) NP -&gt;
         NL = NP
IsP' : is_pair is_integer is_clause H
IsP'1 : is_list (is_pair is_integer is_clause) T
CL : count H [] 0
CP : H = H -&gt; false
CP1 : count H T 0
============================
 permutation [] (H::T)
</pre>
<pre class="code extensibella"id="275">
 &lt; <b>apply CP to _.</b>

Subgoal 2:

Variables: P T H
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (H::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X (H::T) NL -&gt; count X P NP -&gt; NL = NP
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
============================
 permutation (H::T) P
</pre>
<pre class="code extensibella"id="276">
 &lt; <b>CLH: apply is_count_exists to IsL Is.</b>

Subgoal 2:

Variables: P T H N
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (H::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X (H::T) NL -&gt; count X P NP -&gt; NL = NP
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count H (H::T) N
============================
 permutation (H::T) P
</pre>
<pre class="code extensibella"id="277">
 &lt; <b>CPH: apply is_count_exists to IsP Is.</b>

Subgoal 2:

Variables: P T H N N1
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (H::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X (H::T) NL -&gt; count X P NP -&gt; NL = NP
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count H (H::T) N
CPH : count H P N1
============================
 permutation (H::T) P
</pre>
<pre class="code extensibella"id="278">
 &lt; <b>G: apply count_greater_0 to CLH.</b>

Subgoal 2:

Variables: P T H N N1
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (H::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X (H::T) NL -&gt; count X P NP -&gt; NL = NP
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count H (H::T) N
CPH : count H P N1
G : N &gt; 0
============================
 permutation (H::T) P
</pre>
<pre class="code extensibella"id="279">
 &lt; <b>apply Same to _ CLH CPH.</b>

Subgoal 2:

Variables: P T H N1
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (H::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X (H::T) NL -&gt; count X P NP -&gt; NL = NP
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count H (H::T) N1
CPH : count H P N1
G : N1 &gt; 0
============================
 permutation (H::T) P
</pre>
<pre class="code extensibella"id="280">
 &lt; <b>M: apply count_mem to CPH G.</b>

Subgoal 2:

Variables: P T H N1
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (H::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X (H::T) NL -&gt; count X P NP -&gt; NL = NP
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count H (H::T) N1
CPH : count H P N1
G : N1 &gt; 0
M : mem H P
============================
 permutation (H::T) P
</pre>
<pre class="code extensibella"id="281">
 &lt; <b>S: apply mem_select to M.</b>

Subgoal 2:

Variables: P T H N1 L'
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (H::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X (H::T) NL -&gt; count X P NP -&gt; NL = NP
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count H (H::T) N1
CPH : count H P N1
G : N1 &gt; 0
M : mem H P
S : select H L' P
============================
 permutation (H::T) P
</pre>
<pre class="code extensibella"id="282">
 &lt; <b>IsL': assert is_list (is_pair is_integer is_clause) L'.</b>

Subgoal 2.1:

Variables: P T H N1 L'
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (H::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X (H::T) NL -&gt; count X P NP -&gt; NL = NP
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count H (H::T) N1
CPH : count H P N1
G : N1 &gt; 0
M : mem H P
S : select H L' P
============================
 is_list (is_pair is_integer is_clause) L'
</pre>
<pre class="code extensibella"id="283">
 &lt; <b>case Is.</b>

Subgoal 2.1:

Variables: P T N1 L' B A
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) ((A, B)::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X ((A, B)::T) NL -&gt; count X P NP -&gt;
         NL = NP
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count (A, B) ((A, B)::T) N1
CPH : count (A, B) P N1
G : N1 &gt; 0
M : mem (A, B) P
S : select (A, B) L' P
H1 : is_integer A
H2 : is_clause B
============================
 is_list (is_pair is_integer is_clause) L'
</pre>
<pre class="code extensibella"id="284">
 &lt; <b>apply select_is to _ S.</b>

Subgoal 2.1:

Variables: P T N1 L' B A
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) ((A, B)::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X ((A, B)::T) NL -&gt; count X P NP -&gt;
         NL = NP
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count (A, B) ((A, B)::T) N1
CPH : count (A, B) P N1
G : N1 &gt; 0
M : mem (A, B) P
S : select (A, B) L' P
H1 : is_integer A
H2 : is_clause B
H3 : is_list (is_pair is_integer is_clause) L'
============================
 is_list (is_pair is_integer is_clause) L'
</pre>
<pre class="code extensibella"id="285">
 &lt; <b>search.</b>

Subgoal 2:

Variables: P T H N1 L'
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (H::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X (H::T) NL -&gt; count X P NP -&gt; NL = NP
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count H (H::T) N1
CPH : count H P N1
G : N1 &gt; 0
M : mem H P
S : select H L' P
IsL' : is_list (is_pair is_integer is_clause) L'
============================
 permutation (H::T) P
</pre>
<pre class="code extensibella"id="286">
 &lt; <b>assert forall X NL NP,
     is_pair is_integer is_clause X -&gt; count X T NL -&gt; count X L' NP -&gt; NL = NP.</b>

Subgoal 2.2:

Variables: P T H N1 L'
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (H::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X (H::T) NL -&gt; count X P NP -&gt; NL = NP
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count H (H::T) N1
CPH : count H P N1
G : N1 &gt; 0
M : mem H P
S : select H L' P
IsL' : is_list (is_pair is_integer is_clause) L'
============================
 forall X NL NP,
   is_pair is_integer is_clause X -&gt; count X T NL -&gt; count X L' NP -&gt; NL = NP
</pre>
<pre class="code extensibella"id="287">
 &lt; <b>intros IsX CT CL'.</b>

Subgoal 2.2:

Variables: P T H N1 L' X NL NP
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (H::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X (H::T) NL -&gt; count X P NP -&gt; NL = NP
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count H (H::T) N1
CPH : count H P N1
G : N1 &gt; 0
M : mem H P
S : select H L' P
IsL' : is_list (is_pair is_integer is_clause) L'
IsX : is_pair is_integer is_clause X
CT : count X T NL
CL' : count X L' NP
============================
 NL = NP
</pre>
<pre class="code extensibella"id="288">
 &lt; <b>Or: apply is_pair_eq_or_not to Is IsX.</b>

Subgoal 2.2:

Variables: P T H N1 L' X NL NP
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (H::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X (H::T) NL -&gt; count X P NP -&gt; NL = NP
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count H (H::T) N1
CPH : count H P N1
G : N1 &gt; 0
M : mem H P
S : select H L' P
IsL' : is_list (is_pair is_integer is_clause) L'
IsX : is_pair is_integer is_clause X
CT : count X T NL
CL' : count X L' NP
Or : H = X \/ (H = X -&gt; false)
============================
 NL = NP
</pre>
<pre class="code extensibella"id="289">
 &lt; <b>E: case Or.</b>

Subgoal 2.2.1:

Variables: P T N1 L' X NL NP
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (X::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X1 NL NP,
         is_pair is_integer is_clause X1 -&gt; count X1 (X::T) NL -&gt; count X1 P NP -&gt;
         NL = NP
Is : is_pair is_integer is_clause X
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count X (X::T) N1
CPH : count X P N1
G : N1 &gt; 0
M : mem X P
S : select X L' P
IsL' : is_list (is_pair is_integer is_clause) L'
IsX : is_pair is_integer is_clause X
CT : count X T NL
CL' : count X L' NP
============================
 NL = NP
</pre>
<pre class="code extensibella"id="290">
 &lt; <b>IsNP: apply count_is_integer to CL'.</b>

Subgoal 2.2.1:

Variables: P T N1 L' X NL NP
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (X::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X1 NL NP,
         is_pair is_integer is_clause X1 -&gt; count X1 (X::T) NL -&gt; count X1 P NP -&gt;
         NL = NP
Is : is_pair is_integer is_clause X
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count X (X::T) N1
CPH : count X P N1
G : N1 &gt; 0
M : mem X P
S : select X L' P
IsL' : is_list (is_pair is_integer is_clause) L'
IsX : is_pair is_integer is_clause X
CT : count X T NL
CL' : count X L' NP
IsNP : is_integer NP
============================
 NL = NP
</pre>
<pre class="code extensibella"id="291">
 &lt; <b>PlusNP: apply plus_integer_total to _ IsNP with
             N1 = 1.</b>

Subgoal 2.2.1:

Variables: P T N1 L' X NL NP N3
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (X::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X1 NL NP,
         is_pair is_integer is_clause X1 -&gt; count X1 (X::T) NL -&gt; count X1 P NP -&gt;
         NL = NP
Is : is_pair is_integer is_clause X
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count X (X::T) N1
CPH : count X P N1
G : N1 &gt; 0
M : mem X P
S : select X L' P
IsL' : is_list (is_pair is_integer is_clause) L'
IsX : is_pair is_integer is_clause X
CT : count X T NL
CL' : count X L' NP
IsNP : is_integer NP
PlusNP : 1 + NP = N3
============================
 NL = NP
</pre>
<pre class="code extensibella"id="292">
 &lt; <b>CXP: apply count_select to CL' S PlusNP.</b>

Subgoal 2.2.1:

Variables: P T N1 L' X NL NP N3
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (X::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X1 NL NP,
         is_pair is_integer is_clause X1 -&gt; count X1 (X::T) NL -&gt; count X1 P NP -&gt;
         NL = NP
Is : is_pair is_integer is_clause X
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count X (X::T) N1
CPH : count X P N1
G : N1 &gt; 0
M : mem X P
S : select X L' P
IsL' : is_list (is_pair is_integer is_clause) L'
IsX : is_pair is_integer is_clause X
CT : count X T NL
CL' : count X L' NP
IsNP : is_integer NP
PlusNP : 1 + NP = N3
CXP : count X P N3
============================
 NL = NP
</pre>
<pre class="code extensibella"id="293">
 &lt; <b>IsNL: apply count_is_integer to CT.</b>

Subgoal 2.2.1:

Variables: P T N1 L' X NL NP N3
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (X::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X1 NL NP,
         is_pair is_integer is_clause X1 -&gt; count X1 (X::T) NL -&gt; count X1 P NP -&gt;
         NL = NP
Is : is_pair is_integer is_clause X
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count X (X::T) N1
CPH : count X P N1
G : N1 &gt; 0
M : mem X P
S : select X L' P
IsL' : is_list (is_pair is_integer is_clause) L'
IsX : is_pair is_integer is_clause X
CT : count X T NL
CL' : count X L' NP
IsNP : is_integer NP
PlusNP : 1 + NP = N3
CXP : count X P N3
IsNL : is_integer NL
============================
 NL = NP
</pre>
<pre class="code extensibella"id="294">
 &lt; <b>PlusNL: apply plus_integer_total to _ IsNL with
             N1 = 1.</b>

Subgoal 2.2.1:

Variables: P T N1 L' X NL NP N3 N2
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (X::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X1 NL NP,
         is_pair is_integer is_clause X1 -&gt; count X1 (X::T) NL -&gt; count X1 P NP -&gt;
         NL = NP
Is : is_pair is_integer is_clause X
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count X (X::T) N1
CPH : count X P N1
G : N1 &gt; 0
M : mem X P
S : select X L' P
IsL' : is_list (is_pair is_integer is_clause) L'
IsX : is_pair is_integer is_clause X
CT : count X T NL
CL' : count X L' NP
IsNP : is_integer NP
PlusNP : 1 + NP = N3
CXP : count X P N3
IsNL : is_integer NL
PlusNL : 1 + NL = N2
============================
 NL = NP
</pre>
<pre class="code extensibella"id="295">
 &lt; <b>CXL: assert count X (X::T) N2.</b>

Subgoal 2.2.1:

Variables: P T N1 L' X NL NP N3 N2
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (X::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X1 NL NP,
         is_pair is_integer is_clause X1 -&gt; count X1 (X::T) NL -&gt; count X1 P NP -&gt;
         NL = NP
Is : is_pair is_integer is_clause X
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count X (X::T) N1
CPH : count X P N1
G : N1 &gt; 0
M : mem X P
S : select X L' P
IsL' : is_list (is_pair is_integer is_clause) L'
IsX : is_pair is_integer is_clause X
CT : count X T NL
CL' : count X L' NP
IsNP : is_integer NP
PlusNP : 1 + NP = N3
CXP : count X P N3
IsNL : is_integer NL
PlusNL : 1 + NL = N2
CXL : count X (X::T) N2
============================
 NL = NP
</pre>
<pre class="code extensibella"id="296">
 &lt; <b>apply Same to _ CXL CXP.</b>

Subgoal 2.2.1:

Variables: P T N1 L' X NL NP N3
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (X::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X1 NL NP,
         is_pair is_integer is_clause X1 -&gt; count X1 (X::T) NL -&gt; count X1 P NP -&gt;
         NL = NP
Is : is_pair is_integer is_clause X
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count X (X::T) N1
CPH : count X P N1
G : N1 &gt; 0
M : mem X P
S : select X L' P
IsL' : is_list (is_pair is_integer is_clause) L'
IsX : is_pair is_integer is_clause X
CT : count X T NL
CL' : count X L' NP
IsNP : is_integer NP
PlusNP : 1 + NP = N3
CXP : count X P N3
IsNL : is_integer NL
PlusNL : 1 + NL = N3
CXL : count X (X::T) N3
============================
 NL = NP
</pre>
<pre class="code extensibella"id="297">
 &lt; <b>P: apply plus_integer_comm to _ _ PlusNP.</b>

Subgoal 2.2.1:

Variables: P T N1 L' X NL NP N3
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (X::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X1 NL NP,
         is_pair is_integer is_clause X1 -&gt; count X1 (X::T) NL -&gt; count X1 P NP -&gt;
         NL = NP
Is : is_pair is_integer is_clause X
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count X (X::T) N1
CPH : count X P N1
G : N1 &gt; 0
M : mem X P
S : select X L' P
IsL' : is_list (is_pair is_integer is_clause) L'
IsX : is_pair is_integer is_clause X
CT : count X T NL
CL' : count X L' NP
IsNP : is_integer NP
PlusNP : 1 + NP = N3
CXP : count X P N3
IsNL : is_integer NL
PlusNL : 1 + NL = N3
CXL : count X (X::T) N3
P : NP + 1 = N3
============================
 NL = NP
</pre>
<pre class="code extensibella"id="298">
 &lt; <b>M: apply plus_minus_same_integer to _ _ P.</b>

Subgoal 2.2.1:

Variables: P T N1 L' X NL NP N3
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (X::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X1 NL NP,
         is_pair is_integer is_clause X1 -&gt; count X1 (X::T) NL -&gt; count X1 P NP -&gt;
         NL = NP
Is : is_pair is_integer is_clause X
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count X (X::T) N1
CPH : count X P N1
G : N1 &gt; 0
M : mem X P
S : select X L' P
IsL' : is_list (is_pair is_integer is_clause) L'
IsX : is_pair is_integer is_clause X
CT : count X T NL
CL' : count X L' NP
IsNP : is_integer NP
PlusNP : 1 + NP = N3
CXP : count X P N3
IsNL : is_integer NL
PlusNL : 1 + NL = N3
CXL : count X (X::T) N3
P : NP + 1 = N3
M1 : N3 - 1 = NP
============================
 NL = NP
</pre>
<pre class="code extensibella"id="299">
 &lt; <b>P': apply plus_integer_comm to _ _ PlusNL.</b>

Subgoal 2.2.1:

Variables: P T N1 L' X NL NP N3
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (X::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X1 NL NP,
         is_pair is_integer is_clause X1 -&gt; count X1 (X::T) NL -&gt; count X1 P NP -&gt;
         NL = NP
Is : is_pair is_integer is_clause X
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count X (X::T) N1
CPH : count X P N1
G : N1 &gt; 0
M : mem X P
S : select X L' P
IsL' : is_list (is_pair is_integer is_clause) L'
IsX : is_pair is_integer is_clause X
CT : count X T NL
CL' : count X L' NP
IsNP : is_integer NP
PlusNP : 1 + NP = N3
CXP : count X P N3
IsNL : is_integer NL
PlusNL : 1 + NL = N3
CXL : count X (X::T) N3
P : NP + 1 = N3
M1 : N3 - 1 = NP
P' : NL + 1 = N3
============================
 NL = NP
</pre>
<pre class="code extensibella"id="300">
 &lt; <b>M': apply plus_minus_same_integer to _ _ P'.</b>

Subgoal 2.2.1:

Variables: P T N1 L' X NL NP N3
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (X::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X1 NL NP,
         is_pair is_integer is_clause X1 -&gt; count X1 (X::T) NL -&gt; count X1 P NP -&gt;
         NL = NP
Is : is_pair is_integer is_clause X
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count X (X::T) N1
CPH : count X P N1
G : N1 &gt; 0
M : mem X P
S : select X L' P
IsL' : is_list (is_pair is_integer is_clause) L'
IsX : is_pair is_integer is_clause X
CT : count X T NL
CL' : count X L' NP
IsNP : is_integer NP
PlusNP : 1 + NP = N3
CXP : count X P N3
IsNL : is_integer NL
PlusNL : 1 + NL = N3
CXL : count X (X::T) N3
P : NP + 1 = N3
M1 : N3 - 1 = NP
P' : NL + 1 = N3
M' : N3 - 1 = NL
============================
 NL = NP
</pre>
<pre class="code extensibella"id="301">
 &lt; <b>apply minus_integer_unique to M1 M'.</b>

Subgoal 2.2.1:

Variables: P T N1 L' X NL N3
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (X::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X1 NL NP,
         is_pair is_integer is_clause X1 -&gt; count X1 (X::T) NL -&gt; count X1 P NP -&gt;
         NL = NP
Is : is_pair is_integer is_clause X
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count X (X::T) N1
CPH : count X P N1
G : N1 &gt; 0
M : mem X P
S : select X L' P
IsL' : is_list (is_pair is_integer is_clause) L'
IsX : is_pair is_integer is_clause X
CT : count X T NL
CL' : count X L' NL
IsNP : is_integer NL
PlusNP : 1 + NL = N3
CXP : count X P N3
IsNL : is_integer NL
PlusNL : 1 + NL = N3
CXL : count X (X::T) N3
P : NL + 1 = N3
M1 : N3 - 1 = NL
P' : NL + 1 = N3
M' : N3 - 1 = NL
============================
 NL = NL
</pre>
<pre class="code extensibella"id="302">
 &lt; <b>search.</b>

Subgoal 2.2.2:

Variables: P T H N1 L' X NL NP
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (H::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X (H::T) NL -&gt; count X P NP -&gt; NL = NP
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count H (H::T) N1
CPH : count H P N1
G : N1 &gt; 0
M : mem H P
S : select H L' P
IsL' : is_list (is_pair is_integer is_clause) L'
IsX : is_pair is_integer is_clause X
CT : count X T NL
CL' : count X L' NP
E : H = X -&gt; false
============================
 NL = NP
</pre>
<pre class="code extensibella"id="303">
 &lt; <b>assert X = H -&gt; false.</b>

Subgoal 2.2.2.1:

Variables: P T H N1 L' X NL NP
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (H::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X (H::T) NL -&gt; count X P NP -&gt; NL = NP
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count H (H::T) N1
CPH : count H P N1
G : N1 &gt; 0
M : mem H P
S : select H L' P
IsL' : is_list (is_pair is_integer is_clause) L'
IsX : is_pair is_integer is_clause X
CT : count X T NL
CL' : count X L' NP
E : H = X -&gt; false
============================
 X = H -&gt; false
</pre>
<pre class="code extensibella"id="304">
 &lt; <b>intros A.</b>

Subgoal 2.2.2.1:

Variables: P T H N1 L' X NL NP
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (H::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X (H::T) NL -&gt; count X P NP -&gt; NL = NP
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count H (H::T) N1
CPH : count H P N1
G : N1 &gt; 0
M : mem H P
S : select H L' P
IsL' : is_list (is_pair is_integer is_clause) L'
IsX : is_pair is_integer is_clause X
CT : count X T NL
CL' : count X L' NP
E : H = X -&gt; false
A : X = H
============================
 false
</pre>
<pre class="code extensibella"id="305">
 &lt; <b>case A.</b>

Subgoal 2.2.2.1:

Variables: P T H N1 L' NL NP
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (H::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X (H::T) NL -&gt; count X P NP -&gt; NL = NP
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count H (H::T) N1
CPH : count H P N1
G : N1 &gt; 0
M : mem H P
S : select H L' P
IsL' : is_list (is_pair is_integer is_clause) L'
IsX : is_pair is_integer is_clause H
CT : count H T NL
CL' : count H L' NP
E : H = H -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="306">
 &lt; <b>backchain E.</b>

Subgoal 2.2.2:

Variables: P T H N1 L' X NL NP
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (H::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X (H::T) NL -&gt; count X P NP -&gt; NL = NP
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count H (H::T) N1
CPH : count H P N1
G : N1 &gt; 0
M : mem H P
S : select H L' P
IsL' : is_list (is_pair is_integer is_clause) L'
IsX : is_pair is_integer is_clause X
CT : count X T NL
CL' : count X L' NP
E : H = X -&gt; false
H1 : X = H -&gt; false
============================
 NL = NP
</pre>
<pre class="code extensibella"id="307">
 &lt; <b>CXP: apply count_select_neq to CL' S _.</b>

Subgoal 2.2.2:

Variables: P T H N1 L' X NL NP
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (H::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X (H::T) NL -&gt; count X P NP -&gt; NL = NP
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count H (H::T) N1
CPH : count H P N1
G : N1 &gt; 0
M : mem H P
S : select H L' P
IsL' : is_list (is_pair is_integer is_clause) L'
IsX : is_pair is_integer is_clause X
CT : count X T NL
CL' : count X L' NP
E : H = X -&gt; false
H1 : X = H -&gt; false
CXP : count X P NP
============================
 NL = NP
</pre>
<pre class="code extensibella"id="308">
 &lt; <b>CXL: assert count X (H::T) NL.</b>

Subgoal 2.2.2:

Variables: P T H N1 L' X NL NP
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (H::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X (H::T) NL -&gt; count X P NP -&gt; NL = NP
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count H (H::T) N1
CPH : count H P N1
G : N1 &gt; 0
M : mem H P
S : select H L' P
IsL' : is_list (is_pair is_integer is_clause) L'
IsX : is_pair is_integer is_clause X
CT : count X T NL
CL' : count X L' NP
E : H = X -&gt; false
H1 : X = H -&gt; false
CXP : count X P NP
CXL : count X (H::T) NL
============================
 NL = NP
</pre>
<pre class="code extensibella"id="309">
 &lt; <b>apply Same to _ CXL CXP.</b>

Subgoal 2.2.2:

Variables: P T H N1 L' X NP
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (H::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X (H::T) NL -&gt; count X P NP -&gt; NL = NP
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count H (H::T) N1
CPH : count H P N1
G : N1 &gt; 0
M : mem H P
S : select H L' P
IsL' : is_list (is_pair is_integer is_clause) L'
IsX : is_pair is_integer is_clause X
CT : count X T NP
CL' : count X L' NP
E : H = X -&gt; false
H1 : X = H -&gt; false
CXP : count X P NP
CXL : count X (H::T) NP
============================
 NP = NP
</pre>
<pre class="code extensibella"id="310">
 &lt; <b>search.</b>

Subgoal 2:

Variables: P T H N1 L'
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (H::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X (H::T) NL -&gt; count X P NP -&gt; NL = NP
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count H (H::T) N1
CPH : count H P N1
G : N1 &gt; 0
M : mem H P
S : select H L' P
IsL' : is_list (is_pair is_integer is_clause) L'
H1 : forall X NL NP,
       is_pair is_integer is_clause X -&gt; count X T NL -&gt; count X L' NP -&gt; NL = NP
============================
 permutation (H::T) P
</pre>
<pre class="code extensibella"id="311">
 &lt; <b>apply IH to Is1 IsL' _.</b>

Subgoal 2:

Variables: P T H N1 L'
IH : forall L P,
       is_list (is_pair is_integer is_clause) L * -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       (forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X L NL -&gt; count X P NP -&gt; NL = NP) -&gt;
       permutation L P
IsL : is_list (is_pair is_integer is_clause) (H::T) @
IsP : is_list (is_pair is_integer is_clause) P
Same : forall X NL NP,
         is_pair is_integer is_clause X -&gt; count X (H::T) NL -&gt; count X P NP -&gt; NL = NP
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
CLH : count H (H::T) N1
CPH : count H P N1
G : N1 &gt; 0
M : mem H P
S : select H L' P
IsL' : is_list (is_pair is_integer is_clause) L'
H1 : forall X NL NP,
       is_pair is_integer is_clause X -&gt; count X T NL -&gt; count X L' NP -&gt; NL = NP
H2 : permutation T L'
============================
 permutation (H::T) P
</pre>
<pre class="code extensibella"id="312">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="313">
 &lt; <b>Theorem selects_permutation :
     forall L P IDC LRest PRest,
       is_list (is_pair is_integer is_clause) L -&gt; is_list (is_pair is_integer is_clause) P -&gt;
       permutation L P -&gt; select IDC LRest L -&gt; select IDC PRest P -&gt; permutation LRest PRest.</b>

============================
 forall L P IDC LRest PRest,
   is_list (is_pair is_integer is_clause) L -&gt; is_list (is_pair is_integer is_clause) P -&gt;
   permutation L P -&gt; select IDC LRest L -&gt; select IDC PRest P -&gt; permutation LRest PRest
</pre>
<pre class="code extensibella"id="314">
 &lt; <b>intros IsL IsP Prm SL SP.</b>

Variables: L P IDC LRest PRest
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select IDC LRest L
SP : select IDC PRest P
============================
 permutation LRest PRest
</pre>
<pre class="code extensibella"id="315">
 &lt; <b>IsLRest: assert is_list (is_pair is_integer is_clause) LRest.</b>

Subgoal 1:

Variables: L P IDC LRest PRest
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select IDC LRest L
SP : select IDC PRest P
============================
 is_list (is_pair is_integer is_clause) LRest
</pre>
<pre class="code extensibella"id="316">
 &lt; <b>M: apply select_mem to SL.</b>

Subgoal 1:

Variables: L P IDC LRest PRest
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select IDC LRest L
SP : select IDC PRest P
M : mem IDC L
============================
 is_list (is_pair is_integer is_clause) LRest
</pre>
<pre class="code extensibella"id="317">
 &lt; <b>apply mem_is to IsL M.</b>

Subgoal 1:

Variables: L P LRest PRest ID C
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select (ID, C) LRest L
SP : select (ID, C) PRest P
M : mem (ID, C) L
H1 : is_integer ID
H2 : is_clause C
============================
 is_list (is_pair is_integer is_clause) LRest
</pre>
<pre class="code extensibella"id="318">
 &lt; <b>apply select_is to IsL SL.</b>

Subgoal 1:

Variables: L P LRest PRest ID C
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select (ID, C) LRest L
SP : select (ID, C) PRest P
M : mem (ID, C) L
H1 : is_integer ID
H2 : is_clause C
H3 : is_list (is_pair is_integer is_clause) LRest
============================
 is_list (is_pair is_integer is_clause) LRest
</pre>
<pre class="code extensibella"id="319">
 &lt; <b>search.</b>

Variables: L P IDC LRest PRest
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select IDC LRest L
SP : select IDC PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
============================
 permutation LRest PRest
</pre>
<pre class="code extensibella"id="320">
 &lt; <b>IsPRest: assert is_list (is_pair is_integer is_clause) PRest.</b>

Subgoal 2:

Variables: L P IDC LRest PRest
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select IDC LRest L
SP : select IDC PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
============================
 is_list (is_pair is_integer is_clause) PRest
</pre>
<pre class="code extensibella"id="321">
 &lt; <b>M: apply select_mem to SP.</b>

Subgoal 2:

Variables: L P IDC LRest PRest
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select IDC LRest L
SP : select IDC PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
M : mem IDC P
============================
 is_list (is_pair is_integer is_clause) PRest
</pre>
<pre class="code extensibella"id="322">
 &lt; <b>apply mem_is to IsP M.</b>

Subgoal 2:

Variables: L P LRest PRest ID C
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select (ID, C) LRest L
SP : select (ID, C) PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
M : mem (ID, C) P
H1 : is_integer ID
H2 : is_clause C
============================
 is_list (is_pair is_integer is_clause) PRest
</pre>
<pre class="code extensibella"id="323">
 &lt; <b>apply select_is to IsP SP.</b>

Subgoal 2:

Variables: L P LRest PRest ID C
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select (ID, C) LRest L
SP : select (ID, C) PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
M : mem (ID, C) P
H1 : is_integer ID
H2 : is_clause C
H3 : is_list (is_pair is_integer is_clause) PRest
============================
 is_list (is_pair is_integer is_clause) PRest
</pre>
<pre class="code extensibella"id="324">
 &lt; <b>search.</b>

Variables: L P IDC LRest PRest
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select IDC LRest L
SP : select IDC PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
============================
 permutation LRest PRest
</pre>
<pre class="code extensibella"id="325">
 &lt; <b>assert forall X NL NP,
     is_pair is_integer is_clause X -&gt; count X LRest NL -&gt; count X PRest NP -&gt; NL = NP.</b>

Subgoal 3:

Variables: L P IDC LRest PRest
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select IDC LRest L
SP : select IDC PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
============================
 forall X NL NP,
   is_pair is_integer is_clause X -&gt; count X LRest NL -&gt; count X PRest NP -&gt; NL = NP
</pre>
<pre class="code extensibella"id="326">
 &lt; <b>intros IsX CL CP.</b>

Subgoal 3:

Variables: L P IDC LRest PRest X NL NP
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select IDC LRest L
SP : select IDC PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
IsX : is_pair is_integer is_clause X
CL : count X LRest NL
CP : count X PRest NP
============================
 NL = NP
</pre>
<pre class="code extensibella"id="327">
 &lt; <b>M: apply select_mem to SL.</b>

Subgoal 3:

Variables: L P IDC LRest PRest X NL NP
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select IDC LRest L
SP : select IDC PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
IsX : is_pair is_integer is_clause X
CL : count X LRest NL
CP : count X PRest NP
M : mem IDC L
============================
 NL = NP
</pre>
<pre class="code extensibella"id="328">
 &lt; <b>Is: apply mem_is to _ M.</b>

Subgoal 3:

Variables: L P LRest PRest X NL NP ID C
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select (ID, C) LRest L
SP : select (ID, C) PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
IsX : is_pair is_integer is_clause X
CL : count X LRest NL
CP : count X PRest NP
M : mem (ID, C) L
Is : is_integer ID
Is1 : is_clause C
============================
 NL = NP
</pre>
<pre class="code extensibella"id="329">
 &lt; <b>IsPair: assert is_pair is_integer is_clause (ID, C).</b>

Subgoal 3:

Variables: L P LRest PRest X NL NP ID C
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select (ID, C) LRest L
SP : select (ID, C) PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
IsX : is_pair is_integer is_clause X
CL : count X LRest NL
CP : count X PRest NP
M : mem (ID, C) L
Is : is_integer ID
Is1 : is_clause C
IsPair : is_pair is_integer is_clause (ID, C)
============================
 NL = NP
</pre>
<pre class="code extensibella"id="330">
 &lt; <b>Or: apply is_pair_eq_or_not to IsX IsPair.</b>

Subgoal 3:

Variables: L P LRest PRest X NL NP ID C
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select (ID, C) LRest L
SP : select (ID, C) PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
IsX : is_pair is_integer is_clause X
CL : count X LRest NL
CP : count X PRest NP
M : mem (ID, C) L
Is : is_integer ID
Is1 : is_clause C
IsPair : is_pair is_integer is_clause (ID, C)
Or : X = (ID, C) \/ (X = (ID, C) -&gt; false)
============================
 NL = NP
</pre>
<pre class="code extensibella"id="331">
 &lt; <b>Eq: case Or.</b>

Subgoal 3.1:

Variables: L P LRest PRest NL NP ID C
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select (ID, C) LRest L
SP : select (ID, C) PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
IsX : is_pair is_integer is_clause (ID, C)
CL : count (ID, C) LRest NL
CP : count (ID, C) PRest NP
M : mem (ID, C) L
Is : is_integer ID
Is1 : is_clause C
IsPair : is_pair is_integer is_clause (ID, C)
============================
 NL = NP
</pre>
<pre class="code extensibella"id="332">
 &lt; <b>IsNL: apply count_is_integer to CL.</b>

Subgoal 3.1:

Variables: L P LRest PRest NL NP ID C
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select (ID, C) LRest L
SP : select (ID, C) PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
IsX : is_pair is_integer is_clause (ID, C)
CL : count (ID, C) LRest NL
CP : count (ID, C) PRest NP
M : mem (ID, C) L
Is : is_integer ID
Is1 : is_clause C
IsPair : is_pair is_integer is_clause (ID, C)
IsNL : is_integer NL
============================
 NL = NP
</pre>
<pre class="code extensibella"id="333">
 &lt; <b>PL: apply plus_integer_total to _ IsNL with
         N1 = 1.</b>

Subgoal 3.1:

Variables: L P LRest PRest NL NP ID C N3
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select (ID, C) LRest L
SP : select (ID, C) PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
IsX : is_pair is_integer is_clause (ID, C)
CL : count (ID, C) LRest NL
CP : count (ID, C) PRest NP
M : mem (ID, C) L
Is : is_integer ID
Is1 : is_clause C
IsPair : is_pair is_integer is_clause (ID, C)
IsNL : is_integer NL
PL : 1 + NL = N3
============================
 NL = NP
</pre>
<pre class="code extensibella"id="334">
 &lt; <b>IsNP: apply count_is_integer to CP.</b>

Subgoal 3.1:

Variables: L P LRest PRest NL NP ID C N3
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select (ID, C) LRest L
SP : select (ID, C) PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
IsX : is_pair is_integer is_clause (ID, C)
CL : count (ID, C) LRest NL
CP : count (ID, C) PRest NP
M : mem (ID, C) L
Is : is_integer ID
Is1 : is_clause C
IsPair : is_pair is_integer is_clause (ID, C)
IsNL : is_integer NL
PL : 1 + NL = N3
IsNP : is_integer NP
============================
 NL = NP
</pre>
<pre class="code extensibella"id="335">
 &lt; <b>PP: apply plus_integer_total to _ IsNP with
         N1 = 1.</b>

Subgoal 3.1:

Variables: L P LRest PRest NL NP ID C N3 N1
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select (ID, C) LRest L
SP : select (ID, C) PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
IsX : is_pair is_integer is_clause (ID, C)
CL : count (ID, C) LRest NL
CP : count (ID, C) PRest NP
M : mem (ID, C) L
Is : is_integer ID
Is1 : is_clause C
IsPair : is_pair is_integer is_clause (ID, C)
IsNL : is_integer NL
PL : 1 + NL = N3
IsNP : is_integer NP
PP : 1 + NP = N1
============================
 NL = NP
</pre>
<pre class="code extensibella"id="336">
 &lt; <b>CLFull: apply count_select to CL SL PL.</b>

Subgoal 3.1:

Variables: L P LRest PRest NL NP ID C N3 N1
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select (ID, C) LRest L
SP : select (ID, C) PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
IsX : is_pair is_integer is_clause (ID, C)
CL : count (ID, C) LRest NL
CP : count (ID, C) PRest NP
M : mem (ID, C) L
Is : is_integer ID
Is1 : is_clause C
IsPair : is_pair is_integer is_clause (ID, C)
IsNL : is_integer NL
PL : 1 + NL = N3
IsNP : is_integer NP
PP : 1 + NP = N1
CLFull : count (ID, C) L N3
============================
 NL = NP
</pre>
<pre class="code extensibella"id="337">
 &lt; <b>CPFull: apply count_select to CP SP PP.</b>

Subgoal 3.1:

Variables: L P LRest PRest NL NP ID C N3 N1
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select (ID, C) LRest L
SP : select (ID, C) PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
IsX : is_pair is_integer is_clause (ID, C)
CL : count (ID, C) LRest NL
CP : count (ID, C) PRest NP
M : mem (ID, C) L
Is : is_integer ID
Is1 : is_clause C
IsPair : is_pair is_integer is_clause (ID, C)
IsNL : is_integer NL
PL : 1 + NL = N3
IsNP : is_integer NP
PP : 1 + NP = N1
CLFull : count (ID, C) L N3
CPFull : count (ID, C) P N1
============================
 NL = NP
</pre>
<pre class="code extensibella"id="338">
 &lt; <b>apply permutation_counts to Prm CLFull CPFull.</b>

Subgoal 3.1:

Variables: L P LRest PRest NL NP ID C N1
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select (ID, C) LRest L
SP : select (ID, C) PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
IsX : is_pair is_integer is_clause (ID, C)
CL : count (ID, C) LRest NL
CP : count (ID, C) PRest NP
M : mem (ID, C) L
Is : is_integer ID
Is1 : is_clause C
IsPair : is_pair is_integer is_clause (ID, C)
IsNL : is_integer NL
PL : 1 + NL = N1
IsNP : is_integer NP
PP : 1 + NP = N1
CLFull : count (ID, C) L N1
CPFull : count (ID, C) P N1
============================
 NL = NP
</pre>
<pre class="code extensibella"id="339">
 &lt; <b>NP+: apply plus_integer_comm to _ _ PP.</b>

Subgoal 3.1:

Variables: L P LRest PRest NL NP ID C N1
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select (ID, C) LRest L
SP : select (ID, C) PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
IsX : is_pair is_integer is_clause (ID, C)
CL : count (ID, C) LRest NL
CP : count (ID, C) PRest NP
M : mem (ID, C) L
Is : is_integer ID
Is1 : is_clause C
IsPair : is_pair is_integer is_clause (ID, C)
IsNL : is_integer NL
PL : 1 + NL = N1
IsNP : is_integer NP
PP : 1 + NP = N1
CLFull : count (ID, C) L N1
CPFull : count (ID, C) P N1
NP+ : NP + 1 = N1
============================
 NL = NP
</pre>
<pre class="code extensibella"id="340">
 &lt; <b>MP: apply plus_minus_same_integer to _ _ NP+.</b>

Subgoal 3.1:

Variables: L P LRest PRest NL NP ID C N1
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select (ID, C) LRest L
SP : select (ID, C) PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
IsX : is_pair is_integer is_clause (ID, C)
CL : count (ID, C) LRest NL
CP : count (ID, C) PRest NP
M : mem (ID, C) L
Is : is_integer ID
Is1 : is_clause C
IsPair : is_pair is_integer is_clause (ID, C)
IsNL : is_integer NL
PL : 1 + NL = N1
IsNP : is_integer NP
PP : 1 + NP = N1
CLFull : count (ID, C) L N1
CPFull : count (ID, C) P N1
NP+ : NP + 1 = N1
MP : N1 - 1 = NP
============================
 NL = NP
</pre>
<pre class="code extensibella"id="341">
 &lt; <b>NL+: apply plus_integer_comm to _ _ PL.</b>

Subgoal 3.1:

Variables: L P LRest PRest NL NP ID C N1
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select (ID, C) LRest L
SP : select (ID, C) PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
IsX : is_pair is_integer is_clause (ID, C)
CL : count (ID, C) LRest NL
CP : count (ID, C) PRest NP
M : mem (ID, C) L
Is : is_integer ID
Is1 : is_clause C
IsPair : is_pair is_integer is_clause (ID, C)
IsNL : is_integer NL
PL : 1 + NL = N1
IsNP : is_integer NP
PP : 1 + NP = N1
CLFull : count (ID, C) L N1
CPFull : count (ID, C) P N1
NP+ : NP + 1 = N1
MP : N1 - 1 = NP
NL+ : NL + 1 = N1
============================
 NL = NP
</pre>
<pre class="code extensibella"id="342">
 &lt; <b>ML: apply plus_minus_same_integer to _ _ NL+.</b>

Subgoal 3.1:

Variables: L P LRest PRest NL NP ID C N1
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select (ID, C) LRest L
SP : select (ID, C) PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
IsX : is_pair is_integer is_clause (ID, C)
CL : count (ID, C) LRest NL
CP : count (ID, C) PRest NP
M : mem (ID, C) L
Is : is_integer ID
Is1 : is_clause C
IsPair : is_pair is_integer is_clause (ID, C)
IsNL : is_integer NL
PL : 1 + NL = N1
IsNP : is_integer NP
PP : 1 + NP = N1
CLFull : count (ID, C) L N1
CPFull : count (ID, C) P N1
NP+ : NP + 1 = N1
MP : N1 - 1 = NP
NL+ : NL + 1 = N1
ML : N1 - 1 = NL
============================
 NL = NP
</pre>
<pre class="code extensibella"id="343">
 &lt; <b>apply minus_integer_unique to MP ML.</b>

Subgoal 3.1:

Variables: L P LRest PRest NL ID C N1
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select (ID, C) LRest L
SP : select (ID, C) PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
IsX : is_pair is_integer is_clause (ID, C)
CL : count (ID, C) LRest NL
CP : count (ID, C) PRest NL
M : mem (ID, C) L
Is : is_integer ID
Is1 : is_clause C
IsPair : is_pair is_integer is_clause (ID, C)
IsNL : is_integer NL
PL : 1 + NL = N1
IsNP : is_integer NL
PP : 1 + NL = N1
CLFull : count (ID, C) L N1
CPFull : count (ID, C) P N1
NP+ : NL + 1 = N1
MP : N1 - 1 = NL
NL+ : NL + 1 = N1
ML : N1 - 1 = NL
============================
 NL = NL
</pre>
<pre class="code extensibella"id="344">
 &lt; <b>search.</b>

Subgoal 3.2:

Variables: L P LRest PRest X NL NP ID C
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select (ID, C) LRest L
SP : select (ID, C) PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
IsX : is_pair is_integer is_clause X
CL : count X LRest NL
CP : count X PRest NP
M : mem (ID, C) L
Is : is_integer ID
Is1 : is_clause C
IsPair : is_pair is_integer is_clause (ID, C)
Eq : X = (ID, C) -&gt; false
============================
 NL = NP
</pre>
<pre class="code extensibella"id="345">
 &lt; <b>CLFull: apply count_select_neq to CL SL Eq.</b>

Subgoal 3.2:

Variables: L P LRest PRest X NL NP ID C
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select (ID, C) LRest L
SP : select (ID, C) PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
IsX : is_pair is_integer is_clause X
CL : count X LRest NL
CP : count X PRest NP
M : mem (ID, C) L
Is : is_integer ID
Is1 : is_clause C
IsPair : is_pair is_integer is_clause (ID, C)
Eq : X = (ID, C) -&gt; false
CLFull : count X L NL
============================
 NL = NP
</pre>
<pre class="code extensibella"id="346">
 &lt; <b>CPFull: apply count_select_neq to CP SP Eq.</b>

Subgoal 3.2:

Variables: L P LRest PRest X NL NP ID C
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select (ID, C) LRest L
SP : select (ID, C) PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
IsX : is_pair is_integer is_clause X
CL : count X LRest NL
CP : count X PRest NP
M : mem (ID, C) L
Is : is_integer ID
Is1 : is_clause C
IsPair : is_pair is_integer is_clause (ID, C)
Eq : X = (ID, C) -&gt; false
CLFull : count X L NL
CPFull : count X P NP
============================
 NL = NP
</pre>
<pre class="code extensibella"id="347">
 &lt; <b>apply permutation_counts to Prm CLFull CPFull.</b>

Subgoal 3.2:

Variables: L P LRest PRest X NP ID C
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select (ID, C) LRest L
SP : select (ID, C) PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
IsX : is_pair is_integer is_clause X
CL : count X LRest NP
CP : count X PRest NP
M : mem (ID, C) L
Is : is_integer ID
Is1 : is_clause C
IsPair : is_pair is_integer is_clause (ID, C)
Eq : X = (ID, C) -&gt; false
CLFull : count X L NP
CPFull : count X P NP
============================
 NP = NP
</pre>
<pre class="code extensibella"id="348">
 &lt; <b>search.</b>

Variables: L P IDC LRest PRest
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select IDC LRest L
SP : select IDC PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
H1 : forall X NL NP,
       is_pair is_integer is_clause X -&gt; count X LRest NL -&gt; count X PRest NP -&gt;
       NL = NP
============================
 permutation LRest PRest
</pre>
<pre class="code extensibella"id="349">
 &lt; <b>apply counts_permutation to IsLRest IsPRest _.</b>

Variables: L P IDC LRest PRest
IsL : is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
SL : select IDC LRest L
SP : select IDC PRest P
IsLRest : is_list (is_pair is_integer is_clause) LRest
IsPRest : is_list (is_pair is_integer is_clause) PRest
H1 : forall X NL NP,
       is_pair is_integer is_clause X -&gt; count X LRest NL -&gt; count X PRest NP -&gt;
       NL = NP
H2 : permutation LRest PRest
============================
 permutation LRest PRest
</pre>
<pre class="code extensibella"id="350">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="351">
 &lt; <b>Theorem permutation_reflexive :
     forall L, is_list (is_pair is_integer is_clause) L -&gt; permutation L L.</b>

============================
 forall L, is_list (is_pair is_integer is_clause) L -&gt; permutation L L
</pre>
<pre class="code extensibella"id="352">
 &lt; <b>induction on 1.</b>

IH : forall L, is_list (is_pair is_integer is_clause) L * -&gt; permutation L L
============================
 forall L, is_list (is_pair is_integer is_clause) L @ -&gt; permutation L L
</pre>
<pre class="code extensibella"id="353">
 &lt; <b>intros Is.</b>

Variables: L
IH : forall L, is_list (is_pair is_integer is_clause) L * -&gt; permutation L L
Is : is_list (is_pair is_integer is_clause) L @
============================
 permutation L L
</pre>
<pre class="code extensibella"id="354">
 &lt; <b>Is: case Is.</b>

Subgoal 1:

IH : forall L, is_list (is_pair is_integer is_clause) L * -&gt; permutation L L
============================
 permutation [] []
</pre>
<pre class="code extensibella"id="355">
 &lt; <b>search.</b>

Subgoal 2:

Variables: T H
IH : forall L, is_list (is_pair is_integer is_clause) L * -&gt; permutation L L
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
============================
 permutation (H::T) (H::T)
</pre>
<pre class="code extensibella"id="356">
 &lt; <b>apply IH to Is1.</b>

Subgoal 2:

Variables: T H
IH : forall L, is_list (is_pair is_integer is_clause) L * -&gt; permutation L L
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
H1 : permutation T T
============================
 permutation (H::T) (H::T)
</pre>
<pre class="code extensibella"id="357">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="358">
 &lt; <b>Theorem permutation_is :
     forall L P,
       is_list (is_pair is_integer is_clause) P -&gt; permutation L P -&gt; is_list (is_pair is_integer is_clause) L.</b>

============================
 forall L P,
   is_list (is_pair is_integer is_clause) P -&gt; permutation L P -&gt; is_list (is_pair is_integer is_clause) L
</pre>
<pre class="code extensibella"id="359">
 &lt; <b>induction on 2.</b>

IH : forall L P,
       is_list (is_pair is_integer is_clause) P -&gt; permutation L P * -&gt; is_list (is_pair is_integer is_clause) L
============================
 forall L P,
   is_list (is_pair is_integer is_clause) P -&gt; permutation L P @ -&gt; is_list (is_pair is_integer is_clause) L
</pre>
<pre class="code extensibella"id="360">
 &lt; <b>intros IsP Prm.</b>

Variables: L P
IH : forall L P,
       is_list (is_pair is_integer is_clause) P -&gt; permutation L P * -&gt; is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P @
============================
 is_list (is_pair is_integer is_clause) L
</pre>
<pre class="code extensibella"id="361">
 &lt; <b>Prm: case Prm.</b>

Subgoal 1:

IH : forall L P,
       is_list (is_pair is_integer is_clause) P -&gt; permutation L P * -&gt; is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) []
============================
 is_list (is_pair is_integer is_clause) []
</pre>
<pre class="code extensibella"id="362">
 &lt; <b>search.</b>

Subgoal 2:

Variables: P L2 Rest A
IH : forall L P,
       is_list (is_pair is_integer is_clause) P -&gt; permutation L P * -&gt; is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : select A L2 P
Prm1 : permutation Rest L2 *
============================
 is_list (is_pair is_integer is_clause) (A::Rest)
</pre>
<pre class="code extensibella"id="363">
 &lt; <b>IsRest: apply select_is to IsP Prm.</b>

Subgoal 2:

Variables: P L2 Rest A
IH : forall L P,
       is_list (is_pair is_integer is_clause) P -&gt; permutation L P * -&gt; is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : select A L2 P
Prm1 : permutation Rest L2 *
IsRest : is_list (is_pair is_integer is_clause) L2
============================
 is_list (is_pair is_integer is_clause) (A::Rest)
</pre>
<pre class="code extensibella"id="364">
 &lt; <b>apply IH to IsRest Prm1.</b>

Subgoal 2:

Variables: P L2 Rest A
IH : forall L P,
       is_list (is_pair is_integer is_clause) P -&gt; permutation L P * -&gt; is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : select A L2 P
Prm1 : permutation Rest L2 *
IsRest : is_list (is_pair is_integer is_clause) L2
H1 : is_list (is_pair is_integer is_clause) Rest
============================
 is_list (is_pair is_integer is_clause) (A::Rest)
</pre>
<pre class="code extensibella"id="365">
 &lt; <b>IsA: apply select_is_picked to IsP Prm.</b>

Subgoal 2:

Variables: P L2 Rest A
IH : forall L P,
       is_list (is_pair is_integer is_clause) P -&gt; permutation L P * -&gt; is_list (is_pair is_integer is_clause) L
IsP : is_list (is_pair is_integer is_clause) P
Prm : select A L2 P
Prm1 : permutation Rest L2 *
IsRest : is_list (is_pair is_integer is_clause) L2
H1 : is_list (is_pair is_integer is_clause) Rest
IsA : is_pair is_integer is_clause A
============================
 is_list (is_pair is_integer is_clause) (A::Rest)
</pre>
<pre class="code extensibella"id="366">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="367">
 &lt; <b>Define good_assignment : (list lit) -&gt; prop by
   good_assignment A :=
     forall L NL, mem L A -&gt; negate_lit L NL -&gt; mem NL A -&gt; false.</b>


</pre>
<pre class="code extensibella"id="368">
 &lt; <b>Theorem good_assignment_sub :
     forall A B,
       good_assignment A -&gt; (forall X, mem X B -&gt; mem X A) -&gt; good_assignment B.</b>

============================
 forall A B,
   good_assignment A -&gt; (forall X, mem X B -&gt; mem X A) -&gt; good_assignment B
</pre>
<pre class="code extensibella"id="369">
 &lt; <b>intros GA Sub.</b>

Variables: A B
GA : good_assignment A
Sub : forall X, mem X B -&gt; mem X A
============================
 good_assignment B
</pre>
<pre class="code extensibella"id="370">
 &lt; <b>unfold .</b>

Variables: A B
GA : good_assignment A
Sub : forall X, mem X B -&gt; mem X A
============================
 forall L NL, mem L B -&gt; negate_lit L NL -&gt; mem NL B -&gt; false
</pre>
<pre class="code extensibella"id="371">
 &lt; <b>intros MLB Neg MNLB.</b>

Variables: A B L NL
GA : good_assignment A
Sub : forall X, mem X B -&gt; mem X A
MLB : mem L B
Neg : negate_lit L NL
MNLB : mem NL B
============================
 false
</pre>
<pre class="code extensibella"id="372">
 &lt; <b>GA: case GA.</b>

Variables: A B L NL
Sub : forall X, mem X B -&gt; mem X A
MLB : mem L B
Neg : negate_lit L NL
MNLB : mem NL B
GA : forall L NL, mem L A -&gt; negate_lit L NL -&gt; mem NL A -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="373">
 &lt; <b>MLA: apply Sub to MLB.</b>

Variables: A B L NL
Sub : forall X, mem X B -&gt; mem X A
MLB : mem L B
Neg : negate_lit L NL
MNLB : mem NL B
GA : forall L NL, mem L A -&gt; negate_lit L NL -&gt; mem NL A -&gt; false
MLA : mem L A
============================
 false
</pre>
<pre class="code extensibella"id="374">
 &lt; <b>MNLA: apply Sub to MNLB.</b>

Variables: A B L NL
Sub : forall X, mem X B -&gt; mem X A
MLB : mem L B
Neg : negate_lit L NL
MNLB : mem NL B
GA : forall L NL, mem L A -&gt; negate_lit L NL -&gt; mem NL A -&gt; false
MLA : mem L A
MNLA : mem NL A
============================
 false
</pre>
<pre class="code extensibella"id="375">
 &lt; <b>apply GA to MLA Neg _.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="376">
 &lt; <b>Extensible_Theorem
      negate_lit_unique : forall L LA LB,
         IsL : is_lit L -&gt;
         NegA : negate_lit L LA -&gt;
         NegB : negate_lit L LB -&gt;
         LA = LB
      on NegA.</b>

Subgoal 1:

Variables: LB V
IH : forall L LA LB, is_lit L -&gt; negate_lit L LA * -&gt; negate_lit L LB -&gt; LA = LB
IsL : is_lit (pos V)
NegA : negate_lit (pos V) (neg V) @
NegB : negate_lit (pos V) LB
============================
 neg V = LB
</pre>
<pre class="code extensibella"id="377">
 &lt; <b>case NegB.</b>

Subgoal 1:

Variables: V
IH : forall L LA LB, is_lit L -&gt; negate_lit L LA * -&gt; negate_lit L LB -&gt; LA = LB
IsL : is_lit (pos V)
NegA : negate_lit (pos V) (neg V) @
============================
 neg V = neg V
</pre>
<pre class="code extensibella"id="378">
 &lt; <b>search.</b>

Subgoal 2:

Variables: LB V
IH : forall L LA LB, is_lit L -&gt; negate_lit L LA * -&gt; negate_lit L LB -&gt; LA = LB
IsL : is_lit (neg V)
NegA : negate_lit (neg V) (pos V) @
NegB : negate_lit (neg V) LB
============================
 pos V = LB
</pre>
<pre class="code extensibella"id="379">
 &lt; <b>case NegB.</b>

Subgoal 2:

Variables: V
IH : forall L LA LB, is_lit L -&gt; negate_lit L LA * -&gt; negate_lit L LB -&gt; LA = LB
IsL : is_lit (neg V)
NegA : negate_lit (neg V) (pos V) @
============================
 pos V = pos V
</pre>
<pre class="code extensibella"id="380">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="381">
 &lt; <b>Extensible_Theorem
      negate_lit_reverse : forall L NL,
         IsL : is_lit L -&gt;
         Neg : negate_lit L NL -&gt;
         negate_lit NL L
      on Neg.</b>

Subgoal 1:

Variables: V
IH : forall L NL, is_lit L -&gt; negate_lit L NL * -&gt; negate_lit NL L
IsL : is_lit (pos V)
Neg : negate_lit (pos V) (neg V) @
============================
 negate_lit (neg V) (pos V)
</pre>
<pre class="code extensibella"id="382">
 &lt; <b>search.</b>

Subgoal 2:

Variables: V
IH : forall L NL, is_lit L -&gt; negate_lit L NL * -&gt; negate_lit NL L
IsL : is_lit (neg V)
Neg : negate_lit (neg V) (pos V) @
============================
 negate_lit (pos V) (neg V)
</pre>
<pre class="code extensibella"id="383">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="384">
 &lt; <b>Extensible_Theorem
      negate_lit_not_same : forall L,
         IsL : is_lit L -&gt;
         Neg : negate_lit L L -&gt;
         false
      on Neg.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="385">
 &lt; <b>Extensible_Theorem
      negate_lit_is_lit : forall L NL,
         IsL : is_lit L -&gt;
         Neg : negate_lit L NL -&gt;
         is_lit NL
      on Neg.</b>

Subgoal 1:

Variables: V
IH : forall L NL, is_lit L -&gt; negate_lit L NL * -&gt; is_lit NL
IsL : is_lit (pos V)
Neg : negate_lit (pos V) (neg V) @
============================
 is_lit (neg V)
</pre>
<pre class="code extensibella"id="386">
 &lt; <b>case IsL.</b>

Subgoal 1:

Variables: V
IH : forall L NL, is_lit L -&gt; negate_lit L NL * -&gt; is_lit NL
Neg : negate_lit (pos V) (neg V) @
H1 : is_integer V
============================
 is_lit (neg V)
</pre>
<pre class="code extensibella"id="387">
 &lt; <b>search.</b>

Subgoal 2:

Variables: V
IH : forall L NL, is_lit L -&gt; negate_lit L NL * -&gt; is_lit NL
IsL : is_lit (neg V)
Neg : negate_lit (neg V) (pos V) @
============================
 is_lit (pos V)
</pre>
<pre class="code extensibella"id="388">
 &lt; <b>case IsL.</b>

Subgoal 2:

Variables: V
IH : forall L NL, is_lit L -&gt; negate_lit L NL * -&gt; is_lit NL
Neg : negate_lit (neg V) (pos V) @
H1 : is_integer V
============================
 is_lit (pos V)
</pre>
<pre class="code extensibella"id="389">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="390">
 &lt; <b>Extensible_Theorem
      negate_lit_is_lit_back : forall L NL,
         IsNL : is_lit NL -&gt;
         Neg : negate_lit L NL -&gt;
         is_lit L
      on Neg.</b>

Subgoal 1:

Variables: V
IH : forall L NL, is_lit NL -&gt; negate_lit L NL * -&gt; is_lit L
IsNL : is_lit (neg V)
Neg : negate_lit (pos V) (neg V) @
============================
 is_lit (pos V)
</pre>
<pre class="code extensibella"id="391">
 &lt; <b>case IsNL.</b>

Subgoal 1:

Variables: V
IH : forall L NL, is_lit NL -&gt; negate_lit L NL * -&gt; is_lit L
Neg : negate_lit (pos V) (neg V) @
H1 : is_integer V
============================
 is_lit (pos V)
</pre>
<pre class="code extensibella"id="392">
 &lt; <b>search.</b>

Subgoal 2:

Variables: V
IH : forall L NL, is_lit NL -&gt; negate_lit L NL * -&gt; is_lit L
IsNL : is_lit (pos V)
Neg : negate_lit (neg V) (pos V) @
============================
 is_lit (neg V)
</pre>
<pre class="code extensibella"id="393">
 &lt; <b>case IsNL.</b>

Subgoal 2:

Variables: V
IH : forall L NL, is_lit NL -&gt; negate_lit L NL * -&gt; is_lit L
Neg : negate_lit (neg V) (pos V) @
H1 : is_integer V
============================
 is_lit (neg V)
</pre>
<pre class="code extensibella"id="394">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="395">
 &lt; <b>Extensible_Theorem
      negate_lit_exists : forall L,
         IsL : is_lit L -&gt;
         exists NL,
           negate_lit L NL
      on IsL.</b>

Subgoal 1:

Variables: I
IH : forall L, is_lit L * -&gt; exists NL, negate_lit L NL
IsL : is_lit (pos I) @
IsL1 : is_integer I
============================
 exists NL, negate_lit (pos I) NL
</pre>
<pre class="code extensibella"id="396">
 &lt; <b>search.</b>

Subgoal 2:

Variables: I
IH : forall L, is_lit L * -&gt; exists NL, negate_lit L NL
IsL : is_lit (neg I) @
IsL1 : is_integer I
============================
 exists NL, negate_lit (neg I) NL
</pre>
<pre class="code extensibella"id="397">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="398">
 &lt; <b>Translation_Constraint sat_clause_ext_to_trans :
   forall C C' Sat,
   |{clause}- C ~~&gt; C' -&gt; is_list is_lit Sat -&gt; is_clause C -&gt; sat_clause Sat C -&gt;
   sat_clause Sat C'.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="399">
 &lt; <b>Translation_Constraint sat_clause_trans_to_ext :
   forall C C' Sat,
   |{clause}- C ~~&gt; C' -&gt; is_list is_lit Sat -&gt; is_clause C -&gt; sat_clause Sat C' -&gt;
   sat_clause Sat C.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="400">
 &lt; <b>Translation_Constraint unsat_clause_ext_to_trans :
   forall C C' Unsat,
   |{clause}- C ~~&gt; C' -&gt; is_list is_lit Unsat -&gt; is_clause C -&gt; unsat_clause Unsat C -&gt;
   unsat_clause Unsat C'.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="401">
 &lt; <b>Translation_Constraint unsat_clause_trans_to_ext :
   forall C C' Unsat,
   |{clause}- C ~~&gt; C' -&gt; is_list is_lit Unsat -&gt; is_clause C -&gt; unsat_clause Unsat C' -&gt;
   unsat_clause Unsat C.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="402">
 &lt; <b>Translation_Constraint sat_formula_ext_to_trans :
   forall F F' Sat,
   |{formula}- F ~~&gt; F' -&gt; is_list is_lit Sat -&gt; sat_formula Sat F -&gt; sat_formula Sat F'.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="403">
 &lt; <b>Translation_Constraint sat_formula_trans_to_ext :
   forall F F' Sat,
   |{formula}- F ~~&gt; F' -&gt; is_list is_lit Sat -&gt; sat_formula Sat F' -&gt; sat_formula Sat F.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="404">
 &lt; <b>Extensible_Theorem
      unsat_sat_clause : forall A C,
         IsC : is_clause C -&gt;
         IsA : is_list is_lit A -&gt;
         UNSAT : unsat_clause A C -&gt;
         SAT : sat_clause A C -&gt;
         GA : good_assignment A -&gt;
         false
      on UNSAT.</b>

Subgoal 1:

Variables: A
IH : forall A C,
       is_clause C -&gt; is_list is_lit A -&gt; unsat_clause A C * -&gt; sat_clause A C -&gt;
       good_assignment A -&gt; false
IsC : is_clause emptyClause
IsA : is_list is_lit A
UNSAT : unsat_clause A emptyClause @
SAT : sat_clause A emptyClause
GA : good_assignment A
============================
 false
</pre>
<pre class="code extensibella"id="405">
 &lt; <b>SAT: case SAT.</b>

Subgoal 2:

Variables: A NL Rest L
IH : forall A C,
       is_clause C -&gt; is_list is_lit A -&gt; unsat_clause A C * -&gt; sat_clause A C -&gt;
       good_assignment A -&gt; false
IsC : is_clause (or L Rest)
IsA : is_list is_lit A
UNSAT : unsat_clause A (or L Rest) @
SAT : sat_clause A (or L Rest)
GA : good_assignment A
UNSAT1 : negate_lit L NL
UNSAT2 : mem NL A
UNSAT3 : unsat_clause A Rest *
============================
 false
</pre>
<pre class="code extensibella"id="406">
 &lt; <b>SAT: case SAT.</b>

Subgoal 2.1:

Variables: A NL Rest L
IH : forall A C,
       is_clause C -&gt; is_list is_lit A -&gt; unsat_clause A C * -&gt; sat_clause A C -&gt;
       good_assignment A -&gt; false
IsC : is_clause (or L Rest)
IsA : is_list is_lit A
UNSAT : unsat_clause A (or L Rest) @
GA : good_assignment A
UNSAT1 : negate_lit L NL
UNSAT2 : mem NL A
UNSAT3 : unsat_clause A Rest *
SAT : mem L A
============================
 false
</pre>
<pre class="code extensibella"id="407">
 &lt; <b>GA: case GA.</b>

Subgoal 2.1:

Variables: A NL Rest L
IH : forall A C,
       is_clause C -&gt; is_list is_lit A -&gt; unsat_clause A C * -&gt; sat_clause A C -&gt;
       good_assignment A -&gt; false
IsC : is_clause (or L Rest)
IsA : is_list is_lit A
UNSAT : unsat_clause A (or L Rest) @
UNSAT1 : negate_lit L NL
UNSAT2 : mem NL A
UNSAT3 : unsat_clause A Rest *
SAT : mem L A
GA : forall L NL, mem L A -&gt; negate_lit L NL -&gt; mem NL A -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="408">
 &lt; <b>apply GA to SAT _ UNSAT2.</b>

Subgoal 2.2:

Variables: A NL Rest L
IH : forall A C,
       is_clause C -&gt; is_list is_lit A -&gt; unsat_clause A C * -&gt; sat_clause A C -&gt;
       good_assignment A -&gt; false
IsC : is_clause (or L Rest)
IsA : is_list is_lit A
UNSAT : unsat_clause A (or L Rest) @
GA : good_assignment A
UNSAT1 : negate_lit L NL
UNSAT2 : mem NL A
UNSAT3 : unsat_clause A Rest *
SAT : sat_clause A Rest
============================
 false
</pre>
<pre class="code extensibella"id="409">
 &lt; <b>case IsC.</b>

Subgoal 2.2:

Variables: A NL Rest L
IH : forall A C,
       is_clause C -&gt; is_list is_lit A -&gt; unsat_clause A C * -&gt; sat_clause A C -&gt;
       good_assignment A -&gt; false
IsA : is_list is_lit A
UNSAT : unsat_clause A (or L Rest) @
GA : good_assignment A
UNSAT1 : negate_lit L NL
UNSAT2 : mem NL A
UNSAT3 : unsat_clause A Rest *
SAT : sat_clause A Rest
H1 : is_lit L
H2 : is_clause Rest
============================
 false
</pre>
<pre class="code extensibella"id="410">
 &lt; <b>apply IH to _ _ UNSAT3 SAT GA.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="411">
 &lt; <b>Extensible_Theorem
      sat_clause_orderless : forall A1 A2 C,
         IsC : is_clause C -&gt;
         IsA1 : is_list is_lit A1 -&gt;
         IsA2 : is_list is_lit A2 -&gt;
         SAT : sat_clause A1 C -&gt;
         MemA1A2 : (forall L,
           mem L A1 -&gt; mem L A2) -&gt;
         sat_clause A2 C
      on SAT.</b>

Subgoal 1:

Variables: A1 A2 Rest L
IH : forall A1 A2 C,
       is_clause C -&gt; is_list is_lit A1 -&gt; is_list is_lit A2 -&gt; sat_clause A1 C * -&gt;
       (forall L, mem L A1 -&gt; mem L A2) -&gt; sat_clause A2 C
IsC : is_clause (or L Rest)
IsA1 : is_list is_lit A1
IsA2 : is_list is_lit A2
SAT : sat_clause A1 (or L Rest) @
MemA1A2 : forall L, mem L A1 -&gt; mem L A2
SAT1 : mem L A1
============================
 sat_clause A2 (or L Rest)
</pre>
<pre class="code extensibella"id="412">
 &lt; <b>apply MemA1A2 to _.</b>

Subgoal 1:

Variables: A1 A2 Rest L
IH : forall A1 A2 C,
       is_clause C -&gt; is_list is_lit A1 -&gt; is_list is_lit A2 -&gt; sat_clause A1 C * -&gt;
       (forall L, mem L A1 -&gt; mem L A2) -&gt; sat_clause A2 C
IsC : is_clause (or L Rest)
IsA1 : is_list is_lit A1
IsA2 : is_list is_lit A2
SAT : sat_clause A1 (or L Rest) @
MemA1A2 : forall L, mem L A1 -&gt; mem L A2
SAT1 : mem L A1
H1 : mem L A2
============================
 sat_clause A2 (or L Rest)
</pre>
<pre class="code extensibella"id="413">
 &lt; <b>search.</b>

Subgoal 2:

Variables: A1 A2 Rest L
IH : forall A1 A2 C,
       is_clause C -&gt; is_list is_lit A1 -&gt; is_list is_lit A2 -&gt; sat_clause A1 C * -&gt;
       (forall L, mem L A1 -&gt; mem L A2) -&gt; sat_clause A2 C
IsC : is_clause (or L Rest)
IsA1 : is_list is_lit A1
IsA2 : is_list is_lit A2
SAT : sat_clause A1 (or L Rest) @
MemA1A2 : forall L, mem L A1 -&gt; mem L A2
SAT1 : sat_clause A1 Rest *
============================
 sat_clause A2 (or L Rest)
</pre>
<pre class="code extensibella"id="414">
 &lt; <b>case IsC.</b>

Subgoal 2:

Variables: A1 A2 Rest L
IH : forall A1 A2 C,
       is_clause C -&gt; is_list is_lit A1 -&gt; is_list is_lit A2 -&gt; sat_clause A1 C * -&gt;
       (forall L, mem L A1 -&gt; mem L A2) -&gt; sat_clause A2 C
IsA1 : is_list is_lit A1
IsA2 : is_list is_lit A2
SAT : sat_clause A1 (or L Rest) @
MemA1A2 : forall L, mem L A1 -&gt; mem L A2
SAT1 : sat_clause A1 Rest *
H1 : is_lit L
H2 : is_clause Rest
============================
 sat_clause A2 (or L Rest)
</pre>
<pre class="code extensibella"id="415">
 &lt; <b>apply IH to _ _ _ SAT1 _.</b>

Subgoal 2:

Variables: A1 A2 Rest L
IH : forall A1 A2 C,
       is_clause C -&gt; is_list is_lit A1 -&gt; is_list is_lit A2 -&gt; sat_clause A1 C * -&gt;
       (forall L, mem L A1 -&gt; mem L A2) -&gt; sat_clause A2 C
IsA1 : is_list is_lit A1
IsA2 : is_list is_lit A2
SAT : sat_clause A1 (or L Rest) @
MemA1A2 : forall L, mem L A1 -&gt; mem L A2
SAT1 : sat_clause A1 Rest *
H1 : is_lit L
H2 : is_clause Rest
H3 : sat_clause A2 Rest
============================
 sat_clause A2 (or L Rest)
</pre>
<pre class="code extensibella"id="416">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="417">
 &lt; <b>Extensible_Theorem
      sat_formula_orderless : forall A1 A2 F,
         IsF : is_formula F -&gt;
         IsA1 : is_list is_lit A1 -&gt;
         IsA2 : is_list is_lit A2 -&gt;
         SAT : sat_formula A1 F -&gt;
         MemA1A2 : (forall L,
           mem L A1 -&gt; mem L A2) -&gt;
         sat_formula A2 F
      on SAT.</b>

Subgoal 1:

Variables: A1 A2
IH : forall A1 A2 F,
       is_formula F -&gt; is_list is_lit A1 -&gt; is_list is_lit A2 -&gt; sat_formula A1 F * -&gt;
       (forall L, mem L A1 -&gt; mem L A2) -&gt; sat_formula A2 F
IsF : is_formula emptyFormula
IsA1 : is_list is_lit A1
IsA2 : is_list is_lit A2
SAT : sat_formula A1 emptyFormula @
MemA1A2 : forall L, mem L A1 -&gt; mem L A2
============================
 sat_formula A2 emptyFormula
</pre>
<pre class="code extensibella"id="418">
 &lt; <b>search.</b>

Subgoal 2:

Variables: A1 A2 Rest C
IH : forall A1 A2 F,
       is_formula F -&gt; is_list is_lit A1 -&gt; is_list is_lit A2 -&gt; sat_formula A1 F * -&gt;
       (forall L, mem L A1 -&gt; mem L A2) -&gt; sat_formula A2 F
IsF : is_formula (and C Rest)
IsA1 : is_list is_lit A1
IsA2 : is_list is_lit A2
SAT : sat_formula A1 (and C Rest) @
MemA1A2 : forall L, mem L A1 -&gt; mem L A2
SAT1 : sat_clause A1 C
SAT2 : sat_formula A1 Rest *
============================
 sat_formula A2 (and C Rest)
</pre>
<pre class="code extensibella"id="419">
 &lt; <b>case IsF.</b>

Subgoal 2:

Variables: A1 A2 Rest C
IH : forall A1 A2 F,
       is_formula F -&gt; is_list is_lit A1 -&gt; is_list is_lit A2 -&gt; sat_formula A1 F * -&gt;
       (forall L, mem L A1 -&gt; mem L A2) -&gt; sat_formula A2 F
IsA1 : is_list is_lit A1
IsA2 : is_list is_lit A2
SAT : sat_formula A1 (and C Rest) @
MemA1A2 : forall L, mem L A1 -&gt; mem L A2
SAT1 : sat_clause A1 C
SAT2 : sat_formula A1 Rest *
H1 : is_clause C
H2 : is_formula Rest
============================
 sat_formula A2 (and C Rest)
</pre>
<pre class="code extensibella"id="420">
 &lt; <b>apply IH to _ _ _ SAT2 _.</b>

Subgoal 2:

Variables: A1 A2 Rest C
IH : forall A1 A2 F,
       is_formula F -&gt; is_list is_lit A1 -&gt; is_list is_lit A2 -&gt; sat_formula A1 F * -&gt;
       (forall L, mem L A1 -&gt; mem L A2) -&gt; sat_formula A2 F
IsA1 : is_list is_lit A1
IsA2 : is_list is_lit A2
SAT : sat_formula A1 (and C Rest) @
MemA1A2 : forall L, mem L A1 -&gt; mem L A2
SAT1 : sat_clause A1 C
SAT2 : sat_formula A1 Rest *
H1 : is_clause C
H2 : is_formula Rest
H3 : sat_formula A2 Rest
============================
 sat_formula A2 (and C Rest)
</pre>
<pre class="code extensibella"id="421">
 &lt; <b>apply sat_clause_orderless to _ _ _ _ _.</b>

Subgoal 2:

Variables: A1 A2 Rest C
IH : forall A1 A2 F,
       is_formula F -&gt; is_list is_lit A1 -&gt; is_list is_lit A2 -&gt; sat_formula A1 F * -&gt;
       (forall L, mem L A1 -&gt; mem L A2) -&gt; sat_formula A2 F
IsA1 : is_list is_lit A1
IsA2 : is_list is_lit A2
SAT : sat_formula A1 (and C Rest) @
MemA1A2 : forall L, mem L A1 -&gt; mem L A2
SAT1 : sat_clause A1 C
SAT2 : sat_formula A1 Rest *
H1 : is_clause C
H2 : is_formula Rest
H3 : sat_formula A2 Rest
H4 : sat_clause A2 C
============================
 sat_formula A2 (and C Rest)
</pre>
<pre class="code extensibella"id="422">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="423">
 &lt; <b>Extensible_Theorem
      unsat_clause_orderless : forall A1 A2 C,
         IsC : is_clause C -&gt;
         IsA1 : is_list is_lit A1 -&gt;
         IsA2 : is_list is_lit A2 -&gt;
         UNSAT : unsat_clause A1 C -&gt;
         MemA1A2 : (forall L,
           mem L A1 -&gt; mem L A2) -&gt;
         unsat_clause A2 C
      on UNSAT.</b>

Subgoal 1:

Variables: A1 A2
IH : forall A1 A2 C,
       is_clause C -&gt; is_list is_lit A1 -&gt; is_list is_lit A2 -&gt; unsat_clause A1 C * -&gt;
       (forall L, mem L A1 -&gt; mem L A2) -&gt; unsat_clause A2 C
IsC : is_clause emptyClause
IsA1 : is_list is_lit A1
IsA2 : is_list is_lit A2
UNSAT : unsat_clause A1 emptyClause @
MemA1A2 : forall L, mem L A1 -&gt; mem L A2
============================
 unsat_clause A2 emptyClause
</pre>
<pre class="code extensibella"id="424">
 &lt; <b>search.</b>

Subgoal 2:

Variables: A1 A2 NL Rest L
IH : forall A1 A2 C,
       is_clause C -&gt; is_list is_lit A1 -&gt; is_list is_lit A2 -&gt; unsat_clause A1 C * -&gt;
       (forall L, mem L A1 -&gt; mem L A2) -&gt; unsat_clause A2 C
IsC : is_clause (or L Rest)
IsA1 : is_list is_lit A1
IsA2 : is_list is_lit A2
UNSAT : unsat_clause A1 (or L Rest) @
MemA1A2 : forall L, mem L A1 -&gt; mem L A2
UNSAT1 : negate_lit L NL
UNSAT2 : mem NL A1
UNSAT3 : unsat_clause A1 Rest *
============================
 unsat_clause A2 (or L Rest)
</pre>
<pre class="code extensibella"id="425">
 &lt; <b>case IsC.</b>

Subgoal 2:

Variables: A1 A2 NL Rest L
IH : forall A1 A2 C,
       is_clause C -&gt; is_list is_lit A1 -&gt; is_list is_lit A2 -&gt; unsat_clause A1 C * -&gt;
       (forall L, mem L A1 -&gt; mem L A2) -&gt; unsat_clause A2 C
IsA1 : is_list is_lit A1
IsA2 : is_list is_lit A2
UNSAT : unsat_clause A1 (or L Rest) @
MemA1A2 : forall L, mem L A1 -&gt; mem L A2
UNSAT1 : negate_lit L NL
UNSAT2 : mem NL A1
UNSAT3 : unsat_clause A1 Rest *
H1 : is_lit L
H2 : is_clause Rest
============================
 unsat_clause A2 (or L Rest)
</pre>
<pre class="code extensibella"id="426">
 &lt; <b>apply IH to _ _ _ UNSAT3 _.</b>

Subgoal 2:

Variables: A1 A2 NL Rest L
IH : forall A1 A2 C,
       is_clause C -&gt; is_list is_lit A1 -&gt; is_list is_lit A2 -&gt; unsat_clause A1 C * -&gt;
       (forall L, mem L A1 -&gt; mem L A2) -&gt; unsat_clause A2 C
IsA1 : is_list is_lit A1
IsA2 : is_list is_lit A2
UNSAT : unsat_clause A1 (or L Rest) @
MemA1A2 : forall L, mem L A1 -&gt; mem L A2
UNSAT1 : negate_lit L NL
UNSAT2 : mem NL A1
UNSAT3 : unsat_clause A1 Rest *
H1 : is_lit L
H2 : is_clause Rest
H3 : unsat_clause A2 Rest
============================
 unsat_clause A2 (or L Rest)
</pre>
<pre class="code extensibella"id="427">
 &lt; <b>apply MemA1A2 to UNSAT2.</b>

Subgoal 2:

Variables: A1 A2 NL Rest L
IH : forall A1 A2 C,
       is_clause C -&gt; is_list is_lit A1 -&gt; is_list is_lit A2 -&gt; unsat_clause A1 C * -&gt;
       (forall L, mem L A1 -&gt; mem L A2) -&gt; unsat_clause A2 C
IsA1 : is_list is_lit A1
IsA2 : is_list is_lit A2
UNSAT : unsat_clause A1 (or L Rest) @
MemA1A2 : forall L, mem L A1 -&gt; mem L A2
UNSAT1 : negate_lit L NL
UNSAT2 : mem NL A1
UNSAT3 : unsat_clause A1 Rest *
H1 : is_lit L
H2 : is_clause Rest
H3 : unsat_clause A2 Rest
H4 : mem NL A2
============================
 unsat_clause A2 (or L Rest)
</pre>
<pre class="code extensibella"id="428">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="429">
 &lt; <b>Extensible_Theorem
      unit_clause_is : forall A C L,
         IsC : is_clause C -&gt;
         IsA : is_list is_lit A -&gt;
         Unit : unit_clause A C L -&gt;
         is_lit L
      on Unit.</b>

Subgoal 1:

Variables: A L NL C1
IH : forall A C L,
       is_clause C -&gt; is_list is_lit A -&gt; unit_clause A C L * -&gt; is_lit L
IsC : is_clause (or L C1)
IsA : is_list is_lit A
Unit : unit_clause A (or L C1) L @
Unit1 : mem L A -&gt; false
Unit2 : negate_lit L NL
Unit3 : mem NL A -&gt; false
Unit4 : unsat_clause A C1
============================
 is_lit L
</pre>
<pre class="code extensibella"id="430">
 &lt; <b>case IsC.</b>

Subgoal 1:

Variables: A L NL C1
IH : forall A C L,
       is_clause C -&gt; is_list is_lit A -&gt; unit_clause A C L * -&gt; is_lit L
IsA : is_list is_lit A
Unit : unit_clause A (or L C1) L @
Unit1 : mem L A -&gt; false
Unit2 : negate_lit L NL
Unit3 : mem NL A -&gt; false
Unit4 : unsat_clause A C1
H1 : is_lit L
H2 : is_clause C1
============================
 is_lit L
</pre>
<pre class="code extensibella"id="431">
 &lt; <b>search.</b>

Subgoal 2:

Variables: A L NL C1 L1
IH : forall A C L,
       is_clause C -&gt; is_list is_lit A -&gt; unit_clause A C L * -&gt; is_lit L
IsC : is_clause (or L1 C1)
IsA : is_list is_lit A
Unit : unit_clause A (or L1 C1) L @
Unit1 : negate_lit L1 NL
Unit2 : mem NL A
Unit3 : unit_clause A C1 L *
============================
 is_lit L
</pre>
<pre class="code extensibella"id="432">
 &lt; <b>Is: case IsC.</b>

Subgoal 2:

Variables: A L NL C1 L1
IH : forall A C L,
       is_clause C -&gt; is_list is_lit A -&gt; unit_clause A C L * -&gt; is_lit L
IsA : is_list is_lit A
Unit : unit_clause A (or L1 C1) L @
Unit1 : negate_lit L1 NL
Unit2 : mem NL A
Unit3 : unit_clause A C1 L *
Is : is_lit L1
Is1 : is_clause C1
============================
 is_lit L
</pre>
<pre class="code extensibella"id="433">
 &lt; <b>apply IH to _ _ Unit3.</b>

Subgoal 2:

Variables: A L NL C1 L1
IH : forall A C L,
       is_clause C -&gt; is_list is_lit A -&gt; unit_clause A C L * -&gt; is_lit L
IsA : is_list is_lit A
Unit : unit_clause A (or L1 C1) L @
Unit1 : negate_lit L1 NL
Unit2 : mem NL A
Unit3 : unit_clause A C1 L *
Is : is_lit L1
Is1 : is_clause C1
H1 : is_lit L
============================
 is_lit L
</pre>
<pre class="code extensibella"id="434">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="435">
 &lt; <b>Extensible_Theorem
      unit_clause_unique : forall A B C LA LB,
         IsC : is_clause C -&gt;
         IsA : is_list is_lit A -&gt;
         IsB : is_list is_lit B -&gt;
         UnitA : unit_clause A C LA -&gt;
         UnitB : unit_clause B C LB -&gt;
         Prm : permutation A B -&gt;
         LA = LB
      on UnitA.</b>

Subgoal 1:

Variables: A B LA LB NL C1
IH : forall A B C LA LB,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit B -&gt; unit_clause A C LA * -&gt;
       unit_clause B C LB -&gt; permutation A B -&gt; LA = LB
IsC : is_clause (or LA C1)
IsA : is_list is_lit A
IsB : is_list is_lit B
UnitA : unit_clause A (or LA C1) LA @
UnitB : unit_clause B (or LA C1) LB
Prm : permutation A B
UnitA1 : mem LA A -&gt; false
UnitA2 : negate_lit LA NL
UnitA3 : mem NL A -&gt; false
UnitA4 : unsat_clause A C1
============================
 LA = LB
</pre>
<pre class="code extensibella"id="436">
 &lt; <b>UnitB: case UnitB.</b>

Subgoal 1.1:

Variables: A B LB NL C1 NL1
IH : forall A B C LA LB,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit B -&gt; unit_clause A C LA * -&gt;
       unit_clause B C LB -&gt; permutation A B -&gt; LA = LB
IsC : is_clause (or LB C1)
IsA : is_list is_lit A
IsB : is_list is_lit B
UnitA : unit_clause A (or LB C1) LB @
Prm : permutation A B
UnitA1 : mem LB A -&gt; false
UnitA2 : negate_lit LB NL
UnitA3 : mem NL A -&gt; false
UnitA4 : unsat_clause A C1
UnitB : mem LB B -&gt; false
UnitB1 : negate_lit LB NL1
UnitB2 : mem NL1 B -&gt; false
UnitB3 : unsat_clause B C1
============================
 LB = LB
</pre>
<pre class="code extensibella"id="437">
 &lt; <b>search.</b>

Subgoal 1.2:

Variables: A B LA LB NL C1 NL1
IH : forall A B C LA LB,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit B -&gt; unit_clause A C LA * -&gt;
       unit_clause B C LB -&gt; permutation A B -&gt; LA = LB
IsC : is_clause (or LA C1)
IsA : is_list is_lit A
IsB : is_list is_lit B
UnitA : unit_clause A (or LA C1) LA @
Prm : permutation A B
UnitA1 : mem LA A -&gt; false
UnitA2 : negate_lit LA NL
UnitA3 : mem NL A -&gt; false
UnitA4 : unsat_clause A C1
UnitB : negate_lit LA NL1
UnitB1 : mem NL1 B
UnitB2 : unit_clause B C1 LB
============================
 LA = LB
</pre>
<pre class="code extensibella"id="438">
 &lt; <b>IsLA: apply unit_clause_is to _ _ UnitA.</b>

Subgoal 1.2:

Variables: A B LA LB NL C1 NL1
IH : forall A B C LA LB,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit B -&gt; unit_clause A C LA * -&gt;
       unit_clause B C LB -&gt; permutation A B -&gt; LA = LB
IsC : is_clause (or LA C1)
IsA : is_list is_lit A
IsB : is_list is_lit B
UnitA : unit_clause A (or LA C1) LA @
Prm : permutation A B
UnitA1 : mem LA A -&gt; false
UnitA2 : negate_lit LA NL
UnitA3 : mem NL A -&gt; false
UnitA4 : unsat_clause A C1
UnitB : negate_lit LA NL1
UnitB1 : mem NL1 B
UnitB2 : unit_clause B C1 LB
IsLA : is_lit LA
============================
 LA = LB
</pre>
<pre class="code extensibella"id="439">
 &lt; <b>Is: case IsC.</b>

Subgoal 1.2:

Variables: A B LA LB NL C1 NL1
IH : forall A B C LA LB,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit B -&gt; unit_clause A C LA * -&gt;
       unit_clause B C LB -&gt; permutation A B -&gt; LA = LB
IsA : is_list is_lit A
IsB : is_list is_lit B
UnitA : unit_clause A (or LA C1) LA @
Prm : permutation A B
UnitA1 : mem LA A -&gt; false
UnitA2 : negate_lit LA NL
UnitA3 : mem NL A -&gt; false
UnitA4 : unsat_clause A C1
UnitB : negate_lit LA NL1
UnitB1 : mem NL1 B
UnitB2 : unit_clause B C1 LB
IsLA : is_lit LA
Is : is_lit LA
Is1 : is_clause C1
============================
 LA = LB
</pre>
<pre class="code extensibella"id="440">
 &lt; <b>IsLB: apply unit_clause_is to _ _ UnitB2.</b>

Subgoal 1.2:

Variables: A B LA LB NL C1 NL1
IH : forall A B C LA LB,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit B -&gt; unit_clause A C LA * -&gt;
       unit_clause B C LB -&gt; permutation A B -&gt; LA = LB
IsA : is_list is_lit A
IsB : is_list is_lit B
UnitA : unit_clause A (or LA C1) LA @
Prm : permutation A B
UnitA1 : mem LA A -&gt; false
UnitA2 : negate_lit LA NL
UnitA3 : mem NL A -&gt; false
UnitA4 : unsat_clause A C1
UnitB : negate_lit LA NL1
UnitB1 : mem NL1 B
UnitB2 : unit_clause B C1 LB
IsLA : is_lit LA
Is : is_lit LA
Is1 : is_clause C1
IsLB : is_lit LB
============================
 LA = LB
</pre>
<pre class="code extensibella"id="441">
 &lt; <b>apply negate_lit_unique to _ UnitA2 UnitB.</b>

Subgoal 1.2:

Variables: A B LA LB C1 NL1
IH : forall A B C LA LB,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit B -&gt; unit_clause A C LA * -&gt;
       unit_clause B C LB -&gt; permutation A B -&gt; LA = LB
IsA : is_list is_lit A
IsB : is_list is_lit B
UnitA : unit_clause A (or LA C1) LA @
Prm : permutation A B
UnitA1 : mem LA A -&gt; false
UnitA2 : negate_lit LA NL1
UnitA3 : mem NL1 A -&gt; false
UnitA4 : unsat_clause A C1
UnitB : negate_lit LA NL1
UnitB1 : mem NL1 B
UnitB2 : unit_clause B C1 LB
IsLA : is_lit LA
Is : is_lit LA
Is1 : is_clause C1
IsLB : is_lit LB
============================
 LA = LB
</pre>
<pre class="code extensibella"id="442">
 &lt; <b>P: apply permutation_symmetric to Prm.</b>

Subgoal 1.2:

Variables: A B LA LB C1 NL1
IH : forall A B C LA LB,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit B -&gt; unit_clause A C LA * -&gt;
       unit_clause B C LB -&gt; permutation A B -&gt; LA = LB
IsA : is_list is_lit A
IsB : is_list is_lit B
UnitA : unit_clause A (or LA C1) LA @
Prm : permutation A B
UnitA1 : mem LA A -&gt; false
UnitA2 : negate_lit LA NL1
UnitA3 : mem NL1 A -&gt; false
UnitA4 : unsat_clause A C1
UnitB : negate_lit LA NL1
UnitB1 : mem NL1 B
UnitB2 : unit_clause B C1 LB
IsLA : is_lit LA
Is : is_lit LA
Is1 : is_clause C1
IsLB : is_lit LB
P : permutation B A
============================
 LA = LB
</pre>
<pre class="code extensibella"id="443">
 &lt; <b>MemA: apply permutation_mem to P UnitB1.</b>

Subgoal 1.2:

Variables: A B LA LB C1 NL1
IH : forall A B C LA LB,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit B -&gt; unit_clause A C LA * -&gt;
       unit_clause B C LB -&gt; permutation A B -&gt; LA = LB
IsA : is_list is_lit A
IsB : is_list is_lit B
UnitA : unit_clause A (or LA C1) LA @
Prm : permutation A B
UnitA1 : mem LA A -&gt; false
UnitA2 : negate_lit LA NL1
UnitA3 : mem NL1 A -&gt; false
UnitA4 : unsat_clause A C1
UnitB : negate_lit LA NL1
UnitB1 : mem NL1 B
UnitB2 : unit_clause B C1 LB
IsLA : is_lit LA
Is : is_lit LA
Is1 : is_clause C1
IsLB : is_lit LB
P : permutation B A
MemA : mem NL1 A
============================
 LA = LB
</pre>
<pre class="code extensibella"id="444">
 &lt; <b>apply UnitA3 to MemA.</b>

Subgoal 2:

Variables: A B LA LB NL C1 L
IH : forall A B C LA LB,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit B -&gt; unit_clause A C LA * -&gt;
       unit_clause B C LB -&gt; permutation A B -&gt; LA = LB
IsC : is_clause (or L C1)
IsA : is_list is_lit A
IsB : is_list is_lit B
UnitA : unit_clause A (or L C1) LA @
UnitB : unit_clause B (or L C1) LB
Prm : permutation A B
UnitA1 : negate_lit L NL
UnitA2 : mem NL A
UnitA3 : unit_clause A C1 LA *
============================
 LA = LB
</pre>
<pre class="code extensibella"id="445">
 &lt; <b>UnitB: case UnitB.</b>

Subgoal 2.1:

Variables: A B LA LB NL C1 NL1
IH : forall A B C LA LB,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit B -&gt; unit_clause A C LA * -&gt;
       unit_clause B C LB -&gt; permutation A B -&gt; LA = LB
IsC : is_clause (or LB C1)
IsA : is_list is_lit A
IsB : is_list is_lit B
UnitA : unit_clause A (or LB C1) LA @
Prm : permutation A B
UnitA1 : negate_lit LB NL
UnitA2 : mem NL A
UnitA3 : unit_clause A C1 LA *
UnitB : mem LB B -&gt; false
UnitB1 : negate_lit LB NL1
UnitB2 : mem NL1 B -&gt; false
UnitB3 : unsat_clause B C1
============================
 LA = LB
</pre>
<pre class="code extensibella"id="446">
 &lt; <b>MemB: apply permutation_mem to Prm UnitA2.</b>

Subgoal 2.1:

Variables: A B LA LB NL C1 NL1
IH : forall A B C LA LB,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit B -&gt; unit_clause A C LA * -&gt;
       unit_clause B C LB -&gt; permutation A B -&gt; LA = LB
IsC : is_clause (or LB C1)
IsA : is_list is_lit A
IsB : is_list is_lit B
UnitA : unit_clause A (or LB C1) LA @
Prm : permutation A B
UnitA1 : negate_lit LB NL
UnitA2 : mem NL A
UnitA3 : unit_clause A C1 LA *
UnitB : mem LB B -&gt; false
UnitB1 : negate_lit LB NL1
UnitB2 : mem NL1 B -&gt; false
UnitB3 : unsat_clause B C1
MemB : mem NL B
============================
 LA = LB
</pre>
<pre class="code extensibella"id="447">
 &lt; <b>Is: case IsC.</b>

Subgoal 2.1:

Variables: A B LA LB NL C1 NL1
IH : forall A B C LA LB,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit B -&gt; unit_clause A C LA * -&gt;
       unit_clause B C LB -&gt; permutation A B -&gt; LA = LB
IsA : is_list is_lit A
IsB : is_list is_lit B
UnitA : unit_clause A (or LB C1) LA @
Prm : permutation A B
UnitA1 : negate_lit LB NL
UnitA2 : mem NL A
UnitA3 : unit_clause A C1 LA *
UnitB : mem LB B -&gt; false
UnitB1 : negate_lit LB NL1
UnitB2 : mem NL1 B -&gt; false
UnitB3 : unsat_clause B C1
MemB : mem NL B
Is : is_lit LB
Is1 : is_clause C1
============================
 LA = LB
</pre>
<pre class="code extensibella"id="448">
 &lt; <b>apply negate_lit_unique to _ UnitA1 UnitB1.</b>

Subgoal 2.1:

Variables: A B LA LB C1 NL1
IH : forall A B C LA LB,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit B -&gt; unit_clause A C LA * -&gt;
       unit_clause B C LB -&gt; permutation A B -&gt; LA = LB
IsA : is_list is_lit A
IsB : is_list is_lit B
UnitA : unit_clause A (or LB C1) LA @
Prm : permutation A B
UnitA1 : negate_lit LB NL1
UnitA2 : mem NL1 A
UnitA3 : unit_clause A C1 LA *
UnitB : mem LB B -&gt; false
UnitB1 : negate_lit LB NL1
UnitB2 : mem NL1 B -&gt; false
UnitB3 : unsat_clause B C1
MemB : mem NL1 B
Is : is_lit LB
Is1 : is_clause C1
============================
 LA = LB
</pre>
<pre class="code extensibella"id="449">
 &lt; <b>apply UnitB2 to MemB.</b>

Subgoal 2.2:

Variables: A B LA LB NL C1 L NL1
IH : forall A B C LA LB,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit B -&gt; unit_clause A C LA * -&gt;
       unit_clause B C LB -&gt; permutation A B -&gt; LA = LB
IsC : is_clause (or L C1)
IsA : is_list is_lit A
IsB : is_list is_lit B
UnitA : unit_clause A (or L C1) LA @
Prm : permutation A B
UnitA1 : negate_lit L NL
UnitA2 : mem NL A
UnitA3 : unit_clause A C1 LA *
UnitB : negate_lit L NL1
UnitB1 : mem NL1 B
UnitB2 : unit_clause B C1 LB
============================
 LA = LB
</pre>
<pre class="code extensibella"id="450">
 &lt; <b>case IsC.</b>

Subgoal 2.2:

Variables: A B LA LB NL C1 L NL1
IH : forall A B C LA LB,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit B -&gt; unit_clause A C LA * -&gt;
       unit_clause B C LB -&gt; permutation A B -&gt; LA = LB
IsA : is_list is_lit A
IsB : is_list is_lit B
UnitA : unit_clause A (or L C1) LA @
Prm : permutation A B
UnitA1 : negate_lit L NL
UnitA2 : mem NL A
UnitA3 : unit_clause A C1 LA *
UnitB : negate_lit L NL1
UnitB1 : mem NL1 B
UnitB2 : unit_clause B C1 LB
H1 : is_lit L
H2 : is_clause C1
============================
 LA = LB
</pre>
<pre class="code extensibella"id="451">
 &lt; <b>apply IH to _ _ _ UnitA3 _ _.</b>

Subgoal 2.2:

Variables: A B LB NL C1 L NL1
IH : forall A B C LA LB,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit B -&gt; unit_clause A C LA * -&gt;
       unit_clause B C LB -&gt; permutation A B -&gt; LA = LB
IsA : is_list is_lit A
IsB : is_list is_lit B
UnitA : unit_clause A (or L C1) LB @
Prm : permutation A B
UnitA1 : negate_lit L NL
UnitA2 : mem NL A
UnitA3 : unit_clause A C1 LB *
UnitB : negate_lit L NL1
UnitB1 : mem NL1 B
UnitB2 : unit_clause B C1 LB
H1 : is_lit L
H2 : is_clause C1
============================
 LB = LB
</pre>
<pre class="code extensibella"id="452">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="453">
 &lt; <b>Extensible_Theorem
      unit_clause_not_assigned : forall A C L,
         IsC : is_clause C -&gt;
         IsA : is_list is_lit A -&gt;
         UC : unit_clause A C L -&gt;
         Mem : mem L A -&gt;
         false
      on UC.</b>

Subgoal 1:

Variables: A L NL C1
IH : forall A C L,
       is_clause C -&gt; is_list is_lit A -&gt; unit_clause A C L * -&gt; mem L A -&gt; false
IsC : is_clause (or L C1)
IsA : is_list is_lit A
UC : unit_clause A (or L C1) L @
Mem : mem L A
UC1 : mem L A -&gt; false
UC2 : negate_lit L NL
UC3 : mem NL A -&gt; false
UC4 : unsat_clause A C1
============================
 false
</pre>
<pre class="code extensibella"id="454">
 &lt; <b>backchain UC1.</b>

Subgoal 2:

Variables: A L NL C1 L1
IH : forall A C L,
       is_clause C -&gt; is_list is_lit A -&gt; unit_clause A C L * -&gt; mem L A -&gt; false
IsC : is_clause (or L1 C1)
IsA : is_list is_lit A
UC : unit_clause A (or L1 C1) L @
Mem : mem L A
UC1 : negate_lit L1 NL
UC2 : mem NL A
UC3 : unit_clause A C1 L *
============================
 false
</pre>
<pre class="code extensibella"id="455">
 &lt; <b>case IsC.</b>

Subgoal 2:

Variables: A L NL C1 L1
IH : forall A C L,
       is_clause C -&gt; is_list is_lit A -&gt; unit_clause A C L * -&gt; mem L A -&gt; false
IsA : is_list is_lit A
UC : unit_clause A (or L1 C1) L @
Mem : mem L A
UC1 : negate_lit L1 NL
UC2 : mem NL A
UC3 : unit_clause A C1 L *
H1 : is_lit L1
H2 : is_clause C1
============================
 false
</pre>
<pre class="code extensibella"id="456">
 &lt; <b>apply IH to _ _ UC3 Mem.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="457">
 &lt; <b>Extensible_Theorem
      unit_clause_not_assigned_negate : forall A C L NL,
         IsC : is_clause C -&gt;
         IsA : is_list is_lit A -&gt;
         UC : unit_clause A C L -&gt;
         Neg : negate_lit L NL -&gt;
         Mem : mem NL A -&gt;
         false
      on UC.</b>

Subgoal 1:

Variables: A L NL NL1 C1
IH : forall A C L NL,
       is_clause C -&gt; is_list is_lit A -&gt; unit_clause A C L * -&gt; negate_lit L NL -&gt;
       mem NL A -&gt; false
IsC : is_clause (or L C1)
IsA : is_list is_lit A
UC : unit_clause A (or L C1) L @
Neg : negate_lit L NL
Mem : mem NL A
UC1 : mem L A -&gt; false
UC2 : negate_lit L NL1
UC3 : mem NL1 A -&gt; false
UC4 : unsat_clause A C1
============================
 false
</pre>
<pre class="code extensibella"id="458">
 &lt; <b>backchain UC3.</b>

Subgoal 1:

Variables: A L NL NL1 C1
IH : forall A C L NL,
       is_clause C -&gt; is_list is_lit A -&gt; unit_clause A C L * -&gt; negate_lit L NL -&gt;
       mem NL A -&gt; false
IsC : is_clause (or L C1)
IsA : is_list is_lit A
UC : unit_clause A (or L C1) L @
Neg : negate_lit L NL
Mem : mem NL A
UC1 : mem L A -&gt; false
UC2 : negate_lit L NL1
UC3 : mem NL1 A -&gt; false
UC4 : unsat_clause A C1
============================
 mem NL1 A
</pre>
<pre class="code extensibella"id="459">
 &lt; <b>apply unit_clause_is to _ _ UC.</b>

Subgoal 1:

Variables: A L NL NL1 C1
IH : forall A C L NL,
       is_clause C -&gt; is_list is_lit A -&gt; unit_clause A C L * -&gt; negate_lit L NL -&gt;
       mem NL A -&gt; false
IsC : is_clause (or L C1)
IsA : is_list is_lit A
UC : unit_clause A (or L C1) L @
Neg : negate_lit L NL
Mem : mem NL A
UC1 : mem L A -&gt; false
UC2 : negate_lit L NL1
UC3 : mem NL1 A -&gt; false
UC4 : unsat_clause A C1
H1 : is_lit L
============================
 mem NL1 A
</pre>
<pre class="code extensibella"id="460">
 &lt; <b>apply negate_lit_unique to _ Neg UC2.</b>

Subgoal 1:

Variables: A L NL1 C1
IH : forall A C L NL,
       is_clause C -&gt; is_list is_lit A -&gt; unit_clause A C L * -&gt; negate_lit L NL -&gt;
       mem NL A -&gt; false
IsC : is_clause (or L C1)
IsA : is_list is_lit A
UC : unit_clause A (or L C1) L @
Neg : negate_lit L NL1
Mem : mem NL1 A
UC1 : mem L A -&gt; false
UC2 : negate_lit L NL1
UC3 : mem NL1 A -&gt; false
UC4 : unsat_clause A C1
H1 : is_lit L
============================
 mem NL1 A
</pre>
<pre class="code extensibella"id="461">
 &lt; <b>search.</b>

Subgoal 2:

Variables: A L NL NL1 C1 L1
IH : forall A C L NL,
       is_clause C -&gt; is_list is_lit A -&gt; unit_clause A C L * -&gt; negate_lit L NL -&gt;
       mem NL A -&gt; false
IsC : is_clause (or L1 C1)
IsA : is_list is_lit A
UC : unit_clause A (or L1 C1) L @
Neg : negate_lit L NL
Mem : mem NL A
UC1 : negate_lit L1 NL1
UC2 : mem NL1 A
UC3 : unit_clause A C1 L *
============================
 false
</pre>
<pre class="code extensibella"id="462">
 &lt; <b>case IsC.</b>

Subgoal 2:

Variables: A L NL NL1 C1 L1
IH : forall A C L NL,
       is_clause C -&gt; is_list is_lit A -&gt; unit_clause A C L * -&gt; negate_lit L NL -&gt;
       mem NL A -&gt; false
IsA : is_list is_lit A
UC : unit_clause A (or L1 C1) L @
Neg : negate_lit L NL
Mem : mem NL A
UC1 : negate_lit L1 NL1
UC2 : mem NL1 A
UC3 : unit_clause A C1 L *
H1 : is_lit L1
H2 : is_clause C1
============================
 false
</pre>
<pre class="code extensibella"id="463">
 &lt; <b>apply IH to _ _ UC3 _ _.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="464">
 &lt; <b>Extensible_Theorem
      unit_clause_expand : forall A C L E,
         IsC : is_clause C -&gt;
         IsA : is_list is_lit A -&gt;
         IsE : is_list is_lit E -&gt;
         UC : unit_clause A C L -&gt;
         SAT : sat_clause E C -&gt;
         GA_A : good_assignment A -&gt;
         GA_E : good_assignment E -&gt;
         Expand : (forall L,
           mem L A -&gt; mem L E) -&gt;
         mem L E
      on UC.</b>

Subgoal 1:

Variables: A L E NL C1
IH : forall A C L E,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit E -&gt; unit_clause A C L * -&gt;
       sat_clause E C -&gt; good_assignment A -&gt; good_assignment E -&gt; (forall L1,
         mem L1 A -&gt; mem L1 E) -&gt; mem L E
IsC : is_clause (or L C1)
IsA : is_list is_lit A
IsE : is_list is_lit E
UC : unit_clause A (or L C1) L @
SAT : sat_clause E (or L C1)
GA_A : good_assignment A
GA_E : good_assignment E
Expand : forall L, mem L A -&gt; mem L E
UC1 : mem L A -&gt; false
UC2 : negate_lit L NL
UC3 : mem NL A -&gt; false
UC4 : unsat_clause A C1
============================
 mem L E
</pre>
<pre class="code extensibella"id="465">
 &lt; <b>SAT: case SAT.</b>

Subgoal 1.1:

Variables: A L E NL C1
IH : forall A C L E,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit E -&gt; unit_clause A C L * -&gt;
       sat_clause E C -&gt; good_assignment A -&gt; good_assignment E -&gt; (forall L1,
         mem L1 A -&gt; mem L1 E) -&gt; mem L E
IsC : is_clause (or L C1)
IsA : is_list is_lit A
IsE : is_list is_lit E
UC : unit_clause A (or L C1) L @
GA_A : good_assignment A
GA_E : good_assignment E
Expand : forall L, mem L A -&gt; mem L E
UC1 : mem L A -&gt; false
UC2 : negate_lit L NL
UC3 : mem NL A -&gt; false
UC4 : unsat_clause A C1
SAT : mem L E
============================
 mem L E
</pre>
<pre class="code extensibella"id="466">
 &lt; <b>search.</b>

Subgoal 1.2:

Variables: A L E NL C1
IH : forall A C L E,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit E -&gt; unit_clause A C L * -&gt;
       sat_clause E C -&gt; good_assignment A -&gt; good_assignment E -&gt; (forall L1,
         mem L1 A -&gt; mem L1 E) -&gt; mem L E
IsC : is_clause (or L C1)
IsA : is_list is_lit A
IsE : is_list is_lit E
UC : unit_clause A (or L C1) L @
GA_A : good_assignment A
GA_E : good_assignment E
Expand : forall L, mem L A -&gt; mem L E
UC1 : mem L A -&gt; false
UC2 : negate_lit L NL
UC3 : mem NL A -&gt; false
UC4 : unsat_clause A C1
SAT : sat_clause E C1
============================
 mem L E
</pre>
<pre class="code extensibella"id="467">
 &lt; <b>Is: case IsC.</b>

Subgoal 1.2:

Variables: A L E NL C1
IH : forall A C L E,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit E -&gt; unit_clause A C L * -&gt;
       sat_clause E C -&gt; good_assignment A -&gt; good_assignment E -&gt; (forall L1,
         mem L1 A -&gt; mem L1 E) -&gt; mem L E
IsA : is_list is_lit A
IsE : is_list is_lit E
UC : unit_clause A (or L C1) L @
GA_A : good_assignment A
GA_E : good_assignment E
Expand : forall L, mem L A -&gt; mem L E
UC1 : mem L A -&gt; false
UC2 : negate_lit L NL
UC3 : mem NL A -&gt; false
UC4 : unsat_clause A C1
SAT : sat_clause E C1
Is : is_lit L
Is1 : is_clause C1
============================
 mem L E
</pre>
<pre class="code extensibella"id="468">
 &lt; <b>UCE: apply unsat_clause_orderless to _ _ _ UC4 Expand.</b>

Subgoal 1.2:

Variables: A L E NL C1
IH : forall A C L E,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit E -&gt; unit_clause A C L * -&gt;
       sat_clause E C -&gt; good_assignment A -&gt; good_assignment E -&gt; (forall L1,
         mem L1 A -&gt; mem L1 E) -&gt; mem L E
IsA : is_list is_lit A
IsE : is_list is_lit E
UC : unit_clause A (or L C1) L @
GA_A : good_assignment A
GA_E : good_assignment E
Expand : forall L, mem L A -&gt; mem L E
UC1 : mem L A -&gt; false
UC2 : negate_lit L NL
UC3 : mem NL A -&gt; false
UC4 : unsat_clause A C1
SAT : sat_clause E C1
Is : is_lit L
Is1 : is_clause C1
UCE : unsat_clause E C1
============================
 mem L E
</pre>
<pre class="code extensibella"id="469">
 &lt; <b>apply unsat_sat_clause to _ _ UCE SAT _.</b>

Subgoal 2:

Variables: A L E NL C1 L1
IH : forall A C L E,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit E -&gt; unit_clause A C L * -&gt;
       sat_clause E C -&gt; good_assignment A -&gt; good_assignment E -&gt; (forall L1,
         mem L1 A -&gt; mem L1 E) -&gt; mem L E
IsC : is_clause (or L1 C1)
IsA : is_list is_lit A
IsE : is_list is_lit E
UC : unit_clause A (or L1 C1) L @
SAT : sat_clause E (or L1 C1)
GA_A : good_assignment A
GA_E : good_assignment E
Expand : forall L, mem L A -&gt; mem L E
UC1 : negate_lit L1 NL
UC2 : mem NL A
UC3 : unit_clause A C1 L *
============================
 mem L E
</pre>
<pre class="code extensibella"id="470">
 &lt; <b>SAT: case SAT.</b>

Subgoal 2.1:

Variables: A L E NL C1 L1
IH : forall A C L E,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit E -&gt; unit_clause A C L * -&gt;
       sat_clause E C -&gt; good_assignment A -&gt; good_assignment E -&gt; (forall L1,
         mem L1 A -&gt; mem L1 E) -&gt; mem L E
IsC : is_clause (or L1 C1)
IsA : is_list is_lit A
IsE : is_list is_lit E
UC : unit_clause A (or L1 C1) L @
GA_A : good_assignment A
GA_E : good_assignment E
Expand : forall L, mem L A -&gt; mem L E
UC1 : negate_lit L1 NL
UC2 : mem NL A
UC3 : unit_clause A C1 L *
SAT : mem L1 E
============================
 mem L E
</pre>
<pre class="code extensibella"id="471">
 &lt; <b>GA_A: case GA_A.</b>

Subgoal 2.1:

Variables: A L E NL C1 L1
IH : forall A C L E,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit E -&gt; unit_clause A C L * -&gt;
       sat_clause E C -&gt; good_assignment A -&gt; good_assignment E -&gt; (forall L1,
         mem L1 A -&gt; mem L1 E) -&gt; mem L E
IsC : is_clause (or L1 C1)
IsA : is_list is_lit A
IsE : is_list is_lit E
UC : unit_clause A (or L1 C1) L @
GA_E : good_assignment E
Expand : forall L, mem L A -&gt; mem L E
UC1 : negate_lit L1 NL
UC2 : mem NL A
UC3 : unit_clause A C1 L *
SAT : mem L1 E
GA_A : forall L NL, mem L A -&gt; negate_lit L NL -&gt; mem NL A -&gt; false
============================
 mem L E
</pre>
<pre class="code extensibella"id="472">
 &lt; <b>Is: case IsC.</b>

Subgoal 2.1:

Variables: A L E NL C1 L1
IH : forall A C L E,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit E -&gt; unit_clause A C L * -&gt;
       sat_clause E C -&gt; good_assignment A -&gt; good_assignment E -&gt; (forall L1,
         mem L1 A -&gt; mem L1 E) -&gt; mem L E
IsA : is_list is_lit A
IsE : is_list is_lit E
UC : unit_clause A (or L1 C1) L @
GA_E : good_assignment E
Expand : forall L, mem L A -&gt; mem L E
UC1 : negate_lit L1 NL
UC2 : mem NL A
UC3 : unit_clause A C1 L *
SAT : mem L1 E
GA_A : forall L NL, mem L A -&gt; negate_lit L NL -&gt; mem NL A -&gt; false
Is : is_lit L1
Is1 : is_clause C1
============================
 mem L E
</pre>
<pre class="code extensibella"id="473">
 &lt; <b>Neg: apply negate_lit_reverse to _ UC1.</b>

Subgoal 2.1:

Variables: A L E NL C1 L1
IH : forall A C L E,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit E -&gt; unit_clause A C L * -&gt;
       sat_clause E C -&gt; good_assignment A -&gt; good_assignment E -&gt; (forall L1,
         mem L1 A -&gt; mem L1 E) -&gt; mem L E
IsA : is_list is_lit A
IsE : is_list is_lit E
UC : unit_clause A (or L1 C1) L @
GA_E : good_assignment E
Expand : forall L, mem L A -&gt; mem L E
UC1 : negate_lit L1 NL
UC2 : mem NL A
UC3 : unit_clause A C1 L *
SAT : mem L1 E
GA_A : forall L NL, mem L A -&gt; negate_lit L NL -&gt; mem NL A -&gt; false
Is : is_lit L1
Is1 : is_clause C1
Neg : negate_lit NL L1
============================
 mem L E
</pre>
<pre class="code extensibella"id="474">
 &lt; <b>apply GA_A to UC2 Neg _.</b>

Subgoal 2.1:

Variables: A L E NL C1 L1
IH : forall A C L E,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit E -&gt; unit_clause A C L * -&gt;
       sat_clause E C -&gt; good_assignment A -&gt; good_assignment E -&gt; (forall L1,
         mem L1 A -&gt; mem L1 E) -&gt; mem L E
IsA : is_list is_lit A
IsE : is_list is_lit E
UC : unit_clause A (or L1 C1) L @
GA_E : good_assignment E
Expand : forall L, mem L A -&gt; mem L E
UC1 : negate_lit L1 NL
UC2 : mem NL A
UC3 : unit_clause A C1 L *
SAT : mem L1 E
GA_A : forall L NL, mem L A -&gt; negate_lit L NL -&gt; mem NL A -&gt; false
Is : is_lit L1
Is1 : is_clause C1
Neg : negate_lit NL L1
============================
 mem L1 A
</pre>
<pre class="code extensibella"id="475">
 &lt; <b>GA_E: case GA_E.</b>

Subgoal 2.1:

Variables: A L E NL C1 L1
IH : forall A C L E,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit E -&gt; unit_clause A C L * -&gt;
       sat_clause E C -&gt; good_assignment A -&gt; good_assignment E -&gt; (forall L1,
         mem L1 A -&gt; mem L1 E) -&gt; mem L E
IsA : is_list is_lit A
IsE : is_list is_lit E
UC : unit_clause A (or L1 C1) L @
Expand : forall L, mem L A -&gt; mem L E
UC1 : negate_lit L1 NL
UC2 : mem NL A
UC3 : unit_clause A C1 L *
SAT : mem L1 E
GA_A : forall L NL, mem L A -&gt; negate_lit L NL -&gt; mem NL A -&gt; false
Is : is_lit L1
Is1 : is_clause C1
Neg : negate_lit NL L1
GA_E : forall L NL, mem L E -&gt; negate_lit L NL -&gt; mem NL E -&gt; false
============================
 mem L1 A
</pre>
<pre class="code extensibella"id="476">
 &lt; <b>apply GA_E to SAT UC1 _.</b>

Subgoal 2.1:

Variables: A L E NL C1 L1
IH : forall A C L E,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit E -&gt; unit_clause A C L * -&gt;
       sat_clause E C -&gt; good_assignment A -&gt; good_assignment E -&gt; (forall L1,
         mem L1 A -&gt; mem L1 E) -&gt; mem L E
IsA : is_list is_lit A
IsE : is_list is_lit E
UC : unit_clause A (or L1 C1) L @
Expand : forall L, mem L A -&gt; mem L E
UC1 : negate_lit L1 NL
UC2 : mem NL A
UC3 : unit_clause A C1 L *
SAT : mem L1 E
GA_A : forall L NL, mem L A -&gt; negate_lit L NL -&gt; mem NL A -&gt; false
Is : is_lit L1
Is1 : is_clause C1
Neg : negate_lit NL L1
GA_E : forall L NL, mem L E -&gt; negate_lit L NL -&gt; mem NL E -&gt; false
============================
 mem NL E
</pre>
<pre class="code extensibella"id="477">
 &lt; <b>apply Expand to UC2.</b>

Subgoal 2.1:

Variables: A L E NL C1 L1
IH : forall A C L E,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit E -&gt; unit_clause A C L * -&gt;
       sat_clause E C -&gt; good_assignment A -&gt; good_assignment E -&gt; (forall L1,
         mem L1 A -&gt; mem L1 E) -&gt; mem L E
IsA : is_list is_lit A
IsE : is_list is_lit E
UC : unit_clause A (or L1 C1) L @
Expand : forall L, mem L A -&gt; mem L E
UC1 : negate_lit L1 NL
UC2 : mem NL A
UC3 : unit_clause A C1 L *
SAT : mem L1 E
GA_A : forall L NL, mem L A -&gt; negate_lit L NL -&gt; mem NL A -&gt; false
Is : is_lit L1
Is1 : is_clause C1
Neg : negate_lit NL L1
GA_E : forall L NL, mem L E -&gt; negate_lit L NL -&gt; mem NL E -&gt; false
H1 : mem NL E
============================
 mem NL E
</pre>
<pre class="code extensibella"id="478">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: A L E NL C1 L1
IH : forall A C L E,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit E -&gt; unit_clause A C L * -&gt;
       sat_clause E C -&gt; good_assignment A -&gt; good_assignment E -&gt; (forall L1,
         mem L1 A -&gt; mem L1 E) -&gt; mem L E
IsC : is_clause (or L1 C1)
IsA : is_list is_lit A
IsE : is_list is_lit E
UC : unit_clause A (or L1 C1) L @
GA_A : good_assignment A
GA_E : good_assignment E
Expand : forall L, mem L A -&gt; mem L E
UC1 : negate_lit L1 NL
UC2 : mem NL A
UC3 : unit_clause A C1 L *
SAT : sat_clause E C1
============================
 mem L E
</pre>
<pre class="code extensibella"id="479">
 &lt; <b>case IsC.</b>

Subgoal 2.2:

Variables: A L E NL C1 L1
IH : forall A C L E,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit E -&gt; unit_clause A C L * -&gt;
       sat_clause E C -&gt; good_assignment A -&gt; good_assignment E -&gt; (forall L1,
         mem L1 A -&gt; mem L1 E) -&gt; mem L E
IsA : is_list is_lit A
IsE : is_list is_lit E
UC : unit_clause A (or L1 C1) L @
GA_A : good_assignment A
GA_E : good_assignment E
Expand : forall L, mem L A -&gt; mem L E
UC1 : negate_lit L1 NL
UC2 : mem NL A
UC3 : unit_clause A C1 L *
SAT : sat_clause E C1
H1 : is_lit L1
H2 : is_clause C1
============================
 mem L E
</pre>
<pre class="code extensibella"id="480">
 &lt; <b>apply IH to _ _ _ UC3 _ _ _ _.</b>

Subgoal 2.2:

Variables: A L E NL C1 L1
IH : forall A C L E,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit E -&gt; unit_clause A C L * -&gt;
       sat_clause E C -&gt; good_assignment A -&gt; good_assignment E -&gt; (forall L1,
         mem L1 A -&gt; mem L1 E) -&gt; mem L E
IsA : is_list is_lit A
IsE : is_list is_lit E
UC : unit_clause A (or L1 C1) L @
GA_A : good_assignment A
GA_E : good_assignment E
Expand : forall L, mem L A -&gt; mem L E
UC1 : negate_lit L1 NL
UC2 : mem NL A
UC3 : unit_clause A C1 L *
SAT : sat_clause E C1
H1 : is_lit L1
H2 : is_clause C1
H3 : mem L E
============================
 mem L E
</pre>
<pre class="code extensibella"id="481">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="482">
 &lt; <b>Extensible_Theorem
      unit_clause_add : forall A S C L,
         IsC : is_clause C -&gt;
         IsA : is_list is_lit A -&gt;
         IsS : is_list is_lit S -&gt;
         UC : unit_clause A C L -&gt;
         Mem : mem L S -&gt;
         sat_clause S C
      on UC.</b>

Subgoal 1:

Variables: A S L NL C1
IH : forall A S C L,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit S -&gt; unit_clause A C L * -&gt;
       mem L S -&gt; sat_clause S C
IsC : is_clause (or L C1)
IsA : is_list is_lit A
IsS : is_list is_lit S
UC : unit_clause A (or L C1) L @
Mem : mem L S
UC1 : mem L A -&gt; false
UC2 : negate_lit L NL
UC3 : mem NL A -&gt; false
UC4 : unsat_clause A C1
============================
 sat_clause S (or L C1)
</pre>
<pre class="code extensibella"id="483">
 &lt; <b>search.</b>

Subgoal 2:

Variables: A S L NL C1 L1
IH : forall A S C L,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit S -&gt; unit_clause A C L * -&gt;
       mem L S -&gt; sat_clause S C
IsC : is_clause (or L1 C1)
IsA : is_list is_lit A
IsS : is_list is_lit S
UC : unit_clause A (or L1 C1) L @
Mem : mem L S
UC1 : negate_lit L1 NL
UC2 : mem NL A
UC3 : unit_clause A C1 L *
============================
 sat_clause S (or L1 C1)
</pre>
<pre class="code extensibella"id="484">
 &lt; <b>case IsC.</b>

Subgoal 2:

Variables: A S L NL C1 L1
IH : forall A S C L,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit S -&gt; unit_clause A C L * -&gt;
       mem L S -&gt; sat_clause S C
IsA : is_list is_lit A
IsS : is_list is_lit S
UC : unit_clause A (or L1 C1) L @
Mem : mem L S
UC1 : negate_lit L1 NL
UC2 : mem NL A
UC3 : unit_clause A C1 L *
H1 : is_lit L1
H2 : is_clause C1
============================
 sat_clause S (or L1 C1)
</pre>
<pre class="code extensibella"id="485">
 &lt; <b>apply IH to _ _ _ UC3 _.</b>

Subgoal 2:

Variables: A S L NL C1 L1
IH : forall A S C L,
       is_clause C -&gt; is_list is_lit A -&gt; is_list is_lit S -&gt; unit_clause A C L * -&gt;
       mem L S -&gt; sat_clause S C
IsA : is_list is_lit A
IsS : is_list is_lit S
UC : unit_clause A (or L1 C1) L @
Mem : mem L S
UC1 : negate_lit L1 NL
UC2 : mem NL A
UC3 : unit_clause A C1 L *
H1 : is_lit L1
H2 : is_clause C1
H3 : sat_clause S C1
============================
 sat_clause S (or L1 C1)
</pre>
<pre class="code extensibella"id="486">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="487">
 &lt; <b>Theorem remove_all_no_lookup :
     forall Known ID KRest, remove_all Known ID KRest -&gt; no_lookup KRest ID.</b>

============================
 forall Known ID KRest, remove_all Known ID KRest -&gt; no_lookup KRest ID
</pre>
<pre class="code extensibella"id="488">
 &lt; <b>induction on 1.</b>

IH : forall Known ID KRest, remove_all Known ID KRest * -&gt; no_lookup KRest ID
============================
 forall Known ID KRest, remove_all Known ID KRest @ -&gt; no_lookup KRest ID
</pre>
<pre class="code extensibella"id="489">
 &lt; <b>intros RA.</b>

Variables: Known ID KRest
IH : forall Known ID KRest, remove_all Known ID KRest * -&gt; no_lookup KRest ID
RA : remove_all Known ID KRest @
============================
 no_lookup KRest ID
</pre>
<pre class="code extensibella"id="490">
 &lt; <b>RA: case RA.</b>

Subgoal 1:

Variables: ID
IH : forall Known ID KRest, remove_all Known ID KRest * -&gt; no_lookup KRest ID
============================
 no_lookup [] ID
</pre>
<pre class="code extensibella"id="491">
 &lt; <b>search.</b>

Subgoal 2:

Variables: ID KRest IRest C
IH : forall Known ID KRest, remove_all Known ID KRest * -&gt; no_lookup KRest ID
RA : remove_all IRest ID KRest *
============================
 no_lookup KRest ID
</pre>
<pre class="code extensibella"id="492">
 &lt; <b>apply IH to RA.</b>

Subgoal 2:

Variables: ID KRest IRest C
IH : forall Known ID KRest, remove_all Known ID KRest * -&gt; no_lookup KRest ID
RA : remove_all IRest ID KRest *
H1 : no_lookup KRest ID
============================
 no_lookup KRest ID
</pre>
<pre class="code extensibella"id="493">
 &lt; <b>search.</b>

Subgoal 3:

Variables: ID Rest C A IRest
IH : forall Known ID KRest, remove_all Known ID KRest * -&gt; no_lookup KRest ID
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
============================
 no_lookup ((A, C)::Rest) ID
</pre>
<pre class="code extensibella"id="494">
 &lt; <b>apply IH to RA1.</b>

Subgoal 3:

Variables: ID Rest C A IRest
IH : forall Known ID KRest, remove_all Known ID KRest * -&gt; no_lookup KRest ID
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
H1 : no_lookup Rest ID
============================
 no_lookup ((A, C)::Rest) ID
</pre>
<pre class="code extensibella"id="495">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="496">
 &lt; <b>Theorem remove_all_no_mem :
     forall Known ID KRest C,
       remove_all Known ID KRest -&gt; mem (ID, C) KRest -&gt; false.</b>

============================
 forall Known ID KRest C,
   remove_all Known ID KRest -&gt; mem (ID, C) KRest -&gt; false
</pre>
<pre class="code extensibella"id="497">
 &lt; <b>induction on 1.</b>

IH : forall Known ID KRest C,
       remove_all Known ID KRest * -&gt; mem (ID, C) KRest -&gt; false
============================
 forall Known ID KRest C,
   remove_all Known ID KRest @ -&gt; mem (ID, C) KRest -&gt; false
</pre>
<pre class="code extensibella"id="498">
 &lt; <b>intros RA M.</b>

Variables: Known ID KRest C
IH : forall Known ID KRest C,
       remove_all Known ID KRest * -&gt; mem (ID, C) KRest -&gt; false
RA : remove_all Known ID KRest @
M : mem (ID, C) KRest
============================
 false
</pre>
<pre class="code extensibella"id="499">
 &lt; <b>RA: case RA.</b>

Subgoal 1:

Variables: ID C
IH : forall Known ID KRest C,
       remove_all Known ID KRest * -&gt; mem (ID, C) KRest -&gt; false
M : mem (ID, C) []
============================
 false
</pre>
<pre class="code extensibella"id="500">
 &lt; <b>case M.</b>

Subgoal 2:

Variables: ID KRest C IRest C1
IH : forall Known ID KRest C,
       remove_all Known ID KRest * -&gt; mem (ID, C) KRest -&gt; false
M : mem (ID, C) KRest
RA : remove_all IRest ID KRest *
============================
 false
</pre>
<pre class="code extensibella"id="501">
 &lt; <b>apply IH to RA M.</b>

Subgoal 3:

Variables: ID C Rest C1 A IRest
IH : forall Known ID KRest C,
       remove_all Known ID KRest * -&gt; mem (ID, C) KRest -&gt; false
M : mem (ID, C) ((A, C1)::Rest)
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
============================
 false
</pre>
<pre class="code extensibella"id="502">
 &lt; <b>M: case M.</b>

Subgoal 3.1:

Variables: Rest C1 A IRest
IH : forall Known ID KRest C,
       remove_all Known ID KRest * -&gt; mem (ID, C) KRest -&gt; false
RA : A = A -&gt; false
RA1 : remove_all IRest A Rest *
============================
 false
</pre>
<pre class="code extensibella"id="503">
 &lt; <b>backchain RA.</b>

Subgoal 3.2:

Variables: ID C Rest C1 A IRest
IH : forall Known ID KRest C,
       remove_all Known ID KRest * -&gt; mem (ID, C) KRest -&gt; false
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
M : mem (ID, C) Rest
============================
 false
</pre>
<pre class="code extensibella"id="504">
 &lt; <b>apply IH to RA1 M.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="505">
 &lt; <b>Theorem remove_all_still_mem :
     forall Known ID KRest Other C,
       remove_all Known ID KRest -&gt; mem (Other, C) Known -&gt; (ID = Other -&gt; false) -&gt;
       mem (Other, C) KRest.</b>

============================
 forall Known ID KRest Other C,
   remove_all Known ID KRest -&gt; mem (Other, C) Known -&gt; (ID = Other -&gt; false) -&gt;
   mem (Other, C) KRest
</pre>
<pre class="code extensibella"id="506">
 &lt; <b>induction on 1.</b>

IH : forall Known ID KRest Other C,
       remove_all Known ID KRest * -&gt; mem (Other, C) Known -&gt; (ID = Other -&gt; false) -&gt;
       mem (Other, C) KRest
============================
 forall Known ID KRest Other C,
   remove_all Known ID KRest @ -&gt; mem (Other, C) Known -&gt; (ID = Other -&gt; false) -&gt;
   mem (Other, C) KRest
</pre>
<pre class="code extensibella"id="507">
 &lt; <b>intros RA M NEq.</b>

Variables: Known ID KRest Other C
IH : forall Known ID KRest Other C,
       remove_all Known ID KRest * -&gt; mem (Other, C) Known -&gt; (ID = Other -&gt; false) -&gt;
       mem (Other, C) KRest
RA : remove_all Known ID KRest @
M : mem (Other, C) Known
NEq : ID = Other -&gt; false
============================
 mem (Other, C) KRest
</pre>
<pre class="code extensibella"id="508">
 &lt; <b>RA: case RA.</b>

Subgoal 1:

Variables: ID Other C
IH : forall Known ID KRest Other C,
       remove_all Known ID KRest * -&gt; mem (Other, C) Known -&gt; (ID = Other -&gt; false) -&gt;
       mem (Other, C) KRest
M : mem (Other, C) []
NEq : ID = Other -&gt; false
============================
 mem (Other, C) []
</pre>
<pre class="code extensibella"id="509">
 &lt; <b>case M.</b>

Subgoal 2:

Variables: ID KRest Other C IRest C1
IH : forall Known ID KRest Other C,
       remove_all Known ID KRest * -&gt; mem (Other, C) Known -&gt; (ID = Other -&gt; false) -&gt;
       mem (Other, C) KRest
M : mem (Other, C) ((ID, C1)::IRest)
NEq : ID = Other -&gt; false
RA : remove_all IRest ID KRest *
============================
 mem (Other, C) KRest
</pre>
<pre class="code extensibella"id="510">
 &lt; <b>M: case M.</b>

Subgoal 2.1:

Variables: ID KRest IRest C1
IH : forall Known ID KRest Other C,
       remove_all Known ID KRest * -&gt; mem (Other, C) Known -&gt; (ID = Other -&gt; false) -&gt;
       mem (Other, C) KRest
NEq : ID = ID -&gt; false
RA : remove_all IRest ID KRest *
============================
 mem (ID, C1) KRest
</pre>
<pre class="code extensibella"id="511">
 &lt; <b>apply NEq to _.</b>

Subgoal 2.2:

Variables: ID KRest Other C IRest C1
IH : forall Known ID KRest Other C,
       remove_all Known ID KRest * -&gt; mem (Other, C) Known -&gt; (ID = Other -&gt; false) -&gt;
       mem (Other, C) KRest
NEq : ID = Other -&gt; false
RA : remove_all IRest ID KRest *
M : mem (Other, C) IRest
============================
 mem (Other, C) KRest
</pre>
<pre class="code extensibella"id="512">
 &lt; <b>apply IH to RA M NEq.</b>

Subgoal 2.2:

Variables: ID KRest Other C IRest C1
IH : forall Known ID KRest Other C,
       remove_all Known ID KRest * -&gt; mem (Other, C) Known -&gt; (ID = Other -&gt; false) -&gt;
       mem (Other, C) KRest
NEq : ID = Other -&gt; false
RA : remove_all IRest ID KRest *
M : mem (Other, C) IRest
H1 : mem (Other, C) KRest
============================
 mem (Other, C) KRest
</pre>
<pre class="code extensibella"id="513">
 &lt; <b>search.</b>

Subgoal 3:

Variables: ID Other C Rest C1 A IRest
IH : forall Known ID KRest Other C,
       remove_all Known ID KRest * -&gt; mem (Other, C) Known -&gt; (ID = Other -&gt; false) -&gt;
       mem (Other, C) KRest
M : mem (Other, C) ((A, C1)::IRest)
NEq : ID = Other -&gt; false
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
============================
 mem (Other, C) ((A, C1)::Rest)
</pre>
<pre class="code extensibella"id="514">
 &lt; <b>M: case M.</b>

Subgoal 3.1:

Variables: ID Rest C1 A IRest
IH : forall Known ID KRest Other C,
       remove_all Known ID KRest * -&gt; mem (Other, C) Known -&gt; (ID = Other -&gt; false) -&gt;
       mem (Other, C) KRest
NEq : ID = A -&gt; false
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
============================
 mem (A, C1) ((A, C1)::Rest)
</pre>
<pre class="code extensibella"id="515">
 &lt; <b>search.</b>

Subgoal 3.2:

Variables: ID Other C Rest C1 A IRest
IH : forall Known ID KRest Other C,
       remove_all Known ID KRest * -&gt; mem (Other, C) Known -&gt; (ID = Other -&gt; false) -&gt;
       mem (Other, C) KRest
NEq : ID = Other -&gt; false
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
M : mem (Other, C) IRest
============================
 mem (Other, C) ((A, C1)::Rest)
</pre>
<pre class="code extensibella"id="516">
 &lt; <b>apply IH to RA1 M NEq.</b>

Subgoal 3.2:

Variables: ID Other C Rest C1 A IRest
IH : forall Known ID KRest Other C,
       remove_all Known ID KRest * -&gt; mem (Other, C) Known -&gt; (ID = Other -&gt; false) -&gt;
       mem (Other, C) KRest
NEq : ID = Other -&gt; false
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
M : mem (Other, C) IRest
H1 : mem (Other, C) Rest
============================
 mem (Other, C) ((A, C1)::Rest)
</pre>
<pre class="code extensibella"id="517">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="518">
 &lt; <b>Theorem remove_all_mem_after :
     forall Known ID KRest Other C,
       remove_all Known ID KRest -&gt; mem (Other, C) KRest -&gt; mem (Other, C) Known.</b>

============================
 forall Known ID KRest Other C,
   remove_all Known ID KRest -&gt; mem (Other, C) KRest -&gt; mem (Other, C) Known
</pre>
<pre class="code extensibella"id="519">
 &lt; <b>induction on 1.</b>

IH : forall Known ID KRest Other C,
       remove_all Known ID KRest * -&gt; mem (Other, C) KRest -&gt; mem (Other, C) Known
============================
 forall Known ID KRest Other C,
   remove_all Known ID KRest @ -&gt; mem (Other, C) KRest -&gt; mem (Other, C) Known
</pre>
<pre class="code extensibella"id="520">
 &lt; <b>intros RA M.</b>

Variables: Known ID KRest Other C
IH : forall Known ID KRest Other C,
       remove_all Known ID KRest * -&gt; mem (Other, C) KRest -&gt; mem (Other, C) Known
RA : remove_all Known ID KRest @
M : mem (Other, C) KRest
============================
 mem (Other, C) Known
</pre>
<pre class="code extensibella"id="521">
 &lt; <b>RA: case RA.</b>

Subgoal 1:

Variables: ID Other C
IH : forall Known ID KRest Other C,
       remove_all Known ID KRest * -&gt; mem (Other, C) KRest -&gt; mem (Other, C) Known
M : mem (Other, C) []
============================
 mem (Other, C) []
</pre>
<pre class="code extensibella"id="522">
 &lt; <b>search.</b>

Subgoal 2:

Variables: ID KRest Other C IRest C1
IH : forall Known ID KRest Other C,
       remove_all Known ID KRest * -&gt; mem (Other, C) KRest -&gt; mem (Other, C) Known
M : mem (Other, C) KRest
RA : remove_all IRest ID KRest *
============================
 mem (Other, C) ((ID, C1)::IRest)
</pre>
<pre class="code extensibella"id="523">
 &lt; <b>apply IH to RA M.</b>

Subgoal 2:

Variables: ID KRest Other C IRest C1
IH : forall Known ID KRest Other C,
       remove_all Known ID KRest * -&gt; mem (Other, C) KRest -&gt; mem (Other, C) Known
M : mem (Other, C) KRest
RA : remove_all IRest ID KRest *
H1 : mem (Other, C) IRest
============================
 mem (Other, C) ((ID, C1)::IRest)
</pre>
<pre class="code extensibella"id="524">
 &lt; <b>search.</b>

Subgoal 3:

Variables: ID Other C Rest C1 A IRest
IH : forall Known ID KRest Other C,
       remove_all Known ID KRest * -&gt; mem (Other, C) KRest -&gt; mem (Other, C) Known
M : mem (Other, C) ((A, C1)::Rest)
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
============================
 mem (Other, C) ((A, C1)::IRest)
</pre>
<pre class="code extensibella"id="525">
 &lt; <b>M: case M.</b>

Subgoal 3.1:

Variables: ID Rest C1 A IRest
IH : forall Known ID KRest Other C,
       remove_all Known ID KRest * -&gt; mem (Other, C) KRest -&gt; mem (Other, C) Known
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
============================
 mem (A, C1) ((A, C1)::IRest)
</pre>
<pre class="code extensibella"id="526">
 &lt; <b>search.</b>

Subgoal 3.2:

Variables: ID Other C Rest C1 A IRest
IH : forall Known ID KRest Other C,
       remove_all Known ID KRest * -&gt; mem (Other, C) KRest -&gt; mem (Other, C) Known
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
M : mem (Other, C) Rest
============================
 mem (Other, C) ((A, C1)::IRest)
</pre>
<pre class="code extensibella"id="527">
 &lt; <b>apply IH to RA1 M.</b>

Subgoal 3.2:

Variables: ID Other C Rest C1 A IRest
IH : forall Known ID KRest Other C,
       remove_all Known ID KRest * -&gt; mem (Other, C) KRest -&gt; mem (Other, C) Known
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
M : mem (Other, C) Rest
H1 : mem (Other, C) IRest
============================
 mem (Other, C) ((A, C1)::IRest)
</pre>
<pre class="code extensibella"id="528">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="529">
 &lt; <b>Theorem remove_all_lookup_after :
     forall Known KRest ID Other C,
       remove_all Known ID KRest -&gt; lookup KRest Other C -&gt; lookup Known Other C.</b>

============================
 forall Known KRest ID Other C,
   remove_all Known ID KRest -&gt; lookup KRest Other C -&gt; lookup Known Other C
</pre>
<pre class="code extensibella"id="530">
 &lt; <b>induction on 1.</b>

IH : forall Known KRest ID Other C,
       remove_all Known ID KRest * -&gt; lookup KRest Other C -&gt; lookup Known Other C
============================
 forall Known KRest ID Other C,
   remove_all Known ID KRest @ -&gt; lookup KRest Other C -&gt; lookup Known Other C
</pre>
<pre class="code extensibella"id="531">
 &lt; <b>intros RA Lkp.</b>

Variables: Known KRest ID Other C
IH : forall Known KRest ID Other C,
       remove_all Known ID KRest * -&gt; lookup KRest Other C -&gt; lookup Known Other C
RA : remove_all Known ID KRest @
Lkp : lookup KRest Other C
============================
 lookup Known Other C
</pre>
<pre class="code extensibella"id="532">
 &lt; <b>RA: case RA.</b>

Subgoal 1:

Variables: ID Other C
IH : forall Known KRest ID Other C,
       remove_all Known ID KRest * -&gt; lookup KRest Other C -&gt; lookup Known Other C
Lkp : lookup [] Other C
============================
 lookup [] Other C
</pre>
<pre class="code extensibella"id="533">
 &lt; <b>search.</b>

Subgoal 2:

Variables: KRest ID Other C IRest C1
IH : forall Known KRest ID Other C,
       remove_all Known ID KRest * -&gt; lookup KRest Other C -&gt; lookup Known Other C
Lkp : lookup KRest Other C
RA : remove_all IRest ID KRest *
============================
 lookup ((ID, C1)::IRest) Other C
</pre>
<pre class="code extensibella"id="534">
 &lt; <b>assert ID = Other -&gt; false.</b>

Subgoal 2.1:

Variables: KRest ID Other C IRest C1
IH : forall Known KRest ID Other C,
       remove_all Known ID KRest * -&gt; lookup KRest Other C -&gt; lookup Known Other C
Lkp : lookup KRest Other C
RA : remove_all IRest ID KRest *
============================
 ID = Other -&gt; false
</pre>
<pre class="code extensibella"id="535">
 &lt; <b>intros E.</b>

Subgoal 2.1:

Variables: KRest ID Other C IRest C1
IH : forall Known KRest ID Other C,
       remove_all Known ID KRest * -&gt; lookup KRest Other C -&gt; lookup Known Other C
Lkp : lookup KRest Other C
RA : remove_all IRest ID KRest *
E : ID = Other
============================
 false
</pre>
<pre class="code extensibella"id="536">
 &lt; <b>case E.</b>

Subgoal 2.1:

Variables: KRest Other C IRest C1
IH : forall Known KRest ID Other C,
       remove_all Known ID KRest * -&gt; lookup KRest Other C -&gt; lookup Known Other C
Lkp : lookup KRest Other C
RA : remove_all IRest Other KRest *
============================
 false
</pre>
<pre class="code extensibella"id="537">
 &lt; <b>M: apply lookup_mem to Lkp.</b>

Subgoal 2.1:

Variables: KRest Other C IRest C1
IH : forall Known KRest ID Other C,
       remove_all Known ID KRest * -&gt; lookup KRest Other C -&gt; lookup Known Other C
Lkp : lookup KRest Other C
RA : remove_all IRest Other KRest *
M : mem (Other, C) KRest
============================
 false
</pre>
<pre class="code extensibella"id="538">
 &lt; <b>backchain remove_all_no_mem.</b>

Subgoal 2:

Variables: KRest ID Other C IRest C1
IH : forall Known KRest ID Other C,
       remove_all Known ID KRest * -&gt; lookup KRest Other C -&gt; lookup Known Other C
Lkp : lookup KRest Other C
RA : remove_all IRest ID KRest *
H1 : ID = Other -&gt; false
============================
 lookup ((ID, C1)::IRest) Other C
</pre>
<pre class="code extensibella"id="539">
 &lt; <b>apply IH to RA Lkp.</b>

Subgoal 2:

Variables: KRest ID Other C IRest C1
IH : forall Known KRest ID Other C,
       remove_all Known ID KRest * -&gt; lookup KRest Other C -&gt; lookup Known Other C
Lkp : lookup KRest Other C
RA : remove_all IRest ID KRest *
H1 : ID = Other -&gt; false
H2 : lookup IRest Other C
============================
 lookup ((ID, C1)::IRest) Other C
</pre>
<pre class="code extensibella"id="540">
 &lt; <b>search.</b>

Subgoal 3:

Variables: ID Other C Rest C1 A IRest
IH : forall Known KRest ID Other C,
       remove_all Known ID KRest * -&gt; lookup KRest Other C -&gt; lookup Known Other C
Lkp : lookup ((A, C1)::Rest) Other C
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
============================
 lookup ((A, C1)::IRest) Other C
</pre>
<pre class="code extensibella"id="541">
 &lt; <b>Lkp: case Lkp.</b>

Subgoal 3.1:

Variables: ID Other C Rest IRest
IH : forall Known KRest ID Other C,
       remove_all Known ID KRest * -&gt; lookup KRest Other C -&gt; lookup Known Other C
RA : Other = ID -&gt; false
RA1 : remove_all IRest ID Rest *
============================
 lookup ((Other, C)::IRest) Other C
</pre>
<pre class="code extensibella"id="542">
 &lt; <b>search.</b>

Subgoal 3.2:

Variables: ID Other C Rest C1 A IRest
IH : forall Known KRest ID Other C,
       remove_all Known ID KRest * -&gt; lookup KRest Other C -&gt; lookup Known Other C
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
Lkp : A = Other -&gt; false
Lkp1 : lookup Rest Other C
============================
 lookup ((A, C1)::IRest) Other C
</pre>
<pre class="code extensibella"id="543">
 &lt; <b>apply IH to RA1 Lkp1.</b>

Subgoal 3.2:

Variables: ID Other C Rest C1 A IRest
IH : forall Known KRest ID Other C,
       remove_all Known ID KRest * -&gt; lookup KRest Other C -&gt; lookup Known Other C
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
Lkp : A = Other -&gt; false
Lkp1 : lookup Rest Other C
H1 : lookup IRest Other C
============================
 lookup ((A, C1)::IRest) Other C
</pre>
<pre class="code extensibella"id="544">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="545">
 &lt; <b>Theorem remove_all_is :
     forall Known ID KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; remove_all Known ID KRest -&gt;
       is_list (is_pair is_integer is_clause) KRest.</b>

============================
 forall Known ID KRest,
   is_list (is_pair is_integer is_clause) Known -&gt; remove_all Known ID KRest -&gt; is_list (is_pair is_integer is_clause) KRest
</pre>
<pre class="code extensibella"id="546">
 &lt; <b>induction on 2.</b>

IH : forall Known ID KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; remove_all Known ID KRest * -&gt;
       is_list (is_pair is_integer is_clause) KRest
============================
 forall Known ID KRest,
   is_list (is_pair is_integer is_clause) Known -&gt; remove_all Known ID KRest @ -&gt;
   is_list (is_pair is_integer is_clause) KRest
</pre>
<pre class="code extensibella"id="547">
 &lt; <b>intros Is RA.</b>

Variables: Known ID KRest
IH : forall Known ID KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; remove_all Known ID KRest * -&gt;
       is_list (is_pair is_integer is_clause) KRest
Is : is_list (is_pair is_integer is_clause) Known
RA : remove_all Known ID KRest @
============================
 is_list (is_pair is_integer is_clause) KRest
</pre>
<pre class="code extensibella"id="548">
 &lt; <b>RA: case RA.</b>

Subgoal 1:

Variables: ID
IH : forall Known ID KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; remove_all Known ID KRest * -&gt;
       is_list (is_pair is_integer is_clause) KRest
Is : is_list (is_pair is_integer is_clause) []
============================
 is_list (is_pair is_integer is_clause) []
</pre>
<pre class="code extensibella"id="549">
 &lt; <b>search.</b>

Subgoal 2:

Variables: ID KRest IRest C
IH : forall Known ID KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; remove_all Known ID KRest * -&gt;
       is_list (is_pair is_integer is_clause) KRest
Is : is_list (is_pair is_integer is_clause) ((ID, C)::IRest)
RA : remove_all IRest ID KRest *
============================
 is_list (is_pair is_integer is_clause) KRest
</pre>
<pre class="code extensibella"id="550">
 &lt; <b>Is: case Is.</b>

Subgoal 2:

Variables: ID KRest IRest C
IH : forall Known ID KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; remove_all Known ID KRest * -&gt;
       is_list (is_pair is_integer is_clause) KRest
RA : remove_all IRest ID KRest *
Is : is_pair is_integer is_clause (ID, C)
Is1 : is_list (is_pair is_integer is_clause) IRest
============================
 is_list (is_pair is_integer is_clause) KRest
</pre>
<pre class="code extensibella"id="551">
 &lt; <b>apply IH to Is1 RA.</b>

Subgoal 2:

Variables: ID KRest IRest C
IH : forall Known ID KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; remove_all Known ID KRest * -&gt;
       is_list (is_pair is_integer is_clause) KRest
RA : remove_all IRest ID KRest *
Is : is_pair is_integer is_clause (ID, C)
Is1 : is_list (is_pair is_integer is_clause) IRest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 is_list (is_pair is_integer is_clause) KRest
</pre>
<pre class="code extensibella"id="552">
 &lt; <b>search.</b>

Subgoal 3:

Variables: ID Rest C A IRest
IH : forall Known ID KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; remove_all Known ID KRest * -&gt;
       is_list (is_pair is_integer is_clause) KRest
Is : is_list (is_pair is_integer is_clause) ((A, C)::IRest)
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
============================
 is_list (is_pair is_integer is_clause) ((A, C)::Rest)
</pre>
<pre class="code extensibella"id="553">
 &lt; <b>Is: case Is.</b>

Subgoal 3:

Variables: ID Rest C A IRest
IH : forall Known ID KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; remove_all Known ID KRest * -&gt;
       is_list (is_pair is_integer is_clause) KRest
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
Is : is_pair is_integer is_clause (A, C)
Is1 : is_list (is_pair is_integer is_clause) IRest
============================
 is_list (is_pair is_integer is_clause) ((A, C)::Rest)
</pre>
<pre class="code extensibella"id="554">
 &lt; <b>apply IH to Is1 RA1.</b>

Subgoal 3:

Variables: ID Rest C A IRest
IH : forall Known ID KRest,
       is_list (is_pair is_integer is_clause) Known -&gt; remove_all Known ID KRest * -&gt;
       is_list (is_pair is_integer is_clause) KRest
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
Is : is_pair is_integer is_clause (A, C)
Is1 : is_list (is_pair is_integer is_clause) IRest
H1 : is_list (is_pair is_integer is_clause) Rest
============================
 is_list (is_pair is_integer is_clause) ((A, C)::Rest)
</pre>
<pre class="code extensibella"id="555">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="556">
 &lt; <b>Theorem is_remove_all_exists :
     forall Known ID,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID -&gt; exists KRest,
         remove_all Known ID KRest.</b>

============================
 forall Known ID,
   is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID -&gt; exists KRest,
     remove_all Known ID KRest
</pre>
<pre class="code extensibella"id="557">
 &lt; <b>induction on 1.</b>

IH : forall Known ID,
       is_list (is_pair is_integer is_clause) Known * -&gt; is_integer ID -&gt; exists KRest,
         remove_all Known ID KRest
============================
 forall Known ID,
   is_list (is_pair is_integer is_clause) Known @ -&gt; is_integer ID -&gt; exists KRest,
     remove_all Known ID KRest
</pre>
<pre class="code extensibella"id="558">
 &lt; <b>intros IsKnown IsID.</b>

Variables: Known ID
IH : forall Known ID,
       is_list (is_pair is_integer is_clause) Known * -&gt; is_integer ID -&gt; exists KRest,
         remove_all Known ID KRest
IsKnown : is_list (is_pair is_integer is_clause) Known @
IsID : is_integer ID
============================
 exists KRest, remove_all Known ID KRest
</pre>
<pre class="code extensibella"id="559">
 &lt; <b>Is: case IsKnown.</b>

Subgoal 1:

Variables: ID
IH : forall Known ID,
       is_list (is_pair is_integer is_clause) Known * -&gt; is_integer ID -&gt; exists KRest,
         remove_all Known ID KRest
IsID : is_integer ID
============================
 exists KRest, remove_all [] ID KRest
</pre>
<pre class="code extensibella"id="560">
 &lt; <b>search.</b>

Subgoal 2:

Variables: ID T H
IH : forall Known ID,
       is_list (is_pair is_integer is_clause) Known * -&gt; is_integer ID -&gt; exists KRest,
         remove_all Known ID KRest
IsID : is_integer ID
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
============================
 exists KRest, remove_all (H::T) ID KRest
</pre>
<pre class="code extensibella"id="561">
 &lt; <b>apply IH to Is1 IsID.</b>

Subgoal 2:

Variables: ID T H KRest
IH : forall Known ID,
       is_list (is_pair is_integer is_clause) Known * -&gt; is_integer ID -&gt; exists KRest,
         remove_all Known ID KRest
IsID : is_integer ID
Is : is_pair is_integer is_clause H
Is1 : is_list (is_pair is_integer is_clause) T *
H1 : remove_all T ID KRest
============================
 exists KRest, remove_all (H::T) ID KRest
</pre>
<pre class="code extensibella"id="562">
 &lt; <b>Is: case Is.</b>

Subgoal 2:

Variables: ID T KRest B A
IH : forall Known ID,
       is_list (is_pair is_integer is_clause) Known * -&gt; is_integer ID -&gt; exists KRest,
         remove_all Known ID KRest
IsID : is_integer ID
Is1 : is_list (is_pair is_integer is_clause) T *
H1 : remove_all T ID KRest
Is : is_integer A
Is2 : is_clause B
============================
 exists KRest, remove_all ((A, B)::T) ID KRest
</pre>
<pre class="code extensibella"id="563">
 &lt; <b>Or: apply is_integer_eq_or_not to Is IsID.</b>

Subgoal 2:

Variables: ID T KRest B A
IH : forall Known ID,
       is_list (is_pair is_integer is_clause) Known * -&gt; is_integer ID -&gt; exists KRest,
         remove_all Known ID KRest
IsID : is_integer ID
Is1 : is_list (is_pair is_integer is_clause) T *
H1 : remove_all T ID KRest
Is : is_integer A
Is2 : is_clause B
Or : A = ID \/ (A = ID -&gt; false)
============================
 exists KRest, remove_all ((A, B)::T) ID KRest
</pre>
<pre class="code extensibella"id="564">
 &lt; <b>E: case Or.</b>

Subgoal 2.1:

Variables: ID T KRest B
IH : forall Known ID,
       is_list (is_pair is_integer is_clause) Known * -&gt; is_integer ID -&gt; exists KRest,
         remove_all Known ID KRest
IsID : is_integer ID
Is1 : is_list (is_pair is_integer is_clause) T *
H1 : remove_all T ID KRest
Is : is_integer ID
Is2 : is_clause B
============================
 exists KRest, remove_all ((ID, B)::T) ID KRest
</pre>
<pre class="code extensibella"id="565">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: ID T KRest B A
IH : forall Known ID,
       is_list (is_pair is_integer is_clause) Known * -&gt; is_integer ID -&gt; exists KRest,
         remove_all Known ID KRest
IsID : is_integer ID
Is1 : is_list (is_pair is_integer is_clause) T *
H1 : remove_all T ID KRest
Is : is_integer A
Is2 : is_clause B
E : A = ID -&gt; false
============================
 exists KRest, remove_all ((A, B)::T) ID KRest
</pre>
<pre class="code extensibella"id="566">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="567">
 &lt; <b>Theorem remove_all_counts :
     forall Known ID KRest IDC N,
       remove_all Known ID KRest -&gt; count IDC Known N -&gt; ((exists C,
         IDC = (ID, C)) -&gt; false) -&gt; count IDC KRest N.</b>

============================
 forall Known ID KRest IDC N,
   remove_all Known ID KRest -&gt; count IDC Known N -&gt; ((exists C, IDC = (ID, C)) -&gt;
   false) -&gt; count IDC KRest N
</pre>
<pre class="code extensibella"id="568">
 &lt; <b>induction on 1.</b>

IH : forall Known ID KRest IDC N,
       remove_all Known ID KRest * -&gt; count IDC Known N -&gt; ((exists C,
         IDC = (ID, C)) -&gt; false) -&gt; count IDC KRest N
============================
 forall Known ID KRest IDC N,
   remove_all Known ID KRest @ -&gt; count IDC Known N -&gt; ((exists C,
     IDC = (ID, C)) -&gt; false) -&gt; count IDC KRest N
</pre>
<pre class="code extensibella"id="569">
 &lt; <b>intros RA C NEq.</b>

Variables: Known ID KRest IDC N
IH : forall Known ID KRest IDC N,
       remove_all Known ID KRest * -&gt; count IDC Known N -&gt; ((exists C,
         IDC = (ID, C)) -&gt; false) -&gt; count IDC KRest N
RA : remove_all Known ID KRest @
C : count IDC Known N
NEq : (exists C, IDC = (ID, C)) -&gt; false
============================
 count IDC KRest N
</pre>
<pre class="code extensibella"id="570">
 &lt; <b>RA: case RA.</b>

Subgoal 1:

Variables: ID IDC N
IH : forall Known ID KRest IDC N,
       remove_all Known ID KRest * -&gt; count IDC Known N -&gt; ((exists C,
         IDC = (ID, C)) -&gt; false) -&gt; count IDC KRest N
C : count IDC [] N
NEq : (exists C, IDC = (ID, C)) -&gt; false
============================
 count IDC [] N
</pre>
<pre class="code extensibella"id="571">
 &lt; <b>case C.</b>

Subgoal 1:

Variables: ID IDC
IH : forall Known ID KRest IDC N,
       remove_all Known ID KRest * -&gt; count IDC Known N -&gt; ((exists C,
         IDC = (ID, C)) -&gt; false) -&gt; count IDC KRest N
NEq : (exists C, IDC = (ID, C)) -&gt; false
============================
 count IDC [] 0
</pre>
<pre class="code extensibella"id="572">
 &lt; <b>search.</b>

Subgoal 2:

Variables: ID KRest IDC N IRest C
IH : forall Known ID KRest IDC N,
       remove_all Known ID KRest * -&gt; count IDC Known N -&gt; ((exists C,
         IDC = (ID, C)) -&gt; false) -&gt; count IDC KRest N
C : count IDC ((ID, C)::IRest) N
NEq : (exists C, IDC = (ID, C)) -&gt; false
RA : remove_all IRest ID KRest *
============================
 count IDC KRest N
</pre>
<pre class="code extensibella"id="573">
 &lt; <b>C: case C.</b>

Subgoal 2.1:

Variables: ID KRest N IRest C N1
IH : forall Known ID KRest IDC N,
       remove_all Known ID KRest * -&gt; count IDC Known N -&gt; ((exists C,
         IDC = (ID, C)) -&gt; false) -&gt; count IDC KRest N
NEq : (exists C1, (ID, C) = (ID, C1)) -&gt; false
RA : remove_all IRest ID KRest *
C : count (ID, C) IRest N1
C1 : 1 + N1 = N
============================
 count (ID, C) KRest N
</pre>
<pre class="code extensibella"id="574">
 &lt; <b>apply NEq to _.</b>

Subgoal 2.2:

Variables: ID KRest IDC N IRest C
IH : forall Known ID KRest IDC N,
       remove_all Known ID KRest * -&gt; count IDC Known N -&gt; ((exists C,
         IDC = (ID, C)) -&gt; false) -&gt; count IDC KRest N
NEq : (exists C, IDC = (ID, C)) -&gt; false
RA : remove_all IRest ID KRest *
C : IDC = (ID, C) -&gt; false
C1 : count IDC IRest N
============================
 count IDC KRest N
</pre>
<pre class="code extensibella"id="575">
 &lt; <b>apply IH to RA C1 NEq.</b>

Subgoal 2.2:

Variables: ID KRest IDC N IRest C
IH : forall Known ID KRest IDC N,
       remove_all Known ID KRest * -&gt; count IDC Known N -&gt; ((exists C,
         IDC = (ID, C)) -&gt; false) -&gt; count IDC KRest N
NEq : (exists C, IDC = (ID, C)) -&gt; false
RA : remove_all IRest ID KRest *
C : IDC = (ID, C) -&gt; false
C1 : count IDC IRest N
H1 : count IDC KRest N
============================
 count IDC KRest N
</pre>
<pre class="code extensibella"id="576">
 &lt; <b>search.</b>

Subgoal 3:

Variables: ID IDC N Rest C A IRest
IH : forall Known ID KRest IDC N,
       remove_all Known ID KRest * -&gt; count IDC Known N -&gt; ((exists C,
         IDC = (ID, C)) -&gt; false) -&gt; count IDC KRest N
C : count IDC ((A, C)::IRest) N
NEq : (exists C, IDC = (ID, C)) -&gt; false
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
============================
 count IDC ((A, C)::Rest) N
</pre>
<pre class="code extensibella"id="577">
 &lt; <b>C: case C.</b>

Subgoal 3.1:

Variables: ID N Rest C A IRest N1
IH : forall Known ID KRest IDC N,
       remove_all Known ID KRest * -&gt; count IDC Known N -&gt; ((exists C,
         IDC = (ID, C)) -&gt; false) -&gt; count IDC KRest N
NEq : (exists C1, (A, C) = (ID, C1)) -&gt; false
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
C : count (A, C) IRest N1
C1 : 1 + N1 = N
============================
 count (A, C) ((A, C)::Rest) N
</pre>
<pre class="code extensibella"id="578">
 &lt; <b>apply IH to RA1 C _.</b>

Subgoal 3.1:

Variables: ID N Rest C A IRest N1
IH : forall Known ID KRest IDC N,
       remove_all Known ID KRest * -&gt; count IDC Known N -&gt; ((exists C,
         IDC = (ID, C)) -&gt; false) -&gt; count IDC KRest N
NEq : (exists C1, (A, C) = (ID, C1)) -&gt; false
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
C : count (A, C) IRest N1
C1 : 1 + N1 = N
H1 : count (A, C) Rest N1
============================
 count (A, C) ((A, C)::Rest) N
</pre>
<pre class="code extensibella"id="579">
 &lt; <b>search.</b>

Subgoal 3.2:

Variables: ID IDC N Rest C A IRest
IH : forall Known ID KRest IDC N,
       remove_all Known ID KRest * -&gt; count IDC Known N -&gt; ((exists C,
         IDC = (ID, C)) -&gt; false) -&gt; count IDC KRest N
NEq : (exists C, IDC = (ID, C)) -&gt; false
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
C : IDC = (A, C) -&gt; false
C1 : count IDC IRest N
============================
 count IDC ((A, C)::Rest) N
</pre>
<pre class="code extensibella"id="580">
 &lt; <b>apply IH to RA1 C1 _.</b>

Subgoal 3.2:

Variables: ID IDC N Rest C A IRest
IH : forall Known ID KRest IDC N,
       remove_all Known ID KRest * -&gt; count IDC Known N -&gt; ((exists C,
         IDC = (ID, C)) -&gt; false) -&gt; count IDC KRest N
NEq : (exists C, IDC = (ID, C)) -&gt; false
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
C : IDC = (A, C) -&gt; false
C1 : count IDC IRest N
H1 : count IDC Rest N
============================
 count IDC ((A, C)::Rest) N
</pre>
<pre class="code extensibella"id="581">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="582">
 &lt; <b>Theorem remove_all_permutation :
     forall Known ID KRest P,
       is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID -&gt; remove_all Known ID KRest -&gt;
       permutation Known P -&gt; exists P',
         remove_all P ID P' /\ permutation KRest P'.</b>

============================
 forall Known ID KRest P,
   is_list (is_pair is_integer is_clause) Known -&gt; is_integer ID -&gt; remove_all Known ID KRest -&gt;
   permutation Known P -&gt; exists P', remove_all P ID P' /\ permutation KRest P'
</pre>
<pre class="code extensibella"id="583">
 &lt; <b>intros IsKnown IsID RA Prm.</b>

Variables: Known ID KRest P
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
============================
 exists P', remove_all P ID P' /\ permutation KRest P'
</pre>
<pre class="code extensibella"id="584">
 &lt; <b>Prm': apply permutation_symmetric to Prm.</b>

Variables: Known ID KRest P
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
============================
 exists P', remove_all P ID P' /\ permutation KRest P'
</pre>
<pre class="code extensibella"id="585">
 &lt; <b>IsP: apply permutation_is to IsKnown Prm'.</b>

Variables: Known ID KRest P
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
============================
 exists P', remove_all P ID P' /\ permutation KRest P'
</pre>
<pre class="code extensibella"id="586">
 &lt; <b>RAP: apply is_remove_all_exists to IsP IsID.</b>

Variables: Known ID KRest P KRest1
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
============================
 exists P', remove_all P ID P' /\ permutation KRest P'
</pre>
<pre class="code extensibella"id="587">
 &lt; <b>IsKRest: apply remove_all_is to IsKnown RA.</b>

Variables: Known ID KRest P KRest1
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
============================
 exists P', remove_all P ID P' /\ permutation KRest P'
</pre>
<pre class="code extensibella"id="588">
 &lt; <b>IsKRest1: apply remove_all_is to IsP RAP.</b>

Variables: Known ID KRest P KRest1
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
============================
 exists P', remove_all P ID P' /\ permutation KRest P'
</pre>
<pre class="code extensibella"id="589">
 &lt; <b>assert forall X NL NP,
     is_pair is_integer is_clause X -&gt; count X KRest NL -&gt; count X KRest1 NP -&gt; NL = NP.</b>

Subgoal 1:

Variables: Known ID KRest P KRest1
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
============================
 forall X NL NP,
   is_pair is_integer is_clause X -&gt; count X KRest NL -&gt; count X KRest1 NP -&gt; NL = NP
</pre>
<pre class="code extensibella"id="590">
 &lt; <b>intros IsX CKRest CKRest1.</b>

Subgoal 1:

Variables: Known ID KRest P KRest1 X NL NP
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause X
CKRest : count X KRest NL
CKRest1 : count X KRest1 NP
============================
 NL = NP
</pre>
<pre class="code extensibella"id="591">
 &lt; <b>Is: case IsX (keep).</b>

Subgoal 1:

Variables: Known ID KRest P KRest1 NL NP B A
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (A, B)
CKRest : count (A, B) KRest NL
CKRest1 : count (A, B) KRest1 NP
Is : is_integer A
Is1 : is_clause B
============================
 NL = NP
</pre>
<pre class="code extensibella"id="592">
 &lt; <b>Or: apply is_integer_eq_or_not to Is IsID.</b>

Subgoal 1:

Variables: Known ID KRest P KRest1 NL NP B A
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (A, B)
CKRest : count (A, B) KRest NL
CKRest1 : count (A, B) KRest1 NP
Is : is_integer A
Is1 : is_clause B
Or : A = ID \/ (A = ID -&gt; false)
============================
 NL = NP
</pre>
<pre class="code extensibella"id="593">
 &lt; <b>E: case Or.</b>

Subgoal 1.1:

Variables: Known ID KRest P KRest1 NL NP B
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (ID, B)
CKRest : count (ID, B) KRest NL
CKRest1 : count (ID, B) KRest1 NP
Is : is_integer ID
Is1 : is_clause B
============================
 NL = NP
</pre>
<pre class="code extensibella"id="594">
 &lt; <b>GEq: apply count_geq_0 to CKRest.</b>

Subgoal 1.1:

Variables: Known ID KRest P KRest1 NL NP B
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (ID, B)
CKRest : count (ID, B) KRest NL
CKRest1 : count (ID, B) KRest1 NP
Is : is_integer ID
Is1 : is_clause B
GEq : NL &gt;= 0
============================
 NL = NP
</pre>
<pre class="code extensibella"id="595">
 &lt; <b>Or: apply greatereq_integer_greater_or_eq to GEq.</b>

Subgoal 1.1:

Variables: Known ID KRest P KRest1 NL NP B
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (ID, B)
CKRest : count (ID, B) KRest NL
CKRest1 : count (ID, B) KRest1 NP
Is : is_integer ID
Is1 : is_clause B
GEq : NL &gt;= 0
Or : NL &gt; 0 \/ NL = 0
============================
 NL = NP
</pre>
<pre class="code extensibella"id="596">
 &lt; <b>L: case Or.</b>

Subgoal 1.1.1:

Variables: Known ID KRest P KRest1 NL NP B
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (ID, B)
CKRest : count (ID, B) KRest NL
CKRest1 : count (ID, B) KRest1 NP
Is : is_integer ID
Is1 : is_clause B
GEq : NL &gt;= 0
L : NL &gt; 0
============================
 NL = NP
</pre>
<pre class="code extensibella"id="597">
 &lt; <b>M: apply count_mem to CKRest L.</b>

Subgoal 1.1.1:

Variables: Known ID KRest P KRest1 NL NP B
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (ID, B)
CKRest : count (ID, B) KRest NL
CKRest1 : count (ID, B) KRest1 NP
Is : is_integer ID
Is1 : is_clause B
GEq : NL &gt;= 0
L : NL &gt; 0
M : mem (ID, B) KRest
============================
 NL = NP
</pre>
<pre class="code extensibella"id="598">
 &lt; <b>apply remove_all_no_mem to RA M.</b>

Subgoal 1.1.2:

Variables: Known ID KRest P KRest1 NP B
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (ID, B)
CKRest : count (ID, B) KRest 0
CKRest1 : count (ID, B) KRest1 NP
Is : is_integer ID
Is1 : is_clause B
GEq : 0 &gt;= 0
============================
 0 = NP
</pre>
<pre class="code extensibella"id="599">
 &lt; <b>clear GEq.</b>

Subgoal 1.1.2:

Variables: Known ID KRest P KRest1 NP B
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (ID, B)
CKRest : count (ID, B) KRest 0
CKRest1 : count (ID, B) KRest1 NP
Is : is_integer ID
Is1 : is_clause B
============================
 0 = NP
</pre>
<pre class="code extensibella"id="600">
 &lt; <b>GEq: apply count_geq_0 to CKRest1.</b>

Subgoal 1.1.2:

Variables: Known ID KRest P KRest1 NP B
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (ID, B)
CKRest : count (ID, B) KRest 0
CKRest1 : count (ID, B) KRest1 NP
Is : is_integer ID
Is1 : is_clause B
GEq : NP &gt;= 0
============================
 0 = NP
</pre>
<pre class="code extensibella"id="601">
 &lt; <b>Or: apply greatereq_integer_greater_or_eq to GEq.</b>

Subgoal 1.1.2:

Variables: Known ID KRest P KRest1 NP B
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (ID, B)
CKRest : count (ID, B) KRest 0
CKRest1 : count (ID, B) KRest1 NP
Is : is_integer ID
Is1 : is_clause B
GEq : NP &gt;= 0
Or : NP &gt; 0 \/ NP = 0
============================
 0 = NP
</pre>
<pre class="code extensibella"id="602">
 &lt; <b>L: case Or.</b>

Subgoal 1.1.2.1:

Variables: Known ID KRest P KRest1 NP B
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (ID, B)
CKRest : count (ID, B) KRest 0
CKRest1 : count (ID, B) KRest1 NP
Is : is_integer ID
Is1 : is_clause B
GEq : NP &gt;= 0
L : NP &gt; 0
============================
 0 = NP
</pre>
<pre class="code extensibella"id="603">
 &lt; <b>M: apply count_mem to CKRest1 L.</b>

Subgoal 1.1.2.1:

Variables: Known ID KRest P KRest1 NP B
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (ID, B)
CKRest : count (ID, B) KRest 0
CKRest1 : count (ID, B) KRest1 NP
Is : is_integer ID
Is1 : is_clause B
GEq : NP &gt;= 0
L : NP &gt; 0
M : mem (ID, B) KRest1
============================
 0 = NP
</pre>
<pre class="code extensibella"id="604">
 &lt; <b>apply remove_all_no_mem to RAP M.</b>

Subgoal 1.1.2.2:

Variables: Known ID KRest P KRest1 B
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (ID, B)
CKRest : count (ID, B) KRest 0
CKRest1 : count (ID, B) KRest1 0
Is : is_integer ID
Is1 : is_clause B
GEq : 0 &gt;= 0
============================
 0 = 0
</pre>
<pre class="code extensibella"id="605">
 &lt; <b>search.</b>

Subgoal 1.2:

Variables: Known ID KRest P KRest1 NL NP B A
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (A, B)
CKRest : count (A, B) KRest NL
CKRest1 : count (A, B) KRest1 NP
Is : is_integer A
Is1 : is_clause B
E : A = ID -&gt; false
============================
 NL = NP
</pre>
<pre class="code extensibella"id="606">
 &lt; <b>assert (exists C, (A, B) = (ID, C)) -&gt; false.</b>

Subgoal 1.2.1:

Variables: Known ID KRest P KRest1 NL NP B A
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (A, B)
CKRest : count (A, B) KRest NL
CKRest1 : count (A, B) KRest1 NP
Is : is_integer A
Is1 : is_clause B
E : A = ID -&gt; false
============================
 (exists C, (A, B) = (ID, C)) -&gt; false
</pre>
<pre class="code extensibella"id="607">
 &lt; <b>intros Ex.</b>

Subgoal 1.2.1:

Variables: Known ID KRest P KRest1 NL NP B A
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (A, B)
CKRest : count (A, B) KRest NL
CKRest1 : count (A, B) KRest1 NP
Is : is_integer A
Is1 : is_clause B
E : A = ID -&gt; false
Ex : exists C, (A, B) = (ID, C)
============================
 false
</pre>
<pre class="code extensibella"id="608">
 &lt; <b>case Ex.</b>

Subgoal 1.2.1:

Variables: Known ID KRest P KRest1 NL NP C
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (ID, C)
CKRest : count (ID, C) KRest NL
CKRest1 : count (ID, C) KRest1 NP
Is : is_integer ID
Is1 : is_clause C
E : ID = ID -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="609">
 &lt; <b>backchain E.</b>

Subgoal 1.2:

Variables: Known ID KRest P KRest1 NL NP B A
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (A, B)
CKRest : count (A, B) KRest NL
CKRest1 : count (A, B) KRest1 NP
Is : is_integer A
Is1 : is_clause B
E : A = ID -&gt; false
H1 : (exists C, (A, B) = (ID, C)) -&gt; false
============================
 NL = NP
</pre>
<pre class="code extensibella"id="610">
 &lt; <b>CKnown: apply is_count_exists to IsKnown IsX.</b>

Subgoal 1.2:

Variables: Known ID KRest P KRest1 NL NP B A N
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (A, B)
CKRest : count (A, B) KRest NL
CKRest1 : count (A, B) KRest1 NP
Is : is_integer A
Is1 : is_clause B
E : A = ID -&gt; false
H1 : (exists C, (A, B) = (ID, C)) -&gt; false
CKnown : count (A, B) Known N
============================
 NL = NP
</pre>
<pre class="code extensibella"id="611">
 &lt; <b>CKRest': apply remove_all_counts to RA CKnown _.</b>

Subgoal 1.2:

Variables: Known ID KRest P KRest1 NL NP B A N
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (A, B)
CKRest : count (A, B) KRest NL
CKRest1 : count (A, B) KRest1 NP
Is : is_integer A
Is1 : is_clause B
E : A = ID -&gt; false
H1 : (exists C, (A, B) = (ID, C)) -&gt; false
CKnown : count (A, B) Known N
CKRest' : count (A, B) KRest N
============================
 NL = NP
</pre>
<pre class="code extensibella"id="612">
 &lt; <b>CP: apply is_count_exists to IsP IsX.</b>

Subgoal 1.2:

Variables: Known ID KRest P KRest1 NL NP B A N N1
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (A, B)
CKRest : count (A, B) KRest NL
CKRest1 : count (A, B) KRest1 NP
Is : is_integer A
Is1 : is_clause B
E : A = ID -&gt; false
H1 : (exists C, (A, B) = (ID, C)) -&gt; false
CKnown : count (A, B) Known N
CKRest' : count (A, B) KRest N
CP : count (A, B) P N1
============================
 NL = NP
</pre>
<pre class="code extensibella"id="613">
 &lt; <b>CKRest1': apply remove_all_counts to RAP CP _.</b>

Subgoal 1.2:

Variables: Known ID KRest P KRest1 NL NP B A N N1
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (A, B)
CKRest : count (A, B) KRest NL
CKRest1 : count (A, B) KRest1 NP
Is : is_integer A
Is1 : is_clause B
E : A = ID -&gt; false
H1 : (exists C, (A, B) = (ID, C)) -&gt; false
CKnown : count (A, B) Known N
CKRest' : count (A, B) KRest N
CP : count (A, B) P N1
CKRest1' : count (A, B) KRest1 N1
============================
 NL = NP
</pre>
<pre class="code extensibella"id="614">
 &lt; <b>apply count_unique to CKRest CKRest'.</b>

Subgoal 1.2:

Variables: Known ID KRest P KRest1 NP B A N N1
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (A, B)
CKRest : count (A, B) KRest N
CKRest1 : count (A, B) KRest1 NP
Is : is_integer A
Is1 : is_clause B
E : A = ID -&gt; false
H1 : (exists C, (A, B) = (ID, C)) -&gt; false
CKnown : count (A, B) Known N
CKRest' : count (A, B) KRest N
CP : count (A, B) P N1
CKRest1' : count (A, B) KRest1 N1
============================
 N = NP
</pre>
<pre class="code extensibella"id="615">
 &lt; <b>apply count_unique to CKRest1 CKRest1'.</b>

Subgoal 1.2:

Variables: Known ID KRest P KRest1 B A N N1
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (A, B)
CKRest : count (A, B) KRest N
CKRest1 : count (A, B) KRest1 N1
Is : is_integer A
Is1 : is_clause B
E : A = ID -&gt; false
H1 : (exists C, (A, B) = (ID, C)) -&gt; false
CKnown : count (A, B) Known N
CKRest' : count (A, B) KRest N
CP : count (A, B) P N1
CKRest1' : count (A, B) KRest1 N1
============================
 N = N1
</pre>
<pre class="code extensibella"id="616">
 &lt; <b>apply permutation_counts to _ CKnown CP.</b>

Subgoal 1.2:

Variables: Known ID KRest P KRest1 B A N1
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
IsX : is_pair is_integer is_clause (A, B)
CKRest : count (A, B) KRest N1
CKRest1 : count (A, B) KRest1 N1
Is : is_integer A
Is1 : is_clause B
E : A = ID -&gt; false
H1 : (exists C, (A, B) = (ID, C)) -&gt; false
CKnown : count (A, B) Known N1
CKRest' : count (A, B) KRest N1
CP : count (A, B) P N1
CKRest1' : count (A, B) KRest1 N1
============================
 N1 = N1
</pre>
<pre class="code extensibella"id="617">
 &lt; <b>search.</b>

Variables: Known ID KRest P KRest1
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
H1 : forall X NL NP,
       is_pair is_integer is_clause X -&gt; count X KRest NL -&gt; count X KRest1 NP -&gt;
       NL = NP
============================
 exists P', remove_all P ID P' /\ permutation KRest P'
</pre>
<pre class="code extensibella"id="618">
 &lt; <b>apply counts_permutation to IsKRest IsKRest1 _.</b>

Variables: Known ID KRest P KRest1
IsKnown : is_list (is_pair is_integer is_clause) Known
IsID : is_integer ID
RA : remove_all Known ID KRest
Prm : permutation Known P
Prm' : permutation P Known
IsP : is_list (is_pair is_integer is_clause) P
RAP : remove_all P ID KRest1
IsKRest : is_list (is_pair is_integer is_clause) KRest
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
H1 : forall X NL NP,
       is_pair is_integer is_clause X -&gt; count X KRest NL -&gt; count X KRest1 NP -&gt;
       NL = NP
H2 : permutation KRest KRest1
============================
 exists P', remove_all P ID P' /\ permutation KRest P'
</pre>
<pre class="code extensibella"id="619">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="620">
 &lt; <b>Define good_clause_list : (list (pair integer clause)) -&gt; prop by
   good_clause_list Known :=
     forall ID C1 KRest C2,
       select (ID, C1) KRest Known -&gt; mem (ID, C2) KRest -&gt; false.</b>


</pre>
<pre class="code extensibella"id="621">
 &lt; <b>Theorem good_clause_list_drop :
     forall L IDC, good_clause_list (IDC::L) -&gt; good_clause_list L.</b>

============================
 forall L IDC, good_clause_list (IDC::L) -&gt; good_clause_list L
</pre>
<pre class="code extensibella"id="622">
 &lt; <b>intros GCL.</b>

Variables: L IDC
GCL : good_clause_list (IDC::L)
============================
 good_clause_list L
</pre>
<pre class="code extensibella"id="623">
 &lt; <b>GCL: case GCL.</b>

Variables: L IDC
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest (IDC::L) -&gt; mem (ID, C2) KRest -&gt; false
============================
 good_clause_list L
</pre>
<pre class="code extensibella"id="624">
 &lt; <b>unfold .</b>

Variables: L IDC
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest (IDC::L) -&gt; mem (ID, C2) KRest -&gt; false
============================
 forall ID C1 KRest C2, select (ID, C1) KRest L -&gt; mem (ID, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="625">
 &lt; <b>intros S M.</b>

Variables: L IDC ID C1 KRest C2
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest (IDC::L) -&gt; mem (ID, C2) KRest -&gt; false
S : select (ID, C1) KRest L
M : mem (ID, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="626">
 &lt; <b>backchain GCL to
   ID = ID
   C1 = C1.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="627">
 &lt; <b>Theorem good_clause_list_select :
     forall L Rest ID C,
       good_clause_list L -&gt; select (ID, C) Rest L -&gt; good_clause_list Rest.</b>

============================
 forall L Rest ID C,
   good_clause_list L -&gt; select (ID, C) Rest L -&gt; good_clause_list Rest
</pre>
<pre class="code extensibella"id="628">
 &lt; <b>induction on 2.</b>

IH : forall L Rest ID C,
       good_clause_list L -&gt; select (ID, C) Rest L * -&gt; good_clause_list Rest
============================
 forall L Rest ID C,
   good_clause_list L -&gt; select (ID, C) Rest L @ -&gt; good_clause_list Rest
</pre>
<pre class="code extensibella"id="629">
 &lt; <b>intros GCL S.</b>

Variables: L Rest ID C
IH : forall L Rest ID C,
       good_clause_list L -&gt; select (ID, C) Rest L * -&gt; good_clause_list Rest
GCL : good_clause_list L
S : select (ID, C) Rest L @
============================
 good_clause_list Rest
</pre>
<pre class="code extensibella"id="630">
 &lt; <b>S: case S.</b>

Subgoal 1:

Variables: Rest ID C
IH : forall L Rest ID C,
       good_clause_list L -&gt; select (ID, C) Rest L * -&gt; good_clause_list Rest
GCL : good_clause_list ((ID, C)::Rest)
============================
 good_clause_list Rest
</pre>
<pre class="code extensibella"id="631">
 &lt; <b>apply good_clause_list_drop to GCL.</b>

Subgoal 1:

Variables: Rest ID C
IH : forall L Rest ID C,
       good_clause_list L -&gt; select (ID, C) Rest L * -&gt; good_clause_list Rest
GCL : good_clause_list ((ID, C)::Rest)
H1 : good_clause_list Rest
============================
 good_clause_list Rest
</pre>
<pre class="code extensibella"id="632">
 &lt; <b>search.</b>

Subgoal 2:

Variables: ID C L2 I L1
IH : forall L Rest ID C,
       good_clause_list L -&gt; select (ID, C) Rest L * -&gt; good_clause_list Rest
GCL : good_clause_list (I::L2)
S : select (ID, C) L1 L2 *
============================
 good_clause_list (I::L1)
</pre>
<pre class="code extensibella"id="633">
 &lt; <b>GCL': apply good_clause_list_drop to GCL.</b>

Subgoal 2:

Variables: ID C L2 I L1
IH : forall L Rest ID C,
       good_clause_list L -&gt; select (ID, C) Rest L * -&gt; good_clause_list Rest
GCL : good_clause_list (I::L2)
S : select (ID, C) L1 L2 *
GCL' : good_clause_list L2
============================
 good_clause_list (I::L1)
</pre>
<pre class="code extensibella"id="634">
 &lt; <b>GCL1: apply IH to GCL' S.</b>

Subgoal 2:

Variables: ID C L2 I L1
IH : forall L Rest ID C,
       good_clause_list L -&gt; select (ID, C) Rest L * -&gt; good_clause_list Rest
GCL : good_clause_list (I::L2)
S : select (ID, C) L1 L2 *
GCL' : good_clause_list L2
GCL1 : good_clause_list L1
============================
 good_clause_list (I::L1)
</pre>
<pre class="code extensibella"id="635">
 &lt; <b>unfold .</b>

Subgoal 2:

Variables: ID C L2 I L1
IH : forall L Rest ID C,
       good_clause_list L -&gt; select (ID, C) Rest L * -&gt; good_clause_list Rest
GCL : good_clause_list (I::L2)
S : select (ID, C) L1 L2 *
GCL' : good_clause_list L2
GCL1 : good_clause_list L1
============================
 forall ID C1 KRest C2,
   select (ID, C1) KRest (I::L1) -&gt; mem (ID, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="636">
 &lt; <b>intros Slct M.</b>

Subgoal 2:

Variables: ID C L2 I L1 ID1 C1 KRest C2
IH : forall L Rest ID C,
       good_clause_list L -&gt; select (ID, C) Rest L * -&gt; good_clause_list Rest
GCL : good_clause_list (I::L2)
S : select (ID, C) L1 L2 *
GCL' : good_clause_list L2
GCL1 : good_clause_list L1
Slct : select (ID1, C1) KRest (I::L1)
M : mem (ID1, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="637">
 &lt; <b>Slct: case Slct.</b>

Subgoal 2.1:

Variables: ID C L2 L1 ID1 C1 C2
IH : forall L Rest ID C,
       good_clause_list L -&gt; select (ID, C) Rest L * -&gt; good_clause_list Rest
GCL : good_clause_list ((ID1, C1)::L2)
S : select (ID, C) L1 L2 *
GCL' : good_clause_list L2
GCL1 : good_clause_list L1
M : mem (ID1, C2) L1
============================
 false
</pre>
<pre class="code extensibella"id="638">
 &lt; <b>M': apply mem_after_select_before to S M.</b>

Subgoal 2.1:

Variables: ID C L2 L1 ID1 C1 C2
IH : forall L Rest ID C,
       good_clause_list L -&gt; select (ID, C) Rest L * -&gt; good_clause_list Rest
GCL : good_clause_list ((ID1, C1)::L2)
S : select (ID, C) L1 L2 *
GCL' : good_clause_list L2
GCL1 : good_clause_list L1
M : mem (ID1, C2) L1
M' : mem (ID1, C2) L2
============================
 false
</pre>
<pre class="code extensibella"id="639">
 &lt; <b>GCL: case GCL.</b>

Subgoal 2.1:

Variables: ID C L2 L1 ID1 C1 C2
IH : forall L Rest ID C,
       good_clause_list L -&gt; select (ID, C) Rest L * -&gt; good_clause_list Rest
S : select (ID, C) L1 L2 *
GCL' : good_clause_list L2
GCL1 : good_clause_list L1
M : mem (ID1, C2) L1
M' : mem (ID1, C2) L2
GCL : forall ID C2 KRest C3,
        select (ID, C2) KRest ((ID1, C1)::L2) -&gt; mem (ID, C3) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="640">
 &lt; <b>apply GCL to _ M'.</b>

Subgoal 2.2:

Variables: ID C L2 I L1 ID1 C1 C2 L3
IH : forall L Rest ID C,
       good_clause_list L -&gt; select (ID, C) Rest L * -&gt; good_clause_list Rest
GCL : good_clause_list (I::L2)
S : select (ID, C) L1 L2 *
GCL' : good_clause_list L2
GCL1 : good_clause_list L1
M : mem (ID1, C2) (I::L3)
Slct : select (ID1, C1) L3 L1
============================
 false
</pre>
<pre class="code extensibella"id="641">
 &lt; <b>M: case M.</b>

Subgoal 2.2.1:

Variables: ID C L2 L1 ID1 C1 C2 L3
IH : forall L Rest ID C,
       good_clause_list L -&gt; select (ID, C) Rest L * -&gt; good_clause_list Rest
GCL : good_clause_list ((ID1, C2)::L2)
S : select (ID, C) L1 L2 *
GCL' : good_clause_list L2
GCL1 : good_clause_list L1
Slct : select (ID1, C1) L3 L1
============================
 false
</pre>
<pre class="code extensibella"id="642">
 &lt; <b>MS: apply select_mem to Slct.</b>

Subgoal 2.2.1:

Variables: ID C L2 L1 ID1 C1 C2 L3
IH : forall L Rest ID C,
       good_clause_list L -&gt; select (ID, C) Rest L * -&gt; good_clause_list Rest
GCL : good_clause_list ((ID1, C2)::L2)
S : select (ID, C) L1 L2 *
GCL' : good_clause_list L2
GCL1 : good_clause_list L1
Slct : select (ID1, C1) L3 L1
MS : mem (ID1, C1) L1
============================
 false
</pre>
<pre class="code extensibella"id="643">
 &lt; <b>M': apply mem_after_select_before to S MS.</b>

Subgoal 2.2.1:

Variables: ID C L2 L1 ID1 C1 C2 L3
IH : forall L Rest ID C,
       good_clause_list L -&gt; select (ID, C) Rest L * -&gt; good_clause_list Rest
GCL : good_clause_list ((ID1, C2)::L2)
S : select (ID, C) L1 L2 *
GCL' : good_clause_list L2
GCL1 : good_clause_list L1
Slct : select (ID1, C1) L3 L1
MS : mem (ID1, C1) L1
M' : mem (ID1, C1) L2
============================
 false
</pre>
<pre class="code extensibella"id="644">
 &lt; <b>GCL: case GCL.</b>

Subgoal 2.2.1:

Variables: ID C L2 L1 ID1 C1 C2 L3
IH : forall L Rest ID C,
       good_clause_list L -&gt; select (ID, C) Rest L * -&gt; good_clause_list Rest
S : select (ID, C) L1 L2 *
GCL' : good_clause_list L2
GCL1 : good_clause_list L1
Slct : select (ID1, C1) L3 L1
MS : mem (ID1, C1) L1
M' : mem (ID1, C1) L2
GCL : forall ID C1 KRest C3,
        select (ID, C1) KRest ((ID1, C2)::L2) -&gt; mem (ID, C3) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="645">
 &lt; <b>backchain GCL.</b>

Subgoal 2.2.2:

Variables: ID C L2 I L1 ID1 C1 C2 L3
IH : forall L Rest ID C,
       good_clause_list L -&gt; select (ID, C) Rest L * -&gt; good_clause_list Rest
GCL : good_clause_list (I::L2)
S : select (ID, C) L1 L2 *
GCL' : good_clause_list L2
GCL1 : good_clause_list L1
Slct : select (ID1, C1) L3 L1
M : mem (ID1, C2) L3
============================
 false
</pre>
<pre class="code extensibella"id="646">
 &lt; <b>GCL1: case GCL1.</b>

Subgoal 2.2.2:

Variables: ID C L2 I L1 ID1 C1 C2 L3
IH : forall L Rest ID C,
       good_clause_list L -&gt; select (ID, C) Rest L * -&gt; good_clause_list Rest
GCL : good_clause_list (I::L2)
S : select (ID, C) L1 L2 *
GCL' : good_clause_list L2
Slct : select (ID1, C1) L3 L1
M : mem (ID1, C2) L3
GCL1 : forall ID C1 KRest C2,
         select (ID, C1) KRest L1 -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="647">
 &lt; <b>apply GCL1 to Slct M.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="648">
 &lt; <b>Theorem good_clause_list_remove_all :
     forall Known ID KRest,
       good_clause_list Known -&gt; remove_all Known ID KRest -&gt; good_clause_list KRest.</b>

============================
 forall Known ID KRest,
   good_clause_list Known -&gt; remove_all Known ID KRest -&gt; good_clause_list KRest
</pre>
<pre class="code extensibella"id="649">
 &lt; <b>induction on 2.</b>

IH : forall Known ID KRest,
       good_clause_list Known -&gt; remove_all Known ID KRest * -&gt; good_clause_list KRest
============================
 forall Known ID KRest,
   good_clause_list Known -&gt; remove_all Known ID KRest @ -&gt; good_clause_list KRest
</pre>
<pre class="code extensibella"id="650">
 &lt; <b>intros GCL RA.</b>

Variables: Known ID KRest
IH : forall Known ID KRest,
       good_clause_list Known -&gt; remove_all Known ID KRest * -&gt; good_clause_list KRest
GCL : good_clause_list Known
RA : remove_all Known ID KRest @
============================
 good_clause_list KRest
</pre>
<pre class="code extensibella"id="651">
 &lt; <b>RA: case RA.</b>

Subgoal 1:

Variables: ID
IH : forall Known ID KRest,
       good_clause_list Known -&gt; remove_all Known ID KRest * -&gt; good_clause_list KRest
GCL : good_clause_list []
============================
 good_clause_list []
</pre>
<pre class="code extensibella"id="652">
 &lt; <b>search.</b>

Subgoal 2:

Variables: ID KRest IRest C
IH : forall Known ID KRest,
       good_clause_list Known -&gt; remove_all Known ID KRest * -&gt; good_clause_list KRest
GCL : good_clause_list ((ID, C)::IRest)
RA : remove_all IRest ID KRest *
============================
 good_clause_list KRest
</pre>
<pre class="code extensibella"id="653">
 &lt; <b>GCL': apply good_clause_list_drop to GCL.</b>

Subgoal 2:

Variables: ID KRest IRest C
IH : forall Known ID KRest,
       good_clause_list Known -&gt; remove_all Known ID KRest * -&gt; good_clause_list KRest
GCL : good_clause_list ((ID, C)::IRest)
RA : remove_all IRest ID KRest *
GCL' : good_clause_list IRest
============================
 good_clause_list KRest
</pre>
<pre class="code extensibella"id="654">
 &lt; <b>apply IH to GCL' RA.</b>

Subgoal 2:

Variables: ID KRest IRest C
IH : forall Known ID KRest,
       good_clause_list Known -&gt; remove_all Known ID KRest * -&gt; good_clause_list KRest
GCL : good_clause_list ((ID, C)::IRest)
RA : remove_all IRest ID KRest *
GCL' : good_clause_list IRest
H1 : good_clause_list KRest
============================
 good_clause_list KRest
</pre>
<pre class="code extensibella"id="655">
 &lt; <b>search.</b>

Subgoal 3:

Variables: ID Rest C A IRest
IH : forall Known ID KRest,
       good_clause_list Known -&gt; remove_all Known ID KRest * -&gt; good_clause_list KRest
GCL : good_clause_list ((A, C)::IRest)
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
============================
 good_clause_list ((A, C)::Rest)
</pre>
<pre class="code extensibella"id="656">
 &lt; <b>GCL': apply good_clause_list_drop to GCL.</b>

Subgoal 3:

Variables: ID Rest C A IRest
IH : forall Known ID KRest,
       good_clause_list Known -&gt; remove_all Known ID KRest * -&gt; good_clause_list KRest
GCL : good_clause_list ((A, C)::IRest)
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
GCL' : good_clause_list IRest
============================
 good_clause_list ((A, C)::Rest)
</pre>
<pre class="code extensibella"id="657">
 &lt; <b>GCLR: apply IH to GCL' RA1.</b>

Subgoal 3:

Variables: ID Rest C A IRest
IH : forall Known ID KRest,
       good_clause_list Known -&gt; remove_all Known ID KRest * -&gt; good_clause_list KRest
GCL : good_clause_list ((A, C)::IRest)
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
GCL' : good_clause_list IRest
GCLR : good_clause_list Rest
============================
 good_clause_list ((A, C)::Rest)
</pre>
<pre class="code extensibella"id="658">
 &lt; <b>unfold .</b>

Subgoal 3:

Variables: ID Rest C A IRest
IH : forall Known ID KRest,
       good_clause_list Known -&gt; remove_all Known ID KRest * -&gt; good_clause_list KRest
GCL : good_clause_list ((A, C)::IRest)
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
GCL' : good_clause_list IRest
GCLR : good_clause_list Rest
============================
 forall ID C1 KRest C2,
   select (ID, C1) KRest ((A, C)::Rest) -&gt; mem (ID, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="659">
 &lt; <b>intros S M.</b>

Subgoal 3:

Variables: ID Rest C A IRest ID1 C1 KRest1 C2
IH : forall Known ID KRest,
       good_clause_list Known -&gt; remove_all Known ID KRest * -&gt; good_clause_list KRest
GCL : good_clause_list ((A, C)::IRest)
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
GCL' : good_clause_list IRest
GCLR : good_clause_list Rest
S : select (ID1, C1) KRest1 ((A, C)::Rest)
M : mem (ID1, C2) KRest1
============================
 false
</pre>
<pre class="code extensibella"id="660">
 &lt; <b>S: case S.</b>

Subgoal 3.1:

Variables: ID Rest C A IRest C2
IH : forall Known ID KRest,
       good_clause_list Known -&gt; remove_all Known ID KRest * -&gt; good_clause_list KRest
GCL : good_clause_list ((A, C)::IRest)
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
GCL' : good_clause_list IRest
GCLR : good_clause_list Rest
M : mem (A, C2) Rest
============================
 false
</pre>
<pre class="code extensibella"id="661">
 &lt; <b>M': apply remove_all_mem_after to RA1 M.</b>

Subgoal 3.1:

Variables: ID Rest C A IRest C2
IH : forall Known ID KRest,
       good_clause_list Known -&gt; remove_all Known ID KRest * -&gt; good_clause_list KRest
GCL : good_clause_list ((A, C)::IRest)
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
GCL' : good_clause_list IRest
GCLR : good_clause_list Rest
M : mem (A, C2) Rest
M' : mem (A, C2) IRest
============================
 false
</pre>
<pre class="code extensibella"id="662">
 &lt; <b>GCL: case GCL.</b>

Subgoal 3.1:

Variables: ID Rest C A IRest C2
IH : forall Known ID KRest,
       good_clause_list Known -&gt; remove_all Known ID KRest * -&gt; good_clause_list KRest
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
GCL' : good_clause_list IRest
GCLR : good_clause_list Rest
M : mem (A, C2) Rest
M' : mem (A, C2) IRest
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest ((A, C)::IRest) -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="663">
 &lt; <b>backchain GCL.</b>

Subgoal 3.2:

Variables: ID Rest C A IRest ID1 C1 C2 L1
IH : forall Known ID KRest,
       good_clause_list Known -&gt; remove_all Known ID KRest * -&gt; good_clause_list KRest
GCL : good_clause_list ((A, C)::IRest)
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
GCL' : good_clause_list IRest
GCLR : good_clause_list Rest
M : mem (ID1, C2) ((A, C)::L1)
S : select (ID1, C1) L1 Rest
============================
 false
</pre>
<pre class="code extensibella"id="664">
 &lt; <b>M': apply select_mem to S.</b>

Subgoal 3.2:

Variables: ID Rest C A IRest ID1 C1 C2 L1
IH : forall Known ID KRest,
       good_clause_list Known -&gt; remove_all Known ID KRest * -&gt; good_clause_list KRest
GCL : good_clause_list ((A, C)::IRest)
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
GCL' : good_clause_list IRest
GCLR : good_clause_list Rest
M : mem (ID1, C2) ((A, C)::L1)
S : select (ID1, C1) L1 Rest
M' : mem (ID1, C1) Rest
============================
 false
</pre>
<pre class="code extensibella"id="665">
 &lt; <b>MS: apply remove_all_mem_after to RA1 M'.</b>

Subgoal 3.2:

Variables: ID Rest C A IRest ID1 C1 C2 L1
IH : forall Known ID KRest,
       good_clause_list Known -&gt; remove_all Known ID KRest * -&gt; good_clause_list KRest
GCL : good_clause_list ((A, C)::IRest)
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
GCL' : good_clause_list IRest
GCLR : good_clause_list Rest
M : mem (ID1, C2) ((A, C)::L1)
S : select (ID1, C1) L1 Rest
M' : mem (ID1, C1) Rest
MS : mem (ID1, C1) IRest
============================
 false
</pre>
<pre class="code extensibella"id="666">
 &lt; <b>M: case M.</b>

Subgoal 3.2.1:

Variables: ID Rest C A IRest C1 L1
IH : forall Known ID KRest,
       good_clause_list Known -&gt; remove_all Known ID KRest * -&gt; good_clause_list KRest
GCL : good_clause_list ((A, C)::IRest)
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
GCL' : good_clause_list IRest
GCLR : good_clause_list Rest
S : select (A, C1) L1 Rest
M' : mem (A, C1) Rest
MS : mem (A, C1) IRest
============================
 false
</pre>
<pre class="code extensibella"id="667">
 &lt; <b>GCL: case GCL.</b>

Subgoal 3.2.1:

Variables: ID Rest C A IRest C1 L1
IH : forall Known ID KRest,
       good_clause_list Known -&gt; remove_all Known ID KRest * -&gt; good_clause_list KRest
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
GCL' : good_clause_list IRest
GCLR : good_clause_list Rest
S : select (A, C1) L1 Rest
M' : mem (A, C1) Rest
MS : mem (A, C1) IRest
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest ((A, C)::IRest) -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="668">
 &lt; <b>backchain GCL.</b>

Subgoal 3.2.2:

Variables: ID Rest C A IRest ID1 C1 C2 L1
IH : forall Known ID KRest,
       good_clause_list Known -&gt; remove_all Known ID KRest * -&gt; good_clause_list KRest
GCL : good_clause_list ((A, C)::IRest)
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
GCL' : good_clause_list IRest
GCLR : good_clause_list Rest
S : select (ID1, C1) L1 Rest
M' : mem (ID1, C1) Rest
MS : mem (ID1, C1) IRest
M : mem (ID1, C2) L1
============================
 false
</pre>
<pre class="code extensibella"id="669">
 &lt; <b>GCLR: case GCLR.</b>

Subgoal 3.2.2:

Variables: ID Rest C A IRest ID1 C1 C2 L1
IH : forall Known ID KRest,
       good_clause_list Known -&gt; remove_all Known ID KRest * -&gt; good_clause_list KRest
GCL : good_clause_list ((A, C)::IRest)
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
GCL' : good_clause_list IRest
S : select (ID1, C1) L1 Rest
M' : mem (ID1, C1) Rest
MS : mem (ID1, C1) IRest
M : mem (ID1, C2) L1
GCLR : forall ID C1 KRest C2,
         select (ID, C1) KRest Rest -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="670">
 &lt; <b>backchain GCLR.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="671">
 &lt; <b>Theorem good_clause_list_add :
     forall Known ID C,
       good_clause_list Known -&gt; ((exists C', mem (ID, C') Known) -&gt; false) -&gt; good_clause_list ((ID, C)::Known).</b>

============================
 forall Known ID C,
   good_clause_list Known -&gt; ((exists C', mem (ID, C') Known) -&gt; false) -&gt; good_clause_list ((ID, C)::Known)
</pre>
<pre class="code extensibella"id="672">
 &lt; <b>intros GCL NMem.</b>

Variables: Known ID C
GCL : good_clause_list Known
NMem : (exists C', mem (ID, C') Known) -&gt; false
============================
 good_clause_list ((ID, C)::Known)
</pre>
<pre class="code extensibella"id="673">
 &lt; <b>unfold .</b>

Variables: Known ID C
GCL : good_clause_list Known
NMem : (exists C', mem (ID, C') Known) -&gt; false
============================
 forall ID1 C1 KRest C2,
   select (ID1, C1) KRest ((ID, C)::Known) -&gt; mem (ID1, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="674">
 &lt; <b>intros S M.</b>

Variables: Known ID C ID1 C1 KRest C2
GCL : good_clause_list Known
NMem : (exists C', mem (ID, C') Known) -&gt; false
S : select (ID1, C1) KRest ((ID, C)::Known)
M : mem (ID1, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="675">
 &lt; <b>S: case S.</b>

Subgoal 1:

Variables: Known ID C C2
GCL : good_clause_list Known
NMem : (exists C', mem (ID, C') Known) -&gt; false
M : mem (ID, C2) Known
============================
 false
</pre>
<pre class="code extensibella"id="676">
 &lt; <b>backchain NMem.</b>

Subgoal 2:

Variables: Known ID C ID1 C1 C2 L1
GCL : good_clause_list Known
NMem : (exists C', mem (ID, C') Known) -&gt; false
M : mem (ID1, C2) ((ID, C)::L1)
S : select (ID1, C1) L1 Known
============================
 false
</pre>
<pre class="code extensibella"id="677">
 &lt; <b>M: case M.</b>

Subgoal 2.1:

Variables: Known ID C C1 L1
GCL : good_clause_list Known
NMem : (exists C', mem (ID, C') Known) -&gt; false
S : select (ID, C1) L1 Known
============================
 false
</pre>
<pre class="code extensibella"id="678">
 &lt; <b>M: apply select_mem to S.</b>

Subgoal 2.1:

Variables: Known ID C C1 L1
GCL : good_clause_list Known
NMem : (exists C', mem (ID, C') Known) -&gt; false
S : select (ID, C1) L1 Known
M : mem (ID, C1) Known
============================
 false
</pre>
<pre class="code extensibella"id="679">
 &lt; <b>backchain NMem.</b>

Subgoal 2.2:

Variables: Known ID C ID1 C1 C2 L1
GCL : good_clause_list Known
NMem : (exists C', mem (ID, C') Known) -&gt; false
S : select (ID1, C1) L1 Known
M : mem (ID1, C2) L1
============================
 false
</pre>
<pre class="code extensibella"id="680">
 &lt; <b>GCL: case GCL.</b>

Subgoal 2.2:

Variables: Known ID C ID1 C1 C2 L1
NMem : (exists C', mem (ID, C') Known) -&gt; false
S : select (ID1, C1) L1 Known
M : mem (ID1, C2) L1
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest Known -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="681">
 &lt; <b>backchain GCL.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="682">
 &lt; <b>Theorem good_clause_list_remove_all_add :
     forall Known ID KRest C,
       good_clause_list Known -&gt; remove_all Known ID KRest -&gt; good_clause_list ((ID, C)::KRest).</b>

============================
 forall Known ID KRest C,
   good_clause_list Known -&gt; remove_all Known ID KRest -&gt; good_clause_list ((ID, C)::KRest)
</pre>
<pre class="code extensibella"id="683">
 &lt; <b>intros GCL RA.</b>

Variables: Known ID KRest C
GCL : good_clause_list Known
RA : remove_all Known ID KRest
============================
 good_clause_list ((ID, C)::KRest)
</pre>
<pre class="code extensibella"id="684">
 &lt; <b>apply good_clause_list_remove_all to GCL RA.</b>

Variables: Known ID KRest C
GCL : good_clause_list Known
RA : remove_all Known ID KRest
H1 : good_clause_list KRest
============================
 good_clause_list ((ID, C)::KRest)
</pre>
<pre class="code extensibella"id="685">
 &lt; <b>backchain good_clause_list_add.</b>

Variables: Known ID KRest C
GCL : good_clause_list Known
RA : remove_all Known ID KRest
H1 : good_clause_list KRest
============================
 (exists C', mem (ID, C') KRest) -&gt; false
</pre>
<pre class="code extensibella"id="686">
 &lt; <b>intros M.</b>

Variables: Known ID KRest C
GCL : good_clause_list Known
RA : remove_all Known ID KRest
H1 : good_clause_list KRest
M : exists C', mem (ID, C') KRest
============================
 false
</pre>
<pre class="code extensibella"id="687">
 &lt; <b>M: case M.</b>

Variables: Known ID KRest C C'
GCL : good_clause_list Known
RA : remove_all Known ID KRest
H1 : good_clause_list KRest
M : mem (ID, C') KRest
============================
 false
</pre>
<pre class="code extensibella"id="688">
 &lt; <b>apply remove_all_no_mem to RA M.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="689">
 &lt; <b>Theorem permutation_good_clause_list :
     forall L P,
       is_list (is_pair is_integer is_clause) P -&gt; permutation L P -&gt; good_clause_list L -&gt;
       good_clause_list P.</b>

============================
 forall L P,
   is_list (is_pair is_integer is_clause) P -&gt; permutation L P -&gt; good_clause_list L -&gt;
   good_clause_list P
</pre>
<pre class="code extensibella"id="690">
 &lt; <b>intros IsP Prm GCL.</b>

Variables: L P
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
GCL : good_clause_list L
============================
 good_clause_list P
</pre>
<pre class="code extensibella"id="691">
 &lt; <b>unfold .</b>

Variables: L P
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
GCL : good_clause_list L
============================
 forall ID C1 KRest C2, select (ID, C1) KRest P -&gt; mem (ID, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="692">
 &lt; <b>intros S MK.</b>

Variables: L P ID C1 KRest C2
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
GCL : good_clause_list L
S : select (ID, C1) KRest P
MK : mem (ID, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="693">
 &lt; <b>MS: apply select_mem to S.</b>

Variables: L P ID C1 KRest C2
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
GCL : good_clause_list L
S : select (ID, C1) KRest P
MK : mem (ID, C2) KRest
MS : mem (ID, C1) P
============================
 false
</pre>
<pre class="code extensibella"id="694">
 &lt; <b>Prm': apply permutation_symmetric to Prm.</b>

Variables: L P ID C1 KRest C2
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
GCL : good_clause_list L
S : select (ID, C1) KRest P
MK : mem (ID, C2) KRest
MS : mem (ID, C1) P
Prm' : permutation P L
============================
 false
</pre>
<pre class="code extensibella"id="695">
 &lt; <b>ML1: apply permutation_mem to Prm' MS.</b>

Variables: L P ID C1 KRest C2
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
GCL : good_clause_list L
S : select (ID, C1) KRest P
MK : mem (ID, C2) KRest
MS : mem (ID, C1) P
Prm' : permutation P L
ML1 : mem (ID, C1) L
============================
 false
</pre>
<pre class="code extensibella"id="696">
 &lt; <b>SL: apply mem_select to ML1.</b>

Variables: L P ID C1 KRest C2 L'
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
GCL : good_clause_list L
S : select (ID, C1) KRest P
MK : mem (ID, C2) KRest
MS : mem (ID, C1) P
Prm' : permutation P L
ML1 : mem (ID, C1) L
SL : select (ID, C1) L' L
============================
 false
</pre>
<pre class="code extensibella"id="697">
 &lt; <b>IsL: apply permutation_is to IsP Prm.</b>

Variables: L P ID C1 KRest C2 L'
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
GCL : good_clause_list L
S : select (ID, C1) KRest P
MK : mem (ID, C2) KRest
MS : mem (ID, C1) P
Prm' : permutation P L
ML1 : mem (ID, C1) L
SL : select (ID, C1) L' L
IsL : is_list (is_pair is_integer is_clause) L
============================
 false
</pre>
<pre class="code extensibella"id="698">
 &lt; <b>P': apply selects_permutation to _ _ Prm' S SL.</b>

Variables: L P ID C1 KRest C2 L'
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
GCL : good_clause_list L
S : select (ID, C1) KRest P
MK : mem (ID, C2) KRest
MS : mem (ID, C1) P
Prm' : permutation P L
ML1 : mem (ID, C1) L
SL : select (ID, C1) L' L
IsL : is_list (is_pair is_integer is_clause) L
P' : permutation KRest L'
============================
 false
</pre>
<pre class="code extensibella"id="699">
 &lt; <b>ML': apply permutation_mem to P' MK.</b>

Variables: L P ID C1 KRest C2 L'
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
GCL : good_clause_list L
S : select (ID, C1) KRest P
MK : mem (ID, C2) KRest
MS : mem (ID, C1) P
Prm' : permutation P L
ML1 : mem (ID, C1) L
SL : select (ID, C1) L' L
IsL : is_list (is_pair is_integer is_clause) L
P' : permutation KRest L'
ML' : mem (ID, C2) L'
============================
 false
</pre>
<pre class="code extensibella"id="700">
 &lt; <b>GCL: case GCL.</b>

Variables: L P ID C1 KRest C2 L'
IsP : is_list (is_pair is_integer is_clause) P
Prm : permutation L P
S : select (ID, C1) KRest P
MK : mem (ID, C2) KRest
MS : mem (ID, C1) P
Prm' : permutation P L
ML1 : mem (ID, C1) L
SL : select (ID, C1) L' L
IsL : is_list (is_pair is_integer is_clause) L
P' : permutation KRest L'
ML' : mem (ID, C2) L'
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest L -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="701">
 &lt; <b>backchain GCL.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="702">
 &lt; <b>Theorem good_clause_list_mems :
     forall L X CA CB,
       good_clause_list L -&gt; mem (X, CA) L -&gt; mem (X, CB) L -&gt; CA = CB.</b>

============================
 forall L X CA CB,
   good_clause_list L -&gt; mem (X, CA) L -&gt; mem (X, CB) L -&gt; CA = CB
</pre>
<pre class="code extensibella"id="703">
 &lt; <b>induction on 2.</b>

IH : forall L X CA CB,
       good_clause_list L -&gt; mem (X, CA) L * -&gt; mem (X, CB) L -&gt; CA = CB
============================
 forall L X CA CB,
   good_clause_list L -&gt; mem (X, CA) L @ -&gt; mem (X, CB) L -&gt; CA = CB
</pre>
<pre class="code extensibella"id="704">
 &lt; <b>intros GCL MA MB.</b>

Variables: L X CA CB
IH : forall L X CA CB,
       good_clause_list L -&gt; mem (X, CA) L * -&gt; mem (X, CB) L -&gt; CA = CB
GCL : good_clause_list L
MA : mem (X, CA) L @
MB : mem (X, CB) L
============================
 CA = CB
</pre>
<pre class="code extensibella"id="705">
 &lt; <b>MA: case MA.</b>

Subgoal 1:

Variables: X CA CB Rest
IH : forall L X CA CB,
       good_clause_list L -&gt; mem (X, CA) L * -&gt; mem (X, CB) L -&gt; CA = CB
GCL : good_clause_list ((X, CA)::Rest)
MB : mem (X, CB) ((X, CA)::Rest)
============================
 CA = CB
</pre>
<pre class="code extensibella"id="706">
 &lt; <b>MB: case MB.</b>

Subgoal 1.1:

Variables: X CA Rest
IH : forall L X CA CB,
       good_clause_list L -&gt; mem (X, CA) L * -&gt; mem (X, CB) L -&gt; CA = CB
GCL : good_clause_list ((X, CA)::Rest)
============================
 CA = CA
</pre>
<pre class="code extensibella"id="707">
 &lt; <b>search.</b>

Subgoal 1.2:

Variables: X CA CB Rest
IH : forall L X CA CB,
       good_clause_list L -&gt; mem (X, CA) L * -&gt; mem (X, CB) L -&gt; CA = CB
GCL : good_clause_list ((X, CA)::Rest)
MB : mem (X, CB) Rest
============================
 CA = CB
</pre>
<pre class="code extensibella"id="708">
 &lt; <b>GCL: case GCL.</b>

Subgoal 1.2:

Variables: X CA CB Rest
IH : forall L X CA CB,
       good_clause_list L -&gt; mem (X, CA) L * -&gt; mem (X, CB) L -&gt; CA = CB
MB : mem (X, CB) Rest
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest ((X, CA)::Rest) -&gt; mem (ID, C2) KRest -&gt; false
============================
 CA = CB
</pre>
<pre class="code extensibella"id="709">
 &lt; <b>apply GCL to _ MB.</b>

Subgoal 2:

Variables: X CA CB Rest I
IH : forall L X CA CB,
       good_clause_list L -&gt; mem (X, CA) L * -&gt; mem (X, CB) L -&gt; CA = CB
GCL : good_clause_list (I::Rest)
MB : mem (X, CB) (I::Rest)
MA : mem (X, CA) Rest *
============================
 CA = CB
</pre>
<pre class="code extensibella"id="710">
 &lt; <b>MB: case MB.</b>

Subgoal 2.1:

Variables: X CA CB Rest
IH : forall L X CA CB,
       good_clause_list L -&gt; mem (X, CA) L * -&gt; mem (X, CB) L -&gt; CA = CB
GCL : good_clause_list ((X, CB)::Rest)
MA : mem (X, CA) Rest *
============================
 CA = CB
</pre>
<pre class="code extensibella"id="711">
 &lt; <b>GCL: case GCL.</b>

Subgoal 2.1:

Variables: X CA CB Rest
IH : forall L X CA CB,
       good_clause_list L -&gt; mem (X, CA) L * -&gt; mem (X, CB) L -&gt; CA = CB
MA : mem (X, CA) Rest *
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest ((X, CB)::Rest) -&gt; mem (ID, C2) KRest -&gt; false
============================
 CA = CB
</pre>
<pre class="code extensibella"id="712">
 &lt; <b>apply GCL to _ MA.</b>

Subgoal 2.2:

Variables: X CA CB Rest I
IH : forall L X CA CB,
       good_clause_list L -&gt; mem (X, CA) L * -&gt; mem (X, CB) L -&gt; CA = CB
GCL : good_clause_list (I::Rest)
MA : mem (X, CA) Rest *
MB : mem (X, CB) Rest
============================
 CA = CB
</pre>
<pre class="code extensibella"id="713">
 &lt; <b>GCL': apply good_clause_list_drop to GCL.</b>

Subgoal 2.2:

Variables: X CA CB Rest I
IH : forall L X CA CB,
       good_clause_list L -&gt; mem (X, CA) L * -&gt; mem (X, CB) L -&gt; CA = CB
GCL : good_clause_list (I::Rest)
MA : mem (X, CA) Rest *
MB : mem (X, CB) Rest
GCL' : good_clause_list Rest
============================
 CA = CB
</pre>
<pre class="code extensibella"id="714">
 &lt; <b>apply IH to GCL' MA MB.</b>

Subgoal 2.2:

Variables: X CB Rest I
IH : forall L X CA CB,
       good_clause_list L -&gt; mem (X, CA) L * -&gt; mem (X, CB) L -&gt; CA = CB
GCL : good_clause_list (I::Rest)
MA : mem (X, CB) Rest *
MB : mem (X, CB) Rest
GCL' : good_clause_list Rest
============================
 CB = CB
</pre>
<pre class="code extensibella"id="715">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="716">
 &lt; <b>Theorem rupProof_help_all_mem :
     forall Known A Proof ID,
       rupProof_help Known A Proof -&gt; mem ID Proof -&gt; exists C,
         lookup Known ID C.</b>

============================
 forall Known A Proof ID,
   rupProof_help Known A Proof -&gt; mem ID Proof -&gt; exists C, lookup Known ID C
</pre>
<pre class="code extensibella"id="717">
 &lt; <b>induction on 1.</b>

IH : forall Known A Proof ID,
       rupProof_help Known A Proof * -&gt; mem ID Proof -&gt; exists C,
         lookup Known ID C
============================
 forall Known A Proof ID,
   rupProof_help Known A Proof @ -&gt; mem ID Proof -&gt; exists C, lookup Known ID C
</pre>
<pre class="code extensibella"id="718">
 &lt; <b>intros RUP Mem.</b>

Variables: Known A Proof ID
IH : forall Known A Proof ID,
       rupProof_help Known A Proof * -&gt; mem ID Proof -&gt; exists C,
         lookup Known ID C
RUP : rupProof_help Known A Proof @
Mem : mem ID Proof
============================
 exists C, lookup Known ID C
</pre>
<pre class="code extensibella"id="719">
 &lt; <b>RUP: case RUP.</b>

Subgoal 1:

Variables: Known A ID C ID1
IH : forall Known A Proof ID,
       rupProof_help Known A Proof * -&gt; mem ID Proof -&gt; exists C,
         lookup Known ID C
Mem : mem ID [ID1]
RUP : lookup Known ID1 C
RUP1 : unsat_clause A C
============================
 exists C, lookup Known ID C
</pre>
<pre class="code extensibella"id="720">
 &lt; <b>Mem: case Mem.</b>

Subgoal 1.1:

Variables: Known A C ID1
IH : forall Known A Proof ID,
       rupProof_help Known A Proof * -&gt; mem ID Proof -&gt; exists C,
         lookup Known ID C
RUP : lookup Known ID1 C
RUP1 : unsat_clause A C
============================
 exists C, lookup Known ID1 C
</pre>
<pre class="code extensibella"id="721">
 &lt; <b>search.</b>

Subgoal 1.2:

Variables: Known A ID C ID1
IH : forall Known A Proof ID,
       rupProof_help Known A Proof * -&gt; mem ID Proof -&gt; exists C,
         lookup Known ID C
RUP : lookup Known ID1 C
RUP1 : unsat_clause A C
Mem : mem ID []
============================
 exists C, lookup Known ID C
</pre>
<pre class="code extensibella"id="722">
 &lt; <b>case Mem.</b>

Subgoal 2:

Variables: Known A ID C L Prf ID1
IH : forall Known A Proof ID,
       rupProof_help Known A Proof * -&gt; mem ID Proof -&gt; exists C,
         lookup Known ID C
Mem : mem ID (ID1::Prf)
RUP : lookup Known ID1 C
RUP1 : unit_clause A C L
RUP2 : rupProof_help Known (L::A) Prf *
============================
 exists C, lookup Known ID C
</pre>
<pre class="code extensibella"id="723">
 &lt; <b>Mem: case Mem.</b>

Subgoal 2.1:

Variables: Known A C L Prf ID1
IH : forall Known A Proof ID,
       rupProof_help Known A Proof * -&gt; mem ID Proof -&gt; exists C,
         lookup Known ID C
RUP : lookup Known ID1 C
RUP1 : unit_clause A C L
RUP2 : rupProof_help Known (L::A) Prf *
============================
 exists C, lookup Known ID1 C
</pre>
<pre class="code extensibella"id="724">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: Known A ID C L Prf ID1
IH : forall Known A Proof ID,
       rupProof_help Known A Proof * -&gt; mem ID Proof -&gt; exists C,
         lookup Known ID C
RUP : lookup Known ID1 C
RUP1 : unit_clause A C L
RUP2 : rupProof_help Known (L::A) Prf *
Mem : mem ID Prf
============================
 exists C, lookup Known ID C
</pre>
<pre class="code extensibella"id="725">
 &lt; <b>apply IH to RUP2 Mem.</b>

Subgoal 2.2:

Variables: Known A ID C L Prf ID1 C1
IH : forall Known A Proof ID,
       rupProof_help Known A Proof * -&gt; mem ID Proof -&gt; exists C,
         lookup Known ID C
RUP : lookup Known ID1 C
RUP1 : unit_clause A C L
RUP2 : rupProof_help Known (L::A) Prf *
Mem : mem ID Prf
H1 : lookup Known ID C1
============================
 exists C, lookup Known ID C
</pre>
<pre class="code extensibella"id="726">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="727">
 &lt; <b>Theorem rupProof_help_is :
     forall Known A Proof,
       rupProof_help Known A Proof -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list is_integer Proof.</b>

============================
 forall Known A Proof,
   rupProof_help Known A Proof -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
   is_list is_integer Proof
</pre>
<pre class="code extensibella"id="728">
 &lt; <b>induction on 1.</b>

IH : forall Known A Proof,
       rupProof_help Known A Proof * -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list is_integer Proof
============================
 forall Known A Proof,
   rupProof_help Known A Proof @ -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
   is_list is_integer Proof
</pre>
<pre class="code extensibella"id="729">
 &lt; <b>intros RUP IsK.</b>

Variables: Known A Proof
IH : forall Known A Proof,
       rupProof_help Known A Proof * -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list is_integer Proof
RUP : rupProof_help Known A Proof @
IsK : is_list (is_pair is_integer is_clause) Known
============================
 is_list is_integer Proof
</pre>
<pre class="code extensibella"id="730">
 &lt; <b>RUP: case RUP.</b>

Subgoal 1:

Variables: Known A C ID
IH : forall Known A Proof,
       rupProof_help Known A Proof * -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list is_integer Proof
IsK : is_list (is_pair is_integer is_clause) Known
RUP : lookup Known ID C
RUP1 : unsat_clause A C
============================
 is_list is_integer [ID]
</pre>
<pre class="code extensibella"id="731">
 &lt; <b>apply lookup_is_key to IsK RUP.</b>

Subgoal 1:

Variables: Known A C ID
IH : forall Known A Proof,
       rupProof_help Known A Proof * -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list is_integer Proof
IsK : is_list (is_pair is_integer is_clause) Known
RUP : lookup Known ID C
RUP1 : unsat_clause A C
H1 : is_integer ID
============================
 is_list is_integer [ID]
</pre>
<pre class="code extensibella"id="732">
 &lt; <b>search.</b>

Subgoal 2:

Variables: Known A C L Prf ID
IH : forall Known A Proof,
       rupProof_help Known A Proof * -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list is_integer Proof
IsK : is_list (is_pair is_integer is_clause) Known
RUP : lookup Known ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help Known (L::A) Prf *
============================
 is_list is_integer (ID::Prf)
</pre>
<pre class="code extensibella"id="733">
 &lt; <b>apply lookup_is_key to IsK RUP.</b>

Subgoal 2:

Variables: Known A C L Prf ID
IH : forall Known A Proof,
       rupProof_help Known A Proof * -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list is_integer Proof
IsK : is_list (is_pair is_integer is_clause) Known
RUP : lookup Known ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help Known (L::A) Prf *
H1 : is_integer ID
============================
 is_list is_integer (ID::Prf)
</pre>
<pre class="code extensibella"id="734">
 &lt; <b>apply IH to RUP2 IsK.</b>

Subgoal 2:

Variables: Known A C L Prf ID
IH : forall Known A Proof,
       rupProof_help Known A Proof * -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list is_integer Proof
IsK : is_list (is_pair is_integer is_clause) Known
RUP : lookup Known ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help Known (L::A) Prf *
H1 : is_integer ID
H2 : is_list is_integer Prf
============================
 is_list is_integer (ID::Prf)
</pre>
<pre class="code extensibella"id="735">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="736">
 &lt; <b>Theorem rupProof_help_unsat :
     forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof -&gt; (forall (L : lit), mem L A -&gt; mem L Sat) -&gt;
       (forall (InID : integer) (InC : clause),
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false.</b>

============================
 forall Known A Sat Proof,
   is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
   rupProof_help Known A Proof -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
     lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
   false
</pre>
<pre class="code extensibella"id="737">
 &lt; <b>induction on 4.</b>

IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
============================
 forall Known A Sat Proof,
   is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
   rupProof_help Known A Proof @ -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
     lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
   false
</pre>
<pre class="code extensibella"id="738">
 &lt; <b>intros IsKnown IsA IsSat RUP Expand Sat GA_A GA_Sat.</b>

Variables: Known A Sat Proof
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
RUP : rupProof_help Known A Proof @
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
============================
 false
</pre>
<pre class="code extensibella"id="739">
 &lt; <b>RUP: case RUP.</b>

Subgoal 1:

Variables: Known A Sat C ID
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID C
RUP1 : unsat_clause A C
============================
 false
</pre>
<pre class="code extensibella"id="740">
 &lt; <b>SatC: apply Sat to RUP.</b>

Subgoal 1:

Variables: Known A Sat C ID
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID C
RUP1 : unsat_clause A C
SatC : sat_clause Sat C
============================
 false
</pre>
<pre class="code extensibella"id="741">
 &lt; <b>M: apply lookup_mem to RUP.</b>

Subgoal 1:

Variables: Known A Sat C ID
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID C
RUP1 : unsat_clause A C
SatC : sat_clause Sat C
M : mem (ID, C) Known
============================
 false
</pre>
<pre class="code extensibella"id="742">
 &lt; <b>Is: apply mem_is to _ M.</b>

Subgoal 1:

Variables: Known A Sat ID1 C1
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID1 C1
RUP1 : unsat_clause A C1
SatC : sat_clause Sat C1
M : mem (ID1, C1) Known
Is : is_integer ID1
Is1 : is_clause C1
============================
 false
</pre>
<pre class="code extensibella"id="743">
 &lt; <b>UnsatC: apply unsat_clause_orderless to _ _ _ RUP1 Expand.</b>

Subgoal 1:

Variables: Known A Sat ID1 C1
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID1 C1
RUP1 : unsat_clause A C1
SatC : sat_clause Sat C1
M : mem (ID1, C1) Known
Is : is_integer ID1
Is1 : is_clause C1
UnsatC : unsat_clause Sat C1
============================
 false
</pre>
<pre class="code extensibella"id="744">
 &lt; <b>apply unsat_sat_clause to _ _ UnsatC SatC _.</b>

Subgoal 2:

Variables: Known A Sat C L Prf ID
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help Known (L::A) Prf *
============================
 false
</pre>
<pre class="code extensibella"id="745">
 &lt; <b>Sat: apply Sat to RUP.</b>

Subgoal 2:

Variables: Known A Sat C L Prf ID
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help Known (L::A) Prf *
Sat1 : sat_clause Sat C
============================
 false
</pre>
<pre class="code extensibella"id="746">
 &lt; <b>M: apply lookup_mem to RUP.</b>

Subgoal 2:

Variables: Known A Sat C L Prf ID
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help Known (L::A) Prf *
Sat1 : sat_clause Sat C
M : mem (ID, C) Known
============================
 false
</pre>
<pre class="code extensibella"id="747">
 &lt; <b>Is: apply mem_is to _ M.</b>

Subgoal 2:

Variables: Known A Sat L Prf ID1 C1
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID1 C1
RUP1 : unit_clause A C1 L
RUP2 : rupProof_help Known (L::A) Prf *
Sat1 : sat_clause Sat C1
M : mem (ID1, C1) Known
Is : is_integer ID1
Is1 : is_clause C1
============================
 false
</pre>
<pre class="code extensibella"id="748">
 &lt; <b>MemL: apply unit_clause_expand to _ _ _ RUP1 _ GA_A GA_Sat Expand.</b>

Subgoal 2:

Variables: Known A Sat L Prf ID1 C1
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID1 C1
RUP1 : unit_clause A C1 L
RUP2 : rupProof_help Known (L::A) Prf *
Sat1 : sat_clause Sat C1
M : mem (ID1, C1) Known
Is : is_integer ID1
Is1 : is_clause C1
MemL : mem L Sat
============================
 false
</pre>
<pre class="code extensibella"id="749">
 &lt; <b>MemImp: assert forall (X : lit),
     mem X (L::A) -&gt; mem X Sat.</b>

Subgoal 2.1:

Variables: Known A Sat L Prf ID1 C1
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID1 C1
RUP1 : unit_clause A C1 L
RUP2 : rupProof_help Known (L::A) Prf *
Sat1 : sat_clause Sat C1
M : mem (ID1, C1) Known
Is : is_integer ID1
Is1 : is_clause C1
MemL : mem L Sat
============================
 forall X, mem X (L::A) -&gt; mem X Sat
</pre>
<pre class="code extensibella"id="750">
 &lt; <b>intros Mem.</b>

Subgoal 2.1:

Variables: Known A Sat L Prf ID1 C1 X
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID1 C1
RUP1 : unit_clause A C1 L
RUP2 : rupProof_help Known (L::A) Prf *
Sat1 : sat_clause Sat C1
M : mem (ID1, C1) Known
Is : is_integer ID1
Is1 : is_clause C1
MemL : mem L Sat
Mem : mem X (L::A)
============================
 mem X Sat
</pre>
<pre class="code extensibella"id="751">
 &lt; <b>Mem: case Mem.</b>

Subgoal 2.1.1:

Variables: Known A Sat L Prf ID1 C1
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID1 C1
RUP1 : unit_clause A C1 L
RUP2 : rupProof_help Known (L::A) Prf *
Sat1 : sat_clause Sat C1
M : mem (ID1, C1) Known
Is : is_integer ID1
Is1 : is_clause C1
MemL : mem L Sat
============================
 mem L Sat
</pre>
<pre class="code extensibella"id="752">
 &lt; <b>search.</b>

Subgoal 2.1.2:

Variables: Known A Sat L Prf ID1 C1 X
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID1 C1
RUP1 : unit_clause A C1 L
RUP2 : rupProof_help Known (L::A) Prf *
Sat1 : sat_clause Sat C1
M : mem (ID1, C1) Known
Is : is_integer ID1
Is1 : is_clause C1
MemL : mem L Sat
Mem : mem X A
============================
 mem X Sat
</pre>
<pre class="code extensibella"id="753">
 &lt; <b>backchain Expand.</b>

Subgoal 2:

Variables: Known A Sat L Prf ID1 C1
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID1 C1
RUP1 : unit_clause A C1 L
RUP2 : rupProof_help Known (L::A) Prf *
Sat1 : sat_clause Sat C1
M : mem (ID1, C1) Known
Is : is_integer ID1
Is1 : is_clause C1
MemL : mem L Sat
MemImp : forall X, mem X (L::A) -&gt; mem X Sat
============================
 false
</pre>
<pre class="code extensibella"id="754">
 &lt; <b>IsL: apply unit_clause_is to _ _ RUP1.</b>

Subgoal 2:

Variables: Known A Sat L Prf ID1 C1
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID1 C1
RUP1 : unit_clause A C1 L
RUP2 : rupProof_help Known (L::A) Prf *
Sat1 : sat_clause Sat C1
M : mem (ID1, C1) Known
Is : is_integer ID1
Is1 : is_clause C1
MemL : mem L Sat
MemImp : forall X, mem X (L::A) -&gt; mem X Sat
IsL : is_lit L
============================
 false
</pre>
<pre class="code extensibella"id="755">
 &lt; <b>backchain IH to
   Known = Known
   A = L::A
   Sat = Sat
   Proof = Prf.</b>

Subgoal 2:

Variables: Known A Sat L Prf ID1 C1
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID1 C1
RUP1 : unit_clause A C1 L
RUP2 : rupProof_help Known (L::A) Prf *
Sat1 : sat_clause Sat C1
M : mem (ID1, C1) Known
Is : is_integer ID1
Is1 : is_clause C1
MemL : mem L Sat
MemImp : forall X, mem X (L::A) -&gt; mem X Sat
IsL : is_lit L
============================
 good_assignment (L::A)
</pre>
<pre class="code extensibella"id="756">
 &lt; <b>unfold .</b>

Subgoal 2:

Variables: Known A Sat L Prf ID1 C1
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID1 C1
RUP1 : unit_clause A C1 L
RUP2 : rupProof_help Known (L::A) Prf *
Sat1 : sat_clause Sat C1
M : mem (ID1, C1) Known
Is : is_integer ID1
Is1 : is_clause C1
MemL : mem L Sat
MemImp : forall X, mem X (L::A) -&gt; mem X Sat
IsL : is_lit L
============================
 forall L1 NL, mem L1 (L::A) -&gt; negate_lit L1 NL -&gt; mem NL (L::A) -&gt; false
</pre>
<pre class="code extensibella"id="757">
 &lt; <b>intros MemL1 NegL1 MemNL.</b>

Subgoal 2:

Variables: Known A Sat L Prf ID1 C1 L1 NL
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID1 C1
RUP1 : unit_clause A C1 L
RUP2 : rupProof_help Known (L::A) Prf *
Sat1 : sat_clause Sat C1
M : mem (ID1, C1) Known
Is : is_integer ID1
Is1 : is_clause C1
MemL : mem L Sat
MemImp : forall X, mem X (L::A) -&gt; mem X Sat
IsL : is_lit L
MemL1 : mem L1 (L::A)
NegL1 : negate_lit L1 NL
MemNL : mem NL (L::A)
============================
 false
</pre>
<pre class="code extensibella"id="758">
 &lt; <b>MemL1: case MemL1.</b>

Subgoal 2.2:

Variables: Known A Sat L Prf ID1 C1 NL
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID1 C1
RUP1 : unit_clause A C1 L
RUP2 : rupProof_help Known (L::A) Prf *
Sat1 : sat_clause Sat C1
M : mem (ID1, C1) Known
Is : is_integer ID1
Is1 : is_clause C1
MemL : mem L Sat
MemImp : forall X, mem X (L::A) -&gt; mem X Sat
IsL : is_lit L
NegL1 : negate_lit L NL
MemNL : mem NL (L::A)
============================
 false
</pre>
<pre class="code extensibella"id="759">
 &lt; <b>MemNL: case MemNL.</b>

Subgoal 2.2.1:

Variables: Known A Sat L Prf ID1 C1
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID1 C1
RUP1 : unit_clause A C1 L
RUP2 : rupProof_help Known (L::A) Prf *
Sat1 : sat_clause Sat C1
M : mem (ID1, C1) Known
Is : is_integer ID1
Is1 : is_clause C1
MemL : mem L Sat
MemImp : forall X, mem X (L::A) -&gt; mem X Sat
IsL : is_lit L
NegL1 : negate_lit L L
============================
 false
</pre>
<pre class="code extensibella"id="760">
 &lt; <b>apply negate_lit_not_same to _ NegL1.</b>

Subgoal 2.2.2:

Variables: Known A Sat L Prf ID1 C1 NL
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID1 C1
RUP1 : unit_clause A C1 L
RUP2 : rupProof_help Known (L::A) Prf *
Sat1 : sat_clause Sat C1
M : mem (ID1, C1) Known
Is : is_integer ID1
Is1 : is_clause C1
MemL : mem L Sat
MemImp : forall X, mem X (L::A) -&gt; mem X Sat
IsL : is_lit L
NegL1 : negate_lit L NL
MemNL : mem NL A
============================
 false
</pre>
<pre class="code extensibella"id="761">
 &lt; <b>apply unit_clause_not_assigned_negate to _ _ RUP1 NegL1 MemNL.</b>

Subgoal 2.3:

Variables: Known A Sat L Prf ID1 C1 L1 NL
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID1 C1
RUP1 : unit_clause A C1 L
RUP2 : rupProof_help Known (L::A) Prf *
Sat1 : sat_clause Sat C1
M : mem (ID1, C1) Known
Is : is_integer ID1
Is1 : is_clause C1
MemL : mem L Sat
MemImp : forall X, mem X (L::A) -&gt; mem X Sat
IsL : is_lit L
NegL1 : negate_lit L1 NL
MemNL : mem NL (L::A)
MemL1 : mem L1 A
============================
 false
</pre>
<pre class="code extensibella"id="762">
 &lt; <b>MemNL: case MemNL.</b>

Subgoal 2.3.1:

Variables: Known A Sat L Prf ID1 C1 L1
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID1 C1
RUP1 : unit_clause A C1 L
RUP2 : rupProof_help Known (L::A) Prf *
Sat1 : sat_clause Sat C1
M : mem (ID1, C1) Known
Is : is_integer ID1
Is1 : is_clause C1
MemL : mem L Sat
MemImp : forall X, mem X (L::A) -&gt; mem X Sat
IsL : is_lit L
NegL1 : negate_lit L1 L
MemL1 : mem L1 A
============================
 false
</pre>
<pre class="code extensibella"id="763">
 &lt; <b>apply mem_is_lit to _ MemL1.</b>

Subgoal 2.3.1:

Variables: Known A Sat L Prf ID1 C1 L1
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID1 C1
RUP1 : unit_clause A C1 L
RUP2 : rupProof_help Known (L::A) Prf *
Sat1 : sat_clause Sat C1
M : mem (ID1, C1) Known
Is : is_integer ID1
Is1 : is_clause C1
MemL : mem L Sat
MemImp : forall X, mem X (L::A) -&gt; mem X Sat
IsL : is_lit L
NegL1 : negate_lit L1 L
MemL1 : mem L1 A
H1 : is_lit L1
============================
 false
</pre>
<pre class="code extensibella"id="764">
 &lt; <b>apply negate_lit_reverse to _ NegL1.</b>

Subgoal 2.3.1:

Variables: Known A Sat L Prf ID1 C1 L1
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID1 C1
RUP1 : unit_clause A C1 L
RUP2 : rupProof_help Known (L::A) Prf *
Sat1 : sat_clause Sat C1
M : mem (ID1, C1) Known
Is : is_integer ID1
Is1 : is_clause C1
MemL : mem L Sat
MemImp : forall X, mem X (L::A) -&gt; mem X Sat
IsL : is_lit L
NegL1 : negate_lit L1 L
MemL1 : mem L1 A
H1 : is_lit L1
H2 : negate_lit L L1
============================
 false
</pre>
<pre class="code extensibella"id="765">
 &lt; <b>apply unit_clause_not_assigned_negate to _ _ RUP1 _ MemL1.</b>

Subgoal 2.3.2:

Variables: Known A Sat L Prf ID1 C1 L1 NL
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_A : good_assignment A
GA_Sat : good_assignment Sat
RUP : lookup Known ID1 C1
RUP1 : unit_clause A C1 L
RUP2 : rupProof_help Known (L::A) Prf *
Sat1 : sat_clause Sat C1
M : mem (ID1, C1) Known
Is : is_integer ID1
Is1 : is_clause C1
MemL : mem L Sat
MemImp : forall X, mem X (L::A) -&gt; mem X Sat
IsL : is_lit L
NegL1 : negate_lit L1 NL
MemL1 : mem L1 A
MemNL : mem NL A
============================
 false
</pre>
<pre class="code extensibella"id="766">
 &lt; <b>GA_A: case GA_A.</b>

Subgoal 2.3.2:

Variables: Known A Sat L Prf ID1 C1 L1 NL
IH : forall Known A Sat Proof,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit A -&gt; is_list is_lit Sat -&gt;
       rupProof_help Known A Proof * -&gt; (forall L, mem L A -&gt; mem L Sat) -&gt; (forall InID InC,
         lookup Known InID InC -&gt; sat_clause Sat InC) -&gt; good_assignment A -&gt; good_assignment Sat -&gt;
       false
IsKnown : is_list (is_pair is_integer is_clause) Known
IsA : is_list is_lit A
IsSat : is_list is_lit Sat
Expand : forall L, mem L A -&gt; mem L Sat
Sat : forall InID InC, lookup Known InID InC -&gt; sat_clause Sat InC
GA_Sat : good_assignment Sat
RUP : lookup Known ID1 C1
RUP1 : unit_clause A C1 L
RUP2 : rupProof_help Known (L::A) Prf *
Sat1 : sat_clause Sat C1
M : mem (ID1, C1) Known
Is : is_integer ID1
Is1 : is_clause C1
MemL : mem L Sat
MemImp : forall X, mem X (L::A) -&gt; mem X Sat
IsL : is_lit L
NegL1 : negate_lit L1 NL
MemL1 : mem L1 A
MemNL : mem NL A
GA_A : forall L NL, mem L A -&gt; negate_lit L NL -&gt; mem NL A -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="767">
 &lt; <b>apply GA_A to MemL1 NegL1 _.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="768">
 &lt; <b>Theorem rupProof_help_orderless :
     forall K1 K2 A Prf,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; rupProof_help K1 A Prf -&gt; (forall ID C,
         mem (ID, C) K1 -&gt; mem (ID, C) K2) -&gt; rupProof_help K2 A Prf.</b>

============================
 forall K1 K2 A Prf,
   is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
   good_clause_list K2 -&gt; rupProof_help K1 A Prf -&gt; (forall ID C,
     mem (ID, C) K1 -&gt; mem (ID, C) K2) -&gt; rupProof_help K2 A Prf
</pre>
<pre class="code extensibella"id="769">
 &lt; <b>induction on 4.</b>

IH : forall K1 K2 A Prf,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; rupProof_help K1 A Prf * -&gt; (forall ID C,
         mem (ID, C) K1 -&gt; mem (ID, C) K2) -&gt; rupProof_help K2 A Prf
============================
 forall K1 K2 A Prf,
   is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
   good_clause_list K2 -&gt; rupProof_help K1 A Prf @ -&gt; (forall ID C,
     mem (ID, C) K1 -&gt; mem (ID, C) K2) -&gt; rupProof_help K2 A Prf
</pre>
<pre class="code extensibella"id="770">
 &lt; <b>intros IsK1 IsK2 GCL2 RUPPH MemK1K2.</b>

Variables: K1 K2 A Prf
IH : forall K1 K2 A Prf,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; rupProof_help K1 A Prf * -&gt; (forall ID C,
         mem (ID, C) K1 -&gt; mem (ID, C) K2) -&gt; rupProof_help K2 A Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL2 : good_clause_list K2
RUPPH : rupProof_help K1 A Prf @
MemK1K2 : forall ID C, mem (ID, C) K1 -&gt; mem (ID, C) K2
============================
 rupProof_help K2 A Prf
</pre>
<pre class="code extensibella"id="771">
 &lt; <b>RUPPH: case RUPPH.</b>

Subgoal 1:

Variables: K1 K2 A C ID
IH : forall K1 K2 A Prf,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; rupProof_help K1 A Prf * -&gt; (forall ID C,
         mem (ID, C) K1 -&gt; mem (ID, C) K2) -&gt; rupProof_help K2 A Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL2 : good_clause_list K2
MemK1K2 : forall ID C, mem (ID, C) K1 -&gt; mem (ID, C) K2
RUPPH : lookup K1 ID C
RUPPH1 : unsat_clause A C
============================
 rupProof_help K2 A [ID]
</pre>
<pre class="code extensibella"id="772">
 &lt; <b>M1: apply lookup_mem to RUPPH.</b>

Subgoal 1:

Variables: K1 K2 A C ID
IH : forall K1 K2 A Prf,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; rupProof_help K1 A Prf * -&gt; (forall ID C,
         mem (ID, C) K1 -&gt; mem (ID, C) K2) -&gt; rupProof_help K2 A Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL2 : good_clause_list K2
MemK1K2 : forall ID C, mem (ID, C) K1 -&gt; mem (ID, C) K2
RUPPH : lookup K1 ID C
RUPPH1 : unsat_clause A C
M1 : mem (ID, C) K1
============================
 rupProof_help K2 A [ID]
</pre>
<pre class="code extensibella"id="773">
 &lt; <b>M2: apply MemK1K2 to M1.</b>

Subgoal 1:

Variables: K1 K2 A C ID
IH : forall K1 K2 A Prf,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; rupProof_help K1 A Prf * -&gt; (forall ID C,
         mem (ID, C) K1 -&gt; mem (ID, C) K2) -&gt; rupProof_help K2 A Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL2 : good_clause_list K2
MemK1K2 : forall ID C, mem (ID, C) K1 -&gt; mem (ID, C) K2
RUPPH : lookup K1 ID C
RUPPH1 : unsat_clause A C
M1 : mem (ID, C) K1
M2 : mem (ID, C) K2
============================
 rupProof_help K2 A [ID]
</pre>
<pre class="code extensibella"id="774">
 &lt; <b>Is: apply mem_is to IsK1 M1.</b>

Subgoal 1:

Variables: K1 K2 A ID1 C1
IH : forall K1 K2 A Prf,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; rupProof_help K1 A Prf * -&gt; (forall ID C,
         mem (ID, C) K1 -&gt; mem (ID, C) K2) -&gt; rupProof_help K2 A Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL2 : good_clause_list K2
MemK1K2 : forall ID C, mem (ID, C) K1 -&gt; mem (ID, C) K2
RUPPH : lookup K1 ID1 C1
RUPPH1 : unsat_clause A C1
M1 : mem (ID1, C1) K1
M2 : mem (ID1, C1) K2
Is : is_integer ID1
Is1 : is_clause C1
============================
 rupProof_help K2 A [ID1]
</pre>
<pre class="code extensibella"id="775">
 &lt; <b>L: apply is_list_mem_lookup to _ M2 _.</b>

Subgoal 1:

Variables: K1 K2 A ID1 C1 C'
IH : forall K1 K2 A Prf,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; rupProof_help K1 A Prf * -&gt; (forall ID C,
         mem (ID, C) K1 -&gt; mem (ID, C) K2) -&gt; rupProof_help K2 A Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL2 : good_clause_list K2
MemK1K2 : forall ID C, mem (ID, C) K1 -&gt; mem (ID, C) K2
RUPPH : lookup K1 ID1 C1
RUPPH1 : unsat_clause A C1
M1 : mem (ID1, C1) K1
M2 : mem (ID1, C1) K2
Is : is_integer ID1
Is1 : is_clause C1
L : lookup K2 ID1 C'
============================
 rupProof_help K2 A [ID1]
</pre>
<pre class="code extensibella"id="776">
 &lt; <b>ML: apply lookup_mem to L.</b>

Subgoal 1:

Variables: K1 K2 A ID1 C1 C'
IH : forall K1 K2 A Prf,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; rupProof_help K1 A Prf * -&gt; (forall ID C,
         mem (ID, C) K1 -&gt; mem (ID, C) K2) -&gt; rupProof_help K2 A Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL2 : good_clause_list K2
MemK1K2 : forall ID C, mem (ID, C) K1 -&gt; mem (ID, C) K2
RUPPH : lookup K1 ID1 C1
RUPPH1 : unsat_clause A C1
M1 : mem (ID1, C1) K1
M2 : mem (ID1, C1) K2
Is : is_integer ID1
Is1 : is_clause C1
L : lookup K2 ID1 C'
ML : mem (ID1, C') K2
============================
 rupProof_help K2 A [ID1]
</pre>
<pre class="code extensibella"id="777">
 &lt; <b>apply good_clause_list_mems to GCL2 M2 ML.</b>

Subgoal 1:

Variables: K1 K2 A ID1 C'
IH : forall K1 K2 A Prf,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; rupProof_help K1 A Prf * -&gt; (forall ID C,
         mem (ID, C) K1 -&gt; mem (ID, C) K2) -&gt; rupProof_help K2 A Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL2 : good_clause_list K2
MemK1K2 : forall ID C, mem (ID, C) K1 -&gt; mem (ID, C) K2
RUPPH : lookup K1 ID1 C'
RUPPH1 : unsat_clause A C'
M1 : mem (ID1, C') K1
M2 : mem (ID1, C') K2
Is : is_integer ID1
Is1 : is_clause C'
L : lookup K2 ID1 C'
ML : mem (ID1, C') K2
============================
 rupProof_help K2 A [ID1]
</pre>
<pre class="code extensibella"id="778">
 &lt; <b>search.</b>

Subgoal 2:

Variables: K1 K2 A C L Prf1 ID
IH : forall K1 K2 A Prf,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; rupProof_help K1 A Prf * -&gt; (forall ID C,
         mem (ID, C) K1 -&gt; mem (ID, C) K2) -&gt; rupProof_help K2 A Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL2 : good_clause_list K2
MemK1K2 : forall ID C, mem (ID, C) K1 -&gt; mem (ID, C) K2
RUPPH : lookup K1 ID C
RUPPH1 : unit_clause A C L
RUPPH2 : rupProof_help K1 (L::A) Prf1 *
============================
 rupProof_help K2 A (ID::Prf1)
</pre>
<pre class="code extensibella"id="779">
 &lt; <b>M1: apply lookup_mem to RUPPH.</b>

Subgoal 2:

Variables: K1 K2 A C L Prf1 ID
IH : forall K1 K2 A Prf,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; rupProof_help K1 A Prf * -&gt; (forall ID C,
         mem (ID, C) K1 -&gt; mem (ID, C) K2) -&gt; rupProof_help K2 A Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL2 : good_clause_list K2
MemK1K2 : forall ID C, mem (ID, C) K1 -&gt; mem (ID, C) K2
RUPPH : lookup K1 ID C
RUPPH1 : unit_clause A C L
RUPPH2 : rupProof_help K1 (L::A) Prf1 *
M1 : mem (ID, C) K1
============================
 rupProof_help K2 A (ID::Prf1)
</pre>
<pre class="code extensibella"id="780">
 &lt; <b>M2: apply MemK1K2 to M1.</b>

Subgoal 2:

Variables: K1 K2 A C L Prf1 ID
IH : forall K1 K2 A Prf,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; rupProof_help K1 A Prf * -&gt; (forall ID C,
         mem (ID, C) K1 -&gt; mem (ID, C) K2) -&gt; rupProof_help K2 A Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL2 : good_clause_list K2
MemK1K2 : forall ID C, mem (ID, C) K1 -&gt; mem (ID, C) K2
RUPPH : lookup K1 ID C
RUPPH1 : unit_clause A C L
RUPPH2 : rupProof_help K1 (L::A) Prf1 *
M1 : mem (ID, C) K1
M2 : mem (ID, C) K2
============================
 rupProof_help K2 A (ID::Prf1)
</pre>
<pre class="code extensibella"id="781">
 &lt; <b>Is: apply mem_is to IsK1 M1.</b>

Subgoal 2:

Variables: K1 K2 A L Prf1 ID1 C1
IH : forall K1 K2 A Prf,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; rupProof_help K1 A Prf * -&gt; (forall ID C,
         mem (ID, C) K1 -&gt; mem (ID, C) K2) -&gt; rupProof_help K2 A Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL2 : good_clause_list K2
MemK1K2 : forall ID C, mem (ID, C) K1 -&gt; mem (ID, C) K2
RUPPH : lookup K1 ID1 C1
RUPPH1 : unit_clause A C1 L
RUPPH2 : rupProof_help K1 (L::A) Prf1 *
M1 : mem (ID1, C1) K1
M2 : mem (ID1, C1) K2
Is : is_integer ID1
Is1 : is_clause C1
============================
 rupProof_help K2 A (ID1::Prf1)
</pre>
<pre class="code extensibella"id="782">
 &lt; <b>L: apply is_list_mem_lookup to _ M2 _.</b>

Subgoal 2:

Variables: K1 K2 A L Prf1 ID1 C1 C'
IH : forall K1 K2 A Prf,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; rupProof_help K1 A Prf * -&gt; (forall ID C,
         mem (ID, C) K1 -&gt; mem (ID, C) K2) -&gt; rupProof_help K2 A Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL2 : good_clause_list K2
MemK1K2 : forall ID C, mem (ID, C) K1 -&gt; mem (ID, C) K2
RUPPH : lookup K1 ID1 C1
RUPPH1 : unit_clause A C1 L
RUPPH2 : rupProof_help K1 (L::A) Prf1 *
M1 : mem (ID1, C1) K1
M2 : mem (ID1, C1) K2
Is : is_integer ID1
Is1 : is_clause C1
L : lookup K2 ID1 C'
============================
 rupProof_help K2 A (ID1::Prf1)
</pre>
<pre class="code extensibella"id="783">
 &lt; <b>ML: apply lookup_mem to L.</b>

Subgoal 2:

Variables: K1 K2 A L Prf1 ID1 C1 C'
IH : forall K1 K2 A Prf,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; rupProof_help K1 A Prf * -&gt; (forall ID C,
         mem (ID, C) K1 -&gt; mem (ID, C) K2) -&gt; rupProof_help K2 A Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL2 : good_clause_list K2
MemK1K2 : forall ID C, mem (ID, C) K1 -&gt; mem (ID, C) K2
RUPPH : lookup K1 ID1 C1
RUPPH1 : unit_clause A C1 L
RUPPH2 : rupProof_help K1 (L::A) Prf1 *
M1 : mem (ID1, C1) K1
M2 : mem (ID1, C1) K2
Is : is_integer ID1
Is1 : is_clause C1
L : lookup K2 ID1 C'
ML : mem (ID1, C') K2
============================
 rupProof_help K2 A (ID1::Prf1)
</pre>
<pre class="code extensibella"id="784">
 &lt; <b>apply good_clause_list_mems to _ M2 ML.</b>

Subgoal 2:

Variables: K1 K2 A L Prf1 ID1 C'
IH : forall K1 K2 A Prf,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; rupProof_help K1 A Prf * -&gt; (forall ID C,
         mem (ID, C) K1 -&gt; mem (ID, C) K2) -&gt; rupProof_help K2 A Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL2 : good_clause_list K2
MemK1K2 : forall ID C, mem (ID, C) K1 -&gt; mem (ID, C) K2
RUPPH : lookup K1 ID1 C'
RUPPH1 : unit_clause A C' L
RUPPH2 : rupProof_help K1 (L::A) Prf1 *
M1 : mem (ID1, C') K1
M2 : mem (ID1, C') K2
Is : is_integer ID1
Is1 : is_clause C'
L : lookup K2 ID1 C'
ML : mem (ID1, C') K2
============================
 rupProof_help K2 A (ID1::Prf1)
</pre>
<pre class="code extensibella"id="785">
 &lt; <b>apply IH to _ _ _ RUPPH2 _.</b>

Subgoal 2:

Variables: K1 K2 A L Prf1 ID1 C'
IH : forall K1 K2 A Prf,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; rupProof_help K1 A Prf * -&gt; (forall ID C,
         mem (ID, C) K1 -&gt; mem (ID, C) K2) -&gt; rupProof_help K2 A Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL2 : good_clause_list K2
MemK1K2 : forall ID C, mem (ID, C) K1 -&gt; mem (ID, C) K2
RUPPH : lookup K1 ID1 C'
RUPPH1 : unit_clause A C' L
RUPPH2 : rupProof_help K1 (L::A) Prf1 *
M1 : mem (ID1, C') K1
M2 : mem (ID1, C') K2
Is : is_integer ID1
Is1 : is_clause C'
L : lookup K2 ID1 C'
ML : mem (ID1, C') K2
H1 : rupProof_help K2 (L::A) Prf1
============================
 rupProof_help K2 A (ID1::Prf1)
</pre>
<pre class="code extensibella"id="786">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="787">
 &lt; <b>Extensible_Theorem
      gatherLits_is : forall C L,
         IsC : is_clause C -&gt;
         GL : gatherLits C L -&gt;
         is_list is_lit L
      on GL.</b>

Subgoal 1:

IH : forall C L, is_clause C -&gt; gatherLits C L * -&gt; is_list is_lit L
IsC : is_clause emptyClause
GL : gatherLits emptyClause [] @
============================
 is_list is_lit []
</pre>
<pre class="code extensibella"id="788">
 &lt; <b>search.</b>

Subgoal 2:

Variables: LRest L1 Rest
IH : forall C L, is_clause C -&gt; gatherLits C L * -&gt; is_list is_lit L
IsC : is_clause (or L1 Rest)
GL : gatherLits (or L1 Rest) (L1::LRest) @
GL1 : gatherLits Rest LRest *
============================
 is_list is_lit (L1::LRest)
</pre>
<pre class="code extensibella"id="789">
 &lt; <b>Is: case IsC.</b>

Subgoal 2:

Variables: LRest L1 Rest
IH : forall C L, is_clause C -&gt; gatherLits C L * -&gt; is_list is_lit L
GL : gatherLits (or L1 Rest) (L1::LRest) @
GL1 : gatherLits Rest LRest *
Is : is_lit L1
Is1 : is_clause Rest
============================
 is_list is_lit (L1::LRest)
</pre>
<pre class="code extensibella"id="790">
 &lt; <b>apply IH to _ GL1.</b>

Subgoal 2:

Variables: LRest L1 Rest
IH : forall C L, is_clause C -&gt; gatherLits C L * -&gt; is_list is_lit L
GL : gatherLits (or L1 Rest) (L1::LRest) @
GL1 : gatherLits Rest LRest *
Is : is_lit L1
Is1 : is_clause Rest
H1 : is_list is_lit LRest
============================
 is_list is_lit (L1::LRest)
</pre>
<pre class="code extensibella"id="791">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="792">
 &lt; <b>Extensible_Theorem
      gatherLits_exists : forall C,
         IsC : is_clause C -&gt;
         exists L,
           gatherLits C L
      on IsC.</b>

Subgoal 1:

IH : forall C, is_clause C * -&gt; exists L, gatherLits C L
IsC : is_clause emptyClause @
============================
 exists L, gatherLits emptyClause L
</pre>
<pre class="code extensibella"id="793">
 &lt; <b>search.</b>

Subgoal 2:

Variables: Clause Lit
IH : forall C, is_clause C * -&gt; exists L, gatherLits C L
IsC : is_clause (or Lit Clause) @
IsC1 : is_lit Lit
IsC2 : is_clause Clause *
============================
 exists L, gatherLits (or Lit Clause) L
</pre>
<pre class="code extensibella"id="794">
 &lt; <b>apply IH to IsC2.</b>

Subgoal 2:

Variables: Clause Lit L
IH : forall C, is_clause C * -&gt; exists L, gatherLits C L
IsC : is_clause (or Lit Clause) @
IsC1 : is_lit Lit
IsC2 : is_clause Clause *
H1 : gatherLits Clause L
============================
 exists L, gatherLits (or Lit Clause) L
</pre>
<pre class="code extensibella"id="795">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="796">
 &lt; <b>Extensible_Theorem
      gatherLits_permutation : forall C L1 L2,
         IsC : is_clause C -&gt;
         GL1 : gatherLits C L1 -&gt;
         GL2 : gatherLits C L2 -&gt;
         permutation L1 L2
      on GL1.</b>

Subgoal 1:

Variables: L2
IH : forall C L1 L2,
       is_clause C -&gt; gatherLits C L1 * -&gt; gatherLits C L2 -&gt; permutation L1 L2
IsC : is_clause emptyClause
GL1 : gatherLits emptyClause [] @
GL2 : gatherLits emptyClause L2
============================
 permutation [] L2
</pre>
<pre class="code extensibella"id="797">
 &lt; <b>case GL2.</b>

Subgoal 1:

IH : forall C L1 L2,
       is_clause C -&gt; gatherLits C L1 * -&gt; gatherLits C L2 -&gt; permutation L1 L2
IsC : is_clause emptyClause
GL1 : gatherLits emptyClause [] @
============================
 permutation [] []
</pre>
<pre class="code extensibella"id="798">
 &lt; <b>search.</b>

Subgoal 2:

Variables: L2 LRest L Rest
IH : forall C L1 L2,
       is_clause C -&gt; gatherLits C L1 * -&gt; gatherLits C L2 -&gt; permutation L1 L2
IsC : is_clause (or L Rest)
GL1 : gatherLits (or L Rest) (L::LRest) @
GL2 : gatherLits (or L Rest) L2
GL3 : gatherLits Rest LRest *
============================
 permutation (L::LRest) L2
</pre>
<pre class="code extensibella"id="799">
 &lt; <b>GL2: case GL2.</b>

Subgoal 2:

Variables: LRest L Rest LRest1
IH : forall C L1 L2,
       is_clause C -&gt; gatherLits C L1 * -&gt; gatherLits C L2 -&gt; permutation L1 L2
IsC : is_clause (or L Rest)
GL1 : gatherLits (or L Rest) (L::LRest) @
GL3 : gatherLits Rest LRest *
GL2 : gatherLits Rest LRest1
============================
 permutation (L::LRest) (L::LRest1)
</pre>
<pre class="code extensibella"id="800">
 &lt; <b>Is: case IsC.</b>

Subgoal 2:

Variables: LRest L Rest LRest1
IH : forall C L1 L2,
       is_clause C -&gt; gatherLits C L1 * -&gt; gatherLits C L2 -&gt; permutation L1 L2
GL1 : gatherLits (or L Rest) (L::LRest) @
GL3 : gatherLits Rest LRest *
GL2 : gatherLits Rest LRest1
Is : is_lit L
Is1 : is_clause Rest
============================
 permutation (L::LRest) (L::LRest1)
</pre>
<pre class="code extensibella"id="801">
 &lt; <b>apply IH to _ GL3 GL2.</b>

Subgoal 2:

Variables: LRest L Rest LRest1
IH : forall C L1 L2,
       is_clause C -&gt; gatherLits C L1 * -&gt; gatherLits C L2 -&gt; permutation L1 L2
GL1 : gatherLits (or L Rest) (L::LRest) @
GL3 : gatherLits Rest LRest *
GL2 : gatherLits Rest LRest1
Is : is_lit L
Is1 : is_clause Rest
H1 : permutation LRest LRest1
============================
 permutation (L::LRest) (L::LRest1)
</pre>
<pre class="code extensibella"id="802">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="803">
 &lt; <b>Translation_Constraint trans_gatherLits :
   forall C C' L,
   |{clause}- C ~~&gt; C' -&gt; is_clause C -&gt; gatherLits C L -&gt; exists L',
     gatherLits C' L'.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="804">
 &lt; <b>Translation_Constraint trans_gatherLits_permutation :
   forall C C' L L',
   |{clause}- C ~~&gt; C' -&gt; is_clause C -&gt; gatherLits C L -&gt; gatherLits C' L' -&gt; permutation L L'.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="805">
 &lt; <b>Extensible_Theorem
      gatherLits_sat : forall C Lits Sat,
         IsC : is_clause C -&gt;
         IsSat : is_list is_lit Sat -&gt;
         GL : gatherLits C Lits -&gt;
         Sat : sat_clause Sat C -&gt;
         exists L,
           mem L Lits /\ mem L Sat
      on Sat.</b>

Subgoal 1:

Variables: Lits Sat Rest L
IH : forall C Lits Sat,
       is_clause C -&gt; is_list is_lit Sat -&gt; gatherLits C Lits -&gt; sat_clause Sat C * -&gt;
       exists L, mem L Lits /\ mem L Sat
IsC : is_clause (or L Rest)
IsSat : is_list is_lit Sat
GL : gatherLits (or L Rest) Lits
Sat : sat_clause Sat (or L Rest) @
Sat1 : mem L Sat
============================
 exists L, mem L Lits /\ mem L Sat
</pre>
<pre class="code extensibella"id="806">
 &lt; <b>case GL.</b>

Subgoal 1:

Variables: Sat Rest L LRest
IH : forall C Lits Sat,
       is_clause C -&gt; is_list is_lit Sat -&gt; gatherLits C Lits -&gt; sat_clause Sat C * -&gt;
       exists L, mem L Lits /\ mem L Sat
IsC : is_clause (or L Rest)
IsSat : is_list is_lit Sat
Sat : sat_clause Sat (or L Rest) @
Sat1 : mem L Sat
H1 : gatherLits Rest LRest
============================
 exists L1, mem L1 (L::LRest) /\ mem L1 Sat
</pre>
<pre class="code extensibella"id="807">
 &lt; <b>search.</b>

Subgoal 2:

Variables: Lits Sat Rest L
IH : forall C Lits Sat,
       is_clause C -&gt; is_list is_lit Sat -&gt; gatherLits C Lits -&gt; sat_clause Sat C * -&gt;
       exists L, mem L Lits /\ mem L Sat
IsC : is_clause (or L Rest)
IsSat : is_list is_lit Sat
GL : gatherLits (or L Rest) Lits
Sat : sat_clause Sat (or L Rest) @
Sat1 : sat_clause Sat Rest *
============================
 exists L, mem L Lits /\ mem L Sat
</pre>
<pre class="code extensibella"id="808">
 &lt; <b>Is: case IsC.</b>

Subgoal 2:

Variables: Lits Sat Rest L
IH : forall C Lits Sat,
       is_clause C -&gt; is_list is_lit Sat -&gt; gatherLits C Lits -&gt; sat_clause Sat C * -&gt;
       exists L, mem L Lits /\ mem L Sat
IsSat : is_list is_lit Sat
GL : gatherLits (or L Rest) Lits
Sat : sat_clause Sat (or L Rest) @
Sat1 : sat_clause Sat Rest *
Is : is_lit L
Is1 : is_clause Rest
============================
 exists L, mem L Lits /\ mem L Sat
</pre>
<pre class="code extensibella"id="809">
 &lt; <b>GL: case GL.</b>

Subgoal 2:

Variables: Sat Rest L LRest
IH : forall C Lits Sat,
       is_clause C -&gt; is_list is_lit Sat -&gt; gatherLits C Lits -&gt; sat_clause Sat C * -&gt;
       exists L, mem L Lits /\ mem L Sat
IsSat : is_list is_lit Sat
Sat : sat_clause Sat (or L Rest) @
Sat1 : sat_clause Sat Rest *
Is : is_lit L
Is1 : is_clause Rest
GL : gatherLits Rest LRest
============================
 exists L1, mem L1 (L::LRest) /\ mem L1 Sat
</pre>
<pre class="code extensibella"id="810">
 &lt; <b>apply IH to _ _ GL Sat1.</b>

Subgoal 2:

Variables: Sat Rest L LRest L1
IH : forall C Lits Sat,
       is_clause C -&gt; is_list is_lit Sat -&gt; gatherLits C Lits -&gt; sat_clause Sat C * -&gt;
       exists L, mem L Lits /\ mem L Sat
IsSat : is_list is_lit Sat
Sat : sat_clause Sat (or L Rest) @
Sat1 : sat_clause Sat Rest *
Is : is_lit L
Is1 : is_clause Rest
GL : gatherLits Rest LRest
H1 : mem L1 LRest
H2 : mem L1 Sat
============================
 exists L1, mem L1 (L::LRest) /\ mem L1 Sat
</pre>
<pre class="code extensibella"id="811">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="812">
 &lt; <b>Extensible_Theorem
      gatherLits_mem_sat : forall C Lits Sat L,
         IsC : is_clause C -&gt;
         IsSat : is_list is_lit Sat -&gt;
         GL : gatherLits C Lits -&gt;
         MemLits : mem L Lits -&gt;
         MemSat : mem L Sat -&gt;
         sat_clause Sat C
      on GL.</b>

Subgoal 1:

Variables: Sat L
IH : forall C Lits Sat L,
       is_clause C -&gt; is_list is_lit Sat -&gt; gatherLits C Lits * -&gt; mem L Lits -&gt;
       mem L Sat -&gt; sat_clause Sat C
IsC : is_clause emptyClause
IsSat : is_list is_lit Sat
GL : gatherLits emptyClause [] @
MemLits : mem L []
MemSat : mem L Sat
============================
 sat_clause Sat emptyClause
</pre>
<pre class="code extensibella"id="813">
 &lt; <b>case MemLits.</b>

Subgoal 2:

Variables: Sat L LRest L1 Rest
IH : forall C Lits Sat L,
       is_clause C -&gt; is_list is_lit Sat -&gt; gatherLits C Lits * -&gt; mem L Lits -&gt;
       mem L Sat -&gt; sat_clause Sat C
IsC : is_clause (or L1 Rest)
IsSat : is_list is_lit Sat
GL : gatherLits (or L1 Rest) (L1::LRest) @
MemLits : mem L (L1::LRest)
MemSat : mem L Sat
GL1 : gatherLits Rest LRest *
============================
 sat_clause Sat (or L1 Rest)
</pre>
<pre class="code extensibella"id="814">
 &lt; <b>MemLits: case MemLits.</b>

Subgoal 2.1:

Variables: Sat LRest L1 Rest
IH : forall C Lits Sat L,
       is_clause C -&gt; is_list is_lit Sat -&gt; gatherLits C Lits * -&gt; mem L Lits -&gt;
       mem L Sat -&gt; sat_clause Sat C
IsC : is_clause (or L1 Rest)
IsSat : is_list is_lit Sat
GL : gatherLits (or L1 Rest) (L1::LRest) @
MemSat : mem L1 Sat
GL1 : gatherLits Rest LRest *
============================
 sat_clause Sat (or L1 Rest)
</pre>
<pre class="code extensibella"id="815">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: Sat L LRest L1 Rest
IH : forall C Lits Sat L,
       is_clause C -&gt; is_list is_lit Sat -&gt; gatherLits C Lits * -&gt; mem L Lits -&gt;
       mem L Sat -&gt; sat_clause Sat C
IsC : is_clause (or L1 Rest)
IsSat : is_list is_lit Sat
GL : gatherLits (or L1 Rest) (L1::LRest) @
MemSat : mem L Sat
GL1 : gatherLits Rest LRest *
MemLits : mem L LRest
============================
 sat_clause Sat (or L1 Rest)
</pre>
<pre class="code extensibella"id="816">
 &lt; <b>Is: case IsC.</b>

Subgoal 2.2:

Variables: Sat L LRest L1 Rest
IH : forall C Lits Sat L,
       is_clause C -&gt; is_list is_lit Sat -&gt; gatherLits C Lits * -&gt; mem L Lits -&gt;
       mem L Sat -&gt; sat_clause Sat C
IsSat : is_list is_lit Sat
GL : gatherLits (or L1 Rest) (L1::LRest) @
MemSat : mem L Sat
GL1 : gatherLits Rest LRest *
MemLits : mem L LRest
Is : is_lit L1
Is1 : is_clause Rest
============================
 sat_clause Sat (or L1 Rest)
</pre>
<pre class="code extensibella"id="817">
 &lt; <b>apply IH to _ _ GL1 MemLits MemSat.</b>

Subgoal 2.2:

Variables: Sat L LRest L1 Rest
IH : forall C Lits Sat L,
       is_clause C -&gt; is_list is_lit Sat -&gt; gatherLits C Lits * -&gt; mem L Lits -&gt;
       mem L Sat -&gt; sat_clause Sat C
IsSat : is_list is_lit Sat
GL : gatherLits (or L1 Rest) (L1::LRest) @
MemSat : mem L Sat
GL1 : gatherLits Rest LRest *
MemLits : mem L LRest
Is : is_lit L1
Is1 : is_clause Rest
H1 : sat_clause Sat Rest
============================
 sat_clause Sat (or L1 Rest)
</pre>
<pre class="code extensibella"id="818">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="819">
 &lt; <b>Extensible_Theorem
      gatherLits_unsat : forall C Lits Unsat L,
         GA : good_assignment Unsat -&gt;
         IsC : is_clause C -&gt;
         IsUnsat : is_list is_lit Unsat -&gt;
         GL : gatherLits C Lits -&gt;
         Unsat : unsat_clause Unsat C -&gt;
         MemLits : mem L Lits -&gt;
         MemUnsat : mem L Unsat -&gt;
         false
      on Unsat.</b>

Subgoal 1:

Variables: Lits Unsat L
IH : forall C Lits Unsat L,
       good_assignment Unsat -&gt; is_clause C -&gt; is_list is_lit Unsat -&gt; gatherLits C Lits -&gt;
       unsat_clause Unsat C * -&gt; mem L Lits -&gt; mem L Unsat -&gt; false
GA : good_assignment Unsat
IsC : is_clause emptyClause
IsUnsat : is_list is_lit Unsat
GL : gatherLits emptyClause Lits
Unsat : unsat_clause Unsat emptyClause @
MemLits : mem L Lits
MemUnsat : mem L Unsat
============================
 false
</pre>
<pre class="code extensibella"id="820">
 &lt; <b>case GL.</b>

Subgoal 1:

Variables: Unsat L
IH : forall C Lits Unsat L,
       good_assignment Unsat -&gt; is_clause C -&gt; is_list is_lit Unsat -&gt; gatherLits C Lits -&gt;
       unsat_clause Unsat C * -&gt; mem L Lits -&gt; mem L Unsat -&gt; false
GA : good_assignment Unsat
IsC : is_clause emptyClause
IsUnsat : is_list is_lit Unsat
Unsat : unsat_clause Unsat emptyClause @
MemLits : mem L []
MemUnsat : mem L Unsat
============================
 false
</pre>
<pre class="code extensibella"id="821">
 &lt; <b>case MemLits.</b>

Subgoal 2:

Variables: Lits Unsat L NL Rest L1
IH : forall C Lits Unsat L,
       good_assignment Unsat -&gt; is_clause C -&gt; is_list is_lit Unsat -&gt; gatherLits C Lits -&gt;
       unsat_clause Unsat C * -&gt; mem L Lits -&gt; mem L Unsat -&gt; false
GA : good_assignment Unsat
IsC : is_clause (or L1 Rest)
IsUnsat : is_list is_lit Unsat
GL : gatherLits (or L1 Rest) Lits
Unsat : unsat_clause Unsat (or L1 Rest) @
MemLits : mem L Lits
MemUnsat : mem L Unsat
Unsat1 : negate_lit L1 NL
Unsat2 : mem NL Unsat
Unsat3 : unsat_clause Unsat Rest *
============================
 false
</pre>
<pre class="code extensibella"id="822">
 &lt; <b>GL: case GL.</b>

Subgoal 2:

Variables: Unsat L NL Rest L1 LRest
IH : forall C Lits Unsat L,
       good_assignment Unsat -&gt; is_clause C -&gt; is_list is_lit Unsat -&gt; gatherLits C Lits -&gt;
       unsat_clause Unsat C * -&gt; mem L Lits -&gt; mem L Unsat -&gt; false
GA : good_assignment Unsat
IsC : is_clause (or L1 Rest)
IsUnsat : is_list is_lit Unsat
Unsat : unsat_clause Unsat (or L1 Rest) @
MemLits : mem L (L1::LRest)
MemUnsat : mem L Unsat
Unsat1 : negate_lit L1 NL
Unsat2 : mem NL Unsat
Unsat3 : unsat_clause Unsat Rest *
GL : gatherLits Rest LRest
============================
 false
</pre>
<pre class="code extensibella"id="823">
 &lt; <b>MemLits: case MemLits.</b>

Subgoal 2.1:

Variables: Unsat NL Rest L1 LRest
IH : forall C Lits Unsat L,
       good_assignment Unsat -&gt; is_clause C -&gt; is_list is_lit Unsat -&gt; gatherLits C Lits -&gt;
       unsat_clause Unsat C * -&gt; mem L Lits -&gt; mem L Unsat -&gt; false
GA : good_assignment Unsat
IsC : is_clause (or L1 Rest)
IsUnsat : is_list is_lit Unsat
Unsat : unsat_clause Unsat (or L1 Rest) @
MemUnsat : mem L1 Unsat
Unsat1 : negate_lit L1 NL
Unsat2 : mem NL Unsat
Unsat3 : unsat_clause Unsat Rest *
GL : gatherLits Rest LRest
============================
 false
</pre>
<pre class="code extensibella"id="824">
 &lt; <b>GA: case GA.</b>

Subgoal 2.1:

Variables: Unsat NL Rest L1 LRest
IH : forall C Lits Unsat L,
       good_assignment Unsat -&gt; is_clause C -&gt; is_list is_lit Unsat -&gt; gatherLits C Lits -&gt;
       unsat_clause Unsat C * -&gt; mem L Lits -&gt; mem L Unsat -&gt; false
IsC : is_clause (or L1 Rest)
IsUnsat : is_list is_lit Unsat
Unsat : unsat_clause Unsat (or L1 Rest) @
MemUnsat : mem L1 Unsat
Unsat1 : negate_lit L1 NL
Unsat2 : mem NL Unsat
Unsat3 : unsat_clause Unsat Rest *
GL : gatherLits Rest LRest
GA : forall L NL, mem L Unsat -&gt; negate_lit L NL -&gt; mem NL Unsat -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="825">
 &lt; <b>apply GA to MemUnsat Unsat1 Unsat2.</b>

Subgoal 2.2:

Variables: Unsat L NL Rest L1 LRest
IH : forall C Lits Unsat L,
       good_assignment Unsat -&gt; is_clause C -&gt; is_list is_lit Unsat -&gt; gatherLits C Lits -&gt;
       unsat_clause Unsat C * -&gt; mem L Lits -&gt; mem L Unsat -&gt; false
GA : good_assignment Unsat
IsC : is_clause (or L1 Rest)
IsUnsat : is_list is_lit Unsat
Unsat : unsat_clause Unsat (or L1 Rest) @
MemUnsat : mem L Unsat
Unsat1 : negate_lit L1 NL
Unsat2 : mem NL Unsat
Unsat3 : unsat_clause Unsat Rest *
GL : gatherLits Rest LRest
MemLits : mem L LRest
============================
 false
</pre>
<pre class="code extensibella"id="826">
 &lt; <b>Is: case IsC.</b>

Subgoal 2.2:

Variables: Unsat L NL Rest L1 LRest
IH : forall C Lits Unsat L,
       good_assignment Unsat -&gt; is_clause C -&gt; is_list is_lit Unsat -&gt; gatherLits C Lits -&gt;
       unsat_clause Unsat C * -&gt; mem L Lits -&gt; mem L Unsat -&gt; false
GA : good_assignment Unsat
IsUnsat : is_list is_lit Unsat
Unsat : unsat_clause Unsat (or L1 Rest) @
MemUnsat : mem L Unsat
Unsat1 : negate_lit L1 NL
Unsat2 : mem NL Unsat
Unsat3 : unsat_clause Unsat Rest *
GL : gatherLits Rest LRest
MemLits : mem L LRest
Is : is_lit L1
Is1 : is_clause Rest
============================
 false
</pre>
<pre class="code extensibella"id="827">
 &lt; <b>apply IH to GA _ _ GL Unsat3 MemLits MemUnsat.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="828">
 &lt; <b>Theorem negateLitList_is :
     forall L NL, is_list is_lit L -&gt; negateLitList L NL -&gt; is_list is_lit NL.</b>

============================
 forall L NL, is_list is_lit L -&gt; negateLitList L NL -&gt; is_list is_lit NL
</pre>
<pre class="code extensibella"id="829">
 &lt; <b>induction on 2.</b>

IH : forall L NL, is_list is_lit L -&gt; negateLitList L NL * -&gt; is_list is_lit NL
============================
 forall L NL, is_list is_lit L -&gt; negateLitList L NL @ -&gt; is_list is_lit NL
</pre>
<pre class="code extensibella"id="830">
 &lt; <b>intros IsL NLL.</b>

Variables: L NL
IH : forall L NL, is_list is_lit L -&gt; negateLitList L NL * -&gt; is_list is_lit NL
IsL : is_list is_lit L
NLL : negateLitList L NL @
============================
 is_list is_lit NL
</pre>
<pre class="code extensibella"id="831">
 &lt; <b>NLL: case NLL.</b>

Subgoal 1:

IH : forall L NL, is_list is_lit L -&gt; negateLitList L NL * -&gt; is_list is_lit NL
IsL : is_list is_lit []
============================
 is_list is_lit []
</pre>
<pre class="code extensibella"id="832">
 &lt; <b>search.</b>

Subgoal 2:

Variables: NRest N LRest L1
IH : forall L NL, is_list is_lit L -&gt; negateLitList L NL * -&gt; is_list is_lit NL
IsL : is_list is_lit (L1::LRest)
NLL : negate_lit L1 N
NLL1 : negateLitList LRest NRest *
============================
 is_list is_lit (N::NRest)
</pre>
<pre class="code extensibella"id="833">
 &lt; <b>Is: case IsL.</b>

Subgoal 2:

Variables: NRest N LRest L1
IH : forall L NL, is_list is_lit L -&gt; negateLitList L NL * -&gt; is_list is_lit NL
NLL : negate_lit L1 N
NLL1 : negateLitList LRest NRest *
Is : is_lit L1
Is1 : is_list is_lit LRest
============================
 is_list is_lit (N::NRest)
</pre>
<pre class="code extensibella"id="834">
 &lt; <b>apply IH to _ NLL1.</b>

Subgoal 2:

Variables: NRest N LRest L1
IH : forall L NL, is_list is_lit L -&gt; negateLitList L NL * -&gt; is_list is_lit NL
NLL : negate_lit L1 N
NLL1 : negateLitList LRest NRest *
Is : is_lit L1
Is1 : is_list is_lit LRest
H1 : is_list is_lit NRest
============================
 is_list is_lit (N::NRest)
</pre>
<pre class="code extensibella"id="835">
 &lt; <b>apply negate_lit_is_lit to _ NLL.</b>

Subgoal 2:

Variables: NRest N LRest L1
IH : forall L NL, is_list is_lit L -&gt; negateLitList L NL * -&gt; is_list is_lit NL
NLL : negate_lit L1 N
NLL1 : negateLitList LRest NRest *
Is : is_lit L1
Is1 : is_list is_lit LRest
H1 : is_list is_lit NRest
H2 : is_lit N
============================
 is_list is_lit (N::NRest)
</pre>
<pre class="code extensibella"id="836">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="837">
 &lt; <b>Theorem negateLitList_exists :
     forall L, is_list is_lit L -&gt; exists NL, negateLitList L NL.</b>

============================
 forall L, is_list is_lit L -&gt; exists NL, negateLitList L NL
</pre>
<pre class="code extensibella"id="838">
 &lt; <b>induction on 1.</b>

IH : forall L, is_list is_lit L * -&gt; exists NL, negateLitList L NL
============================
 forall L, is_list is_lit L @ -&gt; exists NL, negateLitList L NL
</pre>
<pre class="code extensibella"id="839">
 &lt; <b>intros IsL.</b>

Variables: L
IH : forall L, is_list is_lit L * -&gt; exists NL, negateLitList L NL
IsL : is_list is_lit L @
============================
 exists NL, negateLitList L NL
</pre>
<pre class="code extensibella"id="840">
 &lt; <b>Is: case IsL.</b>

Subgoal 1:

IH : forall L, is_list is_lit L * -&gt; exists NL, negateLitList L NL
============================
 exists NL, negateLitList [] NL
</pre>
<pre class="code extensibella"id="841">
 &lt; <b>search.</b>

Subgoal 2:

Variables: T H
IH : forall L, is_list is_lit L * -&gt; exists NL, negateLitList L NL
Is : is_lit H
Is1 : is_list is_lit T *
============================
 exists NL, negateLitList (H::T) NL
</pre>
<pre class="code extensibella"id="842">
 &lt; <b>apply negate_lit_exists to Is.</b>

Subgoal 2:

Variables: T H NL
IH : forall L, is_list is_lit L * -&gt; exists NL, negateLitList L NL
Is : is_lit H
Is1 : is_list is_lit T *
H1 : negate_lit H NL
============================
 exists NL, negateLitList (H::T) NL
</pre>
<pre class="code extensibella"id="843">
 &lt; <b>apply IH to Is1.</b>

Subgoal 2:

Variables: T H NL NL1
IH : forall L, is_list is_lit L * -&gt; exists NL, negateLitList L NL
Is : is_lit H
Is1 : is_list is_lit T *
H1 : negate_lit H NL
H2 : negateLitList T NL1
============================
 exists NL, negateLitList (H::T) NL
</pre>
<pre class="code extensibella"id="844">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="845">
 &lt; <b>Theorem negateLitList_mem_negate_before :
     forall X NL L NX,
       is_list is_lit NL -&gt; mem X NL -&gt; negateLitList L NL -&gt; negate_lit X NX -&gt;
       mem NX L.</b>

============================
 forall X NL L NX,
   is_list is_lit NL -&gt; mem X NL -&gt; negateLitList L NL -&gt; negate_lit X NX -&gt; mem NX L
</pre>
<pre class="code extensibella"id="846">
 &lt; <b>induction on 2.</b>

IH : forall X NL L NX,
       is_list is_lit NL -&gt; mem X NL * -&gt; negateLitList L NL -&gt; negate_lit X NX -&gt;
       mem NX L
============================
 forall X NL L NX,
   is_list is_lit NL -&gt; mem X NL @ -&gt; negateLitList L NL -&gt; negate_lit X NX -&gt; mem NX L
</pre>
<pre class="code extensibella"id="847">
 &lt; <b>intros IsNL Mem NLL Neg.</b>

Variables: X NL L NX
IH : forall X NL L NX,
       is_list is_lit NL -&gt; mem X NL * -&gt; negateLitList L NL -&gt; negate_lit X NX -&gt;
       mem NX L
IsNL : is_list is_lit NL
Mem : mem X NL @
NLL : negateLitList L NL
Neg : negate_lit X NX
============================
 mem NX L
</pre>
<pre class="code extensibella"id="848">
 &lt; <b>Mem: case Mem.</b>

Subgoal 1:

Variables: X L NX Rest
IH : forall X NL L NX,
       is_list is_lit NL -&gt; mem X NL * -&gt; negateLitList L NL -&gt; negate_lit X NX -&gt;
       mem NX L
IsNL : is_list is_lit (X::Rest)
NLL : negateLitList L (X::Rest)
Neg : negate_lit X NX
============================
 mem NX L
</pre>
<pre class="code extensibella"id="849">
 &lt; <b>NLL: case NLL.</b>

Subgoal 1:

Variables: X NX Rest LRest L1
IH : forall X NL L NX,
       is_list is_lit NL -&gt; mem X NL * -&gt; negateLitList L NL -&gt; negate_lit X NX -&gt;
       mem NX L
IsNL : is_list is_lit (X::Rest)
Neg : negate_lit X NX
NLL : negate_lit L1 X
NLL1 : negateLitList LRest Rest
============================
 mem NX (L1::LRest)
</pre>
<pre class="code extensibella"id="850">
 &lt; <b>Is: case IsNL.</b>

Subgoal 1:

Variables: X NX Rest LRest L1
IH : forall X NL L NX,
       is_list is_lit NL -&gt; mem X NL * -&gt; negateLitList L NL -&gt; negate_lit X NX -&gt;
       mem NX L
Neg : negate_lit X NX
NLL : negate_lit L1 X
NLL1 : negateLitList LRest Rest
Is : is_lit X
Is1 : is_list is_lit Rest
============================
 mem NX (L1::LRest)
</pre>
<pre class="code extensibella"id="851">
 &lt; <b>apply negate_lit_is_lit_back to _ NLL.</b>

Subgoal 1:

Variables: X NX Rest LRest L1
IH : forall X NL L NX,
       is_list is_lit NL -&gt; mem X NL * -&gt; negateLitList L NL -&gt; negate_lit X NX -&gt;
       mem NX L
Neg : negate_lit X NX
NLL : negate_lit L1 X
NLL1 : negateLitList LRest Rest
Is : is_lit X
Is1 : is_list is_lit Rest
H1 : is_lit L1
============================
 mem NX (L1::LRest)
</pre>
<pre class="code extensibella"id="852">
 &lt; <b>NegXL1: apply negate_lit_reverse to _ NLL.</b>

Subgoal 1:

Variables: X NX Rest LRest L1
IH : forall X NL L NX,
       is_list is_lit NL -&gt; mem X NL * -&gt; negateLitList L NL -&gt; negate_lit X NX -&gt;
       mem NX L
Neg : negate_lit X NX
NLL : negate_lit L1 X
NLL1 : negateLitList LRest Rest
Is : is_lit X
Is1 : is_list is_lit Rest
H1 : is_lit L1
NegXL1 : negate_lit X L1
============================
 mem NX (L1::LRest)
</pre>
<pre class="code extensibella"id="853">
 &lt; <b>apply negate_lit_unique to _ Neg NegXL1.</b>

Subgoal 1:

Variables: X Rest LRest L1
IH : forall X NL L NX,
       is_list is_lit NL -&gt; mem X NL * -&gt; negateLitList L NL -&gt; negate_lit X NX -&gt;
       mem NX L
Neg : negate_lit X L1
NLL : negate_lit L1 X
NLL1 : negateLitList LRest Rest
Is : is_lit X
Is1 : is_list is_lit Rest
H1 : is_lit L1
NegXL1 : negate_lit X L1
============================
 mem L1 (L1::LRest)
</pre>
<pre class="code extensibella"id="854">
 &lt; <b>search.</b>

Subgoal 2:

Variables: X L NX Rest I
IH : forall X NL L NX,
       is_list is_lit NL -&gt; mem X NL * -&gt; negateLitList L NL -&gt; negate_lit X NX -&gt;
       mem NX L
IsNL : is_list is_lit (I::Rest)
NLL : negateLitList L (I::Rest)
Neg : negate_lit X NX
Mem : mem X Rest *
============================
 mem NX L
</pre>
<pre class="code extensibella"id="855">
 &lt; <b>NLL: case NLL.</b>

Subgoal 2:

Variables: X NX Rest I LRest L1
IH : forall X NL L NX,
       is_list is_lit NL -&gt; mem X NL * -&gt; negateLitList L NL -&gt; negate_lit X NX -&gt;
       mem NX L
IsNL : is_list is_lit (I::Rest)
Neg : negate_lit X NX
Mem : mem X Rest *
NLL : negate_lit L1 I
NLL1 : negateLitList LRest Rest
============================
 mem NX (L1::LRest)
</pre>
<pre class="code extensibella"id="856">
 &lt; <b>case IsNL.</b>

Subgoal 2:

Variables: X NX Rest I LRest L1
IH : forall X NL L NX,
       is_list is_lit NL -&gt; mem X NL * -&gt; negateLitList L NL -&gt; negate_lit X NX -&gt;
       mem NX L
Neg : negate_lit X NX
Mem : mem X Rest *
NLL : negate_lit L1 I
NLL1 : negateLitList LRest Rest
H1 : is_lit I
H2 : is_list is_lit Rest
============================
 mem NX (L1::LRest)
</pre>
<pre class="code extensibella"id="857">
 &lt; <b>apply IH to _ Mem _ _.</b>

Subgoal 2:

Variables: X NX Rest I LRest L1
IH : forall X NL L NX,
       is_list is_lit NL -&gt; mem X NL * -&gt; negateLitList L NL -&gt; negate_lit X NX -&gt;
       mem NX L
Neg : negate_lit X NX
Mem : mem X Rest *
NLL : negate_lit L1 I
NLL1 : negateLitList LRest Rest
H1 : is_lit I
H2 : is_list is_lit Rest
H3 : mem NX LRest
============================
 mem NX (L1::LRest)
</pre>
<pre class="code extensibella"id="858">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="859">
 &lt; <b>Extensible_Theorem
      negate_lits_unsat : forall C L NL,
         IsC : is_clause C -&gt;
         GL : gatherLits C L -&gt;
         NLL : negateLitList L NL -&gt;
         unsat_clause NL C
      on GL.</b>

Subgoal 1:

Variables: NL
IH : forall C L NL,
       is_clause C -&gt; gatherLits C L * -&gt; negateLitList L NL -&gt; unsat_clause NL C
IsC : is_clause emptyClause
GL : gatherLits emptyClause [] @
NLL : negateLitList [] NL
============================
 unsat_clause NL emptyClause
</pre>
<pre class="code extensibella"id="860">
 &lt; <b>search.</b>

Subgoal 2:

Variables: NL LRest L1 Rest
IH : forall C L NL,
       is_clause C -&gt; gatherLits C L * -&gt; negateLitList L NL -&gt; unsat_clause NL C
IsC : is_clause (or L1 Rest)
GL : gatherLits (or L1 Rest) (L1::LRest) @
NLL : negateLitList (L1::LRest) NL
GL1 : gatherLits Rest LRest *
============================
 unsat_clause NL (or L1 Rest)
</pre>
<pre class="code extensibella"id="861">
 &lt; <b>NLL: case NLL.</b>

Subgoal 2:

Variables: LRest L1 Rest NRest N
IH : forall C L NL,
       is_clause C -&gt; gatherLits C L * -&gt; negateLitList L NL -&gt; unsat_clause NL C
IsC : is_clause (or L1 Rest)
GL : gatherLits (or L1 Rest) (L1::LRest) @
GL1 : gatherLits Rest LRest *
NLL : negate_lit L1 N
NLL1 : negateLitList LRest NRest
============================
 unsat_clause (N::NRest) (or L1 Rest)
</pre>
<pre class="code extensibella"id="862">
 &lt; <b>Is: case IsC.</b>

Subgoal 2:

Variables: LRest L1 Rest NRest N
IH : forall C L NL,
       is_clause C -&gt; gatherLits C L * -&gt; negateLitList L NL -&gt; unsat_clause NL C
GL : gatherLits (or L1 Rest) (L1::LRest) @
GL1 : gatherLits Rest LRest *
NLL : negate_lit L1 N
NLL1 : negateLitList LRest NRest
Is : is_lit L1
Is1 : is_clause Rest
============================
 unsat_clause (N::NRest) (or L1 Rest)
</pre>
<pre class="code extensibella"id="863">
 &lt; <b>UC: apply IH to _ GL1 NLL1.</b>

Subgoal 2:

Variables: LRest L1 Rest NRest N
IH : forall C L NL,
       is_clause C -&gt; gatherLits C L * -&gt; negateLitList L NL -&gt; unsat_clause NL C
GL : gatherLits (or L1 Rest) (L1::LRest) @
GL1 : gatherLits Rest LRest *
NLL : negate_lit L1 N
NLL1 : negateLitList LRest NRest
Is : is_lit L1
Is1 : is_clause Rest
UC : unsat_clause NRest Rest
============================
 unsat_clause (N::NRest) (or L1 Rest)
</pre>
<pre class="code extensibella"id="864">
 &lt; <b>apply negate_lit_is_lit to _ NLL.</b>

Subgoal 2:

Variables: LRest L1 Rest NRest N
IH : forall C L NL,
       is_clause C -&gt; gatherLits C L * -&gt; negateLitList L NL -&gt; unsat_clause NL C
GL : gatherLits (or L1 Rest) (L1::LRest) @
GL1 : gatherLits Rest LRest *
NLL : negate_lit L1 N
NLL1 : negateLitList LRest NRest
Is : is_lit L1
Is1 : is_clause Rest
UC : unsat_clause NRest Rest
H1 : is_lit N
============================
 unsat_clause (N::NRest) (or L1 Rest)
</pre>
<pre class="code extensibella"id="865">
 &lt; <b>apply gatherLits_is to _ GL1.</b>

Subgoal 2:

Variables: LRest L1 Rest NRest N
IH : forall C L NL,
       is_clause C -&gt; gatherLits C L * -&gt; negateLitList L NL -&gt; unsat_clause NL C
GL : gatherLits (or L1 Rest) (L1::LRest) @
GL1 : gatherLits Rest LRest *
NLL : negate_lit L1 N
NLL1 : negateLitList LRest NRest
Is : is_lit L1
Is1 : is_clause Rest
UC : unsat_clause NRest Rest
H1 : is_lit N
H2 : is_list is_lit LRest
============================
 unsat_clause (N::NRest) (or L1 Rest)
</pre>
<pre class="code extensibella"id="866">
 &lt; <b>apply negateLitList_is to _ NLL1.</b>

Subgoal 2:

Variables: LRest L1 Rest NRest N
IH : forall C L NL,
       is_clause C -&gt; gatherLits C L * -&gt; negateLitList L NL -&gt; unsat_clause NL C
GL : gatherLits (or L1 Rest) (L1::LRest) @
GL1 : gatherLits Rest LRest *
NLL : negate_lit L1 N
NLL1 : negateLitList LRest NRest
Is : is_lit L1
Is1 : is_clause Rest
UC : unsat_clause NRest Rest
H1 : is_lit N
H2 : is_list is_lit LRest
H3 : is_list is_lit NRest
============================
 unsat_clause (N::NRest) (or L1 Rest)
</pre>
<pre class="code extensibella"id="867">
 &lt; <b>apply unsat_clause_orderless to _ _ _ UC _ with
     A2 = N::NRest.</b>

Subgoal 2:

Variables: LRest L1 Rest NRest N
IH : forall C L NL,
       is_clause C -&gt; gatherLits C L * -&gt; negateLitList L NL -&gt; unsat_clause NL C
GL : gatherLits (or L1 Rest) (L1::LRest) @
GL1 : gatherLits Rest LRest *
NLL : negate_lit L1 N
NLL1 : negateLitList LRest NRest
Is : is_lit L1
Is1 : is_clause Rest
UC : unsat_clause NRest Rest
H1 : is_lit N
H2 : is_list is_lit LRest
H3 : is_list is_lit NRest
H4 : unsat_clause (N::NRest) Rest
============================
 unsat_clause (N::NRest) (or L1 Rest)
</pre>
<pre class="code extensibella"id="868">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="869">
 &lt; <b>Theorem rupProof_all_mem :
     forall Known C Proof ID,
       rupProof Known C Proof -&gt; mem ID Proof -&gt; exists C', lookup Known ID C'.</b>

============================
 forall Known C Proof ID,
   rupProof Known C Proof -&gt; mem ID Proof -&gt; exists C', lookup Known ID C'
</pre>
<pre class="code extensibella"id="870">
 &lt; <b>intros RUP Mem.</b>

Variables: Known C Proof ID
RUP : rupProof Known C Proof
Mem : mem ID Proof
============================
 exists C', lookup Known ID C'
</pre>
<pre class="code extensibella"id="871">
 &lt; <b>RUP: case RUP.</b>

Variables: Known C Proof ID Lits A
Mem : mem ID Proof
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Proof
============================
 exists C', lookup Known ID C'
</pre>
<pre class="code extensibella"id="872">
 &lt; <b>apply rupProof_help_all_mem to RUP2 Mem.</b>

Variables: Known C Proof ID Lits A C1
Mem : mem ID Proof
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Proof
H1 : lookup Known ID C1
============================
 exists C', lookup Known ID C'
</pre>
<pre class="code extensibella"id="873">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="874">
 &lt; <b>Theorem rupProof_is :
     forall Known C Proof,
       rupProof Known C Proof -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list is_integer Proof.</b>

============================
 forall Known C Proof,
   rupProof Known C Proof -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list is_integer Proof
</pre>
<pre class="code extensibella"id="875">
 &lt; <b>intros RUP IsK.</b>

Variables: Known C Proof
RUP : rupProof Known C Proof
IsK : is_list (is_pair is_integer is_clause) Known
============================
 is_list is_integer Proof
</pre>
<pre class="code extensibella"id="876">
 &lt; <b>RUP: case RUP.</b>

Variables: Known C Proof Lits A
IsK : is_list (is_pair is_integer is_clause) Known
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Proof
============================
 is_list is_integer Proof
</pre>
<pre class="code extensibella"id="877">
 &lt; <b>apply rupProof_help_is to RUP2 IsK.</b>

Variables: Known C Proof Lits A
IsK : is_list (is_pair is_integer is_clause) Known
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Proof
H1 : is_list is_integer Proof
============================
 is_list is_integer Proof
</pre>
<pre class="code extensibella"id="878">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="879">
 &lt; <b>Theorem rupProof_maintains_sat :
     forall Known C Prf Sat,
       is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit Sat -&gt; rupProof Known C Prf -&gt;
       (forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC) -&gt; is_clause C -&gt;
       is_list is_lit Sat -&gt; good_assignment Sat -&gt; exists S,
         ((is_list is_lit S /\ good_assignment S) /\
         (forall L, mem L Sat -&gt; mem L S)) /\
         sat_clause S C.</b>

============================
 forall Known C Prf Sat,
   is_list (is_pair is_integer is_clause) Known -&gt; is_list is_lit Sat -&gt; rupProof Known C Prf -&gt;
   (forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC) -&gt; is_clause C -&gt; is_list is_lit Sat -&gt;
   good_assignment Sat -&gt; exists S,
     ((is_list is_lit S /\ good_assignment S) /\
     (forall L, mem L Sat -&gt; mem L S)) /\
     sat_clause S C
</pre>
<pre class="code extensibella"id="880">
 &lt; <b>intros IsKnown IsSat RUP Sat IsC IsSat GA_Sat.</b>

Variables: Known C Prf Sat
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
RUP : rupProof Known C Prf
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
============================
 exists S,
   ((is_list is_lit S /\ good_assignment S) /\ (forall L, mem L Sat -&gt; mem L S)) /\
   sat_clause S C
</pre>
<pre class="code extensibella"id="881">
 &lt; <b>RUP: case RUP.</b>

Variables: Known C Prf Sat Lits A
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
============================
 exists S,
   ((is_list is_lit S /\ good_assignment S) /\ (forall L, mem L Sat -&gt; mem L S)) /\
   sat_clause S C
</pre>
<pre class="code extensibella"id="882">
 &lt; <b>IsLits: apply gatherLits_is to IsC RUP.</b>

Variables: Known C Prf Sat Lits A
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
============================
 exists S,
   ((is_list is_lit S /\ good_assignment S) /\ (forall L, mem L Sat -&gt; mem L S)) /\
   sat_clause S C
</pre>
<pre class="code extensibella"id="883">
 &lt; <b>IsA: apply negateLitList_is to IsLits RUP1.</b>

Variables: Known C Prf Sat Lits A
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
============================
 exists S,
   ((is_list is_lit S /\ good_assignment S) /\ (forall L, mem L Sat -&gt; mem L S)) /\
   sat_clause S C
</pre>
<pre class="code extensibella"id="884">
 &lt; <b>Or: apply is_list_lit_subset_or_not to IsA IsSat.</b>

Variables: Known C Prf Sat Lits A
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Or : (forall X, mem X A -&gt; mem X Sat) \/
     (exists X, mem X A /\ (mem X Sat -&gt; false))
============================
 exists S,
   ((is_list is_lit S /\ good_assignment S) /\ (forall L, mem L Sat -&gt; mem L S)) /\
   sat_clause S C
</pre>
<pre class="code extensibella"id="885">
 &lt; <b>Sub: case Or.</b>

Subgoal 1:

Variables: Known C Prf Sat Lits A
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : forall X, mem X A -&gt; mem X Sat
============================
 exists S,
   ((is_list is_lit S /\ good_assignment S) /\ (forall L, mem L Sat -&gt; mem L S)) /\
   sat_clause S C
</pre>
<pre class="code extensibella"id="886">
 &lt; <b>apply good_assignment_sub to GA_Sat Sub.</b>

Subgoal 1:

Variables: Known C Prf Sat Lits A
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : forall X, mem X A -&gt; mem X Sat
H1 : good_assignment A
============================
 exists S,
   ((is_list is_lit S /\ good_assignment S) /\ (forall L, mem L Sat -&gt; mem L S)) /\
   sat_clause S C
</pre>
<pre class="code extensibella"id="887">
 &lt; <b>apply rupProof_help_unsat to _ _ _ RUP2 Sub Sat _ GA_Sat.</b>

Subgoal 2:

Variables: Known C Prf Sat Lits A X
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
============================
 exists S,
   ((is_list is_lit S /\ good_assignment S) /\ (forall L, mem L Sat -&gt; mem L S)) /\
   sat_clause S C
</pre>
<pre class="code extensibella"id="888">
 &lt; <b>IsX: apply mem_is_lit to _ Sub.</b>

Subgoal 2:

Variables: Known C Prf Sat Lits A X
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
============================
 exists S,
   ((is_list is_lit S /\ good_assignment S) /\ (forall L, mem L Sat -&gt; mem L S)) /\
   sat_clause S C
</pre>
<pre class="code extensibella"id="889">
 &lt; <b>Neg: apply negate_lit_exists to IsX.</b>

Subgoal 2:

Variables: Known C Prf Sat Lits A X NL
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
============================
 exists S,
   ((is_list is_lit S /\ good_assignment S) /\ (forall L, mem L Sat -&gt; mem L S)) /\
   sat_clause S C
</pre>
<pre class="code extensibella"id="890">
 &lt; <b>IsNX: apply negate_lit_is_lit to IsX Neg.</b>

Subgoal 2:

Variables: Known C Prf Sat Lits A X NL
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
============================
 exists S,
   ((is_list is_lit S /\ good_assignment S) /\ (forall L, mem L Sat -&gt; mem L S)) /\
   sat_clause S C
</pre>
<pre class="code extensibella"id="891">
 &lt; <b>Or: apply is_list_lit_mem_or_not to IsSat IsNX.</b>

Subgoal 2:

Variables: Known C Prf Sat Lits A X NL
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
Or : mem NL Sat \/ (mem NL Sat -&gt; false)
============================
 exists S,
   ((is_list is_lit S /\ good_assignment S) /\ (forall L, mem L Sat -&gt; mem L S)) /\
   sat_clause S C
</pre>
<pre class="code extensibella"id="892">
 &lt; <b>MemNXSat: case Or.</b>

Subgoal 2.1:

Variables: Known C Prf Sat Lits A X NL
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat
============================
 exists S,
   ((is_list is_lit S /\ good_assignment S) /\ (forall L, mem L Sat -&gt; mem L S)) /\
   sat_clause S C
</pre>
<pre class="code extensibella"id="893">
 &lt; <b>exists Sat.</b>

Subgoal 2.1:

Variables: Known C Prf Sat Lits A X NL
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat
============================
 ((is_list is_lit Sat /\ good_assignment Sat) /\
 (forall L, mem L Sat -&gt; mem L Sat)) /\
 sat_clause Sat C
</pre>
<pre class="code extensibella"id="894">
 &lt; <b>split.</b>

Subgoal 2.1.1:

Variables: Known C Prf Sat Lits A X NL
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat
============================
 is_list is_lit Sat
</pre>
<pre class="code extensibella"id="895">
 &lt; <b>search.</b>

Subgoal 2.1.2:

Variables: Known C Prf Sat Lits A X NL
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat
============================
 good_assignment Sat
</pre>
<pre class="code extensibella"id="896">
 &lt; <b>search.</b>

Subgoal 2.1.3:

Variables: Known C Prf Sat Lits A X NL
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat
============================
 forall L, mem L Sat -&gt; mem L Sat
</pre>
<pre class="code extensibella"id="897">
 &lt; <b>search.</b>

Subgoal 2.1.4:

Variables: Known C Prf Sat Lits A X NL
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat
============================
 sat_clause Sat C
</pre>
<pre class="code extensibella"id="898">
 &lt; <b>NegNLX: apply negate_lit_reverse to _ Neg.</b>

Subgoal 2.1.4:

Variables: Known C Prf Sat Lits A X NL
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat
NegNLX : negate_lit NL X
============================
 sat_clause Sat C
</pre>
<pre class="code extensibella"id="899">
 &lt; <b>apply negateLitList_mem_negate_before to _ Sub RUP1 _.</b>

Subgoal 2.1.4:

Variables: Known C Prf Sat Lits A X NL
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat
NegNLX : negate_lit NL X
H1 : mem NL Lits
============================
 sat_clause Sat C
</pre>
<pre class="code extensibella"id="900">
 &lt; <b>apply gatherLits_mem_sat to _ _ RUP _ MemNXSat.</b>

Subgoal 2.1.4:

Variables: Known C Prf Sat Lits A X NL
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat
NegNLX : negate_lit NL X
H1 : mem NL Lits
H2 : sat_clause Sat C
============================
 sat_clause Sat C
</pre>
<pre class="code extensibella"id="901">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: Known C Prf Sat Lits A X NL
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat -&gt; false
============================
 exists S,
   ((is_list is_lit S /\ good_assignment S) /\ (forall L, mem L Sat -&gt; mem L S)) /\
   sat_clause S C
</pre>
<pre class="code extensibella"id="902">
 &lt; <b>exists NL::Sat.</b>

Subgoal 2.2:

Variables: Known C Prf Sat Lits A X NL
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat -&gt; false
============================
 ((is_list is_lit (NL::Sat) /\ good_assignment (NL::Sat)) /\
 (forall L, mem L Sat -&gt; mem L (NL::Sat))) /\
 sat_clause (NL::Sat) C
</pre>
<pre class="code extensibella"id="903">
 &lt; <b>split.</b>

Subgoal 2.2.1:

Variables: Known C Prf Sat Lits A X NL
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat -&gt; false
============================
 is_list is_lit (NL::Sat)
</pre>
<pre class="code extensibella"id="904">
 &lt; <b>search.</b>

Subgoal 2.2.2:

Variables: Known C Prf Sat Lits A X NL
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat -&gt; false
============================
 good_assignment (NL::Sat)
</pre>
<pre class="code extensibella"id="905">
 &lt; <b>unfold .</b>

Subgoal 2.2.2:

Variables: Known C Prf Sat Lits A X NL
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat -&gt; false
============================
 forall L NL1, mem L (NL::Sat) -&gt; negate_lit L NL1 -&gt; mem NL1 (NL::Sat) -&gt; false
</pre>
<pre class="code extensibella"id="906">
 &lt; <b>intros ML NegL MNL.</b>

Subgoal 2.2.2:

Variables: Known C Prf Sat Lits A X NL L NL1
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat -&gt; false
ML : mem L (NL::Sat)
NegL : negate_lit L NL1
MNL : mem NL1 (NL::Sat)
============================
 false
</pre>
<pre class="code extensibella"id="907">
 &lt; <b>ML: case ML.</b>

Subgoal 2.2.2.1:

Variables: Known C Prf Sat Lits A X NL NL1
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat -&gt; false
NegL : negate_lit NL NL1
MNL : mem NL1 (NL::Sat)
============================
 false
</pre>
<pre class="code extensibella"id="908">
 &lt; <b>NegNXX: apply negate_lit_reverse to _ Neg.</b>

Subgoal 2.2.2.1:

Variables: Known C Prf Sat Lits A X NL NL1
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat -&gt; false
NegL : negate_lit NL NL1
MNL : mem NL1 (NL::Sat)
NegNXX : negate_lit NL X
============================
 false
</pre>
<pre class="code extensibella"id="909">
 &lt; <b>apply negate_lit_unique to _ NegL NegNXX.</b>

Subgoal 2.2.2.1:

Variables: Known C Prf Sat Lits A X NL
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat -&gt; false
NegL : negate_lit NL X
MNL : mem X (NL::Sat)
NegNXX : negate_lit NL X
============================
 false
</pre>
<pre class="code extensibella"id="910">
 &lt; <b>MNL: case MNL.</b>

Subgoal 2.2.2.1.1:

Variables: Known C Prf Sat Lits A NL
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem NL A
Sub1 : mem NL Sat -&gt; false
IsX : is_lit NL
Neg : negate_lit NL NL
IsNX : is_lit NL
MemNXSat : mem NL Sat -&gt; false
NegL : negate_lit NL NL
NegNXX : negate_lit NL NL
============================
 false
</pre>
<pre class="code extensibella"id="911">
 &lt; <b>apply negate_lit_not_same to _ NegL.</b>

Subgoal 2.2.2.1.2:

Variables: Known C Prf Sat Lits A X NL
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat -&gt; false
NegL : negate_lit NL X
NegNXX : negate_lit NL X
MNL : mem X Sat
============================
 false
</pre>
<pre class="code extensibella"id="912">
 &lt; <b>apply Sub1 to MNL.</b>

Subgoal 2.2.2.2:

Variables: Known C Prf Sat Lits A X NL L NL1
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat -&gt; false
NegL : negate_lit L NL1
MNL : mem NL1 (NL::Sat)
ML : mem L Sat
============================
 false
</pre>
<pre class="code extensibella"id="913">
 &lt; <b>MNL: case MNL.</b>

Subgoal 2.2.2.2.1:

Variables: Known C Prf Sat Lits A X NL L
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat -&gt; false
NegL : negate_lit L NL
ML : mem L Sat
============================
 false
</pre>
<pre class="code extensibella"id="914">
 &lt; <b>NegNXX: apply negate_lit_reverse to _ Neg.</b>

Subgoal 2.2.2.2.1:

Variables: Known C Prf Sat Lits A X NL L
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat -&gt; false
NegL : negate_lit L NL
ML : mem L Sat
NegNXX : negate_lit NL X
============================
 false
</pre>
<pre class="code extensibella"id="915">
 &lt; <b>apply mem_is_lit to _ ML.</b>

Subgoal 2.2.2.2.1:

Variables: Known C Prf Sat Lits A X NL L
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat -&gt; false
NegL : negate_lit L NL
ML : mem L Sat
NegNXX : negate_lit NL X
H1 : is_lit L
============================
 false
</pre>
<pre class="code extensibella"id="916">
 &lt; <b>NegNXL: apply negate_lit_reverse to _ NegL.</b>

Subgoal 2.2.2.2.1:

Variables: Known C Prf Sat Lits A X NL L
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat -&gt; false
NegL : negate_lit L NL
ML : mem L Sat
NegNXX : negate_lit NL X
H1 : is_lit L
NegNXL : negate_lit NL L
============================
 false
</pre>
<pre class="code extensibella"id="917">
 &lt; <b>apply negate_lit_unique to _ NegNXX NegNXL.</b>

Subgoal 2.2.2.2.1:

Variables: Known C Prf Sat Lits A NL L
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem L A
Sub1 : mem L Sat -&gt; false
IsX : is_lit L
Neg : negate_lit L NL
IsNX : is_lit NL
MemNXSat : mem NL Sat -&gt; false
NegL : negate_lit L NL
ML : mem L Sat
NegNXX : negate_lit NL L
H1 : is_lit L
NegNXL : negate_lit NL L
============================
 false
</pre>
<pre class="code extensibella"id="918">
 &lt; <b>apply Sub1 to ML.</b>

Subgoal 2.2.2.2.2:

Variables: Known C Prf Sat Lits A X NL L NL1
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat -&gt; false
NegL : negate_lit L NL1
ML : mem L Sat
MNL : mem NL1 Sat
============================
 false
</pre>
<pre class="code extensibella"id="919">
 &lt; <b>GA: case GA_Sat.</b>

Subgoal 2.2.2.2.2:

Variables: Known C Prf Sat Lits A X NL L NL1
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat -&gt; false
NegL : negate_lit L NL1
ML : mem L Sat
MNL : mem NL1 Sat
GA : forall L NL, mem L Sat -&gt; negate_lit L NL -&gt; mem NL Sat -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="920">
 &lt; <b>apply GA to ML NegL MNL.</b>

Subgoal 2.2.3:

Variables: Known C Prf Sat Lits A X NL
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat -&gt; false
============================
 forall L, mem L Sat -&gt; mem L (NL::Sat)
</pre>
<pre class="code extensibella"id="921">
 &lt; <b>search.</b>

Subgoal 2.2.4:

Variables: Known C Prf Sat Lits A X NL
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat -&gt; false
============================
 sat_clause (NL::Sat) C
</pre>
<pre class="code extensibella"id="922">
 &lt; <b>apply negateLitList_mem_negate_before to _ Sub RUP1 _.</b>

Subgoal 2.2.4:

Variables: Known C Prf Sat Lits A X NL
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat -&gt; false
H1 : mem NL Lits
============================
 sat_clause (NL::Sat) C
</pre>
<pre class="code extensibella"id="923">
 &lt; <b>apply gatherLits_mem_sat to _ _ RUP _ _ with
     Sat = NL::Sat.</b>

Subgoal 2.2.4:

Variables: Known C Prf Sat Lits A X NL
IsKnown : is_list (is_pair is_integer is_clause) Known
IsSat : is_list is_lit Sat
Sat : forall ID InC, lookup Known ID InC -&gt; sat_clause Sat InC
IsC : is_clause C
IsSat1 : is_list is_lit Sat
GA_Sat : good_assignment Sat
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help Known A Prf
IsLits : is_list is_lit Lits
IsA : is_list is_lit A
Sub : mem X A
Sub1 : mem X Sat -&gt; false
IsX : is_lit X
Neg : negate_lit X NL
IsNX : is_lit NL
MemNXSat : mem NL Sat -&gt; false
H1 : mem NL Lits
H2 : sat_clause (NL::Sat) C
============================
 sat_clause (NL::Sat) C
</pre>
<pre class="code extensibella"id="924">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="925">
 &lt; <b>Theorem rupProof_orderless :
     forall K1 K2 C Prf,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; rupProof K1 C Prf -&gt; (forall ID C',
         mem (ID, C') K1 -&gt; mem (ID, C') K2) -&gt; rupProof K2 C Prf.</b>

============================
 forall K1 K2 C Prf,
   is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
   good_clause_list K2 -&gt; rupProof K1 C Prf -&gt; (forall ID C',
     mem (ID, C') K1 -&gt; mem (ID, C') K2) -&gt; rupProof K2 C Prf
</pre>
<pre class="code extensibella"id="926">
 &lt; <b>intros IsK1 IsK2 GCL RUP MemK1K2.</b>

Variables: K1 K2 C Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
RUP : rupProof K1 C Prf
MemK1K2 : forall ID C', mem (ID, C') K1 -&gt; mem (ID, C') K2
============================
 rupProof K2 C Prf
</pre>
<pre class="code extensibella"id="927">
 &lt; <b>RUP: case RUP.</b>

Variables: K1 K2 C Prf Lits A
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
MemK1K2 : forall ID C', mem (ID, C') K1 -&gt; mem (ID, C') K2
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help K1 A Prf
============================
 rupProof K2 C Prf
</pre>
<pre class="code extensibella"id="928">
 &lt; <b>apply rupProof_help_orderless to IsK1 IsK2 GCL RUP2 MemK1K2.</b>

Variables: K1 K2 C Prf Lits A
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
MemK1K2 : forall ID C', mem (ID, C') K1 -&gt; mem (ID, C') K2
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help K1 A Prf
H1 : rupProof_help K2 A Prf
============================
 rupProof K2 C Prf
</pre>
<pre class="code extensibella"id="929">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="930">
 &lt; <b>Theorem rupProof_permutation :
     forall K1 K2 C Prf,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; rupProof K1 C Prf -&gt; permutation K1 K2 -&gt; rupProof K2 C Prf.</b>

============================
 forall K1 K2 C Prf,
   is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
   good_clause_list K2 -&gt; rupProof K1 C Prf -&gt; permutation K1 K2 -&gt; rupProof K2 C Prf
</pre>
<pre class="code extensibella"id="931">
 &lt; <b>intros IsK1 IsK2 GCL RUP Prm.</b>

Variables: K1 K2 C Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
RUP : rupProof K1 C Prf
Prm : permutation K1 K2
============================
 rupProof K2 C Prf
</pre>
<pre class="code extensibella"id="932">
 &lt; <b>MemBoth: assert forall ID C',
     mem (ID, C') K1 -&gt; mem (ID, C') K2.</b>

Subgoal 1:

Variables: K1 K2 C Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
RUP : rupProof K1 C Prf
Prm : permutation K1 K2
============================
 forall ID C', mem (ID, C') K1 -&gt; mem (ID, C') K2
</pre>
<pre class="code extensibella"id="933">
 &lt; <b>intros M.</b>

Subgoal 1:

Variables: K1 K2 C Prf ID C'
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
RUP : rupProof K1 C Prf
Prm : permutation K1 K2
M : mem (ID, C') K1
============================
 mem (ID, C') K2
</pre>
<pre class="code extensibella"id="934">
 &lt; <b>apply permutation_mem to Prm M.</b>

Subgoal 1:

Variables: K1 K2 C Prf ID C'
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
RUP : rupProof K1 C Prf
Prm : permutation K1 K2
M : mem (ID, C') K1
H1 : mem (ID, C') K2
============================
 mem (ID, C') K2
</pre>
<pre class="code extensibella"id="935">
 &lt; <b>search.</b>

Variables: K1 K2 C Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
RUP : rupProof K1 C Prf
Prm : permutation K1 K2
MemBoth : forall ID C', mem (ID, C') K1 -&gt; mem (ID, C') K2
============================
 rupProof K2 C Prf
</pre>
<pre class="code extensibella"id="936">
 &lt; <b>apply rupProof_orderless to IsK1 IsK2 GCL RUP MemBoth.</b>

Variables: K1 K2 C Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
RUP : rupProof K1 C Prf
Prm : permutation K1 K2
MemBoth : forall ID C', mem (ID, C') K1 -&gt; mem (ID, C') K2
H1 : rupProof K2 C Prf
============================
 rupProof K2 C Prf
</pre>
<pre class="code extensibella"id="937">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="938">
 &lt; <b>Translation_Constraint trans_proof_is :
   forall Known P PT,
   Trans : Known |{proof}- P ~~&gt; PT -&gt;
   IsP : is_proof P -&gt;
   IsKnown : is_list (is_pair is_integer is_clause) Known -&gt;
   is_proof PT.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="939">
 &lt; <b>Theorem sat_lemma :
     forall ID C Known KRest S,
       (forall CID InC, lookup ((ID, C)::Known) CID InC -&gt; sat_clause S InC) -&gt; remove_all Known ID KRest -&gt;
       forall CID InC, lookup ((ID, C)::KRest) CID InC -&gt; sat_clause S InC.</b>

============================
 forall ID C Known KRest S,
   (forall CID InC, lookup ((ID, C)::Known) CID InC -&gt; sat_clause S InC) -&gt; remove_all Known ID KRest -&gt;
   forall CID InC, lookup ((ID, C)::KRest) CID InC -&gt; sat_clause S InC
</pre>
<pre class="code extensibella"id="940">
 &lt; <b>intros AllSat RA Lkp.</b>

Variables: ID C Known KRest S CID InC
AllSat : forall CID InC, lookup ((ID, C)::Known) CID InC -&gt; sat_clause S InC
RA : remove_all Known ID KRest
Lkp : lookup ((ID, C)::KRest) CID InC
============================
 sat_clause S InC
</pre>
<pre class="code extensibella"id="941">
 &lt; <b>Lkp: case Lkp.</b>

Subgoal 1:

Variables: Known KRest S CID InC
AllSat : forall CID1 InC1,
           lookup ((CID, InC)::Known) CID1 InC1 -&gt; sat_clause S InC1
RA : remove_all Known CID KRest
============================
 sat_clause S InC
</pre>
<pre class="code extensibella"id="942">
 &lt; <b>backchain AllSat.</b>

Subgoal 2:

Variables: ID C Known KRest S CID InC
AllSat : forall CID InC, lookup ((ID, C)::Known) CID InC -&gt; sat_clause S InC
RA : remove_all Known ID KRest
Lkp : ID = CID -&gt; false
Lkp1 : lookup KRest CID InC
============================
 sat_clause S InC
</pre>
<pre class="code extensibella"id="943">
 &lt; <b>apply remove_all_lookup_after to RA Lkp1.</b>

Subgoal 2:

Variables: ID C Known KRest S CID InC
AllSat : forall CID InC, lookup ((ID, C)::Known) CID InC -&gt; sat_clause S InC
RA : remove_all Known ID KRest
Lkp : ID = CID -&gt; false
Lkp1 : lookup KRest CID InC
H1 : lookup Known CID InC
============================
 sat_clause S InC
</pre>
<pre class="code extensibella"id="944">
 &lt; <b>backchain AllSat.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="945">
 &lt; <b>Extensible_Theorem
      check_proof_correct : forall Known P Sat,
         IsP : is_proof P -&gt;
         IsSat : is_list is_lit Sat -&gt;
         GA_Sat : good_assignment Sat -&gt;
         GCL : good_clause_list Known -&gt;
         IsKnown : is_list (is_pair is_integer is_clause) Known -&gt;
         CP : checkProof Known P -&gt;
         Sat : (forall CID C,
           lookup Known CID C -&gt; sat_clause Sat C) -&gt;
         false
      on CP.</b>

Subgoal 1:

Variables: Known Sat Prf ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (emptyLrat ID Prf)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (emptyLrat ID Prf) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : rupProof Known emptyClause Prf
============================
 false
</pre>
<pre class="code extensibella"id="946">
 &lt; <b>assert good_assignment [].</b>

Subgoal 1.1:

Variables: Known Sat Prf ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (emptyLrat ID Prf)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (emptyLrat ID Prf) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : rupProof Known emptyClause Prf
============================
 good_assignment []
</pre>
<pre class="code extensibella"id="947">
 &lt; <b>unfold .</b>

Subgoal 1.1:

Variables: Known Sat Prf ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (emptyLrat ID Prf)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (emptyLrat ID Prf) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : rupProof Known emptyClause Prf
============================
 forall L NL, mem L [] -&gt; negate_lit L NL -&gt; mem NL [] -&gt; false
</pre>
<pre class="code extensibella"id="948">
 &lt; <b>intros M.</b>

Subgoal 1.1:

Variables: Known Sat Prf ID L NL
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (emptyLrat ID Prf)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (emptyLrat ID Prf) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : rupProof Known emptyClause Prf
M : mem L []
H1 : negate_lit L NL
H2 : mem NL []
============================
 false
</pre>
<pre class="code extensibella"id="949">
 &lt; <b>case M.</b>

Subgoal 1:

Variables: Known Sat Prf ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (emptyLrat ID Prf)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (emptyLrat ID Prf) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : rupProof Known emptyClause Prf
H1 : good_assignment []
============================
 false
</pre>
<pre class="code extensibella"id="950">
 &lt; <b>assert forall L,
     mem L [] -&gt; mem L Sat.</b>

Subgoal 1.2:

Variables: Known Sat Prf ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (emptyLrat ID Prf)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (emptyLrat ID Prf) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : rupProof Known emptyClause Prf
H1 : good_assignment []
============================
 forall L, mem L [] -&gt; mem L Sat
</pre>
<pre class="code extensibella"id="951">
 &lt; <b>intros M.</b>

Subgoal 1.2:

Variables: Known Sat Prf ID L
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (emptyLrat ID Prf)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (emptyLrat ID Prf) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : rupProof Known emptyClause Prf
H1 : good_assignment []
M : mem L []
============================
 mem L Sat
</pre>
<pre class="code extensibella"id="952">
 &lt; <b>case M.</b>

Subgoal 1:

Variables: Known Sat Prf ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (emptyLrat ID Prf)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (emptyLrat ID Prf) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : rupProof Known emptyClause Prf
H1 : good_assignment []
H2 : forall L, mem L [] -&gt; mem L Sat
============================
 false
</pre>
<pre class="code extensibella"id="953">
 &lt; <b>S: apply rupProof_maintains_sat to _ _ CP1 Sat _ IsSat GA_Sat.</b>

Subgoal 1:

Variables: Known Sat Prf ID S
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (emptyLrat ID Prf)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (emptyLrat ID Prf) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : rupProof Known emptyClause Prf
H1 : good_assignment []
H2 : forall L, mem L [] -&gt; mem L Sat
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S emptyClause
============================
 false
</pre>
<pre class="code extensibella"id="954">
 &lt; <b>case S3.</b>

Subgoal 2:

Variables: Known Sat KRest Rest Prf C ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (addLrupProof ID C Prf Rest)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID C Prf Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
============================
 false
</pre>
<pre class="code extensibella"id="955">
 &lt; <b>GA_Empty: assert good_assignment [].</b>

Subgoal 2.1:

Variables: Known Sat KRest Rest Prf C ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (addLrupProof ID C Prf Rest)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID C Prf Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
============================
 good_assignment []
</pre>
<pre class="code extensibella"id="956">
 &lt; <b>unfold .</b>

Subgoal 2.1:

Variables: Known Sat KRest Rest Prf C ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (addLrupProof ID C Prf Rest)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID C Prf Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
============================
 forall L NL, mem L [] -&gt; negate_lit L NL -&gt; mem NL [] -&gt; false
</pre>
<pre class="code extensibella"id="957">
 &lt; <b>intros M.</b>

Subgoal 2.1:

Variables: Known Sat KRest Rest Prf C ID L NL
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (addLrupProof ID C Prf Rest)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID C Prf Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
M : mem L []
H1 : negate_lit L NL
H2 : mem NL []
============================
 false
</pre>
<pre class="code extensibella"id="958">
 &lt; <b>case M.</b>

Subgoal 2:

Variables: Known Sat KRest Rest Prf C ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (addLrupProof ID C Prf Rest)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID C Prf Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
============================
 false
</pre>
<pre class="code extensibella"id="959">
 &lt; <b>ExpandEmpty: assert forall L,
     mem L [] -&gt; mem L Sat.</b>

Subgoal 2.2:

Variables: Known Sat KRest Rest Prf C ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (addLrupProof ID C Prf Rest)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID C Prf Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
============================
 forall L, mem L [] -&gt; mem L Sat
</pre>
<pre class="code extensibella"id="960">
 &lt; <b>intros M.</b>

Subgoal 2.2:

Variables: Known Sat KRest Rest Prf C ID L
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (addLrupProof ID C Prf Rest)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID C Prf Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
M : mem L []
============================
 mem L Sat
</pre>
<pre class="code extensibella"id="961">
 &lt; <b>case M.</b>

Subgoal 2:

Variables: Known Sat KRest Rest Prf C ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (addLrupProof ID C Prf Rest)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID C Prf Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpandEmpty : forall L, mem L [] -&gt; mem L Sat
============================
 false
</pre>
<pre class="code extensibella"id="962">
 &lt; <b>Is: case IsP.</b>

Subgoal 2:

Variables: Known Sat KRest Rest Prf C ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID C Prf Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpandEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
============================
 false
</pre>
<pre class="code extensibella"id="963">
 &lt; <b>S: apply rupProof_maintains_sat to _ _ CP2 Sat _ IsSat GA_Sat.</b>

Subgoal 2:

Variables: Known Sat KRest Rest Prf C ID S
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID C Prf Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpandEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
============================
 false
</pre>
<pre class="code extensibella"id="964">
 &lt; <b>NewSat: assert forall CID InC,
     lookup ((ID, C)::Known) CID InC -&gt; sat_clause S InC.</b>

Subgoal 2.3:

Variables: Known Sat KRest Rest Prf C ID S
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID C Prf Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpandEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
============================
 forall CID InC, lookup ((ID, C)::Known) CID InC -&gt; sat_clause S InC
</pre>
<pre class="code extensibella"id="965">
 &lt; <b>intros Lkp.</b>

Subgoal 2.3:

Variables: Known Sat KRest Rest Prf C ID S CID InC
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID C Prf Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpandEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
Lkp : lookup ((ID, C)::Known) CID InC
============================
 sat_clause S InC
</pre>
<pre class="code extensibella"id="966">
 &lt; <b>Lkp: case Lkp.</b>

Subgoal 2.3.1:

Variables: Known Sat KRest Rest Prf S CID InC
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof CID InC Prf Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known CID KRest
CP2 : rupProof Known InC Prf
CP3 : checkProof ((CID, InC)::KRest) Rest *
GA_Empty : good_assignment []
ExpandEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer CID
Is1 : is_clause InC
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S InC
============================
 sat_clause S InC
</pre>
<pre class="code extensibella"id="967">
 &lt; <b>search.</b>

Subgoal 2.3.2:

Variables: Known Sat KRest Rest Prf C ID S CID InC
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID C Prf Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpandEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
Lkp : ID = CID -&gt; false
Lkp1 : lookup Known CID InC
============================
 sat_clause S InC
</pre>
<pre class="code extensibella"id="968">
 &lt; <b>SC: apply Sat to Lkp1.</b>

Subgoal 2.3.2:

Variables: Known Sat KRest Rest Prf C ID S CID InC
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID C Prf Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpandEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
Lkp : ID = CID -&gt; false
Lkp1 : lookup Known CID InC
SC : sat_clause Sat InC
============================
 sat_clause S InC
</pre>
<pre class="code extensibella"id="969">
 &lt; <b>M: apply lookup_mem to Lkp1.</b>

Subgoal 2.3.2:

Variables: Known Sat KRest Rest Prf C ID S CID InC
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID C Prf Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpandEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
Lkp : ID = CID -&gt; false
Lkp1 : lookup Known CID InC
SC : sat_clause Sat InC
M : mem (CID, InC) Known
============================
 sat_clause S InC
</pre>
<pre class="code extensibella"id="970">
 &lt; <b>Is: apply mem_is to _ M.</b>

Subgoal 2.3.2:

Variables: Known Sat KRest Rest Prf C ID S ID1 C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID C Prf Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpandEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
Lkp : ID = ID1 -&gt; false
Lkp1 : lookup Known ID1 C1
SC : sat_clause Sat C1
M : mem (ID1, C1) Known
Is4 : is_integer ID1
Is5 : is_clause C1
============================
 sat_clause S C1
</pre>
<pre class="code extensibella"id="971">
 &lt; <b>apply sat_clause_orderless to _ _ _ SC _.</b>

Subgoal 2.3.2:

Variables: Known Sat KRest Rest Prf C ID S ID1 C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID C Prf Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpandEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
Lkp : ID = ID1 -&gt; false
Lkp1 : lookup Known ID1 C1
SC : sat_clause Sat C1
M : mem (ID1, C1) Known
Is4 : is_integer ID1
Is5 : is_clause C1
H1 : sat_clause S C1
============================
 sat_clause S C1
</pre>
<pre class="code extensibella"id="972">
 &lt; <b>search.</b>

Subgoal 2:

Variables: Known Sat KRest Rest Prf C ID S
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID C Prf Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpandEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
NewSat : forall CID InC, lookup ((ID, C)::Known) CID InC -&gt; sat_clause S InC
============================
 false
</pre>
<pre class="code extensibella"id="973">
 &lt; <b>GCL_New: apply good_clause_list_remove_all_add to GCL CP1 with
              C = C.</b>

Subgoal 2:

Variables: Known Sat KRest Rest Prf C ID S
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID C Prf Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpandEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
NewSat : forall CID InC, lookup ((ID, C)::Known) CID InC -&gt; sat_clause S InC
GCL_New : good_clause_list ((ID, C)::KRest)
============================
 false
</pre>
<pre class="code extensibella"id="974">
 &lt; <b>IsKRest: apply remove_all_is to IsKnown CP1.</b>

Subgoal 2:

Variables: Known Sat KRest Rest Prf C ID S
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID C Prf Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpandEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
NewSat : forall CID InC, lookup ((ID, C)::Known) CID InC -&gt; sat_clause S InC
GCL_New : good_clause_list ((ID, C)::KRest)
IsKRest : is_list (is_pair is_integer is_clause) KRest
============================
 false
</pre>
<pre class="code extensibella"id="975">
 &lt; <b>apply IH to Is3 S S1 GCL_New _ CP3 _.</b>

Subgoal 2:

Variables: Known Sat KRest Rest Prf C ID S
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID C Prf Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpandEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
NewSat : forall CID InC, lookup ((ID, C)::Known) CID InC -&gt; sat_clause S InC
GCL_New : good_clause_list ((ID, C)::KRest)
IsKRest : is_list (is_pair is_integer is_clause) KRest
============================
 forall CID C1, lookup ((ID, C)::KRest) CID C1 -&gt; sat_clause S C1
</pre>
<pre class="code extensibella"id="976">
 &lt; <b>backchain sat_lemma.</b>

Subgoal 3:

Variables: Known Sat C KRest Rest ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (deleteLratProof ID Rest)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteLratProof ID Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
============================
 false
</pre>
<pre class="code extensibella"id="977">
 &lt; <b>Is: case IsP.</b>

Subgoal 3:

Variables: Known Sat C KRest Rest ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteLratProof ID Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
============================
 false
</pre>
<pre class="code extensibella"id="978">
 &lt; <b>SatKRest: assert forall CID C,
     lookup KRest CID C -&gt; sat_clause Sat C.</b>

Subgoal 3.1:

Variables: Known Sat C KRest Rest ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteLratProof ID Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
============================
 forall CID C, lookup KRest CID C -&gt; sat_clause Sat C
</pre>
<pre class="code extensibella"id="979">
 &lt; <b>assert forall I C1 C2,
     mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2.</b>

Subgoal 3.1.1:

Variables: Known Sat C KRest Rest ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteLratProof ID Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
============================
 forall I C1 C2, mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2
</pre>
<pre class="code extensibella"id="980">
 &lt; <b>intros MA MB.</b>

Subgoal 3.1.1:

Variables: Known Sat C KRest Rest ID I C1 C2
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteLratProof ID Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
MA : mem (I, C1) Known
MB : mem (I, C2) Known
============================
 C1 = C2
</pre>
<pre class="code extensibella"id="981">
 &lt; <b>apply good_clause_list_mems to _ MA MB.</b>

Subgoal 3.1.1:

Variables: Known Sat C KRest Rest ID I C2
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteLratProof ID Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
MA : mem (I, C2) Known
MB : mem (I, C2) Known
============================
 C2 = C2
</pre>
<pre class="code extensibella"id="982">
 &lt; <b>search.</b>

Subgoal 3.1:

Variables: Known Sat C KRest Rest ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteLratProof ID Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
H1 : forall I C1 C2, mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2
============================
 forall CID C, lookup KRest CID C -&gt; sat_clause Sat C
</pre>
<pre class="code extensibella"id="983">
 &lt; <b>intros Lkp.</b>

Subgoal 3.1:

Variables: Known Sat C KRest Rest ID CID C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteLratProof ID Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
H1 : forall I C1 C2, mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2
Lkp : lookup KRest CID C1
============================
 sat_clause Sat C1
</pre>
<pre class="code extensibella"id="984">
 &lt; <b>MemKRest: apply lookup_mem to Lkp.</b>

Subgoal 3.1:

Variables: Known Sat C KRest Rest ID CID C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteLratProof ID Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
H1 : forall I C1 C2, mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2
Lkp : lookup KRest CID C1
MemKRest : mem (CID, C1) KRest
============================
 sat_clause Sat C1
</pre>
<pre class="code extensibella"id="985">
 &lt; <b>MemKnown: apply mem_after_select_before to CP1 MemKRest.</b>

Subgoal 3.1:

Variables: Known Sat C KRest Rest ID CID C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteLratProof ID Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
H1 : forall I C1 C2, mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2
Lkp : lookup KRest CID C1
MemKRest : mem (CID, C1) KRest
MemKnown : mem (CID, C1) Known
============================
 sat_clause Sat C1
</pre>
<pre class="code extensibella"id="986">
 &lt; <b>apply mem_is to IsKnown MemKnown.</b>

Subgoal 3.1:

Variables: Known Sat C KRest Rest ID ID1 C2
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteLratProof ID Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
H1 : forall I C1 C2, mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2
Lkp : lookup KRest ID1 C2
MemKRest : mem (ID1, C2) KRest
MemKnown : mem (ID1, C2) Known
H2 : is_integer ID1
H3 : is_clause C2
============================
 sat_clause Sat C2
</pre>
<pre class="code extensibella"id="987">
 &lt; <b>apply lookup_after_select to IsKnown _ _ CP1 Lkp.</b>

Subgoal 3.1:

Variables: Known Sat C KRest Rest ID ID1 C2
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteLratProof ID Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
H1 : forall I C1 C2, mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2
Lkp : lookup KRest ID1 C2
MemKRest : mem (ID1, C2) KRest
MemKnown : mem (ID1, C2) Known
H2 : is_integer ID1
H3 : is_clause C2
H4 : lookup Known ID1 C2
============================
 sat_clause Sat C2
</pre>
<pre class="code extensibella"id="988">
 &lt; <b>backchain Sat.</b>

Subgoal 3:

Variables: Known Sat C KRest Rest ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteLratProof ID Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
SatKRest : forall CID C, lookup KRest CID C -&gt; sat_clause Sat C
============================
 false
</pre>
<pre class="code extensibella"id="989">
 &lt; <b>GCL_KRest: apply good_clause_list_select to GCL CP1.</b>

Subgoal 3:

Variables: Known Sat C KRest Rest ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteLratProof ID Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
SatKRest : forall CID C, lookup KRest CID C -&gt; sat_clause Sat C
GCL_KRest : good_clause_list KRest
============================
 false
</pre>
<pre class="code extensibella"id="990">
 &lt; <b>IsKRest: apply select_is to IsKnown CP1.</b>

Subgoal 3:

Variables: Known Sat C KRest Rest ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteLratProof ID Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
SatKRest : forall CID C, lookup KRest CID C -&gt; sat_clause Sat C
GCL_KRest : good_clause_list KRest
IsKRest : is_list (is_pair is_integer is_clause) KRest
============================
 false
</pre>
<pre class="code extensibella"id="991">
 &lt; <b>apply IH to Is1 IsSat GA_Sat GCL_KRest IsKRest CP2 SatKRest.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="992">
 &lt; <b>Extensible_Theorem
      checkProof_orderless : forall K1 K2 Prf,
         IsP : is_proof Prf -&gt;
         IsK1 : is_list (is_pair is_integer is_clause) K1 -&gt;
         IsK2 : is_list (is_pair is_integer is_clause) K2 -&gt;
         GCL : good_clause_list K2 -&gt;
         CP : checkProof K1 Prf -&gt;
         Prm : permutation K1 K2 -&gt;
         checkProof K2 Prf
      on CP.</b>

Subgoal 1:

Variables: K1 K2 Prf1 ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsP : is_proof (emptyLrat ID Prf1)
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (emptyLrat ID Prf1) @
Prm : permutation K1 K2
CP1 : rupProof K1 emptyClause Prf1
============================
 checkProof K2 (emptyLrat ID Prf1)
</pre>
<pre class="code extensibella"id="993">
 &lt; <b>apply rupProof_permutation to IsK1 IsK2 GCL CP1 Prm.</b>

Subgoal 1:

Variables: K1 K2 Prf1 ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsP : is_proof (emptyLrat ID Prf1)
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (emptyLrat ID Prf1) @
Prm : permutation K1 K2
CP1 : rupProof K1 emptyClause Prf1
H1 : rupProof K2 emptyClause Prf1
============================
 checkProof K2 (emptyLrat ID Prf1)
</pre>
<pre class="code extensibella"id="994">
 &lt; <b>search.</b>

Subgoal 2:

Variables: K1 K2 KRest Rest Prf1 C ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsP : is_proof (addLrupProof ID C Prf1 Rest)
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (addLrupProof ID C Prf1 Rest) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest *
============================
 checkProof K2 (addLrupProof ID C Prf1 Rest)
</pre>
<pre class="code extensibella"id="995">
 &lt; <b>Is: case IsP.</b>

Subgoal 2:

Variables: K1 K2 KRest Rest Prf1 C ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (addLrupProof ID C Prf1 Rest) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf1
Is3 : is_proof Rest
============================
 checkProof K2 (addLrupProof ID C Prf1 Rest)
</pre>
<pre class="code extensibella"id="996">
 &lt; <b>Prm': apply permutation_symmetric to Prm.</b>

Subgoal 2:

Variables: K1 K2 KRest Rest Prf1 C ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (addLrupProof ID C Prf1 Rest) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf1
Is3 : is_proof Rest
Prm' : permutation K2 K1
============================
 checkProof K2 (addLrupProof ID C Prf1 Rest)
</pre>
<pre class="code extensibella"id="997">
 &lt; <b>GCL_K1: apply permutation_good_clause_list to _ Prm' GCL.</b>

Subgoal 2:

Variables: K1 K2 KRest Rest Prf1 C ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (addLrupProof ID C Prf1 Rest) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf1
Is3 : is_proof Rest
Prm' : permutation K2 K1
GCL_K1 : good_clause_list K1
============================
 checkProof K2 (addLrupProof ID C Prf1 Rest)
</pre>
<pre class="code extensibella"id="998">
 &lt; <b>RUPP: apply rupProof_permutation to IsK1 IsK2 GCL CP2 Prm.</b>

Subgoal 2:

Variables: K1 K2 KRest Rest Prf1 C ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (addLrupProof ID C Prf1 Rest) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf1
Is3 : is_proof Rest
Prm' : permutation K2 K1
GCL_K1 : good_clause_list K1
RUPP : rupProof K2 C Prf1
============================
 checkProof K2 (addLrupProof ID C Prf1 Rest)
</pre>
<pre class="code extensibella"id="999">
 &lt; <b>RA': apply remove_all_permutation to _ _ CP1 Prm.</b>

Subgoal 2:

Variables: K1 K2 KRest Rest Prf1 C ID P'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (addLrupProof ID C Prf1 Rest) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf1
Is3 : is_proof Rest
Prm' : permutation K2 K1
GCL_K1 : good_clause_list K1
RUPP : rupProof K2 C Prf1
RA' : remove_all K2 ID P'
RA'1 : permutation KRest P'
============================
 checkProof K2 (addLrupProof ID C Prf1 Rest)
</pre>
<pre class="code extensibella"id="1000">
 &lt; <b>Prm': assert permutation ((ID, C)::KRest) ((ID, C)::P').</b>

Subgoal 2:

Variables: K1 K2 KRest Rest Prf1 C ID P'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (addLrupProof ID C Prf1 Rest) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf1
Is3 : is_proof Rest
Prm' : permutation K2 K1
GCL_K1 : good_clause_list K1
RUPP : rupProof K2 C Prf1
RA' : remove_all K2 ID P'
RA'1 : permutation KRest P'
Prm'1 : permutation ((ID, C)::KRest) ((ID, C)::P')
============================
 checkProof K2 (addLrupProof ID C Prf1 Rest)
</pre>
<pre class="code extensibella"id="1001">
 &lt; <b>GCL_P': apply good_clause_list_remove_all_add to GCL RA' with
             C = C.</b>

Subgoal 2:

Variables: K1 K2 KRest Rest Prf1 C ID P'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (addLrupProof ID C Prf1 Rest) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf1
Is3 : is_proof Rest
Prm' : permutation K2 K1
GCL_K1 : good_clause_list K1
RUPP : rupProof K2 C Prf1
RA' : remove_all K2 ID P'
RA'1 : permutation KRest P'
Prm'1 : permutation ((ID, C)::KRest) ((ID, C)::P')
GCL_P' : good_clause_list ((ID, C)::P')
============================
 checkProof K2 (addLrupProof ID C Prf1 Rest)
</pre>
<pre class="code extensibella"id="1002">
 &lt; <b>apply remove_all_is to _ RA'.</b>

Subgoal 2:

Variables: K1 K2 KRest Rest Prf1 C ID P'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (addLrupProof ID C Prf1 Rest) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf1
Is3 : is_proof Rest
Prm' : permutation K2 K1
GCL_K1 : good_clause_list K1
RUPP : rupProof K2 C Prf1
RA' : remove_all K2 ID P'
RA'1 : permutation KRest P'
Prm'1 : permutation ((ID, C)::KRest) ((ID, C)::P')
GCL_P' : good_clause_list ((ID, C)::P')
H1 : is_list (is_pair is_integer is_clause) P'
============================
 checkProof K2 (addLrupProof ID C Prf1 Rest)
</pre>
<pre class="code extensibella"id="1003">
 &lt; <b>apply remove_all_is to _ CP1.</b>

Subgoal 2:

Variables: K1 K2 KRest Rest Prf1 C ID P'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (addLrupProof ID C Prf1 Rest) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf1
Is3 : is_proof Rest
Prm' : permutation K2 K1
GCL_K1 : good_clause_list K1
RUPP : rupProof K2 C Prf1
RA' : remove_all K2 ID P'
RA'1 : permutation KRest P'
Prm'1 : permutation ((ID, C)::KRest) ((ID, C)::P')
GCL_P' : good_clause_list ((ID, C)::P')
H1 : is_list (is_pair is_integer is_clause) P'
H2 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof K2 (addLrupProof ID C Prf1 Rest)
</pre>
<pre class="code extensibella"id="1004">
 &lt; <b>apply IH to Is3 _ _ GCL_P' CP3 _.</b>

Subgoal 2:

Variables: K1 K2 KRest Rest Prf1 C ID P'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (addLrupProof ID C Prf1 Rest) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf1
Is3 : is_proof Rest
Prm' : permutation K2 K1
GCL_K1 : good_clause_list K1
RUPP : rupProof K2 C Prf1
RA' : remove_all K2 ID P'
RA'1 : permutation KRest P'
Prm'1 : permutation ((ID, C)::KRest) ((ID, C)::P')
GCL_P' : good_clause_list ((ID, C)::P')
H1 : is_list (is_pair is_integer is_clause) P'
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : checkProof ((ID, C)::P') Rest
============================
 checkProof K2 (addLrupProof ID C Prf1 Rest)
</pre>
<pre class="code extensibella"id="1005">
 &lt; <b>search.</b>

Subgoal 3:

Variables: K1 K2 C KRest Rest ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsP : is_proof (deleteLratProof ID Rest)
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteLratProof ID Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
============================
 checkProof K2 (deleteLratProof ID Rest)
</pre>
<pre class="code extensibella"id="1006">
 &lt; <b>Is: case IsP.</b>

Subgoal 3:

Variables: K1 K2 C KRest Rest ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteLratProof ID Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
============================
 checkProof K2 (deleteLratProof ID Rest)
</pre>
<pre class="code extensibella"id="1007">
 &lt; <b>IsKRest: apply select_is to _ CP1.</b>

Subgoal 3:

Variables: K1 K2 C KRest Rest ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteLratProof ID Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof K2 (deleteLratProof ID Rest)
</pre>
<pre class="code extensibella"id="1008">
 &lt; <b>MK1: apply select_mem to CP1.</b>

Subgoal 3:

Variables: K1 K2 C KRest Rest ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteLratProof ID Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
MK1 : mem (ID, C) K1
============================
 checkProof K2 (deleteLratProof ID Rest)
</pre>
<pre class="code extensibella"id="1009">
 &lt; <b>MK2: apply permutation_mem to Prm MK1.</b>

Subgoal 3:

Variables: K1 K2 C KRest Rest ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteLratProof ID Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
MK1 : mem (ID, C) K1
MK2 : mem (ID, C) K2
============================
 checkProof K2 (deleteLratProof ID Rest)
</pre>
<pre class="code extensibella"id="1010">
 &lt; <b>S: apply mem_select to MK2.</b>

Subgoal 3:

Variables: K1 K2 C KRest Rest ID L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteLratProof ID Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
MK1 : mem (ID, C) K1
MK2 : mem (ID, C) K2
S : select (ID, C) L' K2
============================
 checkProof K2 (deleteLratProof ID Rest)
</pre>
<pre class="code extensibella"id="1011">
 &lt; <b>Prm': apply permutation_symmetric to Prm.</b>

Subgoal 3:

Variables: K1 K2 C KRest Rest ID L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteLratProof ID Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
MK1 : mem (ID, C) K1
MK2 : mem (ID, C) K2
S : select (ID, C) L' K2
Prm' : permutation K2 K1
============================
 checkProof K2 (deleteLratProof ID Rest)
</pre>
<pre class="code extensibella"id="1012">
 &lt; <b>GCL_K1: apply permutation_good_clause_list to _ Prm' GCL.</b>

Subgoal 3:

Variables: K1 K2 C KRest Rest ID L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteLratProof ID Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
MK1 : mem (ID, C) K1
MK2 : mem (ID, C) K2
S : select (ID, C) L' K2
Prm' : permutation K2 K1
GCL_K1 : good_clause_list K1
============================
 checkProof K2 (deleteLratProof ID Rest)
</pre>
<pre class="code extensibella"id="1013">
 &lt; <b>GCL_L': apply good_clause_list_select to GCL S.</b>

Subgoal 3:

Variables: K1 K2 C KRest Rest ID L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteLratProof ID Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
MK1 : mem (ID, C) K1
MK2 : mem (ID, C) K2
S : select (ID, C) L' K2
Prm' : permutation K2 K1
GCL_K1 : good_clause_list K1
GCL_L' : good_clause_list L'
============================
 checkProof K2 (deleteLratProof ID Rest)
</pre>
<pre class="code extensibella"id="1014">
 &lt; <b>IsL': apply select_is to _ S.</b>

Subgoal 3:

Variables: K1 K2 C KRest Rest ID L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteLratProof ID Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
MK1 : mem (ID, C) K1
MK2 : mem (ID, C) K2
S : select (ID, C) L' K2
Prm' : permutation K2 K1
GCL_K1 : good_clause_list K1
GCL_L' : good_clause_list L'
IsL' : is_list (is_pair is_integer is_clause) L'
============================
 checkProof K2 (deleteLratProof ID Rest)
</pre>
<pre class="code extensibella"id="1015">
 &lt; <b>P': apply selects_permutation to _ _ Prm' _ _.</b>

Subgoal 3:

Variables: K1 K2 C KRest Rest ID L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteLratProof ID Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
MK1 : mem (ID, C) K1
MK2 : mem (ID, C) K2
S : select (ID, C) L' K2
Prm' : permutation K2 K1
GCL_K1 : good_clause_list K1
GCL_L' : good_clause_list L'
IsL' : is_list (is_pair is_integer is_clause) L'
P' : permutation L' KRest
============================
 checkProof K2 (deleteLratProof ID Rest)
</pre>
<pre class="code extensibella"id="1016">
 &lt; <b>PrmSub: apply permutation_symmetric to P'.</b>

Subgoal 3:

Variables: K1 K2 C KRest Rest ID L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteLratProof ID Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
MK1 : mem (ID, C) K1
MK2 : mem (ID, C) K2
S : select (ID, C) L' K2
Prm' : permutation K2 K1
GCL_K1 : good_clause_list K1
GCL_L' : good_clause_list L'
IsL' : is_list (is_pair is_integer is_clause) L'
P' : permutation L' KRest
PrmSub : permutation KRest L'
============================
 checkProof K2 (deleteLratProof ID Rest)
</pre>
<pre class="code extensibella"id="1017">
 &lt; <b>apply IH to Is1 _ _ GCL_L' CP2 PrmSub.</b>

Subgoal 3:

Variables: K1 K2 C KRest Rest ID L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteLratProof ID Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
MK1 : mem (ID, C) K1
MK2 : mem (ID, C) K2
S : select (ID, C) L' K2
Prm' : permutation K2 K1
GCL_K1 : good_clause_list K1
GCL_L' : good_clause_list L'
IsL' : is_list (is_pair is_integer is_clause) L'
P' : permutation L' KRest
PrmSub : permutation KRest L'
H1 : checkProof L' Rest
============================
 checkProof K2 (deleteLratProof ID Rest)
</pre>
<pre class="code extensibella"id="1018">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="1019">
 &lt; <b>Ext_Ind checkProof Known P with Known |{proof}- P ~~&gt; P'.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="1020">
 &lt; <b>Translation_Constraint trans_checkProof :
   forall Known P P',
   Known |{proof}- P ~~&gt; P' -&gt; checkProof Known P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
   good_clause_list Known -&gt; checkProof Known P'.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="1021">
 &lt; <b>Extensible_Theorem
      formulaToKnown_all_greater : forall F ID K CID C,
         FTK : formulaToKnown ID F K -&gt;
         Mem : mem (CID, C) K -&gt;
         IsID : is_integer ID -&gt;
         CID &gt;= ID
      on FTK.</b>

Subgoal 1:

Variables: ID CID C
IH : forall F ID K CID C,
       formulaToKnown ID F K * -&gt; mem (CID, C) K -&gt; is_integer ID -&gt; CID &gt;= ID
FTK : formulaToKnown ID emptyFormula [] @
Mem : mem (CID, C) []
IsID : is_integer ID
============================
 CID &gt;= ID
</pre>
<pre class="code extensibella"id="1022">
 &lt; <b>case Mem.</b>

Subgoal 2:

Variables: ID CID C NewID KRest C1 Rest
IH : forall F ID K CID C,
       formulaToKnown ID F K * -&gt; mem (CID, C) K -&gt; is_integer ID -&gt; CID &gt;= ID
FTK : formulaToKnown ID (and C1 Rest) ((ID, C1)::KRest) @
Mem : mem (CID, C) ((ID, C1)::KRest)
IsID : is_integer ID
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest *
============================
 CID &gt;= ID
</pre>
<pre class="code extensibella"id="1023">
 &lt; <b>Mem: case Mem.</b>

Subgoal 2.1:

Variables: ID NewID KRest C1 Rest
IH : forall F ID K CID C,
       formulaToKnown ID F K * -&gt; mem (CID, C) K -&gt; is_integer ID -&gt; CID &gt;= ID
FTK : formulaToKnown ID (and C1 Rest) ((ID, C1)::KRest) @
IsID : is_integer ID
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest *
============================
 ID &gt;= ID
</pre>
<pre class="code extensibella"id="1024">
 &lt; <b>backchain is_integer_greatereq.</b>

Subgoal 2.2:

Variables: ID CID C NewID KRest C1 Rest
IH : forall F ID K CID C,
       formulaToKnown ID F K * -&gt; mem (CID, C) K -&gt; is_integer ID -&gt; CID &gt;= ID
FTK : formulaToKnown ID (and C1 Rest) ((ID, C1)::KRest) @
IsID : is_integer ID
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest *
Mem : mem (CID, C) KRest
============================
 CID &gt;= ID
</pre>
<pre class="code extensibella"id="1025">
 &lt; <b>IsNewID: apply plus_integer_is_integer to _ _ FTK1.</b>

Subgoal 2.2:

Variables: ID CID C NewID KRest C1 Rest
IH : forall F ID K CID C,
       formulaToKnown ID F K * -&gt; mem (CID, C) K -&gt; is_integer ID -&gt; CID &gt;= ID
FTK : formulaToKnown ID (and C1 Rest) ((ID, C1)::KRest) @
IsID : is_integer ID
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest *
Mem : mem (CID, C) KRest
IsNewID : is_integer NewID
============================
 CID &gt;= ID
</pre>
<pre class="code extensibella"id="1026">
 &lt; <b>GEq: apply IH to FTK2 Mem IsNewID.</b>

Subgoal 2.2:

Variables: ID CID C NewID KRest C1 Rest
IH : forall F ID K CID C,
       formulaToKnown ID F K * -&gt; mem (CID, C) K -&gt; is_integer ID -&gt; CID &gt;= ID
FTK : formulaToKnown ID (and C1 Rest) ((ID, C1)::KRest) @
IsID : is_integer ID
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest *
Mem : mem (CID, C) KRest
IsNewID : is_integer NewID
GEq : CID &gt;= NewID
============================
 CID &gt;= ID
</pre>
<pre class="code extensibella"id="1027">
 &lt; <b>G_ID: apply is_integer_greatereq to IsID.</b>

Subgoal 2.2:

Variables: ID CID C NewID KRest C1 Rest
IH : forall F ID K CID C,
       formulaToKnown ID F K * -&gt; mem (CID, C) K -&gt; is_integer ID -&gt; CID &gt;= ID
FTK : formulaToKnown ID (and C1 Rest) ((ID, C1)::KRest) @
IsID : is_integer ID
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest *
Mem : mem (CID, C) KRest
IsNewID : is_integer NewID
GEq : CID &gt;= NewID
G_ID : ID &gt;= ID
============================
 CID &gt;= ID
</pre>
<pre class="code extensibella"id="1028">
 &lt; <b>G_New: apply greatereq_integer__add_positive to G_ID _ FTK1.</b>

Subgoal 2.2:

Variables: ID CID C NewID KRest C1 Rest
IH : forall F ID K CID C,
       formulaToKnown ID F K * -&gt; mem (CID, C) K -&gt; is_integer ID -&gt; CID &gt;= ID
FTK : formulaToKnown ID (and C1 Rest) ((ID, C1)::KRest) @
IsID : is_integer ID
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest *
Mem : mem (CID, C) KRest
IsNewID : is_integer NewID
GEq : CID &gt;= NewID
G_ID : ID &gt;= ID
G_New : NewID &gt;= ID
============================
 CID &gt;= ID
</pre>
<pre class="code extensibella"id="1029">
 &lt; <b>apply greatereq_integer_transitive to GEq G_New.</b>

Subgoal 2.2:

Variables: ID CID C NewID KRest C1 Rest
IH : forall F ID K CID C,
       formulaToKnown ID F K * -&gt; mem (CID, C) K -&gt; is_integer ID -&gt; CID &gt;= ID
FTK : formulaToKnown ID (and C1 Rest) ((ID, C1)::KRest) @
IsID : is_integer ID
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest *
Mem : mem (CID, C) KRest
IsNewID : is_integer NewID
GEq : CID &gt;= NewID
G_ID : ID &gt;= ID
G_New : NewID &gt;= ID
H1 : CID &gt;= ID
============================
 CID &gt;= ID
</pre>
<pre class="code extensibella"id="1030">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="1031">
 &lt; <b>Extensible_Theorem
      formulaToKnown_all_unique : forall F ID K CID CA KRest CB,
         FTK : formulaToKnown ID F K -&gt;
         IsID : is_integer ID -&gt;
         Slct : select (CID, CA) KRest K -&gt;
         Mem : mem (CID, CB) KRest -&gt;
         false
      on FTK.</b>

Subgoal 1:

Variables: ID CID CA KRest CB
IH : forall F ID K CID CA KRest CB,
       formulaToKnown ID F K * -&gt; is_integer ID -&gt; select (CID, CA) KRest K -&gt; mem (CID, CB) KRest -&gt;
       false
FTK : formulaToKnown ID emptyFormula [] @
IsID : is_integer ID
Slct : select (CID, CA) KRest []
Mem : mem (CID, CB) KRest
============================
 false
</pre>
<pre class="code extensibella"id="1032">
 &lt; <b>case Slct.</b>

Subgoal 2:

Variables: ID CID CA KRest CB NewID KRest1 C Rest
IH : forall F ID K CID CA KRest CB,
       formulaToKnown ID F K * -&gt; is_integer ID -&gt; select (CID, CA) KRest K -&gt; mem (CID, CB) KRest -&gt;
       false
FTK : formulaToKnown ID (and C Rest) ((ID, C)::KRest1) @
IsID : is_integer ID
Slct : select (CID, CA) KRest ((ID, C)::KRest1)
Mem : mem (CID, CB) KRest
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest1 *
============================
 false
</pre>
<pre class="code extensibella"id="1033">
 &lt; <b>IsNewID: apply plus_integer_is_integer to _ _ FTK1.</b>

Subgoal 2:

Variables: ID CID CA KRest CB NewID KRest1 C Rest
IH : forall F ID K CID CA KRest CB,
       formulaToKnown ID F K * -&gt; is_integer ID -&gt; select (CID, CA) KRest K -&gt; mem (CID, CB) KRest -&gt;
       false
FTK : formulaToKnown ID (and C Rest) ((ID, C)::KRest1) @
IsID : is_integer ID
Slct : select (CID, CA) KRest ((ID, C)::KRest1)
Mem : mem (CID, CB) KRest
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest1 *
IsNewID : is_integer NewID
============================
 false
</pre>
<pre class="code extensibella"id="1034">
 &lt; <b>G: apply greater_plus_positive to _ _ FTK1 _.</b>

Subgoal 2:

Variables: ID CID CA KRest CB NewID KRest1 C Rest
IH : forall F ID K CID CA KRest CB,
       formulaToKnown ID F K * -&gt; is_integer ID -&gt; select (CID, CA) KRest K -&gt; mem (CID, CB) KRest -&gt;
       false
FTK : formulaToKnown ID (and C Rest) ((ID, C)::KRest1) @
IsID : is_integer ID
Slct : select (CID, CA) KRest ((ID, C)::KRest1)
Mem : mem (CID, CB) KRest
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest1 *
IsNewID : is_integer NewID
G : NewID &gt; ID
============================
 false
</pre>
<pre class="code extensibella"id="1035">
 &lt; <b>Slct: case Slct.</b>

Subgoal 2.1:

Variables: ID CB NewID KRest1 C Rest
IH : forall F ID K CID CA KRest CB,
       formulaToKnown ID F K * -&gt; is_integer ID -&gt; select (CID, CA) KRest K -&gt; mem (CID, CB) KRest -&gt;
       false
FTK : formulaToKnown ID (and C Rest) ((ID, C)::KRest1) @
IsID : is_integer ID
Mem : mem (ID, CB) KRest1
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest1 *
IsNewID : is_integer NewID
G : NewID &gt; ID
============================
 false
</pre>
<pre class="code extensibella"id="1036">
 &lt; <b>GEq: apply formulaToKnown_all_greater to FTK2 Mem IsNewID.</b>

Subgoal 2.1:

Variables: ID CB NewID KRest1 C Rest
IH : forall F ID K CID CA KRest CB,
       formulaToKnown ID F K * -&gt; is_integer ID -&gt; select (CID, CA) KRest K -&gt; mem (CID, CB) KRest -&gt;
       false
FTK : formulaToKnown ID (and C Rest) ((ID, C)::KRest1) @
IsID : is_integer ID
Mem : mem (ID, CB) KRest1
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest1 *
IsNewID : is_integer NewID
G : NewID &gt; ID
GEq : ID &gt;= NewID
============================
 false
</pre>
<pre class="code extensibella"id="1037">
 &lt; <b>Or: apply greatereq_integer_greater_or_eq to GEq.</b>

Subgoal 2.1:

Variables: ID CB NewID KRest1 C Rest
IH : forall F ID K CID CA KRest CB,
       formulaToKnown ID F K * -&gt; is_integer ID -&gt; select (CID, CA) KRest K -&gt; mem (CID, CB) KRest -&gt;
       false
FTK : formulaToKnown ID (and C Rest) ((ID, C)::KRest1) @
IsID : is_integer ID
Mem : mem (ID, CB) KRest1
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest1 *
IsNewID : is_integer NewID
G : NewID &gt; ID
GEq : ID &gt;= NewID
Or : ID &gt; NewID \/ ID = NewID
============================
 false
</pre>
<pre class="code extensibella"id="1038">
 &lt; <b>Or: case Or.</b>

Subgoal 2.1.1:

Variables: ID CB NewID KRest1 C Rest
IH : forall F ID K CID CA KRest CB,
       formulaToKnown ID F K * -&gt; is_integer ID -&gt; select (CID, CA) KRest K -&gt; mem (CID, CB) KRest -&gt;
       false
FTK : formulaToKnown ID (and C Rest) ((ID, C)::KRest1) @
IsID : is_integer ID
Mem : mem (ID, CB) KRest1
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest1 *
IsNewID : is_integer NewID
G : NewID &gt; ID
GEq : ID &gt;= NewID
Or : ID &gt; NewID
============================
 false
</pre>
<pre class="code extensibella"id="1039">
 &lt; <b>L: apply greater_integer_flip_less to Or.</b>

Subgoal 2.1.1:

Variables: ID CB NewID KRest1 C Rest
IH : forall F ID K CID CA KRest CB,
       formulaToKnown ID F K * -&gt; is_integer ID -&gt; select (CID, CA) KRest K -&gt; mem (CID, CB) KRest -&gt;
       false
FTK : formulaToKnown ID (and C Rest) ((ID, C)::KRest1) @
IsID : is_integer ID
Mem : mem (ID, CB) KRest1
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest1 *
IsNewID : is_integer NewID
G : NewID &gt; ID
GEq : ID &gt;= NewID
Or : ID &gt; NewID
L : NewID &lt; ID
============================
 false
</pre>
<pre class="code extensibella"id="1040">
 &lt; <b>apply greater_less_impossible to G L.</b>

Subgoal 2.1.2:

Variables: CB NewID KRest1 C Rest
IH : forall F ID K CID CA KRest CB,
       formulaToKnown ID F K * -&gt; is_integer ID -&gt; select (CID, CA) KRest K -&gt; mem (CID, CB) KRest -&gt;
       false
FTK : formulaToKnown NewID (and C Rest) ((NewID, C)::KRest1) @
IsID : is_integer NewID
Mem : mem (NewID, CB) KRest1
FTK1 : NewID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest1 *
IsNewID : is_integer NewID
G : NewID &gt; NewID
GEq : NewID &gt;= NewID
============================
 false
</pre>
<pre class="code extensibella"id="1041">
 &lt; <b>apply greater_integer_not_eq to G.</b>

Subgoal 2.2:

Variables: ID CID CA CB NewID KRest1 C Rest L1
IH : forall F ID K CID CA KRest CB,
       formulaToKnown ID F K * -&gt; is_integer ID -&gt; select (CID, CA) KRest K -&gt; mem (CID, CB) KRest -&gt;
       false
FTK : formulaToKnown ID (and C Rest) ((ID, C)::KRest1) @
IsID : is_integer ID
Mem : mem (CID, CB) ((ID, C)::L1)
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest1 *
IsNewID : is_integer NewID
G : NewID &gt; ID
Slct : select (CID, CA) L1 KRest1
============================
 false
</pre>
<pre class="code extensibella"id="1042">
 &lt; <b>Mem: case Mem.</b>

Subgoal 2.2.1:

Variables: ID CA NewID KRest1 C Rest L1
IH : forall F ID K CID CA KRest CB,
       formulaToKnown ID F K * -&gt; is_integer ID -&gt; select (CID, CA) KRest K -&gt; mem (CID, CB) KRest -&gt;
       false
FTK : formulaToKnown ID (and C Rest) ((ID, C)::KRest1) @
IsID : is_integer ID
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest1 *
IsNewID : is_integer NewID
G : NewID &gt; ID
Slct : select (ID, CA) L1 KRest1
============================
 false
</pre>
<pre class="code extensibella"id="1043">
 &lt; <b>MS: apply select_mem to Slct.</b>

Subgoal 2.2.1:

Variables: ID CA NewID KRest1 C Rest L1
IH : forall F ID K CID CA KRest CB,
       formulaToKnown ID F K * -&gt; is_integer ID -&gt; select (CID, CA) KRest K -&gt; mem (CID, CB) KRest -&gt;
       false
FTK : formulaToKnown ID (and C Rest) ((ID, C)::KRest1) @
IsID : is_integer ID
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest1 *
IsNewID : is_integer NewID
G : NewID &gt; ID
Slct : select (ID, CA) L1 KRest1
MS : mem (ID, CA) KRest1
============================
 false
</pre>
<pre class="code extensibella"id="1044">
 &lt; <b>GEq: apply formulaToKnown_all_greater to FTK2 MS IsNewID.</b>

Subgoal 2.2.1:

Variables: ID CA NewID KRest1 C Rest L1
IH : forall F ID K CID CA KRest CB,
       formulaToKnown ID F K * -&gt; is_integer ID -&gt; select (CID, CA) KRest K -&gt; mem (CID, CB) KRest -&gt;
       false
FTK : formulaToKnown ID (and C Rest) ((ID, C)::KRest1) @
IsID : is_integer ID
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest1 *
IsNewID : is_integer NewID
G : NewID &gt; ID
Slct : select (ID, CA) L1 KRest1
MS : mem (ID, CA) KRest1
GEq : ID &gt;= NewID
============================
 false
</pre>
<pre class="code extensibella"id="1045">
 &lt; <b>Or: apply greatereq_integer_greater_or_eq to GEq.</b>

Subgoal 2.2.1:

Variables: ID CA NewID KRest1 C Rest L1
IH : forall F ID K CID CA KRest CB,
       formulaToKnown ID F K * -&gt; is_integer ID -&gt; select (CID, CA) KRest K -&gt; mem (CID, CB) KRest -&gt;
       false
FTK : formulaToKnown ID (and C Rest) ((ID, C)::KRest1) @
IsID : is_integer ID
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest1 *
IsNewID : is_integer NewID
G : NewID &gt; ID
Slct : select (ID, CA) L1 KRest1
MS : mem (ID, CA) KRest1
GEq : ID &gt;= NewID
Or : ID &gt; NewID \/ ID = NewID
============================
 false
</pre>
<pre class="code extensibella"id="1046">
 &lt; <b>Or: case Or.</b>

Subgoal 2.2.1.1:

Variables: ID CA NewID KRest1 C Rest L1
IH : forall F ID K CID CA KRest CB,
       formulaToKnown ID F K * -&gt; is_integer ID -&gt; select (CID, CA) KRest K -&gt; mem (CID, CB) KRest -&gt;
       false
FTK : formulaToKnown ID (and C Rest) ((ID, C)::KRest1) @
IsID : is_integer ID
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest1 *
IsNewID : is_integer NewID
G : NewID &gt; ID
Slct : select (ID, CA) L1 KRest1
MS : mem (ID, CA) KRest1
GEq : ID &gt;= NewID
Or : ID &gt; NewID
============================
 false
</pre>
<pre class="code extensibella"id="1047">
 &lt; <b>L: apply greater_integer_flip_less to Or.</b>

Subgoal 2.2.1.1:

Variables: ID CA NewID KRest1 C Rest L1
IH : forall F ID K CID CA KRest CB,
       formulaToKnown ID F K * -&gt; is_integer ID -&gt; select (CID, CA) KRest K -&gt; mem (CID, CB) KRest -&gt;
       false
FTK : formulaToKnown ID (and C Rest) ((ID, C)::KRest1) @
IsID : is_integer ID
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest1 *
IsNewID : is_integer NewID
G : NewID &gt; ID
Slct : select (ID, CA) L1 KRest1
MS : mem (ID, CA) KRest1
GEq : ID &gt;= NewID
Or : ID &gt; NewID
L : NewID &lt; ID
============================
 false
</pre>
<pre class="code extensibella"id="1048">
 &lt; <b>apply greater_less_impossible to G L.</b>

Subgoal 2.2.1.2:

Variables: CA NewID KRest1 C Rest L1
IH : forall F ID K CID CA KRest CB,
       formulaToKnown ID F K * -&gt; is_integer ID -&gt; select (CID, CA) KRest K -&gt; mem (CID, CB) KRest -&gt;
       false
FTK : formulaToKnown NewID (and C Rest) ((NewID, C)::KRest1) @
IsID : is_integer NewID
FTK1 : NewID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest1 *
IsNewID : is_integer NewID
G : NewID &gt; NewID
Slct : select (NewID, CA) L1 KRest1
MS : mem (NewID, CA) KRest1
GEq : NewID &gt;= NewID
============================
 false
</pre>
<pre class="code extensibella"id="1049">
 &lt; <b>apply greater_integer_not_eq to G.</b>

Subgoal 2.2.2:

Variables: ID CID CA CB NewID KRest1 C Rest L1
IH : forall F ID K CID CA KRest CB,
       formulaToKnown ID F K * -&gt; is_integer ID -&gt; select (CID, CA) KRest K -&gt; mem (CID, CB) KRest -&gt;
       false
FTK : formulaToKnown ID (and C Rest) ((ID, C)::KRest1) @
IsID : is_integer ID
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest1 *
IsNewID : is_integer NewID
G : NewID &gt; ID
Slct : select (CID, CA) L1 KRest1
Mem : mem (CID, CB) L1
============================
 false
</pre>
<pre class="code extensibella"id="1050">
 &lt; <b>apply IH to FTK2 IsNewID Slct Mem.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="1051">
 &lt; <b>Extensible_Theorem
      formulaToKnown_sat_formula : forall F ID K A CID C,
         FTK : formulaToKnown ID F K -&gt;
         Sat : sat_formula A F -&gt;
         Mem : mem (CID, C) K -&gt;
         sat_clause A C
      on FTK.</b>

Subgoal 1:

Variables: ID A CID C
IH : forall F ID K A CID C,
       formulaToKnown ID F K * -&gt; sat_formula A F -&gt; mem (CID, C) K -&gt; sat_clause A C
FTK : formulaToKnown ID emptyFormula [] @
Sat : sat_formula A emptyFormula
Mem : mem (CID, C) []
============================
 sat_clause A C
</pre>
<pre class="code extensibella"id="1052">
 &lt; <b>case Mem.</b>

Subgoal 2:

Variables: ID A CID C NewID KRest C1 Rest
IH : forall F ID K A CID C,
       formulaToKnown ID F K * -&gt; sat_formula A F -&gt; mem (CID, C) K -&gt; sat_clause A C
FTK : formulaToKnown ID (and C1 Rest) ((ID, C1)::KRest) @
Sat : sat_formula A (and C1 Rest)
Mem : mem (CID, C) ((ID, C1)::KRest)
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest *
============================
 sat_clause A C
</pre>
<pre class="code extensibella"id="1053">
 &lt; <b>Sat: case Sat.</b>

Subgoal 2:

Variables: ID A CID C NewID KRest C1 Rest
IH : forall F ID K A CID C,
       formulaToKnown ID F K * -&gt; sat_formula A F -&gt; mem (CID, C) K -&gt; sat_clause A C
FTK : formulaToKnown ID (and C1 Rest) ((ID, C1)::KRest) @
Mem : mem (CID, C) ((ID, C1)::KRest)
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest *
Sat : sat_clause A C1
Sat1 : sat_formula A Rest
============================
 sat_clause A C
</pre>
<pre class="code extensibella"id="1054">
 &lt; <b>Mem: case Mem.</b>

Subgoal 2.1:

Variables: ID A NewID KRest C1 Rest
IH : forall F ID K A CID C,
       formulaToKnown ID F K * -&gt; sat_formula A F -&gt; mem (CID, C) K -&gt; sat_clause A C
FTK : formulaToKnown ID (and C1 Rest) ((ID, C1)::KRest) @
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest *
Sat : sat_clause A C1
Sat1 : sat_formula A Rest
============================
 sat_clause A C1
</pre>
<pre class="code extensibella"id="1055">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: ID A CID C NewID KRest C1 Rest
IH : forall F ID K A CID C,
       formulaToKnown ID F K * -&gt; sat_formula A F -&gt; mem (CID, C) K -&gt; sat_clause A C
FTK : formulaToKnown ID (and C1 Rest) ((ID, C1)::KRest) @
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest *
Sat : sat_clause A C1
Sat1 : sat_formula A Rest
Mem : mem (CID, C) KRest
============================
 sat_clause A C
</pre>
<pre class="code extensibella"id="1056">
 &lt; <b>apply IH to FTK2 Sat1 Mem.</b>

Subgoal 2.2:

Variables: ID A CID C NewID KRest C1 Rest
IH : forall F ID K A CID C,
       formulaToKnown ID F K * -&gt; sat_formula A F -&gt; mem (CID, C) K -&gt; sat_clause A C
FTK : formulaToKnown ID (and C1 Rest) ((ID, C1)::KRest) @
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest *
Sat : sat_clause A C1
Sat1 : sat_formula A Rest
Mem : mem (CID, C) KRest
H1 : sat_clause A C
============================
 sat_clause A C
</pre>
<pre class="code extensibella"id="1057">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="1058">
 &lt; <b>Extensible_Theorem
      formulaToKnown_is : forall F ID K,
         IsF : is_formula F -&gt;
         IsID : is_integer ID -&gt;
         FTK : formulaToKnown ID F K -&gt;
         is_list (is_pair is_integer is_clause) K
      on FTK.</b>

Subgoal 1:

Variables: ID
IH : forall F ID K,
       is_formula F -&gt; is_integer ID -&gt; formulaToKnown ID F K * -&gt; is_list (is_pair is_integer is_clause) K
IsF : is_formula emptyFormula
IsID : is_integer ID
FTK : formulaToKnown ID emptyFormula [] @
============================
 is_list (is_pair is_integer is_clause) []
</pre>
<pre class="code extensibella"id="1059">
 &lt; <b>search.</b>

Subgoal 2:

Variables: ID NewID KRest C Rest
IH : forall F ID K,
       is_formula F -&gt; is_integer ID -&gt; formulaToKnown ID F K * -&gt; is_list (is_pair is_integer is_clause) K
IsF : is_formula (and C Rest)
IsID : is_integer ID
FTK : formulaToKnown ID (and C Rest) ((ID, C)::KRest) @
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest *
============================
 is_list (is_pair is_integer is_clause) ((ID, C)::KRest)
</pre>
<pre class="code extensibella"id="1060">
 &lt; <b>IsNewID: apply plus_integer_is_integer to IsID _ FTK1.</b>

Subgoal 2:

Variables: ID NewID KRest C Rest
IH : forall F ID K,
       is_formula F -&gt; is_integer ID -&gt; formulaToKnown ID F K * -&gt; is_list (is_pair is_integer is_clause) K
IsF : is_formula (and C Rest)
IsID : is_integer ID
FTK : formulaToKnown ID (and C Rest) ((ID, C)::KRest) @
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest *
IsNewID : is_integer NewID
============================
 is_list (is_pair is_integer is_clause) ((ID, C)::KRest)
</pre>
<pre class="code extensibella"id="1061">
 &lt; <b>Is: case IsF.</b>

Subgoal 2:

Variables: ID NewID KRest C Rest
IH : forall F ID K,
       is_formula F -&gt; is_integer ID -&gt; formulaToKnown ID F K * -&gt; is_list (is_pair is_integer is_clause) K
IsID : is_integer ID
FTK : formulaToKnown ID (and C Rest) ((ID, C)::KRest) @
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest *
IsNewID : is_integer NewID
Is : is_clause C
Is1 : is_formula Rest
============================
 is_list (is_pair is_integer is_clause) ((ID, C)::KRest)
</pre>
<pre class="code extensibella"id="1062">
 &lt; <b>apply IH to Is1 IsNewID FTK2.</b>

Subgoal 2:

Variables: ID NewID KRest C Rest
IH : forall F ID K,
       is_formula F -&gt; is_integer ID -&gt; formulaToKnown ID F K * -&gt; is_list (is_pair is_integer is_clause) K
IsID : is_integer ID
FTK : formulaToKnown ID (and C Rest) ((ID, C)::KRest) @
FTK1 : ID + 1 = NewID
FTK2 : formulaToKnown NewID Rest KRest *
IsNewID : is_integer NewID
Is : is_clause C
Is1 : is_formula Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 is_list (is_pair is_integer is_clause) ((ID, C)::KRest)
</pre>
<pre class="code extensibella"id="1063">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="1064">
 &lt; <b>Theorem proveFormula_correct :
     forall F Prf Sat,
       is_formula F -&gt; is_proof Prf -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt;
       proveFormula F Prf -&gt; sat_formula Sat F -&gt; false.</b>

============================
 forall F Prf Sat,
   is_formula F -&gt; is_proof Prf -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; proveFormula F Prf -&gt;
   sat_formula Sat F -&gt; false
</pre>
<pre class="code extensibella"id="1065">
 &lt; <b>intros IsF IsP IsSat GA_Sat PF Sat.</b>

Variables: F Prf Sat
IsF : is_formula F
IsP : is_proof Prf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
PF : proveFormula F Prf
Sat : sat_formula Sat F
============================
 false
</pre>
<pre class="code extensibella"id="1066">
 &lt; <b>PF: case PF.</b>

Variables: F Prf Sat KnownClauses
IsF : is_formula F
IsP : is_proof Prf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
Sat : sat_formula Sat F
PF : formulaToKnown 1 F KnownClauses
PF1 : checkProof KnownClauses Prf
============================
 false
</pre>
<pre class="code extensibella"id="1067">
 &lt; <b>GCL: assert good_clause_list KnownClauses.</b>

Subgoal 1:

Variables: F Prf Sat KnownClauses
IsF : is_formula F
IsP : is_proof Prf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
Sat : sat_formula Sat F
PF : formulaToKnown 1 F KnownClauses
PF1 : checkProof KnownClauses Prf
============================
 good_clause_list KnownClauses
</pre>
<pre class="code extensibella"id="1068">
 &lt; <b>unfold .</b>

Subgoal 1:

Variables: F Prf Sat KnownClauses
IsF : is_formula F
IsP : is_proof Prf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
Sat : sat_formula Sat F
PF : formulaToKnown 1 F KnownClauses
PF1 : checkProof KnownClauses Prf
============================
 forall ID C1 KRest C2,
   select (ID, C1) KRest KnownClauses -&gt; mem (ID, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="1069">
 &lt; <b>intros S M.</b>

Subgoal 1:

Variables: F Prf Sat KnownClauses ID C1 KRest C2
IsF : is_formula F
IsP : is_proof Prf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
Sat : sat_formula Sat F
PF : formulaToKnown 1 F KnownClauses
PF1 : checkProof KnownClauses Prf
S : select (ID, C1) KRest KnownClauses
M : mem (ID, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="1070">
 &lt; <b>backchain formulaToKnown_all_unique.</b>

Variables: F Prf Sat KnownClauses
IsF : is_formula F
IsP : is_proof Prf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
Sat : sat_formula Sat F
PF : formulaToKnown 1 F KnownClauses
PF1 : checkProof KnownClauses Prf
GCL : good_clause_list KnownClauses
============================
 false
</pre>
<pre class="code extensibella"id="1071">
 &lt; <b>SatC: assert forall CID C,
     lookup KnownClauses CID C -&gt; sat_clause Sat C.</b>

Subgoal 2:

Variables: F Prf Sat KnownClauses
IsF : is_formula F
IsP : is_proof Prf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
Sat : sat_formula Sat F
PF : formulaToKnown 1 F KnownClauses
PF1 : checkProof KnownClauses Prf
GCL : good_clause_list KnownClauses
============================
 forall CID C, lookup KnownClauses CID C -&gt; sat_clause Sat C
</pre>
<pre class="code extensibella"id="1072">
 &lt; <b>intros Lkp.</b>

Subgoal 2:

Variables: F Prf Sat KnownClauses CID C
IsF : is_formula F
IsP : is_proof Prf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
Sat : sat_formula Sat F
PF : formulaToKnown 1 F KnownClauses
PF1 : checkProof KnownClauses Prf
GCL : good_clause_list KnownClauses
Lkp : lookup KnownClauses CID C
============================
 sat_clause Sat C
</pre>
<pre class="code extensibella"id="1073">
 &lt; <b>M: apply lookup_mem to Lkp.</b>

Subgoal 2:

Variables: F Prf Sat KnownClauses CID C
IsF : is_formula F
IsP : is_proof Prf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
Sat : sat_formula Sat F
PF : formulaToKnown 1 F KnownClauses
PF1 : checkProof KnownClauses Prf
GCL : good_clause_list KnownClauses
Lkp : lookup KnownClauses CID C
M : mem (CID, C) KnownClauses
============================
 sat_clause Sat C
</pre>
<pre class="code extensibella"id="1074">
 &lt; <b>apply formulaToKnown_sat_formula to PF Sat M.</b>

Subgoal 2:

Variables: F Prf Sat KnownClauses CID C
IsF : is_formula F
IsP : is_proof Prf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
Sat : sat_formula Sat F
PF : formulaToKnown 1 F KnownClauses
PF1 : checkProof KnownClauses Prf
GCL : good_clause_list KnownClauses
Lkp : lookup KnownClauses CID C
M : mem (CID, C) KnownClauses
H1 : sat_clause Sat C
============================
 sat_clause Sat C
</pre>
<pre class="code extensibella"id="1075">
 &lt; <b>search.</b>

Variables: F Prf Sat KnownClauses
IsF : is_formula F
IsP : is_proof Prf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
Sat : sat_formula Sat F
PF : formulaToKnown 1 F KnownClauses
PF1 : checkProof KnownClauses Prf
GCL : good_clause_list KnownClauses
SatC : forall CID C, lookup KnownClauses CID C -&gt; sat_clause Sat C
============================
 false
</pre>
<pre class="code extensibella"id="1076">
 &lt; <b>IsK: apply formulaToKnown_is to IsF _ PF.</b>

Variables: F Prf Sat KnownClauses
IsF : is_formula F
IsP : is_proof Prf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
Sat : sat_formula Sat F
PF : formulaToKnown 1 F KnownClauses
PF1 : checkProof KnownClauses Prf
GCL : good_clause_list KnownClauses
SatC : forall CID C, lookup KnownClauses CID C -&gt; sat_clause Sat C
IsK : is_list (is_pair is_integer is_clause) KnownClauses
============================
 false
</pre>
<pre class="code extensibella"id="1077">
 &lt; <b>apply check_proof_correct to IsP IsSat GA_Sat GCL IsK PF1 SatC.</b>

Proof completed.
</pre>
</div>
<div class="section">
<a class="navlink" href="../description.html">Back to example home</a>
</div>
</body>
</html>
