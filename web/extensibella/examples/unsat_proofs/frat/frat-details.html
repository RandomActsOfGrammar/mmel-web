<html>
<head>
<title>Extensibella:  Extensibella Example:  unsat_proofs:frat - Details</title>
<link href="../../../../style.css" rel="stylesheet" type="text/css">
<script src="../../../../actions.js"></script>
<link rel="icon" href="../../../images/favicon.png" type="image/x-icon">
</head>
<body class="extensibella">
<div id="header-logo">
<a href="../../../index.html">
<img class="header-logo" src="../../../images/Extensibella.png" alt="Extensibella logo">
</a>
</div>
<h2>Reasoning Details</h2>
<div class="section">
<pre class="code extensibella">
 < <b>Module unsat_proofs:frat.</b>
</pre>
<pre class="code extensibella"id="1">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:proj_lit_unique.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="2">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:proj_lit_is.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="3">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:proj_clause_unique.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="4">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:proj_clause_is.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="5">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:proj_formula_unique.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="6">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:proj_formula_is.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="7">
 &lt; <b>Add_Proj_Rel unsat_proofs:lrat:is_clause.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="8">
 &lt; <b>Prove_Ext_Ind unsat_proofs:lrat:is_clause.</b>

Warning:  No definition of Ext Size for all relations in Ext Ind; defaulting to proving Ext Ind without Ext Size
Proof completed.
</pre>
<pre class="code extensibella"id="9">
 &lt; <b>Add_Proj_Rel unsat_proofs:lrat:is_formula.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="10">
 &lt; <b>Prove_Ext_Ind unsat_proofs:lrat:is_formula.</b>

Warning:  No definition of Ext Size for all relations in Ext Ind; defaulting to proving Ext Ind without Ext Size
Proof completed.
</pre>
<pre class="code extensibella"id="11">
 &lt; <b>Prove unsat_proofs:lrat:is_lit_pos_or_neg.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="12">
 &lt; <b>Prove unsat_proofs:lrat:is_clause_empty_or_not.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="13">
 &lt; <b>Prove unsat_proofs:lrat:is_clause_or_or_not.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="14">
 &lt; <b>Prove unsat_proofs:lrat:is_clause_eq_or_not.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="15">
 &lt; <b>Prove unsat_proofs:lrat:is_formula_empty_or_not.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="16">
 &lt; <b>Prove unsat_proofs:lrat:is_formula_and_or_not.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="17">
 &lt; <b>Prove unsat_proofs:lrat:is_formula_eq_or_not.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="18">
 &lt; <b>Extensible_Theorem
      is_finalClauses_addFClause_or_not : forall F,
         IsF : is_finalClauses F -&gt;
         (exists ID C F', F = addFClause ID C F') \/
         ((exists ID C F', F = addFClause ID C F') -&gt; false)
      on IsF.</b>

Subgoal 1:

Variables: FinalClauses Clause I
IH : forall F,
       is_finalClauses F * -&gt; (exists ID C F', F = addFClause ID C F') \/
       ((exists ID C F', F = addFClause ID C F') -&gt; false)
IsF : is_finalClauses (addFClause I Clause FinalClauses) @
IsF1 : is_integer I
IsF2 : is_clause Clause
IsF3 : is_finalClauses FinalClauses *
============================
 (exists ID C F', addFClause I Clause FinalClauses = addFClause ID C F') \/
 ((exists ID C F', addFClause I Clause FinalClauses = addFClause ID C F') -&gt; false)
</pre>
<pre class="code extensibella"id="19">
 &lt; <b>search.</b>

Subgoal 2:

IH : forall F,
       is_finalClauses F * -&gt; (exists ID C F', F = addFClause ID C F') \/
       ((exists ID C F', F = addFClause ID C F') -&gt; false)
IsF : is_finalClauses endFClause @
============================
 (exists ID C F', endFClause = addFClause ID C F') \/
 ((exists ID C F', endFClause = addFClause ID C F') -&gt; false)
</pre>
<pre class="code extensibella"id="20">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="21">
 &lt; <b>Extensible_Theorem
      is_finalClauses_endFClause_or_not : forall F,
         IsF : is_finalClauses F -&gt;
         F = endFClause \/
         (F = endFClause -&gt; false)
      on IsF.</b>

Subgoal 1:

Variables: FinalClauses Clause I
IH : forall F,
       is_finalClauses F * -&gt; F = endFClause \/ (F = endFClause -&gt; false)
IsF : is_finalClauses (addFClause I Clause FinalClauses) @
IsF1 : is_integer I
IsF2 : is_clause Clause
IsF3 : is_finalClauses FinalClauses *
============================
 addFClause I Clause FinalClauses = endFClause \/
 (addFClause I Clause FinalClauses = endFClause -&gt; false)
</pre>
<pre class="code extensibella"id="22">
 &lt; <b>search.</b>

Subgoal 2:

IH : forall F,
       is_finalClauses F * -&gt; F = endFClause \/ (F = endFClause -&gt; false)
IsF : is_finalClauses endFClause @
============================
 endFClause = endFClause \/ (endFClause = endFClause -&gt; false)
</pre>
<pre class="code extensibella"id="23">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="24">
 &lt; <b>Extensible_Theorem
      is_finalClauses_eq_or_not : forall F1 F2,
         IsF1 : is_finalClauses F1 -&gt;
         IsF2 : is_finalClauses F2 -&gt;
         F1 = F2 \/
         (F1 = F2 -&gt; false)
      on IsF1.</b>

Subgoal 1:

Variables: F2 FinalClauses Clause I
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause I Clause FinalClauses) @
IsF2 : is_finalClauses F2
IsF3 : is_integer I
IsF4 : is_clause Clause
IsF5 : is_finalClauses FinalClauses *
============================
 addFClause I Clause FinalClauses = F2 \/
 (addFClause I Clause FinalClauses = F2 -&gt; false)
</pre>
<pre class="code extensibella"id="25">
 &lt; <b>Or: apply is_finalClauses_addFClause_or_not to IsF2.</b>

Subgoal 1:

Variables: F2 FinalClauses Clause I
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause I Clause FinalClauses) @
IsF2 : is_finalClauses F2
IsF3 : is_integer I
IsF4 : is_clause Clause
IsF5 : is_finalClauses FinalClauses *
Or : (exists ID C F', F2 = addFClause ID C F') \/
     ((exists ID C F', F2 = addFClause ID C F') -&gt; false)
============================
 addFClause I Clause FinalClauses = F2 \/
 (addFClause I Clause FinalClauses = F2 -&gt; false)
</pre>
<pre class="code extensibella"id="26">
 &lt; <b>N: case Or.</b>

Subgoal 1.1:

Variables: FinalClauses Clause I ID C F'
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause I Clause FinalClauses) @
IsF2 : is_finalClauses (addFClause ID C F')
IsF3 : is_integer I
IsF4 : is_clause Clause
IsF5 : is_finalClauses FinalClauses *
============================
 addFClause I Clause FinalClauses = addFClause ID C F' \/
 (addFClause I Clause FinalClauses = addFClause ID C F' -&gt; false)
</pre>
<pre class="code extensibella"id="27">
 &lt; <b>Is': case IsF2.</b>

Subgoal 1.1:

Variables: FinalClauses Clause I ID C F'
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause I Clause FinalClauses) @
IsF3 : is_integer I
IsF4 : is_clause Clause
IsF5 : is_finalClauses FinalClauses *
Is' : is_integer ID
Is'1 : is_clause C
Is'2 : is_finalClauses F'
============================
 addFClause I Clause FinalClauses = addFClause ID C F' \/
 (addFClause I Clause FinalClauses = addFClause ID C F' -&gt; false)
</pre>
<pre class="code extensibella"id="28">
 &lt; <b>Or: apply is_integer_eq_or_not to IsF3 Is'.</b>

Subgoal 1.1:

Variables: FinalClauses Clause I ID C F'
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause I Clause FinalClauses) @
IsF3 : is_integer I
IsF4 : is_clause Clause
IsF5 : is_finalClauses FinalClauses *
Is' : is_integer ID
Is'1 : is_clause C
Is'2 : is_finalClauses F'
Or : I = ID \/ (I = ID -&gt; false)
============================
 addFClause I Clause FinalClauses = addFClause ID C F' \/
 (addFClause I Clause FinalClauses = addFClause ID C F' -&gt; false)
</pre>
<pre class="code extensibella"id="29">
 &lt; <b>N: case Or.</b>

Subgoal 1.1.1:

Variables: FinalClauses Clause ID C F'
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause ID Clause FinalClauses) @
IsF3 : is_integer ID
IsF4 : is_clause Clause
IsF5 : is_finalClauses FinalClauses *
Is' : is_integer ID
Is'1 : is_clause C
Is'2 : is_finalClauses F'
============================
 addFClause ID Clause FinalClauses = addFClause ID C F' \/
 (addFClause ID Clause FinalClauses = addFClause ID C F' -&gt; false)
</pre>
<pre class="code extensibella"id="30">
 &lt; <b>Or: apply is_clause_eq_or_not to IsF4 Is'1.</b>

Subgoal 1.1.1:

Variables: FinalClauses Clause ID C F'
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause ID Clause FinalClauses) @
IsF3 : is_integer ID
IsF4 : is_clause Clause
IsF5 : is_finalClauses FinalClauses *
Is' : is_integer ID
Is'1 : is_clause C
Is'2 : is_finalClauses F'
Or : Clause = C \/ (Clause = C -&gt; false)
============================
 addFClause ID Clause FinalClauses = addFClause ID C F' \/
 (addFClause ID Clause FinalClauses = addFClause ID C F' -&gt; false)
</pre>
<pre class="code extensibella"id="31">
 &lt; <b>N: case Or.</b>

Subgoal 1.1.1.1:

Variables: FinalClauses ID C F'
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause ID C FinalClauses) @
IsF3 : is_integer ID
IsF4 : is_clause C
IsF5 : is_finalClauses FinalClauses *
Is' : is_integer ID
Is'1 : is_clause C
Is'2 : is_finalClauses F'
============================
 addFClause ID C FinalClauses = addFClause ID C F' \/
 (addFClause ID C FinalClauses = addFClause ID C F' -&gt; false)
</pre>
<pre class="code extensibella"id="32">
 &lt; <b>Or: apply IH to IsF5 Is'2.</b>

Subgoal 1.1.1.1:

Variables: FinalClauses ID C F'
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause ID C FinalClauses) @
IsF3 : is_integer ID
IsF4 : is_clause C
IsF5 : is_finalClauses FinalClauses *
Is' : is_integer ID
Is'1 : is_clause C
Is'2 : is_finalClauses F'
Or : FinalClauses = F' \/ (FinalClauses = F' -&gt; false)
============================
 addFClause ID C FinalClauses = addFClause ID C F' \/
 (addFClause ID C FinalClauses = addFClause ID C F' -&gt; false)
</pre>
<pre class="code extensibella"id="33">
 &lt; <b>N: case Or.</b>

Subgoal 1.1.1.1.1:

Variables: ID C F'
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause ID C F') @
IsF3 : is_integer ID
IsF4 : is_clause C
IsF5 : is_finalClauses F' *
Is' : is_integer ID
Is'1 : is_clause C
Is'2 : is_finalClauses F'
============================
 addFClause ID C F' = addFClause ID C F' \/
 (addFClause ID C F' = addFClause ID C F' -&gt; false)
</pre>
<pre class="code extensibella"id="34">
 &lt; <b>search.</b>

Subgoal 1.1.1.1.2:

Variables: FinalClauses ID C F'
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause ID C FinalClauses) @
IsF3 : is_integer ID
IsF4 : is_clause C
IsF5 : is_finalClauses FinalClauses *
Is' : is_integer ID
Is'1 : is_clause C
Is'2 : is_finalClauses F'
N : FinalClauses = F' -&gt; false
============================
 addFClause ID C FinalClauses = addFClause ID C F' \/
 (addFClause ID C FinalClauses = addFClause ID C F' -&gt; false)
</pre>
<pre class="code extensibella"id="35">
 &lt; <b>right.</b>

Subgoal 1.1.1.1.2:

Variables: FinalClauses ID C F'
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause ID C FinalClauses) @
IsF3 : is_integer ID
IsF4 : is_clause C
IsF5 : is_finalClauses FinalClauses *
Is' : is_integer ID
Is'1 : is_clause C
Is'2 : is_finalClauses F'
N : FinalClauses = F' -&gt; false
============================
 addFClause ID C FinalClauses = addFClause ID C F' -&gt; false
</pre>
<pre class="code extensibella"id="36">
 &lt; <b>intros E.</b>

Subgoal 1.1.1.1.2:

Variables: FinalClauses ID C F'
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause ID C FinalClauses) @
IsF3 : is_integer ID
IsF4 : is_clause C
IsF5 : is_finalClauses FinalClauses *
Is' : is_integer ID
Is'1 : is_clause C
Is'2 : is_finalClauses F'
N : FinalClauses = F' -&gt; false
E : addFClause ID C FinalClauses = addFClause ID C F'
============================
 false
</pre>
<pre class="code extensibella"id="37">
 &lt; <b>case E.</b>

Subgoal 1.1.1.1.2:

Variables: ID C F'
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause ID C F') @
IsF3 : is_integer ID
IsF4 : is_clause C
IsF5 : is_finalClauses F' *
Is' : is_integer ID
Is'1 : is_clause C
Is'2 : is_finalClauses F'
N : F' = F' -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="38">
 &lt; <b>backchain N.</b>

Subgoal 1.1.1.2:

Variables: FinalClauses Clause ID C F'
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause ID Clause FinalClauses) @
IsF3 : is_integer ID
IsF4 : is_clause Clause
IsF5 : is_finalClauses FinalClauses *
Is' : is_integer ID
Is'1 : is_clause C
Is'2 : is_finalClauses F'
N : Clause = C -&gt; false
============================
 addFClause ID Clause FinalClauses = addFClause ID C F' \/
 (addFClause ID Clause FinalClauses = addFClause ID C F' -&gt; false)
</pre>
<pre class="code extensibella"id="39">
 &lt; <b>right.</b>

Subgoal 1.1.1.2:

Variables: FinalClauses Clause ID C F'
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause ID Clause FinalClauses) @
IsF3 : is_integer ID
IsF4 : is_clause Clause
IsF5 : is_finalClauses FinalClauses *
Is' : is_integer ID
Is'1 : is_clause C
Is'2 : is_finalClauses F'
N : Clause = C -&gt; false
============================
 addFClause ID Clause FinalClauses = addFClause ID C F' -&gt; false
</pre>
<pre class="code extensibella"id="40">
 &lt; <b>intros E.</b>

Subgoal 1.1.1.2:

Variables: FinalClauses Clause ID C F'
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause ID Clause FinalClauses) @
IsF3 : is_integer ID
IsF4 : is_clause Clause
IsF5 : is_finalClauses FinalClauses *
Is' : is_integer ID
Is'1 : is_clause C
Is'2 : is_finalClauses F'
N : Clause = C -&gt; false
E : addFClause ID Clause FinalClauses = addFClause ID C F'
============================
 false
</pre>
<pre class="code extensibella"id="41">
 &lt; <b>case E.</b>

Subgoal 1.1.1.2:

Variables: ID C F'
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause ID C F') @
IsF3 : is_integer ID
IsF4 : is_clause C
IsF5 : is_finalClauses F' *
Is' : is_integer ID
Is'1 : is_clause C
Is'2 : is_finalClauses F'
N : C = C -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="42">
 &lt; <b>backchain N.</b>

Subgoal 1.1.2:

Variables: FinalClauses Clause I ID C F'
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause I Clause FinalClauses) @
IsF3 : is_integer I
IsF4 : is_clause Clause
IsF5 : is_finalClauses FinalClauses *
Is' : is_integer ID
Is'1 : is_clause C
Is'2 : is_finalClauses F'
N : I = ID -&gt; false
============================
 addFClause I Clause FinalClauses = addFClause ID C F' \/
 (addFClause I Clause FinalClauses = addFClause ID C F' -&gt; false)
</pre>
<pre class="code extensibella"id="43">
 &lt; <b>right.</b>

Subgoal 1.1.2:

Variables: FinalClauses Clause I ID C F'
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause I Clause FinalClauses) @
IsF3 : is_integer I
IsF4 : is_clause Clause
IsF5 : is_finalClauses FinalClauses *
Is' : is_integer ID
Is'1 : is_clause C
Is'2 : is_finalClauses F'
N : I = ID -&gt; false
============================
 addFClause I Clause FinalClauses = addFClause ID C F' -&gt; false
</pre>
<pre class="code extensibella"id="44">
 &lt; <b>intros E.</b>

Subgoal 1.1.2:

Variables: FinalClauses Clause I ID C F'
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause I Clause FinalClauses) @
IsF3 : is_integer I
IsF4 : is_clause Clause
IsF5 : is_finalClauses FinalClauses *
Is' : is_integer ID
Is'1 : is_clause C
Is'2 : is_finalClauses F'
N : I = ID -&gt; false
E : addFClause I Clause FinalClauses = addFClause ID C F'
============================
 false
</pre>
<pre class="code extensibella"id="45">
 &lt; <b>case E.</b>

Subgoal 1.1.2:

Variables: ID C F'
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause ID C F') @
IsF3 : is_integer ID
IsF4 : is_clause C
IsF5 : is_finalClauses F' *
Is' : is_integer ID
Is'1 : is_clause C
Is'2 : is_finalClauses F'
N : ID = ID -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="46">
 &lt; <b>backchain N.</b>

Subgoal 1.2:

Variables: F2 FinalClauses Clause I
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause I Clause FinalClauses) @
IsF2 : is_finalClauses F2
IsF3 : is_integer I
IsF4 : is_clause Clause
IsF5 : is_finalClauses FinalClauses *
N : (exists ID C F', F2 = addFClause ID C F') -&gt; false
============================
 addFClause I Clause FinalClauses = F2 \/
 (addFClause I Clause FinalClauses = F2 -&gt; false)
</pre>
<pre class="code extensibella"id="47">
 &lt; <b>right.</b>

Subgoal 1.2:

Variables: F2 FinalClauses Clause I
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause I Clause FinalClauses) @
IsF2 : is_finalClauses F2
IsF3 : is_integer I
IsF4 : is_clause Clause
IsF5 : is_finalClauses FinalClauses *
N : (exists ID C F', F2 = addFClause ID C F') -&gt; false
============================
 addFClause I Clause FinalClauses = F2 -&gt; false
</pre>
<pre class="code extensibella"id="48">
 &lt; <b>intros E.</b>

Subgoal 1.2:

Variables: F2 FinalClauses Clause I
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause I Clause FinalClauses) @
IsF2 : is_finalClauses F2
IsF3 : is_integer I
IsF4 : is_clause Clause
IsF5 : is_finalClauses FinalClauses *
N : (exists ID C F', F2 = addFClause ID C F') -&gt; false
E : addFClause I Clause FinalClauses = F2
============================
 false
</pre>
<pre class="code extensibella"id="49">
 &lt; <b>case E.</b>

Subgoal 1.2:

Variables: FinalClauses Clause I
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses (addFClause I Clause FinalClauses) @
IsF2 : is_finalClauses (addFClause I Clause FinalClauses)
IsF3 : is_integer I
IsF4 : is_clause Clause
IsF5 : is_finalClauses FinalClauses *
N : (exists ID C F', addFClause I Clause FinalClauses = addFClause ID C F') -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="50">
 &lt; <b>backchain N.</b>

Subgoal 2:

Variables: F2
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses endFClause @
IsF2 : is_finalClauses F2
============================
 endFClause = F2 \/ (endFClause = F2 -&gt; false)
</pre>
<pre class="code extensibella"id="51">
 &lt; <b>Or: apply is_finalClauses_endFClause_or_not to IsF2.</b>

Subgoal 2:

Variables: F2
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses endFClause @
IsF2 : is_finalClauses F2
Or : F2 = endFClause \/ (F2 = endFClause -&gt; false)
============================
 endFClause = F2 \/ (endFClause = F2 -&gt; false)
</pre>
<pre class="code extensibella"id="52">
 &lt; <b>N: case Or.</b>

Subgoal 2.1:

IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses endFClause @
IsF2 : is_finalClauses endFClause
============================
 endFClause = endFClause \/ (endFClause = endFClause -&gt; false)
</pre>
<pre class="code extensibella"id="53">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: F2
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses endFClause @
IsF2 : is_finalClauses F2
N : F2 = endFClause -&gt; false
============================
 endFClause = F2 \/ (endFClause = F2 -&gt; false)
</pre>
<pre class="code extensibella"id="54">
 &lt; <b>right.</b>

Subgoal 2.2:

Variables: F2
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses endFClause @
IsF2 : is_finalClauses F2
N : F2 = endFClause -&gt; false
============================
 endFClause = F2 -&gt; false
</pre>
<pre class="code extensibella"id="55">
 &lt; <b>intros E.</b>

Subgoal 2.2:

Variables: F2
IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses endFClause @
IsF2 : is_finalClauses F2
N : F2 = endFClause -&gt; false
E : endFClause = F2
============================
 false
</pre>
<pre class="code extensibella"id="56">
 &lt; <b>case E.</b>

Subgoal 2.2:

IH : forall F1 F2,
       is_finalClauses F1 * -&gt; is_finalClauses F2 -&gt; F1 = F2 \/
       (F1 = F2 -&gt; false)
IsF1 : is_finalClauses endFClause @
IsF2 : is_finalClauses endFClause
N : endFClause = endFClause -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="57">
 &lt; <b>backchain N.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="58">
 &lt; <b>Prove unsat_proofs:lrat:negate_lit_unique.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="59">
 &lt; <b>Prove unsat_proofs:lrat:negate_lit_reverse.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="60">
 &lt; <b>Prove unsat_proofs:lrat:negate_lit_not_same.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="61">
 &lt; <b>Prove unsat_proofs:lrat:negate_lit_is_lit.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="62">
 &lt; <b>Prove unsat_proofs:lrat:negate_lit_is_lit_back.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="63">
 &lt; <b>Prove unsat_proofs:lrat:negate_lit_exists.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="64">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:sat_clause_ext_to_proj.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="65">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:sat_clause_proj_to_ext.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="66">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:unsat_clause_ext_to_proj.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="67">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:unsat_clause_proj_to_ext.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="68">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:sat_formula_ext_to_proj.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="69">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:sat_formula_proj_to_ext.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="70">
 &lt; <b>Prove unsat_proofs:lrat:unsat_sat_clause.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="71">
 &lt; <b>Prove unsat_proofs:lrat:sat_clause_orderless.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="72">
 &lt; <b>Prove unsat_proofs:lrat:sat_formula_orderless.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="73">
 &lt; <b>Prove unsat_proofs:lrat:unsat_clause_orderless.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="74">
 &lt; <b>Prove unsat_proofs:lrat:unit_clause_is.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="75">
 &lt; <b>Prove unsat_proofs:lrat:unit_clause_unique.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="76">
 &lt; <b>Prove unsat_proofs:lrat:unit_clause_not_assigned.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="77">
 &lt; <b>Prove unsat_proofs:lrat:unit_clause_not_assigned_negate.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="78">
 &lt; <b>Prove unsat_proofs:lrat:unit_clause_expand.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="79">
 &lt; <b>Prove unsat_proofs:lrat:unit_clause_add.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="80">
 &lt; <b>Prove unsat_proofs:lrat:gatherLits_is.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="81">
 &lt; <b>Prove unsat_proofs:lrat:gatherLits_exists.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="82">
 &lt; <b>Prove unsat_proofs:lrat:gatherLits_permutation.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="83">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:proj_gatherLits.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="84">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:proj_gatherLits_permutation.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="85">
 &lt; <b>Prove unsat_proofs:lrat:gatherLits_sat.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="86">
 &lt; <b>Prove unsat_proofs:lrat:gatherLits_mem_sat.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="87">
 &lt; <b>Prove unsat_proofs:lrat:gatherLits_unsat.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="88">
 &lt; <b>Prove unsat_proofs:lrat:negate_lits_unsat.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="89">
 &lt; <b>Extensible_Theorem
      checkFinalClauses_orderless : forall K1 K2 FC,
         IsK1 : is_list (is_pair is_integer is_clause) K1 -&gt;
         IsK2 : is_list (is_pair is_integer is_clause) K2 -&gt;
         CFC : checkFinalClauses K1 FC -&gt;
         Prm : permutation K1 K2 -&gt;
         checkFinalClauses K2 FC
      on CFC.</b>

Subgoal 1:

Variables: K1 K2 KRest Rest C ID
IH : forall K1 K2 FC,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       checkFinalClauses K1 FC * -&gt; permutation K1 K2 -&gt; checkFinalClauses K2 FC
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
CFC : checkFinalClauses K1 (addFClause ID C Rest) @
Prm : permutation K1 K2
CFC1 : select (ID, C) KRest K1
CFC2 : checkFinalClauses KRest Rest *
============================
 checkFinalClauses K2 (addFClause ID C Rest)
</pre>
<pre class="code extensibella"id="90">
 &lt; <b>M1: apply select_mem to CFC1.</b>

Subgoal 1:

Variables: K1 K2 KRest Rest C ID
IH : forall K1 K2 FC,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       checkFinalClauses K1 FC * -&gt; permutation K1 K2 -&gt; checkFinalClauses K2 FC
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
CFC : checkFinalClauses K1 (addFClause ID C Rest) @
Prm : permutation K1 K2
CFC1 : select (ID, C) KRest K1
CFC2 : checkFinalClauses KRest Rest *
M1 : mem (ID, C) K1
============================
 checkFinalClauses K2 (addFClause ID C Rest)
</pre>
<pre class="code extensibella"id="91">
 &lt; <b>M2: apply permutation_mem to Prm M1.</b>

Subgoal 1:

Variables: K1 K2 KRest Rest C ID
IH : forall K1 K2 FC,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       checkFinalClauses K1 FC * -&gt; permutation K1 K2 -&gt; checkFinalClauses K2 FC
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
CFC : checkFinalClauses K1 (addFClause ID C Rest) @
Prm : permutation K1 K2
CFC1 : select (ID, C) KRest K1
CFC2 : checkFinalClauses KRest Rest *
M1 : mem (ID, C) K1
M2 : mem (ID, C) K2
============================
 checkFinalClauses K2 (addFClause ID C Rest)
</pre>
<pre class="code extensibella"id="92">
 &lt; <b>S: apply mem_select to M2.</b>

Subgoal 1:

Variables: K1 K2 KRest Rest C ID L'
IH : forall K1 K2 FC,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       checkFinalClauses K1 FC * -&gt; permutation K1 K2 -&gt; checkFinalClauses K2 FC
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
CFC : checkFinalClauses K1 (addFClause ID C Rest) @
Prm : permutation K1 K2
CFC1 : select (ID, C) KRest K1
CFC2 : checkFinalClauses KRest Rest *
M1 : mem (ID, C) K1
M2 : mem (ID, C) K2
S : select (ID, C) L' K2
============================
 checkFinalClauses K2 (addFClause ID C Rest)
</pre>
<pre class="code extensibella"id="93">
 &lt; <b>apply selects_permutation to _ _ Prm _ _.</b>

Subgoal 1:

Variables: K1 K2 KRest Rest C ID L'
IH : forall K1 K2 FC,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       checkFinalClauses K1 FC * -&gt; permutation K1 K2 -&gt; checkFinalClauses K2 FC
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
CFC : checkFinalClauses K1 (addFClause ID C Rest) @
Prm : permutation K1 K2
CFC1 : select (ID, C) KRest K1
CFC2 : checkFinalClauses KRest Rest *
M1 : mem (ID, C) K1
M2 : mem (ID, C) K2
S : select (ID, C) L' K2
H1 : permutation KRest L'
============================
 checkFinalClauses K2 (addFClause ID C Rest)
</pre>
<pre class="code extensibella"id="94">
 &lt; <b>apply select_is to IsK1 _.</b>

Subgoal 1:

Variables: K1 K2 KRest Rest C ID L'
IH : forall K1 K2 FC,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       checkFinalClauses K1 FC * -&gt; permutation K1 K2 -&gt; checkFinalClauses K2 FC
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
CFC : checkFinalClauses K1 (addFClause ID C Rest) @
Prm : permutation K1 K2
CFC1 : select (ID, C) KRest K1
CFC2 : checkFinalClauses KRest Rest *
M1 : mem (ID, C) K1
M2 : mem (ID, C) K2
S : select (ID, C) L' K2
H1 : permutation KRest L'
H2 : is_list (is_pair is_integer is_clause) KRest
============================
 checkFinalClauses K2 (addFClause ID C Rest)
</pre>
<pre class="code extensibella"id="95">
 &lt; <b>apply select_is to IsK2 _.</b>

Subgoal 1:

Variables: K1 K2 KRest Rest C ID L'
IH : forall K1 K2 FC,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       checkFinalClauses K1 FC * -&gt; permutation K1 K2 -&gt; checkFinalClauses K2 FC
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
CFC : checkFinalClauses K1 (addFClause ID C Rest) @
Prm : permutation K1 K2
CFC1 : select (ID, C) KRest K1
CFC2 : checkFinalClauses KRest Rest *
M1 : mem (ID, C) K1
M2 : mem (ID, C) K2
S : select (ID, C) L' K2
H1 : permutation KRest L'
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : is_list (is_pair is_integer is_clause) L'
============================
 checkFinalClauses K2 (addFClause ID C Rest)
</pre>
<pre class="code extensibella"id="96">
 &lt; <b>apply IH to _ _ CFC2 _.</b>

Subgoal 1:

Variables: K1 K2 KRest Rest C ID L'
IH : forall K1 K2 FC,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       checkFinalClauses K1 FC * -&gt; permutation K1 K2 -&gt; checkFinalClauses K2 FC
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
CFC : checkFinalClauses K1 (addFClause ID C Rest) @
Prm : permutation K1 K2
CFC1 : select (ID, C) KRest K1
CFC2 : checkFinalClauses KRest Rest *
M1 : mem (ID, C) K1
M2 : mem (ID, C) K2
S : select (ID, C) L' K2
H1 : permutation KRest L'
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : is_list (is_pair is_integer is_clause) L'
H4 : checkFinalClauses L' Rest
============================
 checkFinalClauses K2 (addFClause ID C Rest)
</pre>
<pre class="code extensibella"id="97">
 &lt; <b>search.</b>

Subgoal 2:

Variables: K2
IH : forall K1 K2 FC,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       checkFinalClauses K1 FC * -&gt; permutation K1 K2 -&gt; checkFinalClauses K2 FC
IsK1 : is_list (is_pair is_integer is_clause) []
IsK2 : is_list (is_pair is_integer is_clause) K2
CFC : checkFinalClauses [] endFClause @
Prm : permutation [] K2
============================
 checkFinalClauses K2 endFClause
</pre>
<pre class="code extensibella"id="98">
 &lt; <b>case Prm.</b>

Subgoal 2:

IH : forall K1 K2 FC,
       is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       checkFinalClauses K1 FC * -&gt; permutation K1 K2 -&gt; checkFinalClauses K2 FC
IsK1 : is_list (is_pair is_integer is_clause) []
IsK2 : is_list (is_pair is_integer is_clause) []
CFC : checkFinalClauses [] endFClause @
============================
 checkFinalClauses [] endFClause
</pre>
<pre class="code extensibella"id="99">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="100">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:proj_proof_is.</b>

Subgoal 1:

Variables: Known Prf ID FC
Proj : Known |{proof}- endFrat ID FC ~~&gt; emptyLrat ID Prf
IsP : is_proof (endFrat ID FC)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Proj1 : rupProof Known emptyClause Prf
============================
 is_proof (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="101">
 &lt; <b>Is: case IsP.</b>

Subgoal 1:

Variables: Known Prf ID FC
Proj : Known |{proof}- endFrat ID FC ~~&gt; emptyLrat ID Prf
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Proj1 : rupProof Known emptyClause Prf
Is : is_integer ID
Is1 : is_finalClauses FC
============================
 is_proof (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="102">
 &lt; <b>apply rupProof_is to Proj1 IsKnown.</b>

Subgoal 1:

Variables: Known Prf ID FC
Proj : Known |{proof}- endFrat ID FC ~~&gt; emptyLrat ID Prf
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Proj1 : rupProof Known emptyClause Prf
Is : is_integer ID
Is1 : is_finalClauses FC
H1 : is_list is_integer Prf
============================
 is_proof (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="103">
 &lt; <b>search.</b>

Subgoal 2:

Variables: Known Prf ID FC
Proj : Known |{proof}- endFratPrf ID Prf FC ~~&gt; emptyLrat ID Prf
IsP : is_proof (endFratPrf ID Prf FC)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
============================
 is_proof (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="104">
 &lt; <b>Is: case IsP.</b>

Subgoal 2:

Variables: Known Prf ID FC
Proj : Known |{proof}- endFratPrf ID Prf FC ~~&gt; emptyLrat ID Prf
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Is : is_integer ID
Is1 : is_list is_integer Prf
Is2 : is_finalClauses FC
============================
 is_proof (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="105">
 &lt; <b>search.</b>

Subgoal 3:

Variables: Known Rest Prf C ID
Proj : Known |{proof}- addProofless ID C Rest ~~&gt; addLrupProof ID C Prf Rest
IsP : is_proof (addProofless ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Proj1 : rupProof Known C Prf
============================
 is_proof (addLrupProof ID C Prf Rest)
</pre>
<pre class="code extensibella"id="106">
 &lt; <b>Is: case IsP.</b>

Subgoal 3:

Variables: Known Rest Prf C ID
Proj : Known |{proof}- addProofless ID C Rest ~~&gt; addLrupProof ID C Prf Rest
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Proj1 : rupProof Known C Prf
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
============================
 is_proof (addLrupProof ID C Prf Rest)
</pre>
<pre class="code extensibella"id="107">
 &lt; <b>apply rupProof_is to Proj1 IsKnown.</b>

Subgoal 3:

Variables: Known Rest Prf C ID
Proj : Known |{proof}- addProofless ID C Rest ~~&gt; addLrupProof ID C Prf Rest
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Proj1 : rupProof Known C Prf
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list is_integer Prf
============================
 is_proof (addLrupProof ID C Prf Rest)
</pre>
<pre class="code extensibella"id="108">
 &lt; <b>search.</b>

Subgoal 4:

Variables: Known Rest F C T
Proj : Known |{proof}- relocateClause F T Rest ~~&gt; addLrupProof T C [F] (deleteLratProof F Rest)
IsP : is_proof (relocateClause F T Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Proj1 : T = F -&gt; false
Proj2 : mem (F, C) Known
============================
 is_proof (addLrupProof T C [F] (deleteLratProof F Rest))
</pre>
<pre class="code extensibella"id="109">
 &lt; <b>Is: case IsP.</b>

Subgoal 4:

Variables: Known Rest F C T
Proj : Known |{proof}- relocateClause F T Rest ~~&gt; addLrupProof T C [F] (deleteLratProof F Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Proj1 : T = F -&gt; false
Proj2 : mem (F, C) Known
Is : is_integer F
Is1 : is_integer T
Is2 : is_proof Rest
============================
 is_proof (addLrupProof T C [F] (deleteLratProof F Rest))
</pre>
<pre class="code extensibella"id="110">
 &lt; <b>IsFC: apply mem_is to IsKnown Proj2.</b>

Subgoal 4:

Variables: Known Rest T ID C1
Proj : Known |{proof}- relocateClause ID T Rest ~~&gt; addLrupProof T C1 [ID] (deleteLratProof ID Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Proj1 : T = ID -&gt; false
Proj2 : mem (ID, C1) Known
Is : is_integer ID
Is1 : is_integer T
Is2 : is_proof Rest
IsFC : is_integer ID
IsFC1 : is_clause C1
============================
 is_proof (addLrupProof T C1 [ID] (deleteLratProof ID Rest))
</pre>
<pre class="code extensibella"id="111">
 &lt; <b>search.</b>

Subgoal 5:

Variables: Known PT ID
Proj : Known |{proof}- relocateClause ID ID PT ~~&gt; PT
IsP : is_proof (relocateClause ID ID PT)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
============================
 is_proof PT
</pre>
<pre class="code extensibella"id="112">
 &lt; <b>Is: case IsP.</b>

Subgoal 5:

Variables: Known PT ID
Proj : Known |{proof}- relocateClause ID ID PT ~~&gt; PT
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Is : is_integer ID
Is1 : is_integer ID
Is2 : is_proof PT
============================
 is_proof PT
</pre>
<pre class="code extensibella"id="113">
 &lt; <b>search.</b>

Subgoal 6:

Variables: Known Rest ID C
Proj : Known |{proof}- deleteFrat ID C Rest ~~&gt; deleteLratProof ID Rest
IsP : is_proof (deleteFrat ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
============================
 is_proof (deleteLratProof ID Rest)
</pre>
<pre class="code extensibella"id="114">
 &lt; <b>case IsP.</b>

Subgoal 6:

Variables: Known Rest ID C
Proj : Known |{proof}- deleteFrat ID C Rest ~~&gt; deleteLratProof ID Rest
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
============================
 is_proof (deleteLratProof ID Rest)
</pre>
<pre class="code extensibella"id="115">
 &lt; <b>search.</b>

Subgoal 7:

Variables: Known PT Comment
Proj : Known |{proof}- commentProof Comment PT ~~&gt; PT
IsP : is_proof (commentProof Comment PT)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
============================
 is_proof PT
</pre>
<pre class="code extensibella"id="116">
 &lt; <b>case IsP.</b>

Subgoal 7:

Variables: Known PT Comment
Proj : Known |{proof}- commentProof Comment PT ~~&gt; PT
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
H1 : is_string Comment
H2 : is_proof PT
============================
 is_proof PT
</pre>
<pre class="code extensibella"id="117">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="118">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:proj_proof_extend.</b>

Subgoal 1:

Variables: Known Known' Prf ID FC
Proj : Known |{proof}- endFrat ID FC ~~&gt; emptyLrat ID Prf
IsP : is_proof (endFrat ID FC)
IsKnown : is_list (is_pair is_integer is_clause) Known
IsKnown' : is_list (is_pair is_integer is_clause) Known'
GCL : good_clause_list Known
GCL' : good_clause_list Known'
Mems : forall ID C, mem (ID, C) Known -&gt; mem (ID, C) Known'
Proj1 : rupProof Known emptyClause Prf
============================
 Known' |{proof}- endFrat ID FC ~~&gt; emptyLrat ID Prf
</pre>
<pre class="code extensibella"id="119">
 &lt; <b>apply rupProof_orderless to _ IsKnown' _ Proj1 _.</b>

Subgoal 1:

Variables: Known Known' Prf ID FC
Proj : Known |{proof}- endFrat ID FC ~~&gt; emptyLrat ID Prf
IsP : is_proof (endFrat ID FC)
IsKnown : is_list (is_pair is_integer is_clause) Known
IsKnown' : is_list (is_pair is_integer is_clause) Known'
GCL : good_clause_list Known
GCL' : good_clause_list Known'
Mems : forall ID C, mem (ID, C) Known -&gt; mem (ID, C) Known'
Proj1 : rupProof Known emptyClause Prf
H1 : rupProof Known' emptyClause Prf
============================
 Known' |{proof}- endFrat ID FC ~~&gt; emptyLrat ID Prf
</pre>
<pre class="code extensibella"id="120">
 &lt; <b>search.</b>

Subgoal 2:

Variables: Known Known' Prf ID FC
Proj : Known |{proof}- endFratPrf ID Prf FC ~~&gt; emptyLrat ID Prf
IsP : is_proof (endFratPrf ID Prf FC)
IsKnown : is_list (is_pair is_integer is_clause) Known
IsKnown' : is_list (is_pair is_integer is_clause) Known'
GCL : good_clause_list Known
GCL' : good_clause_list Known'
Mems : forall ID C, mem (ID, C) Known -&gt; mem (ID, C) Known'
============================
 Known' |{proof}- endFratPrf ID Prf FC ~~&gt; emptyLrat ID Prf
</pre>
<pre class="code extensibella"id="121">
 &lt; <b>search.</b>

Subgoal 3:

Variables: Known Known' Rest Prf C ID
Proj : Known |{proof}- addProofless ID C Rest ~~&gt; addLrupProof ID C Prf Rest
IsP : is_proof (addProofless ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
IsKnown' : is_list (is_pair is_integer is_clause) Known'
GCL : good_clause_list Known
GCL' : good_clause_list Known'
Mems : forall ID C, mem (ID, C) Known -&gt; mem (ID, C) Known'
Proj1 : rupProof Known C Prf
============================
 Known' |{proof}- addProofless ID C Rest ~~&gt; addLrupProof ID C Prf Rest
</pre>
<pre class="code extensibella"id="122">
 &lt; <b>apply rupProof_orderless to _ IsKnown' _ Proj1 _.</b>

Subgoal 3:

Variables: Known Known' Rest Prf C ID
Proj : Known |{proof}- addProofless ID C Rest ~~&gt; addLrupProof ID C Prf Rest
IsP : is_proof (addProofless ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
IsKnown' : is_list (is_pair is_integer is_clause) Known'
GCL : good_clause_list Known
GCL' : good_clause_list Known'
Mems : forall ID C, mem (ID, C) Known -&gt; mem (ID, C) Known'
Proj1 : rupProof Known C Prf
H1 : rupProof Known' C Prf
============================
 Known' |{proof}- addProofless ID C Rest ~~&gt; addLrupProof ID C Prf Rest
</pre>
<pre class="code extensibella"id="123">
 &lt; <b>search.</b>

Subgoal 4:

Variables: Known Known' Rest F C T
Proj : Known |{proof}- relocateClause F T Rest ~~&gt; addLrupProof T C [F] (deleteLratProof F Rest)
IsP : is_proof (relocateClause F T Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
IsKnown' : is_list (is_pair is_integer is_clause) Known'
GCL : good_clause_list Known
GCL' : good_clause_list Known'
Mems : forall ID C, mem (ID, C) Known -&gt; mem (ID, C) Known'
Proj1 : T = F -&gt; false
Proj2 : mem (F, C) Known
============================
 Known' |{proof}- relocateClause F T Rest ~~&gt; addLrupProof T C [F] (deleteLratProof F Rest)
</pre>
<pre class="code extensibella"id="124">
 &lt; <b>apply Mems to Proj2.</b>

Subgoal 4:

Variables: Known Known' Rest F C T
Proj : Known |{proof}- relocateClause F T Rest ~~&gt; addLrupProof T C [F] (deleteLratProof F Rest)
IsP : is_proof (relocateClause F T Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
IsKnown' : is_list (is_pair is_integer is_clause) Known'
GCL : good_clause_list Known
GCL' : good_clause_list Known'
Mems : forall ID C, mem (ID, C) Known -&gt; mem (ID, C) Known'
Proj1 : T = F -&gt; false
Proj2 : mem (F, C) Known
H1 : mem (F, C) Known'
============================
 Known' |{proof}- relocateClause F T Rest ~~&gt; addLrupProof T C [F] (deleteLratProof F Rest)
</pre>
<pre class="code extensibella"id="125">
 &lt; <b>search.</b>

Subgoal 5:

Variables: Known PT Known' ID
Proj : Known |{proof}- relocateClause ID ID PT ~~&gt; PT
IsP : is_proof (relocateClause ID ID PT)
IsKnown : is_list (is_pair is_integer is_clause) Known
IsKnown' : is_list (is_pair is_integer is_clause) Known'
GCL : good_clause_list Known
GCL' : good_clause_list Known'
Mems : forall ID C, mem (ID, C) Known -&gt; mem (ID, C) Known'
============================
 Known' |{proof}- relocateClause ID ID PT ~~&gt; PT
</pre>
<pre class="code extensibella"id="126">
 &lt; <b>search.</b>

Subgoal 6:

Variables: Known Known' Rest ID C
Proj : Known |{proof}- deleteFrat ID C Rest ~~&gt; deleteLratProof ID Rest
IsP : is_proof (deleteFrat ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
IsKnown' : is_list (is_pair is_integer is_clause) Known'
GCL : good_clause_list Known
GCL' : good_clause_list Known'
Mems : forall ID C, mem (ID, C) Known -&gt; mem (ID, C) Known'
============================
 Known' |{proof}- deleteFrat ID C Rest ~~&gt; deleteLratProof ID Rest
</pre>
<pre class="code extensibella"id="127">
 &lt; <b>search.</b>

Subgoal 7:

Variables: Known PT Known' Comment
Proj : Known |{proof}- commentProof Comment PT ~~&gt; PT
IsP : is_proof (commentProof Comment PT)
IsKnown : is_list (is_pair is_integer is_clause) Known
IsKnown' : is_list (is_pair is_integer is_clause) Known'
GCL : good_clause_list Known
GCL' : good_clause_list Known'
Mems : forall ID C, mem (ID, C) Known -&gt; mem (ID, C) Known'
============================
 Known' |{proof}- commentProof Comment PT ~~&gt; PT
</pre>
<pre class="code extensibella"id="128">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="129">
 &lt; <b>Prove unsat_proofs:lrat:check_proof_correct.</b>

Subgoal 4:

Variables: Known Sat KRest Prf Final ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (endFrat ID Final)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (endFrat ID Final) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
============================
 false
</pre>
<pre class="code extensibella"id="130">
 &lt; <b>GA_Empty: assert good_assignment [].</b>

Subgoal 4.1:

Variables: Known Sat KRest Prf Final ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (endFrat ID Final)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (endFrat ID Final) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
============================
 good_assignment []
</pre>
<pre class="code extensibella"id="131">
 &lt; <b>unfold .</b>

Subgoal 4.1:

Variables: Known Sat KRest Prf Final ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (endFrat ID Final)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (endFrat ID Final) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
============================
 forall L NL, mem L [] -&gt; negate_lit L NL -&gt; mem NL [] -&gt; false
</pre>
<pre class="code extensibella"id="132">
 &lt; <b>intros M.</b>

Subgoal 4.1:

Variables: Known Sat KRest Prf Final ID L NL
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (endFrat ID Final)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (endFrat ID Final) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
M : mem L []
H1 : negate_lit L NL
H2 : mem NL []
============================
 false
</pre>
<pre class="code extensibella"id="133">
 &lt; <b>case M.</b>

Subgoal 4:

Variables: Known Sat KRest Prf Final ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (endFrat ID Final)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (endFrat ID Final) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
GA_Empty : good_assignment []
============================
 false
</pre>
<pre class="code extensibella"id="134">
 &lt; <b>ExpASat: assert forall L,
     mem L [] -&gt; mem L Sat.</b>

Subgoal 4.2:

Variables: Known Sat KRest Prf Final ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (endFrat ID Final)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (endFrat ID Final) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
GA_Empty : good_assignment []
============================
 forall L, mem L [] -&gt; mem L Sat
</pre>
<pre class="code extensibella"id="135">
 &lt; <b>intros M.</b>

Subgoal 4.2:

Variables: Known Sat KRest Prf Final ID L
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (endFrat ID Final)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (endFrat ID Final) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
GA_Empty : good_assignment []
M : mem L []
============================
 mem L Sat
</pre>
<pre class="code extensibella"id="136">
 &lt; <b>case M.</b>

Subgoal 4:

Variables: Known Sat KRest Prf Final ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (endFrat ID Final)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (endFrat ID Final) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
GA_Empty : good_assignment []
ExpASat : forall L, mem L [] -&gt; mem L Sat
============================
 false
</pre>
<pre class="code extensibella"id="137">
 &lt; <b>S: apply rupProof_maintains_sat to _ _ CP2 Sat _ IsSat GA_Sat.</b>

Subgoal 4:

Variables: Known Sat KRest Prf Final ID S
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (endFrat ID Final)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (endFrat ID Final) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
GA_Empty : good_assignment []
ExpASat : forall L, mem L [] -&gt; mem L Sat
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S emptyClause
============================
 false
</pre>
<pre class="code extensibella"id="138">
 &lt; <b>case S3.</b>

Subgoal 5:

Variables: Known Sat KRest Final Prf ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (endFratPrf ID Prf Final)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (endFratPrf ID Prf Final) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
============================
 false
</pre>
<pre class="code extensibella"id="139">
 &lt; <b>GA_Empty: assert good_assignment [].</b>

Subgoal 5.1:

Variables: Known Sat KRest Final Prf ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (endFratPrf ID Prf Final)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (endFratPrf ID Prf Final) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
============================
 good_assignment []
</pre>
<pre class="code extensibella"id="140">
 &lt; <b>unfold .</b>

Subgoal 5.1:

Variables: Known Sat KRest Final Prf ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (endFratPrf ID Prf Final)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (endFratPrf ID Prf Final) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
============================
 forall L NL, mem L [] -&gt; negate_lit L NL -&gt; mem NL [] -&gt; false
</pre>
<pre class="code extensibella"id="141">
 &lt; <b>intros M.</b>

Subgoal 5.1:

Variables: Known Sat KRest Final Prf ID L NL
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (endFratPrf ID Prf Final)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (endFratPrf ID Prf Final) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
M : mem L []
H1 : negate_lit L NL
H2 : mem NL []
============================
 false
</pre>
<pre class="code extensibella"id="142">
 &lt; <b>case M.</b>

Subgoal 5:

Variables: Known Sat KRest Final Prf ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (endFratPrf ID Prf Final)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (endFratPrf ID Prf Final) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
GA_Empty : good_assignment []
============================
 false
</pre>
<pre class="code extensibella"id="143">
 &lt; <b>ExpASat: assert forall L,
     mem L [] -&gt; mem L Sat.</b>

Subgoal 5.2:

Variables: Known Sat KRest Final Prf ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (endFratPrf ID Prf Final)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (endFratPrf ID Prf Final) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
GA_Empty : good_assignment []
============================
 forall L, mem L [] -&gt; mem L Sat
</pre>
<pre class="code extensibella"id="144">
 &lt; <b>intros M.</b>

Subgoal 5.2:

Variables: Known Sat KRest Final Prf ID L
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (endFratPrf ID Prf Final)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (endFratPrf ID Prf Final) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
GA_Empty : good_assignment []
M : mem L []
============================
 mem L Sat
</pre>
<pre class="code extensibella"id="145">
 &lt; <b>case M.</b>

Subgoal 5:

Variables: Known Sat KRest Final Prf ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (endFratPrf ID Prf Final)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (endFratPrf ID Prf Final) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
GA_Empty : good_assignment []
ExpASat : forall L, mem L [] -&gt; mem L Sat
============================
 false
</pre>
<pre class="code extensibella"id="146">
 &lt; <b>S: apply rupProof_maintains_sat to _ _ CP2 Sat _ IsSat GA_Sat.</b>

Subgoal 5:

Variables: Known Sat KRest Final Prf ID S
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (endFratPrf ID Prf Final)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (endFratPrf ID Prf Final) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
GA_Empty : good_assignment []
ExpASat : forall L, mem L [] -&gt; mem L Sat
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S emptyClause
============================
 false
</pre>
<pre class="code extensibella"id="147">
 &lt; <b>case S3.</b>

Subgoal 6:

Variables: Known Sat KRest Prf Rest C ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (addProofless ID C Rest)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
============================
 false
</pre>
<pre class="code extensibella"id="148">
 &lt; <b>GA_Empty: assert good_assignment [].</b>

Subgoal 6.1:

Variables: Known Sat KRest Prf Rest C ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (addProofless ID C Rest)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
============================
 good_assignment []
</pre>
<pre class="code extensibella"id="149">
 &lt; <b>unfold .</b>

Subgoal 6.1:

Variables: Known Sat KRest Prf Rest C ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (addProofless ID C Rest)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
============================
 forall L NL, mem L [] -&gt; negate_lit L NL -&gt; mem NL [] -&gt; false
</pre>
<pre class="code extensibella"id="150">
 &lt; <b>intros M.</b>

Subgoal 6.1:

Variables: Known Sat KRest Prf Rest C ID L NL
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (addProofless ID C Rest)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
M : mem L []
H1 : negate_lit L NL
H2 : mem NL []
============================
 false
</pre>
<pre class="code extensibella"id="151">
 &lt; <b>case M.</b>

Subgoal 6:

Variables: Known Sat KRest Prf Rest C ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (addProofless ID C Rest)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
============================
 false
</pre>
<pre class="code extensibella"id="152">
 &lt; <b>ExpEmpty: assert forall L,
     mem L [] -&gt; mem L Sat.</b>

Subgoal 6.2:

Variables: Known Sat KRest Prf Rest C ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (addProofless ID C Rest)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
============================
 forall L, mem L [] -&gt; mem L Sat
</pre>
<pre class="code extensibella"id="153">
 &lt; <b>intros M.</b>

Subgoal 6.2:

Variables: Known Sat KRest Prf Rest C ID L
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (addProofless ID C Rest)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
M : mem L []
============================
 mem L Sat
</pre>
<pre class="code extensibella"id="154">
 &lt; <b>case M.</b>

Subgoal 6:

Variables: Known Sat KRest Prf Rest C ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (addProofless ID C Rest)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpEmpty : forall L, mem L [] -&gt; mem L Sat
============================
 false
</pre>
<pre class="code extensibella"id="155">
 &lt; <b>Is: case IsP.</b>

Subgoal 6:

Variables: Known Sat KRest Prf Rest C ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
============================
 false
</pre>
<pre class="code extensibella"id="156">
 &lt; <b>S: apply rupProof_maintains_sat to _ _ CP2 Sat _ IsSat GA_Sat.</b>

Subgoal 6:

Variables: Known Sat KRest Prf Rest C ID S
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
============================
 false
</pre>
<pre class="code extensibella"id="157">
 &lt; <b>NewSat: assert forall CID InC,
     lookup ((ID, C)::Known) CID InC -&gt; sat_clause S InC.</b>

Subgoal 6.3:

Variables: Known Sat KRest Prf Rest C ID S
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
============================
 forall CID InC, lookup ((ID, C)::Known) CID InC -&gt; sat_clause S InC
</pre>
<pre class="code extensibella"id="158">
 &lt; <b>intros Lkp.</b>

Subgoal 6.3:

Variables: Known Sat KRest Prf Rest C ID S CID InC
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
Lkp : lookup ((ID, C)::Known) CID InC
============================
 sat_clause S InC
</pre>
<pre class="code extensibella"id="159">
 &lt; <b>Lkp: case Lkp.</b>

Subgoal 6.3.1:

Variables: Known Sat KRest Prf Rest S CID InC
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless CID InC Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known CID KRest
CP2 : rupProof Known InC Prf
CP3 : checkProof ((CID, InC)::KRest) Rest *
GA_Empty : good_assignment []
ExpEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer CID
Is1 : is_clause InC
Is2 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S InC
============================
 sat_clause S InC
</pre>
<pre class="code extensibella"id="160">
 &lt; <b>search.</b>

Subgoal 6.3.2:

Variables: Known Sat KRest Prf Rest C ID S CID InC
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
Lkp : ID = CID -&gt; false
Lkp1 : lookup Known CID InC
============================
 sat_clause S InC
</pre>
<pre class="code extensibella"id="161">
 &lt; <b>SC: apply Sat to Lkp1.</b>

Subgoal 6.3.2:

Variables: Known Sat KRest Prf Rest C ID S CID InC
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
Lkp : ID = CID -&gt; false
Lkp1 : lookup Known CID InC
SC : sat_clause Sat InC
============================
 sat_clause S InC
</pre>
<pre class="code extensibella"id="162">
 &lt; <b>M: apply lookup_mem to Lkp1.</b>

Subgoal 6.3.2:

Variables: Known Sat KRest Prf Rest C ID S CID InC
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
Lkp : ID = CID -&gt; false
Lkp1 : lookup Known CID InC
SC : sat_clause Sat InC
M : mem (CID, InC) Known
============================
 sat_clause S InC
</pre>
<pre class="code extensibella"id="163">
 &lt; <b>Is: apply mem_is to _ M.</b>

Subgoal 6.3.2:

Variables: Known Sat KRest Prf Rest C ID S ID1 C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
Lkp : ID = ID1 -&gt; false
Lkp1 : lookup Known ID1 C1
SC : sat_clause Sat C1
M : mem (ID1, C1) Known
Is3 : is_integer ID1
Is4 : is_clause C1
============================
 sat_clause S C1
</pre>
<pre class="code extensibella"id="164">
 &lt; <b>apply sat_clause_orderless to _ _ _ SC _.</b>

Subgoal 6.3.2:

Variables: Known Sat KRest Prf Rest C ID S ID1 C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
Lkp : ID = ID1 -&gt; false
Lkp1 : lookup Known ID1 C1
SC : sat_clause Sat C1
M : mem (ID1, C1) Known
Is3 : is_integer ID1
Is4 : is_clause C1
H1 : sat_clause S C1
============================
 sat_clause S C1
</pre>
<pre class="code extensibella"id="165">
 &lt; <b>search.</b>

Subgoal 6:

Variables: Known Sat KRest Prf Rest C ID S
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
NewSat : forall CID InC, lookup ((ID, C)::Known) CID InC -&gt; sat_clause S InC
============================
 false
</pre>
<pre class="code extensibella"id="166">
 &lt; <b>GCL_New: apply good_clause_list_remove_all_add to GCL CP1 with
              C = C.</b>

Subgoal 6:

Variables: Known Sat KRest Prf Rest C ID S
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
NewSat : forall CID InC, lookup ((ID, C)::Known) CID InC -&gt; sat_clause S InC
GCL_New : good_clause_list ((ID, C)::KRest)
============================
 false
</pre>
<pre class="code extensibella"id="167">
 &lt; <b>NewSat': assert forall CID C1,
     lookup ((ID, C)::KRest) CID C1 -&gt; sat_clause S C1.</b>

Subgoal 6.4:

Variables: Known Sat KRest Prf Rest C ID S
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
NewSat : forall CID InC, lookup ((ID, C)::Known) CID InC -&gt; sat_clause S InC
GCL_New : good_clause_list ((ID, C)::KRest)
============================
 forall CID C1, lookup ((ID, C)::KRest) CID C1 -&gt; sat_clause S C1
</pre>
<pre class="code extensibella"id="168">
 &lt; <b>intros Lkp.</b>

Subgoal 6.4:

Variables: Known Sat KRest Prf Rest C ID S CID C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
NewSat : forall CID InC, lookup ((ID, C)::Known) CID InC -&gt; sat_clause S InC
GCL_New : good_clause_list ((ID, C)::KRest)
Lkp : lookup ((ID, C)::KRest) CID C1
============================
 sat_clause S C1
</pre>
<pre class="code extensibella"id="169">
 &lt; <b>Lkp: case Lkp.</b>

Subgoal 6.4.1:

Variables: Known Sat KRest Prf Rest S CID C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless CID C1 Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known CID KRest
CP2 : rupProof Known C1 Prf
CP3 : checkProof ((CID, C1)::KRest) Rest *
GA_Empty : good_assignment []
ExpEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer CID
Is1 : is_clause C1
Is2 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C1
NewSat : forall CID1 InC, lookup ((CID, C1)::Known) CID1 InC -&gt; sat_clause S InC
GCL_New : good_clause_list ((CID, C1)::KRest)
============================
 sat_clause S C1
</pre>
<pre class="code extensibella"id="170">
 &lt; <b>backchain NewSat.</b>

Subgoal 6.4.2:

Variables: Known Sat KRest Prf Rest C ID S CID C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
NewSat : forall CID InC, lookup ((ID, C)::Known) CID InC -&gt; sat_clause S InC
GCL_New : good_clause_list ((ID, C)::KRest)
Lkp : ID = CID -&gt; false
Lkp1 : lookup KRest CID C1
============================
 sat_clause S C1
</pre>
<pre class="code extensibella"id="171">
 &lt; <b>apply remove_all_lookup_after to CP1 Lkp1.</b>

Subgoal 6.4.2:

Variables: Known Sat KRest Prf Rest C ID S CID C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
NewSat : forall CID InC, lookup ((ID, C)::Known) CID InC -&gt; sat_clause S InC
GCL_New : good_clause_list ((ID, C)::KRest)
Lkp : ID = CID -&gt; false
Lkp1 : lookup KRest CID C1
H1 : lookup Known CID C1
============================
 sat_clause S C1
</pre>
<pre class="code extensibella"id="172">
 &lt; <b>backchain NewSat.</b>

Subgoal 6:

Variables: Known Sat KRest Prf Rest C ID S
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
NewSat : forall CID InC, lookup ((ID, C)::Known) CID InC -&gt; sat_clause S InC
GCL_New : good_clause_list ((ID, C)::KRest)
NewSat' : forall CID C1, lookup ((ID, C)::KRest) CID C1 -&gt; sat_clause S C1
============================
 false
</pre>
<pre class="code extensibella"id="173">
 &lt; <b>assert is_list (is_pair is_integer is_clause) ((ID, C)::KRest).</b>

Subgoal 6.5:

Variables: Known Sat KRest Prf Rest C ID S
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
NewSat : forall CID InC, lookup ((ID, C)::Known) CID InC -&gt; sat_clause S InC
GCL_New : good_clause_list ((ID, C)::KRest)
NewSat' : forall CID C1, lookup ((ID, C)::KRest) CID C1 -&gt; sat_clause S C1
============================
 is_list (is_pair is_integer is_clause) ((ID, C)::KRest)
</pre>
<pre class="code extensibella"id="174">
 &lt; <b>apply remove_all_is to _ CP1.</b>

Subgoal 6.5:

Variables: Known Sat KRest Prf Rest C ID S
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
NewSat : forall CID InC, lookup ((ID, C)::Known) CID InC -&gt; sat_clause S InC
GCL_New : good_clause_list ((ID, C)::KRest)
NewSat' : forall CID C1, lookup ((ID, C)::KRest) CID C1 -&gt; sat_clause S C1
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 is_list (is_pair is_integer is_clause) ((ID, C)::KRest)
</pre>
<pre class="code extensibella"id="175">
 &lt; <b>search.</b>

Subgoal 6:

Variables: Known Sat KRest Prf Rest C ID S
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest *
GA_Empty : good_assignment []
ExpEmpty : forall L, mem L [] -&gt; mem L Sat
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
S : is_list is_lit S
S1 : good_assignment S
S2 : forall L, mem L Sat -&gt; mem L S
S3 : sat_clause S C
NewSat : forall CID InC, lookup ((ID, C)::Known) CID InC -&gt; sat_clause S InC
GCL_New : good_clause_list ((ID, C)::KRest)
NewSat' : forall CID C1, lookup ((ID, C)::KRest) CID C1 -&gt; sat_clause S C1
H1 : is_list (is_pair is_integer is_clause) ((ID, C)::KRest)
============================
 false
</pre>
<pre class="code extensibella"id="176">
 &lt; <b>apply IH to Is2 S S1 GCL_New _ CP3 _.</b>

Subgoal 7:

Variables: Known Sat KRest C KRest2 Rest To From
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (relocateClause From To Rest)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
============================
 false
</pre>
<pre class="code extensibella"id="177">
 &lt; <b>Is: case IsP.</b>

Subgoal 7:

Variables: Known Sat KRest C KRest2 Rest To From
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
============================
 false
</pre>
<pre class="code extensibella"id="178">
 &lt; <b>assert forall CID C1,
     lookup ((To, C)::KRest2) CID C1 -&gt; sat_clause Sat C1.</b>

Subgoal 7.1:

Variables: Known Sat KRest C KRest2 Rest To From
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
============================
 forall CID C1, lookup ((To, C)::KRest2) CID C1 -&gt; sat_clause Sat C1
</pre>
<pre class="code extensibella"id="179">
 &lt; <b>intros Lkp.</b>

Subgoal 7.1:

Variables: Known Sat KRest C KRest2 Rest To From CID C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
Lkp : lookup ((To, C)::KRest2) CID C1
============================
 sat_clause Sat C1
</pre>
<pre class="code extensibella"id="180">
 &lt; <b>Lkp: case Lkp.</b>

Subgoal 7.1.1:

Variables: Known Sat KRest KRest2 Rest From CID C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From CID Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : CID = From -&gt; false
CP2 : remove_all Known CID KRest
CP3 : select (From, C1) KRest2 KRest
CP4 : checkProof ((CID, C1)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer CID
Is2 : is_proof Rest
============================
 sat_clause Sat C1
</pre>
<pre class="code extensibella"id="181">
 &lt; <b>backchain Sat to
   CID = From.</b>

Subgoal 7.1.1:

Variables: Known Sat KRest KRest2 Rest From CID C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From CID Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : CID = From -&gt; false
CP2 : remove_all Known CID KRest
CP3 : select (From, C1) KRest2 KRest
CP4 : checkProof ((CID, C1)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer CID
Is2 : is_proof Rest
============================
 lookup Known From C1
</pre>
<pre class="code extensibella"id="182">
 &lt; <b>M: apply select_mem to CP3.</b>

Subgoal 7.1.1:

Variables: Known Sat KRest KRest2 Rest From CID C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From CID Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : CID = From -&gt; false
CP2 : remove_all Known CID KRest
CP3 : select (From, C1) KRest2 KRest
CP4 : checkProof ((CID, C1)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer CID
Is2 : is_proof Rest
M : mem (From, C1) KRest
============================
 lookup Known From C1
</pre>
<pre class="code extensibella"id="183">
 &lt; <b>M1: apply remove_all_mem_after to CP2 M.</b>

Subgoal 7.1.1:

Variables: Known Sat KRest KRest2 Rest From CID C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From CID Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : CID = From -&gt; false
CP2 : remove_all Known CID KRest
CP3 : select (From, C1) KRest2 KRest
CP4 : checkProof ((CID, C1)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer CID
Is2 : is_proof Rest
M : mem (From, C1) KRest
M1 : mem (From, C1) Known
============================
 lookup Known From C1
</pre>
<pre class="code extensibella"id="184">
 &lt; <b>Lkp': apply is_list_mem_lookup to IsKnown M1 _.</b>

Subgoal 7.1.1:

Variables: Known Sat KRest KRest2 Rest From CID C1 C'
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From CID Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : CID = From -&gt; false
CP2 : remove_all Known CID KRest
CP3 : select (From, C1) KRest2 KRest
CP4 : checkProof ((CID, C1)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer CID
Is2 : is_proof Rest
M : mem (From, C1) KRest
M1 : mem (From, C1) Known
Lkp' : lookup Known From C'
============================
 lookup Known From C1
</pre>
<pre class="code extensibella"id="185">
 &lt; <b>M': apply lookup_mem to Lkp'.</b>

Subgoal 7.1.1:

Variables: Known Sat KRest KRest2 Rest From CID C1 C'
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From CID Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : CID = From -&gt; false
CP2 : remove_all Known CID KRest
CP3 : select (From, C1) KRest2 KRest
CP4 : checkProof ((CID, C1)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer CID
Is2 : is_proof Rest
M : mem (From, C1) KRest
M1 : mem (From, C1) Known
Lkp' : lookup Known From C'
M' : mem (From, C') Known
============================
 lookup Known From C1
</pre>
<pre class="code extensibella"id="186">
 &lt; <b>apply good_clause_list_mems to GCL M1 M'.</b>

Subgoal 7.1.1:

Variables: Known Sat KRest KRest2 Rest From CID C'
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From CID Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : CID = From -&gt; false
CP2 : remove_all Known CID KRest
CP3 : select (From, C') KRest2 KRest
CP4 : checkProof ((CID, C')::KRest2) Rest *
Is : is_integer From
Is1 : is_integer CID
Is2 : is_proof Rest
M : mem (From, C') KRest
M1 : mem (From, C') Known
Lkp' : lookup Known From C'
M' : mem (From, C') Known
============================
 lookup Known From C'
</pre>
<pre class="code extensibella"id="187">
 &lt; <b>search.</b>

Subgoal 7.1.2:

Variables: Known Sat KRest C KRest2 Rest To From CID C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
Lkp : To = CID -&gt; false
Lkp1 : lookup KRest2 CID C1
============================
 sat_clause Sat C1
</pre>
<pre class="code extensibella"id="188">
 &lt; <b>assert CID = From -&gt; false.</b>

Subgoal 7.1.2.1:

Variables: Known Sat KRest C KRest2 Rest To From CID C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
Lkp : To = CID -&gt; false
Lkp1 : lookup KRest2 CID C1
============================
 CID = From -&gt; false
</pre>
<pre class="code extensibella"id="189">
 &lt; <b>M: apply lookup_mem to Lkp1.</b>

Subgoal 7.1.2.1:

Variables: Known Sat KRest C KRest2 Rest To From CID C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
Lkp : To = CID -&gt; false
Lkp1 : lookup KRest2 CID C1
M : mem (CID, C1) KRest2
============================
 CID = From -&gt; false
</pre>
<pre class="code extensibella"id="190">
 &lt; <b>intros E.</b>

Subgoal 7.1.2.1:

Variables: Known Sat KRest C KRest2 Rest To From CID C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
Lkp : To = CID -&gt; false
Lkp1 : lookup KRest2 CID C1
M : mem (CID, C1) KRest2
E : CID = From
============================
 false
</pre>
<pre class="code extensibella"id="191">
 &lt; <b>case E.</b>

Subgoal 7.1.2.1:

Variables: Known Sat KRest C KRest2 Rest To From C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
Lkp : To = From -&gt; false
Lkp1 : lookup KRest2 From C1
M : mem (From, C1) KRest2
============================
 false
</pre>
<pre class="code extensibella"id="192">
 &lt; <b>GCL': apply good_clause_list_remove_all to GCL CP2.</b>

Subgoal 7.1.2.1:

Variables: Known Sat KRest C KRest2 Rest To From C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
Lkp : To = From -&gt; false
Lkp1 : lookup KRest2 From C1
M : mem (From, C1) KRest2
GCL' : good_clause_list KRest
============================
 false
</pre>
<pre class="code extensibella"id="193">
 &lt; <b>GCL': case GCL'.</b>

Subgoal 7.1.2.1:

Variables: Known Sat KRest C KRest2 Rest To From C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
Lkp : To = From -&gt; false
Lkp1 : lookup KRest2 From C1
M : mem (From, C1) KRest2
GCL' : forall ID C1 KRest1 C2,
         select (ID, C1) KRest1 KRest -&gt; mem (ID, C2) KRest1 -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="194">
 &lt; <b>apply GCL' to CP3 M.</b>

Subgoal 7.1.2:

Variables: Known Sat KRest C KRest2 Rest To From CID C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
Lkp : To = CID -&gt; false
Lkp1 : lookup KRest2 CID C1
H1 : CID = From -&gt; false
============================
 sat_clause Sat C1
</pre>
<pre class="code extensibella"id="195">
 &lt; <b>Lkp2: apply lookup_after_select_before to Lkp1 CP3 _.</b>

Subgoal 7.1.2:

Variables: Known Sat KRest C KRest2 Rest To From CID C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
Lkp : To = CID -&gt; false
Lkp1 : lookup KRest2 CID C1
H1 : CID = From -&gt; false
Lkp2 : lookup KRest CID C1
============================
 sat_clause Sat C1
</pre>
<pre class="code extensibella"id="196">
 &lt; <b>apply remove_all_lookup_after to CP2 Lkp2.</b>

Subgoal 7.1.2:

Variables: Known Sat KRest C KRest2 Rest To From CID C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
Lkp : To = CID -&gt; false
Lkp1 : lookup KRest2 CID C1
H1 : CID = From -&gt; false
Lkp2 : lookup KRest CID C1
H2 : lookup Known CID C1
============================
 sat_clause Sat C1
</pre>
<pre class="code extensibella"id="197">
 &lt; <b>backchain Sat.</b>

Subgoal 7:

Variables: Known Sat KRest C KRest2 Rest To From
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : forall CID C1, lookup ((To, C)::KRest2) CID C1 -&gt; sat_clause Sat C1
============================
 false
</pre>
<pre class="code extensibella"id="198">
 &lt; <b>assert is_list (is_pair is_integer is_clause) ((To, C)::KRest2).</b>

Subgoal 7.2:

Variables: Known Sat KRest C KRest2 Rest To From
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : forall CID C1, lookup ((To, C)::KRest2) CID C1 -&gt; sat_clause Sat C1
============================
 is_list (is_pair is_integer is_clause) ((To, C)::KRest2)
</pre>
<pre class="code extensibella"id="199">
 &lt; <b>IsKR: apply remove_all_is to _ CP2.</b>

Subgoal 7.2:

Variables: Known Sat KRest C KRest2 Rest To From
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : forall CID C1, lookup ((To, C)::KRest2) CID C1 -&gt; sat_clause Sat C1
IsKR : is_list (is_pair is_integer is_clause) KRest
============================
 is_list (is_pair is_integer is_clause) ((To, C)::KRest2)
</pre>
<pre class="code extensibella"id="200">
 &lt; <b>apply select_is to _ CP3.</b>

Subgoal 7.2:

Variables: Known Sat KRest C KRest2 Rest To From
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : forall CID C1, lookup ((To, C)::KRest2) CID C1 -&gt; sat_clause Sat C1
IsKR : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
============================
 is_list (is_pair is_integer is_clause) ((To, C)::KRest2)
</pre>
<pre class="code extensibella"id="201">
 &lt; <b>IsPr: apply select_is_picked to _ CP3.</b>

Subgoal 7.2:

Variables: Known Sat KRest C KRest2 Rest To From
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : forall CID C1, lookup ((To, C)::KRest2) CID C1 -&gt; sat_clause Sat C1
IsKR : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
IsPr : is_pair is_integer is_clause (From, C)
============================
 is_list (is_pair is_integer is_clause) ((To, C)::KRest2)
</pre>
<pre class="code extensibella"id="202">
 &lt; <b>case IsPr.</b>

Subgoal 7.2:

Variables: Known Sat KRest C KRest2 Rest To From
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : forall CID C1, lookup ((To, C)::KRest2) CID C1 -&gt; sat_clause Sat C1
IsKR : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : is_integer From
H4 : is_clause C
============================
 is_list (is_pair is_integer is_clause) ((To, C)::KRest2)
</pre>
<pre class="code extensibella"id="203">
 &lt; <b>search.</b>

Subgoal 7:

Variables: Known Sat KRest C KRest2 Rest To From
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : forall CID C1, lookup ((To, C)::KRest2) CID C1 -&gt; sat_clause Sat C1
H2 : is_list (is_pair is_integer is_clause) ((To, C)::KRest2)
============================
 false
</pre>
<pre class="code extensibella"id="204">
 &lt; <b>assert good_clause_list ((To, C)::KRest2).</b>

Subgoal 7.3:

Variables: Known Sat KRest C KRest2 Rest To From
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : forall CID C1, lookup ((To, C)::KRest2) CID C1 -&gt; sat_clause Sat C1
H2 : is_list (is_pair is_integer is_clause) ((To, C)::KRest2)
============================
 good_clause_list ((To, C)::KRest2)
</pre>
<pre class="code extensibella"id="205">
 &lt; <b>GCL1: apply good_clause_list_remove_all to GCL CP2.</b>

Subgoal 7.3:

Variables: Known Sat KRest C KRest2 Rest To From
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : forall CID C1, lookup ((To, C)::KRest2) CID C1 -&gt; sat_clause Sat C1
H2 : is_list (is_pair is_integer is_clause) ((To, C)::KRest2)
GCL1 : good_clause_list KRest
============================
 good_clause_list ((To, C)::KRest2)
</pre>
<pre class="code extensibella"id="206">
 &lt; <b>GCL2: apply good_clause_list_select to GCL1 CP3.</b>

Subgoal 7.3:

Variables: Known Sat KRest C KRest2 Rest To From
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : forall CID C1, lookup ((To, C)::KRest2) CID C1 -&gt; sat_clause Sat C1
H2 : is_list (is_pair is_integer is_clause) ((To, C)::KRest2)
GCL1 : good_clause_list KRest
GCL2 : good_clause_list KRest2
============================
 good_clause_list ((To, C)::KRest2)
</pre>
<pre class="code extensibella"id="207">
 &lt; <b>unfold .</b>

Subgoal 7.3:

Variables: Known Sat KRest C KRest2 Rest To From
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : forall CID C1, lookup ((To, C)::KRest2) CID C1 -&gt; sat_clause Sat C1
H2 : is_list (is_pair is_integer is_clause) ((To, C)::KRest2)
GCL1 : good_clause_list KRest
GCL2 : good_clause_list KRest2
============================
 forall ID C1 KRest C2,
   select (ID, C1) KRest ((To, C)::KRest2) -&gt; mem (ID, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="208">
 &lt; <b>intros S M.</b>

Subgoal 7.3:

Variables: Known Sat KRest C KRest2 Rest To From ID C1 KRest1 C2
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : forall CID C1, lookup ((To, C)::KRest2) CID C1 -&gt; sat_clause Sat C1
H2 : is_list (is_pair is_integer is_clause) ((To, C)::KRest2)
GCL1 : good_clause_list KRest
GCL2 : good_clause_list KRest2
S : select (ID, C1) KRest1 ((To, C)::KRest2)
M : mem (ID, C2) KRest1
============================
 false
</pre>
<pre class="code extensibella"id="209">
 &lt; <b>S: case S.</b>

Subgoal 7.3.1:

Variables: Known Sat KRest C KRest2 Rest To From C2
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : forall CID C1, lookup ((To, C)::KRest2) CID C1 -&gt; sat_clause Sat C1
H2 : is_list (is_pair is_integer is_clause) ((To, C)::KRest2)
GCL1 : good_clause_list KRest
GCL2 : good_clause_list KRest2
M : mem (To, C2) KRest2
============================
 false
</pre>
<pre class="code extensibella"id="210">
 &lt; <b>MKR: apply mem_after_select_before to CP3 M.</b>

Subgoal 7.3.1:

Variables: Known Sat KRest C KRest2 Rest To From C2
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : forall CID C1, lookup ((To, C)::KRest2) CID C1 -&gt; sat_clause Sat C1
H2 : is_list (is_pair is_integer is_clause) ((To, C)::KRest2)
GCL1 : good_clause_list KRest
GCL2 : good_clause_list KRest2
M : mem (To, C2) KRest2
MKR : mem (To, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="211">
 &lt; <b>apply remove_all_no_mem to CP2 MKR.</b>

Subgoal 7.3.2:

Variables: Known Sat KRest C KRest2 Rest To From ID C1 C2 L1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : forall CID C1, lookup ((To, C)::KRest2) CID C1 -&gt; sat_clause Sat C1
H2 : is_list (is_pair is_integer is_clause) ((To, C)::KRest2)
GCL1 : good_clause_list KRest
GCL2 : good_clause_list KRest2
M : mem (ID, C2) ((To, C)::L1)
S : select (ID, C1) L1 KRest2
============================
 false
</pre>
<pre class="code extensibella"id="212">
 &lt; <b>M: case M.</b>

Subgoal 7.3.2.1:

Variables: Known Sat KRest C KRest2 Rest To From C1 L1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : forall CID C1, lookup ((To, C)::KRest2) CID C1 -&gt; sat_clause Sat C1
H2 : is_list (is_pair is_integer is_clause) ((To, C)::KRest2)
GCL1 : good_clause_list KRest
GCL2 : good_clause_list KRest2
S : select (To, C1) L1 KRest2
============================
 false
</pre>
<pre class="code extensibella"id="213">
 &lt; <b>M: apply select_mem to S.</b>

Subgoal 7.3.2.1:

Variables: Known Sat KRest C KRest2 Rest To From C1 L1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : forall CID C1, lookup ((To, C)::KRest2) CID C1 -&gt; sat_clause Sat C1
H2 : is_list (is_pair is_integer is_clause) ((To, C)::KRest2)
GCL1 : good_clause_list KRest
GCL2 : good_clause_list KRest2
S : select (To, C1) L1 KRest2
M : mem (To, C1) KRest2
============================
 false
</pre>
<pre class="code extensibella"id="214">
 &lt; <b>M': apply mem_after_select_before to CP3 M.</b>

Subgoal 7.3.2.1:

Variables: Known Sat KRest C KRest2 Rest To From C1 L1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : forall CID C1, lookup ((To, C)::KRest2) CID C1 -&gt; sat_clause Sat C1
H2 : is_list (is_pair is_integer is_clause) ((To, C)::KRest2)
GCL1 : good_clause_list KRest
GCL2 : good_clause_list KRest2
S : select (To, C1) L1 KRest2
M : mem (To, C1) KRest2
M' : mem (To, C1) KRest
============================
 false
</pre>
<pre class="code extensibella"id="215">
 &lt; <b>apply remove_all_no_mem to CP2 M'.</b>

Subgoal 7.3.2.2:

Variables: Known Sat KRest C KRest2 Rest To From ID C1 C2 L1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : forall CID C1, lookup ((To, C)::KRest2) CID C1 -&gt; sat_clause Sat C1
H2 : is_list (is_pair is_integer is_clause) ((To, C)::KRest2)
GCL1 : good_clause_list KRest
GCL2 : good_clause_list KRest2
S : select (ID, C1) L1 KRest2
M : mem (ID, C2) L1
============================
 false
</pre>
<pre class="code extensibella"id="216">
 &lt; <b>GCL': case GCL2.</b>

Subgoal 7.3.2.2:

Variables: Known Sat KRest C KRest2 Rest To From ID C1 C2 L1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : forall CID C1, lookup ((To, C)::KRest2) CID C1 -&gt; sat_clause Sat C1
H2 : is_list (is_pair is_integer is_clause) ((To, C)::KRest2)
GCL1 : good_clause_list KRest
S : select (ID, C1) L1 KRest2
M : mem (ID, C2) L1
GCL' : forall ID C1 KRest C2,
         select (ID, C1) KRest KRest2 -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="217">
 &lt; <b>apply GCL' to S M.</b>

Subgoal 7:

Variables: Known Sat KRest C KRest2 Rest To From
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : forall CID C1, lookup ((To, C)::KRest2) CID C1 -&gt; sat_clause Sat C1
H2 : is_list (is_pair is_integer is_clause) ((To, C)::KRest2)
H3 : good_clause_list ((To, C)::KRest2)
============================
 false
</pre>
<pre class="code extensibella"id="218">
 &lt; <b>apply IH to Is2 IsSat GA_Sat _ _ CP4 _.</b>

Subgoal 8:

Variables: Known Sat C Rest ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (relocateClause ID ID Rest)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause ID ID Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : mem (ID, C) Known
CP2 : checkProof Known Rest *
============================
 false
</pre>
<pre class="code extensibella"id="219">
 &lt; <b>Is: case IsP.</b>

Subgoal 8:

Variables: Known Sat C Rest ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause ID ID Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : mem (ID, C) Known
CP2 : checkProof Known Rest *
Is : is_integer ID
Is1 : is_integer ID
Is2 : is_proof Rest
============================
 false
</pre>
<pre class="code extensibella"id="220">
 &lt; <b>apply IH to _ _ _ _ _ CP2 _.</b>

Subgoal 9:

Variables: Known Sat KRest Rest C ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (deleteFrat ID C Rest)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteFrat ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
============================
 false
</pre>
<pre class="code extensibella"id="221">
 &lt; <b>Is: case IsP.</b>

Subgoal 9:

Variables: Known Sat KRest Rest C ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteFrat ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
============================
 false
</pre>
<pre class="code extensibella"id="222">
 &lt; <b>IsKRest: apply select_is to _ CP1.</b>

Subgoal 9:

Variables: Known Sat KRest Rest C ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteFrat ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
============================
 false
</pre>
<pre class="code extensibella"id="223">
 &lt; <b>GCL_KRest: apply good_clause_list_select to GCL CP1.</b>

Subgoal 9:

Variables: Known Sat KRest Rest C ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteFrat ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
GCL_KRest : good_clause_list KRest
============================
 false
</pre>
<pre class="code extensibella"id="224">
 &lt; <b>assert forall CID C,
     lookup KRest CID C -&gt; sat_clause Sat C.</b>

Subgoal 9.1:

Variables: Known Sat KRest Rest C ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteFrat ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
GCL_KRest : good_clause_list KRest
============================
 forall CID C1, lookup KRest CID C1 -&gt; sat_clause Sat C1
</pre>
<pre class="code extensibella"id="225">
 &lt; <b>intros L.</b>

Subgoal 9.1:

Variables: Known Sat KRest Rest C ID CID C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteFrat ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
GCL_KRest : good_clause_list KRest
L : lookup KRest CID C1
============================
 sat_clause Sat C1
</pre>
<pre class="code extensibella"id="226">
 &lt; <b>M: apply lookup_mem to L.</b>

Subgoal 9.1:

Variables: Known Sat KRest Rest C ID CID C1
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteFrat ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
GCL_KRest : good_clause_list KRest
L : lookup KRest CID C1
M : mem (CID, C1) KRest
============================
 sat_clause Sat C1
</pre>
<pre class="code extensibella"id="227">
 &lt; <b>apply mem_is to _ M.</b>

Subgoal 9.1:

Variables: Known Sat KRest Rest C ID ID1 C2
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteFrat ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
GCL_KRest : good_clause_list KRest
L : lookup KRest ID1 C2
M : mem (ID1, C2) KRest
H1 : is_integer ID1
H2 : is_clause C2
============================
 sat_clause Sat C2
</pre>
<pre class="code extensibella"id="228">
 &lt; <b>assert forall I C1 C2,
     mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2.</b>

Subgoal 9.1.1:

Variables: Known Sat KRest Rest C ID ID1 C2
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteFrat ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
GCL_KRest : good_clause_list KRest
L : lookup KRest ID1 C2
M : mem (ID1, C2) KRest
H1 : is_integer ID1
H2 : is_clause C2
============================
 forall I C1 C2, mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2
</pre>
<pre class="code extensibella"id="229">
 &lt; <b>intros M1 M2.</b>

Subgoal 9.1.1:

Variables: Known Sat KRest Rest C ID ID1 C2 I C3 C4
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteFrat ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
GCL_KRest : good_clause_list KRest
L : lookup KRest ID1 C2
M : mem (ID1, C2) KRest
H1 : is_integer ID1
H2 : is_clause C2
M1 : mem (I, C3) Known
M2 : mem (I, C4) Known
============================
 C3 = C4
</pre>
<pre class="code extensibella"id="230">
 &lt; <b>apply good_clause_list_mems to _ M1 M2.</b>

Subgoal 9.1.1:

Variables: Known Sat KRest Rest C ID ID1 C2 I C4
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteFrat ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
GCL_KRest : good_clause_list KRest
L : lookup KRest ID1 C2
M : mem (ID1, C2) KRest
H1 : is_integer ID1
H2 : is_clause C2
M1 : mem (I, C4) Known
M2 : mem (I, C4) Known
============================
 C4 = C4
</pre>
<pre class="code extensibella"id="231">
 &lt; <b>search.</b>

Subgoal 9.1:

Variables: Known Sat KRest Rest C ID ID1 C2
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteFrat ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
GCL_KRest : good_clause_list KRest
L : lookup KRest ID1 C2
M : mem (ID1, C2) KRest
H1 : is_integer ID1
H2 : is_clause C2
H3 : forall I C1 C2, mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2
============================
 sat_clause Sat C2
</pre>
<pre class="code extensibella"id="232">
 &lt; <b>L': apply lookup_after_select to _ _ _ CP1 L.</b>

Subgoal 9.1:

Variables: Known Sat KRest Rest C ID ID1 C2
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteFrat ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
GCL_KRest : good_clause_list KRest
L : lookup KRest ID1 C2
M : mem (ID1, C2) KRest
H1 : is_integer ID1
H2 : is_clause C2
H3 : forall I C1 C2, mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2
L' : lookup Known ID1 C2
============================
 sat_clause Sat C2
</pre>
<pre class="code extensibella"id="233">
 &lt; <b>apply Sat to L'.</b>

Subgoal 9.1:

Variables: Known Sat KRest Rest C ID ID1 C2
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteFrat ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
GCL_KRest : good_clause_list KRest
L : lookup KRest ID1 C2
M : mem (ID1, C2) KRest
H1 : is_integer ID1
H2 : is_clause C2
H3 : forall I C1 C2, mem (I, C1) Known -&gt; mem (I, C2) Known -&gt; C1 = C2
L' : lookup Known ID1 C2
H4 : sat_clause Sat C2
============================
 sat_clause Sat C2
</pre>
<pre class="code extensibella"id="234">
 &lt; <b>search.</b>

Subgoal 9:

Variables: Known Sat KRest Rest C ID
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteFrat ID C Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
GCL_KRest : good_clause_list KRest
H1 : forall CID C1, lookup KRest CID C1 -&gt; sat_clause Sat C1
============================
 false
</pre>
<pre class="code extensibella"id="235">
 &lt; <b>apply IH to Is2 IsSat GA_Sat GCL_KRest IsKRest CP2 _.</b>

Subgoal 10:

Variables: Known Sat Rest Comment
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsP : is_proof (commentProof Comment Rest)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (commentProof Comment Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : checkProof Known Rest *
============================
 false
</pre>
<pre class="code extensibella"id="236">
 &lt; <b>Is: case IsP.</b>

Subgoal 10:

Variables: Known Sat Rest Comment
IH : forall Known P Sat,
       is_proof P -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       is_list (is_pair is_integer is_clause) Known -&gt; checkProof Known P * -&gt; (forall CID C,
         lookup Known CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (commentProof Comment Rest) @
Sat : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
CP1 : checkProof Known Rest *
Is : is_string Comment
Is1 : is_proof Rest
============================
 false
</pre>
<pre class="code extensibella"id="237">
 &lt; <b>apply IH to Is1 _ _ _ _ CP1 _.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="238">
 &lt; <b>Prove unsat_proofs:lrat:checkProof_orderless.</b>

Subgoal 4:

Variables: K1 K2 KRest Prf1 Final ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsP : is_proof (endFrat ID Final)
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (endFrat ID Final) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 emptyClause Prf1
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
============================
 checkProof K2 (endFrat ID Final)
</pre>
<pre class="code extensibella"id="239">
 &lt; <b>Is: case IsP.</b>

Subgoal 4:

Variables: K1 K2 KRest Prf1 Final ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (endFrat ID Final) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 emptyClause Prf1
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
Is : is_integer ID
Is1 : is_finalClauses Final
============================
 checkProof K2 (endFrat ID Final)
</pre>
<pre class="code extensibella"id="240">
 &lt; <b>apply rupProof_permutation to IsK1 IsK2 GCL CP2 Prm.</b>

Subgoal 4:

Variables: K1 K2 KRest Prf1 Final ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (endFrat ID Final) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 emptyClause Prf1
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
Is : is_integer ID
Is1 : is_finalClauses Final
H1 : rupProof K2 emptyClause Prf1
============================
 checkProof K2 (endFrat ID Final)
</pre>
<pre class="code extensibella"id="241">
 &lt; <b>Prm': apply remove_all_permutation to _ _ CP1 Prm.</b>

Subgoal 4:

Variables: K1 K2 KRest Prf1 Final ID P'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (endFrat ID Final) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 emptyClause Prf1
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
Is : is_integer ID
Is1 : is_finalClauses Final
H1 : rupProof K2 emptyClause Prf1
Prm' : remove_all K2 ID P'
Prm'1 : permutation KRest P'
============================
 checkProof K2 (endFrat ID Final)
</pre>
<pre class="code extensibella"id="242">
 &lt; <b>apply remove_all_is to _ Prm'.</b>

Subgoal 4:

Variables: K1 K2 KRest Prf1 Final ID P'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (endFrat ID Final) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 emptyClause Prf1
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
Is : is_integer ID
Is1 : is_finalClauses Final
H1 : rupProof K2 emptyClause Prf1
Prm' : remove_all K2 ID P'
Prm'1 : permutation KRest P'
H2 : is_list (is_pair is_integer is_clause) P'
============================
 checkProof K2 (endFrat ID Final)
</pre>
<pre class="code extensibella"id="243">
 &lt; <b>apply remove_all_is to _ CP1.</b>

Subgoal 4:

Variables: K1 K2 KRest Prf1 Final ID P'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (endFrat ID Final) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 emptyClause Prf1
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
Is : is_integer ID
Is1 : is_finalClauses Final
H1 : rupProof K2 emptyClause Prf1
Prm' : remove_all K2 ID P'
Prm'1 : permutation KRest P'
H2 : is_list (is_pair is_integer is_clause) P'
H3 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof K2 (endFrat ID Final)
</pre>
<pre class="code extensibella"id="244">
 &lt; <b>apply checkFinalClauses_orderless to _ _ CP3 _.</b>

Subgoal 4:

Variables: K1 K2 KRest Prf1 Final ID P'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (endFrat ID Final) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 emptyClause Prf1
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
Is : is_integer ID
Is1 : is_finalClauses Final
H1 : rupProof K2 emptyClause Prf1
Prm' : remove_all K2 ID P'
Prm'1 : permutation KRest P'
H2 : is_list (is_pair is_integer is_clause) P'
H3 : is_list (is_pair is_integer is_clause) KRest
H4 : checkFinalClauses ((ID, emptyClause)::P') Final
============================
 checkProof K2 (endFrat ID Final)
</pre>
<pre class="code extensibella"id="245">
 &lt; <b>search.</b>

Subgoal 5:

Variables: K1 K2 KRest Final Prf1 ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsP : is_proof (endFratPrf ID Prf1 Final)
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (endFratPrf ID Prf1 Final) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 emptyClause Prf1
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
============================
 checkProof K2 (endFratPrf ID Prf1 Final)
</pre>
<pre class="code extensibella"id="246">
 &lt; <b>Is: case IsP.</b>

Subgoal 5:

Variables: K1 K2 KRest Final Prf1 ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (endFratPrf ID Prf1 Final) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 emptyClause Prf1
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
Is : is_integer ID
Is1 : is_list is_integer Prf1
Is2 : is_finalClauses Final
============================
 checkProof K2 (endFratPrf ID Prf1 Final)
</pre>
<pre class="code extensibella"id="247">
 &lt; <b>apply rupProof_permutation to IsK1 IsK2 GCL CP2 Prm.</b>

Subgoal 5:

Variables: K1 K2 KRest Final Prf1 ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (endFratPrf ID Prf1 Final) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 emptyClause Prf1
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
Is : is_integer ID
Is1 : is_list is_integer Prf1
Is2 : is_finalClauses Final
H1 : rupProof K2 emptyClause Prf1
============================
 checkProof K2 (endFratPrf ID Prf1 Final)
</pre>
<pre class="code extensibella"id="248">
 &lt; <b>Prm': apply remove_all_permutation to _ _ CP1 Prm.</b>

Subgoal 5:

Variables: K1 K2 KRest Final Prf1 ID P'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (endFratPrf ID Prf1 Final) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 emptyClause Prf1
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
Is : is_integer ID
Is1 : is_list is_integer Prf1
Is2 : is_finalClauses Final
H1 : rupProof K2 emptyClause Prf1
Prm' : remove_all K2 ID P'
Prm'1 : permutation KRest P'
============================
 checkProof K2 (endFratPrf ID Prf1 Final)
</pre>
<pre class="code extensibella"id="249">
 &lt; <b>apply remove_all_is to _ Prm'.</b>

Subgoal 5:

Variables: K1 K2 KRest Final Prf1 ID P'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (endFratPrf ID Prf1 Final) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 emptyClause Prf1
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
Is : is_integer ID
Is1 : is_list is_integer Prf1
Is2 : is_finalClauses Final
H1 : rupProof K2 emptyClause Prf1
Prm' : remove_all K2 ID P'
Prm'1 : permutation KRest P'
H2 : is_list (is_pair is_integer is_clause) P'
============================
 checkProof K2 (endFratPrf ID Prf1 Final)
</pre>
<pre class="code extensibella"id="250">
 &lt; <b>apply remove_all_is to _ CP1.</b>

Subgoal 5:

Variables: K1 K2 KRest Final Prf1 ID P'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (endFratPrf ID Prf1 Final) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 emptyClause Prf1
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
Is : is_integer ID
Is1 : is_list is_integer Prf1
Is2 : is_finalClauses Final
H1 : rupProof K2 emptyClause Prf1
Prm' : remove_all K2 ID P'
Prm'1 : permutation KRest P'
H2 : is_list (is_pair is_integer is_clause) P'
H3 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof K2 (endFratPrf ID Prf1 Final)
</pre>
<pre class="code extensibella"id="251">
 &lt; <b>apply checkFinalClauses_orderless to _ _ CP3 _.</b>

Subgoal 5:

Variables: K1 K2 KRest Final Prf1 ID P'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (endFratPrf ID Prf1 Final) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 emptyClause Prf1
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
Is : is_integer ID
Is1 : is_list is_integer Prf1
Is2 : is_finalClauses Final
H1 : rupProof K2 emptyClause Prf1
Prm' : remove_all K2 ID P'
Prm'1 : permutation KRest P'
H2 : is_list (is_pair is_integer is_clause) P'
H3 : is_list (is_pair is_integer is_clause) KRest
H4 : checkFinalClauses ((ID, emptyClause)::P') Final
============================
 checkProof K2 (endFratPrf ID Prf1 Final)
</pre>
<pre class="code extensibella"id="252">
 &lt; <b>search.</b>

Subgoal 6:

Variables: K1 K2 KRest Prf1 Rest C ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsP : is_proof (addProofless ID C Rest)
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (addProofless ID C Rest) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest *
============================
 checkProof K2 (addProofless ID C Rest)
</pre>
<pre class="code extensibella"id="253">
 &lt; <b>Is: case IsP.</b>

Subgoal 6:

Variables: K1 K2 KRest Prf1 Rest C ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (addProofless ID C Rest) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
============================
 checkProof K2 (addProofless ID C Rest)
</pre>
<pre class="code extensibella"id="254">
 &lt; <b>apply rupProof_permutation to IsK1 IsK2 GCL CP2 Prm.</b>

Subgoal 6:

Variables: K1 K2 KRest Prf1 Rest C ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (addProofless ID C Rest) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : rupProof K2 C Prf1
============================
 checkProof K2 (addProofless ID C Rest)
</pre>
<pre class="code extensibella"id="255">
 &lt; <b>Prm': apply remove_all_permutation to _ _ CP1 Prm.</b>

Subgoal 6:

Variables: K1 K2 KRest Prf1 Rest C ID P'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (addProofless ID C Rest) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : rupProof K2 C Prf1
Prm' : remove_all K2 ID P'
Prm'1 : permutation KRest P'
============================
 checkProof K2 (addProofless ID C Rest)
</pre>
<pre class="code extensibella"id="256">
 &lt; <b>apply remove_all_is to _ Prm'.</b>

Subgoal 6:

Variables: K1 K2 KRest Prf1 Rest C ID P'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (addProofless ID C Rest) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : rupProof K2 C Prf1
Prm' : remove_all K2 ID P'
Prm'1 : permutation KRest P'
H2 : is_list (is_pair is_integer is_clause) P'
============================
 checkProof K2 (addProofless ID C Rest)
</pre>
<pre class="code extensibella"id="257">
 &lt; <b>apply remove_all_is to _ CP1.</b>

Subgoal 6:

Variables: K1 K2 KRest Prf1 Rest C ID P'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (addProofless ID C Rest) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : rupProof K2 C Prf1
Prm' : remove_all K2 ID P'
Prm'1 : permutation KRest P'
H2 : is_list (is_pair is_integer is_clause) P'
H3 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof K2 (addProofless ID C Rest)
</pre>
<pre class="code extensibella"id="258">
 &lt; <b>apply good_clause_list_remove_all_add to GCL Prm' with
     C = C.</b>

Subgoal 6:

Variables: K1 K2 KRest Prf1 Rest C ID P'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (addProofless ID C Rest) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : rupProof K2 C Prf1
Prm' : remove_all K2 ID P'
Prm'1 : permutation KRest P'
H2 : is_list (is_pair is_integer is_clause) P'
H3 : is_list (is_pair is_integer is_clause) KRest
H4 : good_clause_list ((ID, C)::P')
============================
 checkProof K2 (addProofless ID C Rest)
</pre>
<pre class="code extensibella"id="259">
 &lt; <b>apply IH to _ _ _ _ CP3 _.</b>

Subgoal 6:

Variables: K1 K2 KRest Prf1 Rest C ID P'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (addProofless ID C Rest) @
Prm : permutation K1 K2
CP1 : remove_all K1 ID KRest
CP2 : rupProof K1 C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : rupProof K2 C Prf1
Prm' : remove_all K2 ID P'
Prm'1 : permutation KRest P'
H2 : is_list (is_pair is_integer is_clause) P'
H3 : is_list (is_pair is_integer is_clause) KRest
H4 : good_clause_list ((ID, C)::P')
H5 : checkProof ((ID, C)::P') Rest
============================
 checkProof K2 (addProofless ID C Rest)
</pre>
<pre class="code extensibella"id="260">
 &lt; <b>search.</b>

Subgoal 7:

Variables: K1 K2 KRest C KRest2 Rest To From
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsP : is_proof (relocateClause From To Rest)
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
============================
 checkProof K2 (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="261">
 &lt; <b>Is: case IsP.</b>

Subgoal 7:

Variables: K1 K2 KRest C KRest2 Rest To From
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
============================
 checkProof K2 (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="262">
 &lt; <b>M: apply select_mem to CP3.</b>

Subgoal 7:

Variables: K1 K2 KRest C KRest2 Rest To From
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
============================
 checkProof K2 (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="263">
 &lt; <b>Prm': apply remove_all_permutation to _ _ CP2 _.</b>

Subgoal 7:

Variables: K1 K2 KRest C KRest2 Rest To From P'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
============================
 checkProof K2 (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="264">
 &lt; <b>M2: apply permutation_mem to Prm'1 M.</b>

Subgoal 7:

Variables: K1 K2 KRest C KRest2 Rest To From P'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
============================
 checkProof K2 (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="265">
 &lt; <b>S: apply mem_select to M2.</b>

Subgoal 7:

Variables: K1 K2 KRest C KRest2 Rest To From P' L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
S : select (From, C) L' P'
============================
 checkProof K2 (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="266">
 &lt; <b>IsKR: apply remove_all_is to _ CP2.</b>

Subgoal 7:

Variables: K1 K2 KRest C KRest2 Rest To From P' L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
S : select (From, C) L' P'
IsKR : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof K2 (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="267">
 &lt; <b>IsP': apply remove_all_is to _ Prm'.</b>

Subgoal 7:

Variables: K1 K2 KRest C KRest2 Rest To From P' L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
S : select (From, C) L' P'
IsKR : is_list (is_pair is_integer is_clause) KRest
IsP' : is_list (is_pair is_integer is_clause) P'
============================
 checkProof K2 (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="268">
 &lt; <b>Prm'': apply selects_permutation to _ _ Prm'1 CP3 S.</b>

Subgoal 7:

Variables: K1 K2 KRest C KRest2 Rest To From P' L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
S : select (From, C) L' P'
IsKR : is_list (is_pair is_integer is_clause) KRest
IsP' : is_list (is_pair is_integer is_clause) P'
Prm'' : permutation KRest2 L'
============================
 checkProof K2 (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="269">
 &lt; <b>Prm_Final: assert permutation ((To, C)::KRest2) ((To, C)::L').</b>

Subgoal 7:

Variables: K1 K2 KRest C KRest2 Rest To From P' L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
S : select (From, C) L' P'
IsKR : is_list (is_pair is_integer is_clause) KRest
IsP' : is_list (is_pair is_integer is_clause) P'
Prm'' : permutation KRest2 L'
Prm_Final : permutation ((To, C)::KRest2) ((To, C)::L')
============================
 checkProof K2 (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="270">
 &lt; <b>IsPr: apply select_is_picked to _ CP3.</b>

Subgoal 7:

Variables: K1 K2 KRest C KRest2 Rest To From P' L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
S : select (From, C) L' P'
IsKR : is_list (is_pair is_integer is_clause) KRest
IsP' : is_list (is_pair is_integer is_clause) P'
Prm'' : permutation KRest2 L'
Prm_Final : permutation ((To, C)::KRest2) ((To, C)::L')
IsPr : is_pair is_integer is_clause (From, C)
============================
 checkProof K2 (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="271">
 &lt; <b>Is: case IsPr.</b>

Subgoal 7:

Variables: K1 K2 KRest C KRest2 Rest To From P' L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
S : select (From, C) L' P'
IsKR : is_list (is_pair is_integer is_clause) KRest
IsP' : is_list (is_pair is_integer is_clause) P'
Prm'' : permutation KRest2 L'
Prm_Final : permutation ((To, C)::KRest2) ((To, C)::L')
Is3 : is_integer From
Is4 : is_clause C
============================
 checkProof K2 (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="272">
 &lt; <b>IsKR2: apply select_is to _ CP3.</b>

Subgoal 7:

Variables: K1 K2 KRest C KRest2 Rest To From P' L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
S : select (From, C) L' P'
IsKR : is_list (is_pair is_integer is_clause) KRest
IsP' : is_list (is_pair is_integer is_clause) P'
Prm'' : permutation KRest2 L'
Prm_Final : permutation ((To, C)::KRest2) ((To, C)::L')
Is3 : is_integer From
Is4 : is_clause C
IsKR2 : is_list (is_pair is_integer is_clause) KRest2
============================
 checkProof K2 (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="273">
 &lt; <b>IsL': apply select_is to _ S.</b>

Subgoal 7:

Variables: K1 K2 KRest C KRest2 Rest To From P' L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
S : select (From, C) L' P'
IsKR : is_list (is_pair is_integer is_clause) KRest
IsP' : is_list (is_pair is_integer is_clause) P'
Prm'' : permutation KRest2 L'
Prm_Final : permutation ((To, C)::KRest2) ((To, C)::L')
Is3 : is_integer From
Is4 : is_clause C
IsKR2 : is_list (is_pair is_integer is_clause) KRest2
IsL' : is_list (is_pair is_integer is_clause) L'
============================
 checkProof K2 (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="274">
 &lt; <b>GCL_P': apply good_clause_list_remove_all to _ Prm'.</b>

Subgoal 7:

Variables: K1 K2 KRest C KRest2 Rest To From P' L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
S : select (From, C) L' P'
IsKR : is_list (is_pair is_integer is_clause) KRest
IsP' : is_list (is_pair is_integer is_clause) P'
Prm'' : permutation KRest2 L'
Prm_Final : permutation ((To, C)::KRest2) ((To, C)::L')
Is3 : is_integer From
Is4 : is_clause C
IsKR2 : is_list (is_pair is_integer is_clause) KRest2
IsL' : is_list (is_pair is_integer is_clause) L'
GCL_P' : good_clause_list P'
============================
 checkProof K2 (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="275">
 &lt; <b>GCL_L': apply good_clause_list_select to _ S.</b>

Subgoal 7:

Variables: K1 K2 KRest C KRest2 Rest To From P' L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
S : select (From, C) L' P'
IsKR : is_list (is_pair is_integer is_clause) KRest
IsP' : is_list (is_pair is_integer is_clause) P'
Prm'' : permutation KRest2 L'
Prm_Final : permutation ((To, C)::KRest2) ((To, C)::L')
Is3 : is_integer From
Is4 : is_clause C
IsKR2 : is_list (is_pair is_integer is_clause) KRest2
IsL' : is_list (is_pair is_integer is_clause) L'
GCL_P' : good_clause_list P'
GCL_L' : good_clause_list L'
============================
 checkProof K2 (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="276">
 &lt; <b>assert good_clause_list ((To, C)::L').</b>

Subgoal 7.1:

Variables: K1 K2 KRest C KRest2 Rest To From P' L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
S : select (From, C) L' P'
IsKR : is_list (is_pair is_integer is_clause) KRest
IsP' : is_list (is_pair is_integer is_clause) P'
Prm'' : permutation KRest2 L'
Prm_Final : permutation ((To, C)::KRest2) ((To, C)::L')
Is3 : is_integer From
Is4 : is_clause C
IsKR2 : is_list (is_pair is_integer is_clause) KRest2
IsL' : is_list (is_pair is_integer is_clause) L'
GCL_P' : good_clause_list P'
GCL_L' : good_clause_list L'
============================
 good_clause_list ((To, C)::L')
</pre>
<pre class="code extensibella"id="277">
 &lt; <b>unfold .</b>

Subgoal 7.1:

Variables: K1 K2 KRest C KRest2 Rest To From P' L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
S : select (From, C) L' P'
IsKR : is_list (is_pair is_integer is_clause) KRest
IsP' : is_list (is_pair is_integer is_clause) P'
Prm'' : permutation KRest2 L'
Prm_Final : permutation ((To, C)::KRest2) ((To, C)::L')
Is3 : is_integer From
Is4 : is_clause C
IsKR2 : is_list (is_pair is_integer is_clause) KRest2
IsL' : is_list (is_pair is_integer is_clause) L'
GCL_P' : good_clause_list P'
GCL_L' : good_clause_list L'
============================
 forall ID C1 KRest C2,
   select (ID, C1) KRest ((To, C)::L') -&gt; mem (ID, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="278">
 &lt; <b>intros S' M'.</b>

Subgoal 7.1:

Variables: K1 K2 KRest C KRest2 Rest To From P' L' ID C1 KRest1 C2
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
S : select (From, C) L' P'
IsKR : is_list (is_pair is_integer is_clause) KRest
IsP' : is_list (is_pair is_integer is_clause) P'
Prm'' : permutation KRest2 L'
Prm_Final : permutation ((To, C)::KRest2) ((To, C)::L')
Is3 : is_integer From
Is4 : is_clause C
IsKR2 : is_list (is_pair is_integer is_clause) KRest2
IsL' : is_list (is_pair is_integer is_clause) L'
GCL_P' : good_clause_list P'
GCL_L' : good_clause_list L'
S' : select (ID, C1) KRest1 ((To, C)::L')
M' : mem (ID, C2) KRest1
============================
 false
</pre>
<pre class="code extensibella"id="279">
 &lt; <b>S': case S'.</b>

Subgoal 7.1.1:

Variables: K1 K2 KRest C KRest2 Rest To From P' L' C2
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
S : select (From, C) L' P'
IsKR : is_list (is_pair is_integer is_clause) KRest
IsP' : is_list (is_pair is_integer is_clause) P'
Prm'' : permutation KRest2 L'
Prm_Final : permutation ((To, C)::KRest2) ((To, C)::L')
Is3 : is_integer From
Is4 : is_clause C
IsKR2 : is_list (is_pair is_integer is_clause) KRest2
IsL' : is_list (is_pair is_integer is_clause) L'
GCL_P' : good_clause_list P'
GCL_L' : good_clause_list L'
M' : mem (To, C2) L'
============================
 false
</pre>
<pre class="code extensibella"id="280">
 &lt; <b>MKR: apply mem_after_select_before to S M'.</b>

Subgoal 7.1.1:

Variables: K1 K2 KRest C KRest2 Rest To From P' L' C2
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
S : select (From, C) L' P'
IsKR : is_list (is_pair is_integer is_clause) KRest
IsP' : is_list (is_pair is_integer is_clause) P'
Prm'' : permutation KRest2 L'
Prm_Final : permutation ((To, C)::KRest2) ((To, C)::L')
Is3 : is_integer From
Is4 : is_clause C
IsKR2 : is_list (is_pair is_integer is_clause) KRest2
IsL' : is_list (is_pair is_integer is_clause) L'
GCL_P' : good_clause_list P'
GCL_L' : good_clause_list L'
M' : mem (To, C2) L'
MKR : mem (To, C2) P'
============================
 false
</pre>
<pre class="code extensibella"id="281">
 &lt; <b>apply remove_all_no_mem to Prm' MKR.</b>

Subgoal 7.1.2:

Variables: K1 K2 KRest C KRest2 Rest To From P' L' ID C1 C2 L1
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
S : select (From, C) L' P'
IsKR : is_list (is_pair is_integer is_clause) KRest
IsP' : is_list (is_pair is_integer is_clause) P'
Prm'' : permutation KRest2 L'
Prm_Final : permutation ((To, C)::KRest2) ((To, C)::L')
Is3 : is_integer From
Is4 : is_clause C
IsKR2 : is_list (is_pair is_integer is_clause) KRest2
IsL' : is_list (is_pair is_integer is_clause) L'
GCL_P' : good_clause_list P'
GCL_L' : good_clause_list L'
M' : mem (ID, C2) ((To, C)::L1)
S' : select (ID, C1) L1 L'
============================
 false
</pre>
<pre class="code extensibella"id="282">
 &lt; <b>M': case M'.</b>

Subgoal 7.1.2.1:

Variables: K1 K2 KRest C KRest2 Rest To From P' L' C1 L1
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
S : select (From, C) L' P'
IsKR : is_list (is_pair is_integer is_clause) KRest
IsP' : is_list (is_pair is_integer is_clause) P'
Prm'' : permutation KRest2 L'
Prm_Final : permutation ((To, C)::KRest2) ((To, C)::L')
Is3 : is_integer From
Is4 : is_clause C
IsKR2 : is_list (is_pair is_integer is_clause) KRest2
IsL' : is_list (is_pair is_integer is_clause) L'
GCL_P' : good_clause_list P'
GCL_L' : good_clause_list L'
S' : select (To, C1) L1 L'
============================
 false
</pre>
<pre class="code extensibella"id="283">
 &lt; <b>M': apply select_mem to S'.</b>

Subgoal 7.1.2.1:

Variables: K1 K2 KRest C KRest2 Rest To From P' L' C1 L1
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
S : select (From, C) L' P'
IsKR : is_list (is_pair is_integer is_clause) KRest
IsP' : is_list (is_pair is_integer is_clause) P'
Prm'' : permutation KRest2 L'
Prm_Final : permutation ((To, C)::KRest2) ((To, C)::L')
Is3 : is_integer From
Is4 : is_clause C
IsKR2 : is_list (is_pair is_integer is_clause) KRest2
IsL' : is_list (is_pair is_integer is_clause) L'
GCL_P' : good_clause_list P'
GCL_L' : good_clause_list L'
S' : select (To, C1) L1 L'
M' : mem (To, C1) L'
============================
 false
</pre>
<pre class="code extensibella"id="284">
 &lt; <b>M'': apply mem_after_select_before to S M'.</b>

Subgoal 7.1.2.1:

Variables: K1 K2 KRest C KRest2 Rest To From P' L' C1 L1
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
S : select (From, C) L' P'
IsKR : is_list (is_pair is_integer is_clause) KRest
IsP' : is_list (is_pair is_integer is_clause) P'
Prm'' : permutation KRest2 L'
Prm_Final : permutation ((To, C)::KRest2) ((To, C)::L')
Is3 : is_integer From
Is4 : is_clause C
IsKR2 : is_list (is_pair is_integer is_clause) KRest2
IsL' : is_list (is_pair is_integer is_clause) L'
GCL_P' : good_clause_list P'
GCL_L' : good_clause_list L'
S' : select (To, C1) L1 L'
M' : mem (To, C1) L'
M'' : mem (To, C1) P'
============================
 false
</pre>
<pre class="code extensibella"id="285">
 &lt; <b>apply remove_all_no_mem to Prm' M''.</b>

Subgoal 7.1.2.2:

Variables: K1 K2 KRest C KRest2 Rest To From P' L' ID C1 C2 L1
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
S : select (From, C) L' P'
IsKR : is_list (is_pair is_integer is_clause) KRest
IsP' : is_list (is_pair is_integer is_clause) P'
Prm'' : permutation KRest2 L'
Prm_Final : permutation ((To, C)::KRest2) ((To, C)::L')
Is3 : is_integer From
Is4 : is_clause C
IsKR2 : is_list (is_pair is_integer is_clause) KRest2
IsL' : is_list (is_pair is_integer is_clause) L'
GCL_P' : good_clause_list P'
GCL_L' : good_clause_list L'
S' : select (ID, C1) L1 L'
M' : mem (ID, C2) L1
============================
 false
</pre>
<pre class="code extensibella"id="286">
 &lt; <b>GCL': case GCL_L'.</b>

Subgoal 7.1.2.2:

Variables: K1 K2 KRest C KRest2 Rest To From P' L' ID C1 C2 L1
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
S : select (From, C) L' P'
IsKR : is_list (is_pair is_integer is_clause) KRest
IsP' : is_list (is_pair is_integer is_clause) P'
Prm'' : permutation KRest2 L'
Prm_Final : permutation ((To, C)::KRest2) ((To, C)::L')
Is3 : is_integer From
Is4 : is_clause C
IsKR2 : is_list (is_pair is_integer is_clause) KRest2
IsL' : is_list (is_pair is_integer is_clause) L'
GCL_P' : good_clause_list P'
S' : select (ID, C1) L1 L'
M' : mem (ID, C2) L1
GCL' : forall ID C1 KRest C2,
         select (ID, C1) KRest L' -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="287">
 &lt; <b>apply GCL' to S' M'.</b>

Subgoal 7:

Variables: K1 K2 KRest C KRest2 Rest To From P' L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
S : select (From, C) L' P'
IsKR : is_list (is_pair is_integer is_clause) KRest
IsP' : is_list (is_pair is_integer is_clause) P'
Prm'' : permutation KRest2 L'
Prm_Final : permutation ((To, C)::KRest2) ((To, C)::L')
Is3 : is_integer From
Is4 : is_clause C
IsKR2 : is_list (is_pair is_integer is_clause) KRest2
IsL' : is_list (is_pair is_integer is_clause) L'
GCL_P' : good_clause_list P'
GCL_L' : good_clause_list L'
H1 : good_clause_list ((To, C)::L')
============================
 checkProof K2 (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="288">
 &lt; <b>apply IH to Is2 _ _ _ CP4 Prm_Final.</b>

Subgoal 7:

Variables: K1 K2 KRest C KRest2 Rest To From P' L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause From To Rest) @
Prm : permutation K1 K2
CP1 : To = From -&gt; false
CP2 : remove_all K1 To KRest
CP3 : select (From, C) KRest2 KRest
CP4 : checkProof ((To, C)::KRest2) Rest *
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
M : mem (From, C) KRest
Prm' : remove_all K2 To P'
Prm'1 : permutation KRest P'
M2 : mem (From, C) P'
S : select (From, C) L' P'
IsKR : is_list (is_pair is_integer is_clause) KRest
IsP' : is_list (is_pair is_integer is_clause) P'
Prm'' : permutation KRest2 L'
Prm_Final : permutation ((To, C)::KRest2) ((To, C)::L')
Is3 : is_integer From
Is4 : is_clause C
IsKR2 : is_list (is_pair is_integer is_clause) KRest2
IsL' : is_list (is_pair is_integer is_clause) L'
GCL_P' : good_clause_list P'
GCL_L' : good_clause_list L'
H1 : good_clause_list ((To, C)::L')
H2 : checkProof ((To, C)::L') Rest
============================
 checkProof K2 (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="289">
 &lt; <b>search.</b>

Subgoal 8:

Variables: K1 K2 C Rest ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsP : is_proof (relocateClause ID ID Rest)
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause ID ID Rest) @
Prm : permutation K1 K2
CP1 : mem (ID, C) K1
CP2 : checkProof K1 Rest *
============================
 checkProof K2 (relocateClause ID ID Rest)
</pre>
<pre class="code extensibella"id="290">
 &lt; <b>Is: case IsP.</b>

Subgoal 8:

Variables: K1 K2 C Rest ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause ID ID Rest) @
Prm : permutation K1 K2
CP1 : mem (ID, C) K1
CP2 : checkProof K1 Rest *
Is : is_integer ID
Is1 : is_integer ID
Is2 : is_proof Rest
============================
 checkProof K2 (relocateClause ID ID Rest)
</pre>
<pre class="code extensibella"id="291">
 &lt; <b>M2: apply permutation_mem to Prm CP1.</b>

Subgoal 8:

Variables: K1 K2 C Rest ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause ID ID Rest) @
Prm : permutation K1 K2
CP1 : mem (ID, C) K1
CP2 : checkProof K1 Rest *
Is : is_integer ID
Is1 : is_integer ID
Is2 : is_proof Rest
M2 : mem (ID, C) K2
============================
 checkProof K2 (relocateClause ID ID Rest)
</pre>
<pre class="code extensibella"id="292">
 &lt; <b>apply IH to _ _ _ _ CP2 _.</b>

Subgoal 8:

Variables: K1 K2 C Rest ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (relocateClause ID ID Rest) @
Prm : permutation K1 K2
CP1 : mem (ID, C) K1
CP2 : checkProof K1 Rest *
Is : is_integer ID
Is1 : is_integer ID
Is2 : is_proof Rest
M2 : mem (ID, C) K2
H1 : checkProof K2 Rest
============================
 checkProof K2 (relocateClause ID ID Rest)
</pre>
<pre class="code extensibella"id="293">
 &lt; <b>search.</b>

Subgoal 9:

Variables: K1 K2 KRest Rest C ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsP : is_proof (deleteFrat ID C Rest)
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteFrat ID C Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
============================
 checkProof K2 (deleteFrat ID C Rest)
</pre>
<pre class="code extensibella"id="294">
 &lt; <b>Is: case IsP.</b>

Subgoal 9:

Variables: K1 K2 KRest Rest C ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteFrat ID C Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
============================
 checkProof K2 (deleteFrat ID C Rest)
</pre>
<pre class="code extensibella"id="295">
 &lt; <b>IsKRest: apply select_is to _ CP1.</b>

Subgoal 9:

Variables: K1 K2 KRest Rest C ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteFrat ID C Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof K2 (deleteFrat ID C Rest)
</pre>
<pre class="code extensibella"id="296">
 &lt; <b>MK1: apply select_mem to CP1.</b>

Subgoal 9:

Variables: K1 K2 KRest Rest C ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteFrat ID C Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
MK1 : mem (ID, C) K1
============================
 checkProof K2 (deleteFrat ID C Rest)
</pre>
<pre class="code extensibella"id="297">
 &lt; <b>MK2: apply permutation_mem to Prm MK1.</b>

Subgoal 9:

Variables: K1 K2 KRest Rest C ID
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteFrat ID C Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
MK1 : mem (ID, C) K1
MK2 : mem (ID, C) K2
============================
 checkProof K2 (deleteFrat ID C Rest)
</pre>
<pre class="code extensibella"id="298">
 &lt; <b>S: apply mem_select to MK2.</b>

Subgoal 9:

Variables: K1 K2 KRest Rest C ID L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteFrat ID C Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
MK1 : mem (ID, C) K1
MK2 : mem (ID, C) K2
S : select (ID, C) L' K2
============================
 checkProof K2 (deleteFrat ID C Rest)
</pre>
<pre class="code extensibella"id="299">
 &lt; <b>Prm': apply permutation_symmetric to Prm.</b>

Subgoal 9:

Variables: K1 K2 KRest Rest C ID L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteFrat ID C Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
MK1 : mem (ID, C) K1
MK2 : mem (ID, C) K2
S : select (ID, C) L' K2
Prm' : permutation K2 K1
============================
 checkProof K2 (deleteFrat ID C Rest)
</pre>
<pre class="code extensibella"id="300">
 &lt; <b>GCL_K1: apply permutation_good_clause_list to _ Prm' GCL.</b>

Subgoal 9:

Variables: K1 K2 KRest Rest C ID L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteFrat ID C Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
MK1 : mem (ID, C) K1
MK2 : mem (ID, C) K2
S : select (ID, C) L' K2
Prm' : permutation K2 K1
GCL_K1 : good_clause_list K1
============================
 checkProof K2 (deleteFrat ID C Rest)
</pre>
<pre class="code extensibella"id="301">
 &lt; <b>GCL_L': apply good_clause_list_select to GCL S.</b>

Subgoal 9:

Variables: K1 K2 KRest Rest C ID L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteFrat ID C Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
MK1 : mem (ID, C) K1
MK2 : mem (ID, C) K2
S : select (ID, C) L' K2
Prm' : permutation K2 K1
GCL_K1 : good_clause_list K1
GCL_L' : good_clause_list L'
============================
 checkProof K2 (deleteFrat ID C Rest)
</pre>
<pre class="code extensibella"id="302">
 &lt; <b>IsL': apply select_is to _ S.</b>

Subgoal 9:

Variables: K1 K2 KRest Rest C ID L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteFrat ID C Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
MK1 : mem (ID, C) K1
MK2 : mem (ID, C) K2
S : select (ID, C) L' K2
Prm' : permutation K2 K1
GCL_K1 : good_clause_list K1
GCL_L' : good_clause_list L'
IsL' : is_list (is_pair is_integer is_clause) L'
============================
 checkProof K2 (deleteFrat ID C Rest)
</pre>
<pre class="code extensibella"id="303">
 &lt; <b>P': apply selects_permutation to _ _ Prm' _ _.</b>

Subgoal 9:

Variables: K1 K2 KRest Rest C ID L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteFrat ID C Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
MK1 : mem (ID, C) K1
MK2 : mem (ID, C) K2
S : select (ID, C) L' K2
Prm' : permutation K2 K1
GCL_K1 : good_clause_list K1
GCL_L' : good_clause_list L'
IsL' : is_list (is_pair is_integer is_clause) L'
P' : permutation L' KRest
============================
 checkProof K2 (deleteFrat ID C Rest)
</pre>
<pre class="code extensibella"id="304">
 &lt; <b>PrmSub: apply permutation_symmetric to P'.</b>

Subgoal 9:

Variables: K1 K2 KRest Rest C ID L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteFrat ID C Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
MK1 : mem (ID, C) K1
MK2 : mem (ID, C) K2
S : select (ID, C) L' K2
Prm' : permutation K2 K1
GCL_K1 : good_clause_list K1
GCL_L' : good_clause_list L'
IsL' : is_list (is_pair is_integer is_clause) L'
P' : permutation L' KRest
PrmSub : permutation KRest L'
============================
 checkProof K2 (deleteFrat ID C Rest)
</pre>
<pre class="code extensibella"id="305">
 &lt; <b>apply IH to Is2 _ _ GCL_L' CP2 PrmSub.</b>

Subgoal 9:

Variables: K1 K2 KRest Rest C ID L'
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (deleteFrat ID C Rest) @
Prm : permutation K1 K2
CP1 : select (ID, C) KRest K1
CP2 : checkProof KRest Rest *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
IsKRest : is_list (is_pair is_integer is_clause) KRest
MK1 : mem (ID, C) K1
MK2 : mem (ID, C) K2
S : select (ID, C) L' K2
Prm' : permutation K2 K1
GCL_K1 : good_clause_list K1
GCL_L' : good_clause_list L'
IsL' : is_list (is_pair is_integer is_clause) L'
P' : permutation L' KRest
PrmSub : permutation KRest L'
H1 : checkProof L' Rest
============================
 checkProof K2 (deleteFrat ID C Rest)
</pre>
<pre class="code extensibella"id="306">
 &lt; <b>search.</b>

Subgoal 10:

Variables: K1 K2 Rest Comment
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsP : is_proof (commentProof Comment Rest)
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (commentProof Comment Rest) @
Prm : permutation K1 K2
CP1 : checkProof K1 Rest *
============================
 checkProof K2 (commentProof Comment Rest)
</pre>
<pre class="code extensibella"id="307">
 &lt; <b>case IsP.</b>

Subgoal 10:

Variables: K1 K2 Rest Comment
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (commentProof Comment Rest) @
Prm : permutation K1 K2
CP1 : checkProof K1 Rest *
H1 : is_string Comment
H2 : is_proof Rest
============================
 checkProof K2 (commentProof Comment Rest)
</pre>
<pre class="code extensibella"id="308">
 &lt; <b>apply IH to _ _ _ _ CP1 _.</b>

Subgoal 10:

Variables: K1 K2 Rest Comment
IH : forall K1 K2 Prf,
       is_proof Prf -&gt; is_list (is_pair is_integer is_clause) K1 -&gt; is_list (is_pair is_integer is_clause) K2 -&gt;
       good_clause_list K2 -&gt; checkProof K1 Prf * -&gt; permutation K1 K2 -&gt; checkProof K2 Prf
IsK1 : is_list (is_pair is_integer is_clause) K1
IsK2 : is_list (is_pair is_integer is_clause) K2
GCL : good_clause_list K2
CP : checkProof K1 (commentProof Comment Rest) @
Prm : permutation K1 K2
CP1 : checkProof K1 Rest *
H1 : is_string Comment
H2 : is_proof Rest
H3 : checkProof K2 Rest
============================
 checkProof K2 (commentProof Comment Rest)
</pre>
<pre class="code extensibella"id="309">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="310">
 &lt; <b>Theorem rupProof_self :
     forall Known ID C,
       is_clause C -&gt; lookup Known ID C -&gt; rupProof Known C [ID].</b>

============================
 forall Known ID C, is_clause C -&gt; lookup Known ID C -&gt; rupProof Known C [ID]
</pre>
<pre class="code extensibella"id="311">
 &lt; <b>intros IsC Lkp.</b>

Variables: Known ID C
IsC : is_clause C
Lkp : lookup Known ID C
============================
 rupProof Known C [ID]
</pre>
<pre class="code extensibella"id="312">
 &lt; <b>GL: apply gatherLits_exists to IsC.</b>

Variables: Known ID C L
IsC : is_clause C
Lkp : lookup Known ID C
GL : gatherLits C L
============================
 rupProof Known C [ID]
</pre>
<pre class="code extensibella"id="313">
 &lt; <b>IsL: apply gatherLits_is to IsC GL.</b>

Variables: Known ID C L
IsC : is_clause C
Lkp : lookup Known ID C
GL : gatherLits C L
IsL : is_list is_lit L
============================
 rupProof Known C [ID]
</pre>
<pre class="code extensibella"id="314">
 &lt; <b>apply negateLitList_exists to IsL.</b>

Variables: Known ID C L NL
IsC : is_clause C
Lkp : lookup Known ID C
GL : gatherLits C L
IsL : is_list is_lit L
H1 : negateLitList L NL
============================
 rupProof Known C [ID]
</pre>
<pre class="code extensibella"id="315">
 &lt; <b>unfold .</b>

Variables: Known ID C L NL
IsC : is_clause C
Lkp : lookup Known ID C
GL : gatherLits C L
IsL : is_list is_lit L
H1 : negateLitList L NL
============================
 exists Lits A,
   gatherLits C Lits /\ (negateLitList Lits A /\ rupProof_help Known A [ID])
</pre>
<pre class="code extensibella"id="316">
 &lt; <b>exists L,
   NL.</b>

Variables: Known ID C L NL
IsC : is_clause C
Lkp : lookup Known ID C
GL : gatherLits C L
IsL : is_list is_lit L
H1 : negateLitList L NL
============================
 gatherLits C L /\ (negateLitList L NL /\ rupProof_help Known NL [ID])
</pre>
<pre class="code extensibella"id="317">
 &lt; <b>split.</b>

Subgoal 1:

Variables: Known ID C L NL
IsC : is_clause C
Lkp : lookup Known ID C
GL : gatherLits C L
IsL : is_list is_lit L
H1 : negateLitList L NL
============================
 gatherLits C L
</pre>
<pre class="code extensibella"id="318">
 &lt; <b>search.</b>

Subgoal 2:

Variables: Known ID C L NL
IsC : is_clause C
Lkp : lookup Known ID C
GL : gatherLits C L
IsL : is_list is_lit L
H1 : negateLitList L NL
============================
 negateLitList L NL
</pre>
<pre class="code extensibella"id="319">
 &lt; <b>search.</b>

Subgoal 3:

Variables: Known ID C L NL
IsC : is_clause C
Lkp : lookup Known ID C
GL : gatherLits C L
IsL : is_list is_lit L
H1 : negateLitList L NL
============================
 rupProof_help Known NL [ID]
</pre>
<pre class="code extensibella"id="320">
 &lt; <b>unfold .</b>

Subgoal 3:

Variables: Known ID C L NL
IsC : is_clause C
Lkp : lookup Known ID C
GL : gatherLits C L
IsL : is_list is_lit L
H1 : negateLitList L NL
============================
 exists C, lookup Known ID C /\ unsat_clause NL C
</pre>
<pre class="code extensibella"id="321">
 &lt; <b>exists C.</b>

Subgoal 3:

Variables: Known ID C L NL
IsC : is_clause C
Lkp : lookup Known ID C
GL : gatherLits C L
IsL : is_list is_lit L
H1 : negateLitList L NL
============================
 lookup Known ID C /\ unsat_clause NL C
</pre>
<pre class="code extensibella"id="322">
 &lt; <b>split.</b>

Subgoal 3.1:

Variables: Known ID C L NL
IsC : is_clause C
Lkp : lookup Known ID C
GL : gatherLits C L
IsL : is_list is_lit L
H1 : negateLitList L NL
============================
 lookup Known ID C
</pre>
<pre class="code extensibella"id="323">
 &lt; <b>search.</b>

Subgoal 3.2:

Variables: Known ID C L NL
IsC : is_clause C
Lkp : lookup Known ID C
GL : gatherLits C L
IsL : is_list is_lit L
H1 : negateLitList L NL
============================
 unsat_clause NL C
</pre>
<pre class="code extensibella"id="324">
 &lt; <b>apply negate_lits_unsat to _ GL _.</b>

Subgoal 3.2:

Variables: Known ID C L NL
IsC : is_clause C
Lkp : lookup Known ID C
GL : gatherLits C L
IsL : is_list is_lit L
H1 : negateLitList L NL
H2 : unsat_clause NL C
============================
 unsat_clause NL C
</pre>
<pre class="code extensibella"id="325">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="326">
 &lt; <b>Theorem mem_lookup :
     forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; mem (ID, C) K -&gt; exists C',
         lookup K ID C'.</b>

============================
 forall K ID C,
   is_list (is_pair is_integer is_clause) K -&gt; mem (ID, C) K -&gt; exists C',
     lookup K ID C'
</pre>
<pre class="code extensibella"id="327">
 &lt; <b>induction on 2.</b>

IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; mem (ID, C) K * -&gt; exists C',
         lookup K ID C'
============================
 forall K ID C,
   is_list (is_pair is_integer is_clause) K -&gt; mem (ID, C) K @ -&gt; exists C',
     lookup K ID C'
</pre>
<pre class="code extensibella"id="328">
 &lt; <b>intros Is M.</b>

Variables: K ID C
IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; mem (ID, C) K * -&gt; exists C',
         lookup K ID C'
Is : is_list (is_pair is_integer is_clause) K
M : mem (ID, C) K @
============================
 exists C', lookup K ID C'
</pre>
<pre class="code extensibella"id="329">
 &lt; <b>M: case M.</b>

Subgoal 1:

Variables: ID C Rest
IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; mem (ID, C) K * -&gt; exists C',
         lookup K ID C'
Is : is_list (is_pair is_integer is_clause) ((ID, C)::Rest)
============================
 exists C', lookup ((ID, C)::Rest) ID C'
</pre>
<pre class="code extensibella"id="330">
 &lt; <b>search.</b>

Subgoal 2:

Variables: ID C Rest I
IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; mem (ID, C) K * -&gt; exists C',
         lookup K ID C'
Is : is_list (is_pair is_integer is_clause) (I::Rest)
M : mem (ID, C) Rest *
============================
 exists C', lookup (I::Rest) ID C'
</pre>
<pre class="code extensibella"id="331">
 &lt; <b>Is: case Is.</b>

Subgoal 2:

Variables: ID C Rest I
IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; mem (ID, C) K * -&gt; exists C',
         lookup K ID C'
M : mem (ID, C) Rest *
Is : is_pair is_integer is_clause I
Is1 : is_list (is_pair is_integer is_clause) Rest
============================
 exists C', lookup (I::Rest) ID C'
</pre>
<pre class="code extensibella"id="332">
 &lt; <b>IsP: case Is.</b>

Subgoal 2:

Variables: ID C Rest B A
IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; mem (ID, C) K * -&gt; exists C',
         lookup K ID C'
M : mem (ID, C) Rest *
Is1 : is_list (is_pair is_integer is_clause) Rest
IsP : is_integer A
IsP1 : is_clause B
============================
 exists C', lookup ((A, B)::Rest) ID C'
</pre>
<pre class="code extensibella"id="333">
 &lt; <b>IsID: apply mem_is to _ M.</b>

Subgoal 2:

Variables: Rest B A ID1 C1
IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; mem (ID, C) K * -&gt; exists C',
         lookup K ID C'
M : mem (ID1, C1) Rest *
Is1 : is_list (is_pair is_integer is_clause) Rest
IsP : is_integer A
IsP1 : is_clause B
IsID : is_integer ID1
IsID1 : is_clause C1
============================
 exists C', lookup ((A, B)::Rest) ID1 C'
</pre>
<pre class="code extensibella"id="334">
 &lt; <b>Or: apply is_integer_eq_or_not to IsP IsID.</b>

Subgoal 2:

Variables: Rest B A ID1 C1
IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; mem (ID, C) K * -&gt; exists C',
         lookup K ID C'
M : mem (ID1, C1) Rest *
Is1 : is_list (is_pair is_integer is_clause) Rest
IsP : is_integer A
IsP1 : is_clause B
IsID : is_integer ID1
IsID1 : is_clause C1
Or : A = ID1 \/ (A = ID1 -&gt; false)
============================
 exists C', lookup ((A, B)::Rest) ID1 C'
</pre>
<pre class="code extensibella"id="335">
 &lt; <b>N: case Or.</b>

Subgoal 2.1:

Variables: Rest B ID1 C1
IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; mem (ID, C) K * -&gt; exists C',
         lookup K ID C'
M : mem (ID1, C1) Rest *
Is1 : is_list (is_pair is_integer is_clause) Rest
IsP : is_integer ID1
IsP1 : is_clause B
IsID : is_integer ID1
IsID1 : is_clause C1
============================
 exists C', lookup ((ID1, B)::Rest) ID1 C'
</pre>
<pre class="code extensibella"id="336">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: Rest B A ID1 C1
IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; mem (ID, C) K * -&gt; exists C',
         lookup K ID C'
M : mem (ID1, C1) Rest *
Is1 : is_list (is_pair is_integer is_clause) Rest
IsP : is_integer A
IsP1 : is_clause B
IsID : is_integer ID1
IsID1 : is_clause C1
N : A = ID1 -&gt; false
============================
 exists C', lookup ((A, B)::Rest) ID1 C'
</pre>
<pre class="code extensibella"id="337">
 &lt; <b>apply IH to _ M.</b>

Subgoal 2.2:

Variables: Rest B A ID1 C1 C'
IH : forall K ID C,
       is_list (is_pair is_integer is_clause) K -&gt; mem (ID, C) K * -&gt; exists C',
         lookup K ID C'
M : mem (ID1, C1) Rest *
Is1 : is_list (is_pair is_integer is_clause) Rest
IsP : is_integer A
IsP1 : is_clause B
IsID : is_integer ID1
IsID1 : is_clause C1
N : A = ID1 -&gt; false
H1 : lookup Rest ID1 C'
============================
 exists C', lookup ((A, B)::Rest) ID1 C'
</pre>
<pre class="code extensibella"id="338">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="339">
 &lt; <b>Add_Ext_Size unsat_proofs:lrat:checkProof.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="340">
 &lt; <b>Add_Proj_Rel unsat_proofs:lrat:checkProof.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="341">
 &lt; <b>Prove_Ext_Ind unsat_proofs:lrat:checkProof.</b>

Subgoal 4:

Variables: Known KRest Prf Final ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (endFrat ID Final) 1 @@
Acc : acc 1 @
IsP : is_proof (endFrat ID Final)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : remove_all Known ID KRest
R2 : rupProof Known emptyClause Prf
R3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
============================
 &lt;checkProof {P}&gt; Known (endFrat ID Final)
</pre>
<pre class="code extensibella"id="342">
 &lt; <b>search.</b>

Subgoal 5:

Variables: Known KRest Final Prf ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (endFratPrf ID Prf Final) 1 @@
Acc : acc 1 @
IsP : is_proof (endFratPrf ID Prf Final)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : remove_all Known ID KRest
R2 : rupProof Known emptyClause Prf
R3 : checkFinalClauses ((ID, emptyClause)::KRest) Final
============================
 &lt;checkProof {P}&gt; Known (endFratPrf ID Prf Final)
</pre>
<pre class="code extensibella"id="343">
 &lt; <b>search.</b>

Subgoal 6:

Variables: N Known N2 KRest Prf Rest C ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (addProofless ID C Rest) N @@
Acc : acc N @
IsP : is_proof (addProofless ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : remove_all Known ID KRest
R3 : rupProof Known C Prf
R4 : &lt;checkProof {ES}&gt; ((ID, C)::KRest) Rest N2 **
============================
 &lt;checkProof {P}&gt; Known (addProofless ID C Rest)
</pre>
<pre class="code extensibella"id="344">
 &lt; <b>case IsP.</b>

Subgoal 6:

Variables: N Known N2 KRest Prf Rest C ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (addProofless ID C Rest) N @@
Acc : acc N @
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : remove_all Known ID KRest
R3 : rupProof Known C Prf
R4 : &lt;checkProof {ES}&gt; ((ID, C)::KRest) Rest N2 **
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
============================
 &lt;checkProof {P}&gt; Known (addProofless ID C Rest)
</pre>
<pre class="code extensibella"id="345">
 &lt; <b>Acc: case Acc.</b>

Subgoal 6:

Variables: N Known N2 KRest Prf Rest C ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (addProofless ID C Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : remove_all Known ID KRest
R3 : rupProof Known C Prf
R4 : &lt;checkProof {ES}&gt; ((ID, C)::KRest) Rest N2 **
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
============================
 &lt;checkProof {P}&gt; Known (addProofless ID C Rest)
</pre>
<pre class="code extensibella"id="346">
 &lt; <b>apply ext_size_is_int_checkProof to R4.</b>

Subgoal 6:

Variables: N Known N2 KRest Prf Rest C ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (addProofless ID C Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : remove_all Known ID KRest
R3 : rupProof Known C Prf
R4 : &lt;checkProof {ES}&gt; ((ID, C)::KRest) Rest N2 **
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
============================
 &lt;checkProof {P}&gt; Known (addProofless ID C Rest)
</pre>
<pre class="code extensibella"id="347">
 &lt; <b>L: apply lt_plus_one to R1 _.</b>

Subgoal 6:

Variables: N Known N2 KRest Prf Rest C ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (addProofless ID C Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : remove_all Known ID KRest
R3 : rupProof Known C Prf
R4 : &lt;checkProof {ES}&gt; ((ID, C)::KRest) Rest N2 **
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
============================
 &lt;checkProof {P}&gt; Known (addProofless ID C Rest)
</pre>
<pre class="code extensibella"id="348">
 &lt; <b>apply ext_size_pos_checkProof to R4.</b>

Subgoal 6:

Variables: N Known N2 KRest Prf Rest C ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (addProofless ID C Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : remove_all Known ID KRest
R3 : rupProof Known C Prf
R4 : &lt;checkProof {ES}&gt; ((ID, C)::KRest) Rest N2 **
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
============================
 &lt;checkProof {P}&gt; Known (addProofless ID C Rest)
</pre>
<pre class="code extensibella"id="349">
 &lt; <b>A: apply Acc to _ L.</b>

Subgoal 6:

Variables: N Known N2 KRest Prf Rest C ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (addProofless ID C Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : remove_all Known ID KRest
R3 : rupProof Known C Prf
R4 : &lt;checkProof {ES}&gt; ((ID, C)::KRest) Rest N2 **
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
============================
 &lt;checkProof {P}&gt; Known (addProofless ID C Rest)
</pre>
<pre class="code extensibella"id="350">
 &lt; <b>apply remove_all_is to _ R2.</b>

Subgoal 6:

Variables: N Known N2 KRest Prf Rest C ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (addProofless ID C Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : remove_all Known ID KRest
R3 : rupProof Known C Prf
R4 : &lt;checkProof {ES}&gt; ((ID, C)::KRest) Rest N2 **
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
============================
 &lt;checkProof {P}&gt; Known (addProofless ID C Rest)
</pre>
<pre class="code extensibella"id="351">
 &lt; <b>apply good_clause_list_remove_all_add to GCL R2 with
     C = C.</b>

Subgoal 6:

Variables: N Known N2 KRest Prf Rest C ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (addProofless ID C Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : remove_all Known ID KRest
R3 : rupProof Known C Prf
R4 : &lt;checkProof {ES}&gt; ((ID, C)::KRest) Rest N2 **
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : good_clause_list ((ID, C)::KRest)
============================
 &lt;checkProof {P}&gt; Known (addProofless ID C Rest)
</pre>
<pre class="code extensibella"id="352">
 &lt; <b>apply IH to R4 A _ _ _.</b>

Subgoal 6:

Variables: N Known N2 KRest Prf Rest C ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (addProofless ID C Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : remove_all Known ID KRest
R3 : rupProof Known C Prf
R4 : &lt;checkProof {ES}&gt; ((ID, C)::KRest) Rest N2 **
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : good_clause_list ((ID, C)::KRest)
H8 : &lt;checkProof {P}&gt; ((ID, C)::KRest) Rest
============================
 &lt;checkProof {P}&gt; Known (addProofless ID C Rest)
</pre>
<pre class="code extensibella"id="353">
 &lt; <b>search.</b>

Subgoal 7:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
Acc : acc N @
IsP : is_proof (relocateClause From To Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
============================
 &lt;checkProof {P}&gt; Known (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="354">
 &lt; <b>case IsP.</b>

Subgoal 7:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
Acc : acc N @
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
============================
 &lt;checkProof {P}&gt; Known (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="355">
 &lt; <b>Acc: case Acc.</b>

Subgoal 7:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
============================
 &lt;checkProof {P}&gt; Known (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="356">
 &lt; <b>apply ext_size_is_int_checkProof to R5.</b>

Subgoal 7:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
============================
 &lt;checkProof {P}&gt; Known (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="357">
 &lt; <b>L: apply lt_plus_one to R1 _.</b>

Subgoal 7:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
============================
 &lt;checkProof {P}&gt; Known (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="358">
 &lt; <b>apply ext_size_pos_checkProof to R5.</b>

Subgoal 7:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
============================
 &lt;checkProof {P}&gt; Known (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="359">
 &lt; <b>A: apply Acc to _ L.</b>

Subgoal 7:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
============================
 &lt;checkProof {P}&gt; Known (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="360">
 &lt; <b>apply remove_all_is to _ R3.</b>

Subgoal 7:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
============================
 &lt;checkProof {P}&gt; Known (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="361">
 &lt; <b>apply select_is to _ R4.</b>

Subgoal 7:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
============================
 &lt;checkProof {P}&gt; Known (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="362">
 &lt; <b>IsIDC: apply select_is_picked to _ R4.</b>

Subgoal 7:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_pair is_integer is_clause (From, C)
============================
 &lt;checkProof {P}&gt; Known (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="363">
 &lt; <b>IsIDC: case IsIDC.</b>

Subgoal 7:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
============================
 &lt;checkProof {P}&gt; Known (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="364">
 &lt; <b>assert good_clause_list ((To, C)::KRest2).</b>

Subgoal 7.1:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
============================
 good_clause_list ((To, C)::KRest2)
</pre>
<pre class="code extensibella"id="365">
 &lt; <b>GCL1: apply good_clause_list_remove_all to GCL R3.</b>

Subgoal 7.1:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
GCL1 : good_clause_list KRest
============================
 good_clause_list ((To, C)::KRest2)
</pre>
<pre class="code extensibella"id="366">
 &lt; <b>GCL2: apply good_clause_list_select to GCL1 R4.</b>

Subgoal 7.1:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
GCL1 : good_clause_list KRest
GCL2 : good_clause_list KRest2
============================
 good_clause_list ((To, C)::KRest2)
</pre>
<pre class="code extensibella"id="367">
 &lt; <b>unfold .</b>

Subgoal 7.1:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
GCL1 : good_clause_list KRest
GCL2 : good_clause_list KRest2
============================
 forall ID C1 KRest C2,
   select (ID, C1) KRest ((To, C)::KRest2) -&gt; mem (ID, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="368">
 &lt; <b>intros S M.</b>

Subgoal 7.1:

Variables: N Known N2 KRest C KRest2 Rest To From ID C1 KRest1 C2
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
GCL1 : good_clause_list KRest
GCL2 : good_clause_list KRest2
S : select (ID, C1) KRest1 ((To, C)::KRest2)
M : mem (ID, C2) KRest1
============================
 false
</pre>
<pre class="code extensibella"id="369">
 &lt; <b>S: case S.</b>

Subgoal 7.1.1:

Variables: N Known N2 KRest C KRest2 Rest To From C2
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
GCL1 : good_clause_list KRest
GCL2 : good_clause_list KRest2
M : mem (To, C2) KRest2
============================
 false
</pre>
<pre class="code extensibella"id="370">
 &lt; <b>MKR: apply mem_after_select_before to R4 M.</b>

Subgoal 7.1.1:

Variables: N Known N2 KRest C KRest2 Rest To From C2
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
GCL1 : good_clause_list KRest
GCL2 : good_clause_list KRest2
M : mem (To, C2) KRest2
MKR : mem (To, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="371">
 &lt; <b>apply remove_all_no_mem to R3 MKR.</b>

Subgoal 7.1.2:

Variables: N Known N2 KRest C KRest2 Rest To From ID C1 C2 L1
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
GCL1 : good_clause_list KRest
GCL2 : good_clause_list KRest2
M : mem (ID, C2) ((To, C)::L1)
S : select (ID, C1) L1 KRest2
============================
 false
</pre>
<pre class="code extensibella"id="372">
 &lt; <b>M: case M.</b>

Subgoal 7.1.2.1:

Variables: N Known N2 KRest C KRest2 Rest To From C1 L1
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
GCL1 : good_clause_list KRest
GCL2 : good_clause_list KRest2
S : select (To, C1) L1 KRest2
============================
 false
</pre>
<pre class="code extensibella"id="373">
 &lt; <b>M: apply select_mem to S.</b>

Subgoal 7.1.2.1:

Variables: N Known N2 KRest C KRest2 Rest To From C1 L1
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
GCL1 : good_clause_list KRest
GCL2 : good_clause_list KRest2
S : select (To, C1) L1 KRest2
M : mem (To, C1) KRest2
============================
 false
</pre>
<pre class="code extensibella"id="374">
 &lt; <b>M': apply mem_after_select_before to R4 M.</b>

Subgoal 7.1.2.1:

Variables: N Known N2 KRest C KRest2 Rest To From C1 L1
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
GCL1 : good_clause_list KRest
GCL2 : good_clause_list KRest2
S : select (To, C1) L1 KRest2
M : mem (To, C1) KRest2
M' : mem (To, C1) KRest
============================
 false
</pre>
<pre class="code extensibella"id="375">
 &lt; <b>apply remove_all_no_mem to R3 M'.</b>

Subgoal 7.1.2.2:

Variables: N Known N2 KRest C KRest2 Rest To From ID C1 C2 L1
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
GCL1 : good_clause_list KRest
GCL2 : good_clause_list KRest2
S : select (ID, C1) L1 KRest2
M : mem (ID, C2) L1
============================
 false
</pre>
<pre class="code extensibella"id="376">
 &lt; <b>GCL': case GCL2.</b>

Subgoal 7.1.2.2:

Variables: N Known N2 KRest C KRest2 Rest To From ID C1 C2 L1
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
GCL1 : good_clause_list KRest
S : select (ID, C1) L1 KRest2
M : mem (ID, C2) L1
GCL' : forall ID C1 KRest C2,
         select (ID, C1) KRest KRest2 -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="377">
 &lt; <b>apply GCL' to S M.</b>

Subgoal 7:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
============================
 &lt;checkProof {P}&gt; Known (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="378">
 &lt; <b>apply IH to R5 A _ _ _.</b>

Subgoal 7:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
============================
 &lt;checkProof {P}&gt; Known (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="379">
 &lt; <b>MKR: apply select_mem to R4.</b>

Subgoal 7:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
============================
 &lt;checkProof {P}&gt; Known (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="380">
 &lt; <b>MK: apply remove_all_mem_after to R3 MKR.</b>

Subgoal 7:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
MK : mem (From, C) Known
============================
 &lt;checkProof {P}&gt; Known (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="381">
 &lt; <b>LK: apply mem_lookup to _ MK.</b>

Subgoal 7:

Variables: N Known N2 KRest C KRest2 Rest To From C'
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
MK : mem (From, C) Known
LK : lookup Known From C'
============================
 &lt;checkProof {P}&gt; Known (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="382">
 &lt; <b>MK': apply lookup_mem to LK.</b>

Subgoal 7:

Variables: N Known N2 KRest C KRest2 Rest To From C'
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
MK : mem (From, C) Known
LK : lookup Known From C'
MK' : mem (From, C') Known
============================
 &lt;checkProof {P}&gt; Known (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="383">
 &lt; <b>apply good_clause_list_mems to GCL MK' MK.</b>

Subgoal 7:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
MK : mem (From, C) Known
LK : lookup Known From C
MK' : mem (From, C) Known
============================
 &lt;checkProof {P}&gt; Known (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="384">
 &lt; <b>apply rupProof_self to IsIDC1 _ with
     Known = Known ID = From.</b>

Subgoal 7:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
MK : mem (From, C) Known
LK : lookup Known From C
MK' : mem (From, C) Known
H10 : rupProof Known C [From]
============================
 &lt;checkProof {P}&gt; Known (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="385">
 &lt; <b>Proj: assert Known |{proof}- relocateClause From To Rest ~~&gt; addLrupProof To C [From] (deleteLratProof From Rest).</b>

Subgoal 7:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
MK : mem (From, C) Known
LK : lookup Known From C
MK' : mem (From, C) Known
H10 : rupProof Known C [From]
Proj : Known |{proof}- relocateClause From To Rest ~~&gt; addLrupProof To C [From] (deleteLratProof From Rest)
============================
 &lt;checkProof {P}&gt; Known (relocateClause From To Rest)
</pre>
<pre class="code extensibella"id="386">
 &lt; <b>unfold .</b>

Subgoal 7:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
MK : mem (From, C) Known
LK : lookup Known From C
MK' : mem (From, C) Known
H10 : rupProof Known C [From]
Proj : Known |{proof}- relocateClause From To Rest ~~&gt; addLrupProof To C [From] (deleteLratProof From Rest)
============================
 exists P_P KRest C KRest2,
   ((To = From -&gt; false) /\
   (remove_all Known To KRest /\
   (select (From, C) KRest2 KRest /\ &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest))) /\
   (Known |{proof}- relocateClause From To Rest ~~&gt; P_P /\
   &lt;checkProof {P}&gt; Known P_P)
</pre>
<pre class="code extensibella"id="387">
 &lt; <b>exists addLrupProof To C [From] (deleteLratProof From Rest).</b>

Subgoal 7:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
MK : mem (From, C) Known
LK : lookup Known From C
MK' : mem (From, C) Known
H10 : rupProof Known C [From]
Proj : Known |{proof}- relocateClause From To Rest ~~&gt; addLrupProof To C [From] (deleteLratProof From Rest)
============================
 exists KRest C1 KRest2,
   ((To = From -&gt; false) /\
   (remove_all Known To KRest /\
   (select (From, C1) KRest2 KRest /\ &lt;checkProof {P}&gt; ((To, C1)::KRest2) Rest))) /\
   (Known |{proof}- relocateClause From To Rest ~~&gt; addLrupProof To C [From] (deleteLratProof From Rest) /\
   &lt;checkProof {P}&gt; Known (addLrupProof To C [From] (deleteLratProof From Rest)))
</pre>
<pre class="code extensibella"id="388">
 &lt; <b>exists KRest,
   C,
   KRest2.</b>

Subgoal 7:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
MK : mem (From, C) Known
LK : lookup Known From C
MK' : mem (From, C) Known
H10 : rupProof Known C [From]
Proj : Known |{proof}- relocateClause From To Rest ~~&gt; addLrupProof To C [From] (deleteLratProof From Rest)
============================
 ((To = From -&gt; false) /\
 (remove_all Known To KRest /\
 (select (From, C) KRest2 KRest /\ &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest))) /\
 (Known |{proof}- relocateClause From To Rest ~~&gt; addLrupProof To C [From] (deleteLratProof From Rest) /\
 &lt;checkProof {P}&gt; Known (addLrupProof To C [From] (deleteLratProof From Rest)))
</pre>
<pre class="code extensibella"id="389">
 &lt; <b>split.</b>

Subgoal 7.2:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
MK : mem (From, C) Known
LK : lookup Known From C
MK' : mem (From, C) Known
H10 : rupProof Known C [From]
Proj : Known |{proof}- relocateClause From To Rest ~~&gt; addLrupProof To C [From] (deleteLratProof From Rest)
============================
 To = From -&gt; false
</pre>
<pre class="code extensibella"id="390">
 &lt; <b>search.</b>

Subgoal 7.3:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
MK : mem (From, C) Known
LK : lookup Known From C
MK' : mem (From, C) Known
H10 : rupProof Known C [From]
Proj : Known |{proof}- relocateClause From To Rest ~~&gt; addLrupProof To C [From] (deleteLratProof From Rest)
============================
 remove_all Known To KRest
</pre>
<pre class="code extensibella"id="391">
 &lt; <b>search.</b>

Subgoal 7.4:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
MK : mem (From, C) Known
LK : lookup Known From C
MK' : mem (From, C) Known
H10 : rupProof Known C [From]
Proj : Known |{proof}- relocateClause From To Rest ~~&gt; addLrupProof To C [From] (deleteLratProof From Rest)
============================
 select (From, C) KRest2 KRest
</pre>
<pre class="code extensibella"id="392">
 &lt; <b>search.</b>

Subgoal 7.5:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
MK : mem (From, C) Known
LK : lookup Known From C
MK' : mem (From, C) Known
H10 : rupProof Known C [From]
Proj : Known |{proof}- relocateClause From To Rest ~~&gt; addLrupProof To C [From] (deleteLratProof From Rest)
============================
 &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
</pre>
<pre class="code extensibella"id="393">
 &lt; <b>search.</b>

Subgoal 7.6:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
MK : mem (From, C) Known
LK : lookup Known From C
MK' : mem (From, C) Known
H10 : rupProof Known C [From]
Proj : Known |{proof}- relocateClause From To Rest ~~&gt; addLrupProof To C [From] (deleteLratProof From Rest)
============================
 Known |{proof}- relocateClause From To Rest ~~&gt; addLrupProof To C [From] (deleteLratProof From Rest)
</pre>
<pre class="code extensibella"id="394">
 &lt; <b>search.</b>

Subgoal 7.7:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
MK : mem (From, C) Known
LK : lookup Known From C
MK' : mem (From, C) Known
H10 : rupProof Known C [From]
Proj : Known |{proof}- relocateClause From To Rest ~~&gt; addLrupProof To C [From] (deleteLratProof From Rest)
============================
 &lt;checkProof {P}&gt; Known (addLrupProof To C [From] (deleteLratProof From Rest))
</pre>
<pre class="code extensibella"id="395">
 &lt; <b>unfold .</b>

Subgoal 7.7:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
MK : mem (From, C) Known
LK : lookup Known From C
MK' : mem (From, C) Known
H10 : rupProof Known C [From]
Proj : Known |{proof}- relocateClause From To Rest ~~&gt; addLrupProof To C [From] (deleteLratProof From Rest)
============================
 exists KRest,
   remove_all Known To KRest /\
   (rupProof Known C [From] /\
   &lt;checkProof {P}&gt; ((To, C)::KRest) (deleteLratProof From Rest))
</pre>
<pre class="code extensibella"id="396">
 &lt; <b>exists KRest.</b>

Subgoal 7.7:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
MK : mem (From, C) Known
LK : lookup Known From C
MK' : mem (From, C) Known
H10 : rupProof Known C [From]
Proj : Known |{proof}- relocateClause From To Rest ~~&gt; addLrupProof To C [From] (deleteLratProof From Rest)
============================
 remove_all Known To KRest /\
 (rupProof Known C [From] /\
 &lt;checkProof {P}&gt; ((To, C)::KRest) (deleteLratProof From Rest))
</pre>
<pre class="code extensibella"id="397">
 &lt; <b>split.</b>

Subgoal 7.7.1:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
MK : mem (From, C) Known
LK : lookup Known From C
MK' : mem (From, C) Known
H10 : rupProof Known C [From]
Proj : Known |{proof}- relocateClause From To Rest ~~&gt; addLrupProof To C [From] (deleteLratProof From Rest)
============================
 remove_all Known To KRest
</pre>
<pre class="code extensibella"id="398">
 &lt; <b>search.</b>

Subgoal 7.7.2:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
MK : mem (From, C) Known
LK : lookup Known From C
MK' : mem (From, C) Known
H10 : rupProof Known C [From]
Proj : Known |{proof}- relocateClause From To Rest ~~&gt; addLrupProof To C [From] (deleteLratProof From Rest)
============================
 rupProof Known C [From]
</pre>
<pre class="code extensibella"id="399">
 &lt; <b>search.</b>

Subgoal 7.7.3:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
MK : mem (From, C) Known
LK : lookup Known From C
MK' : mem (From, C) Known
H10 : rupProof Known C [From]
Proj : Known |{proof}- relocateClause From To Rest ~~&gt; addLrupProof To C [From] (deleteLratProof From Rest)
============================
 &lt;checkProof {P}&gt; ((To, C)::KRest) (deleteLratProof From Rest)
</pre>
<pre class="code extensibella"id="400">
 &lt; <b>unfold .</b>

Subgoal 7.7.3:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
MK : mem (From, C) Known
LK : lookup Known From C
MK' : mem (From, C) Known
H10 : rupProof Known C [From]
Proj : Known |{proof}- relocateClause From To Rest ~~&gt; addLrupProof To C [From] (deleteLratProof From Rest)
============================
 exists C1 KRest1,
   select (From, C1) KRest1 ((To, C)::KRest) /\ &lt;checkProof {P}&gt; KRest1 Rest
</pre>
<pre class="code extensibella"id="401">
 &lt; <b>exists C,
   (To, C)::KRest2.</b>

Subgoal 7.7.3:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
MK : mem (From, C) Known
LK : lookup Known From C
MK' : mem (From, C) Known
H10 : rupProof Known C [From]
Proj : Known |{proof}- relocateClause From To Rest ~~&gt; addLrupProof To C [From] (deleteLratProof From Rest)
============================
 select (From, C) ((To, C)::KRest2) ((To, C)::KRest) /\
 &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
</pre>
<pre class="code extensibella"id="402">
 &lt; <b>split.</b>

Subgoal 7.7.3.1:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
MK : mem (From, C) Known
LK : lookup Known From C
MK' : mem (From, C) Known
H10 : rupProof Known C [From]
Proj : Known |{proof}- relocateClause From To Rest ~~&gt; addLrupProof To C [From] (deleteLratProof From Rest)
============================
 select (From, C) ((To, C)::KRest2) ((To, C)::KRest)
</pre>
<pre class="code extensibella"id="403">
 &lt; <b>search.</b>

Subgoal 7.7.3.2:

Variables: N Known N2 KRest C KRest2 Rest To From
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause From To Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : To = From -&gt; false
R3 : remove_all Known To KRest
R4 : select (From, C) KRest2 KRest
R5 : &lt;checkProof {ES}&gt; ((To, C)::KRest2) Rest N2 **
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H4 : is_integer N2
L : N2 &lt; N
H5 : 0 &lt;= N2
A : acc N2 *
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : is_list (is_pair is_integer is_clause) KRest2
IsIDC : is_integer From
IsIDC1 : is_clause C
H8 : good_clause_list ((To, C)::KRest2)
H9 : &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
MKR : mem (From, C) KRest
MK : mem (From, C) Known
LK : lookup Known From C
MK' : mem (From, C) Known
H10 : rupProof Known C [From]
Proj : Known |{proof}- relocateClause From To Rest ~~&gt; addLrupProof To C [From] (deleteLratProof From Rest)
============================
 &lt;checkProof {P}&gt; ((To, C)::KRest2) Rest
</pre>
<pre class="code extensibella"id="404">
 &lt; <b>search.</b>

Subgoal 8:

Variables: N Known N2 C Rest ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause ID ID Rest) N @@
Acc : acc N @
IsP : is_proof (relocateClause ID ID Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : mem (ID, C) Known
R3 : &lt;checkProof {ES}&gt; Known Rest N2 **
============================
 &lt;checkProof {P}&gt; Known (relocateClause ID ID Rest)
</pre>
<pre class="code extensibella"id="405">
 &lt; <b>Acc: case Acc.</b>

Subgoal 8:

Variables: N Known N2 C Rest ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause ID ID Rest) N @@
IsP : is_proof (relocateClause ID ID Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : mem (ID, C) Known
R3 : &lt;checkProof {ES}&gt; Known Rest N2 **
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
============================
 &lt;checkProof {P}&gt; Known (relocateClause ID ID Rest)
</pre>
<pre class="code extensibella"id="406">
 &lt; <b>apply ext_size_is_int_checkProof to R3.</b>

Subgoal 8:

Variables: N Known N2 C Rest ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause ID ID Rest) N @@
IsP : is_proof (relocateClause ID ID Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : mem (ID, C) Known
R3 : &lt;checkProof {ES}&gt; Known Rest N2 **
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H1 : is_integer N2
============================
 &lt;checkProof {P}&gt; Known (relocateClause ID ID Rest)
</pre>
<pre class="code extensibella"id="407">
 &lt; <b>L: apply lt_plus_one to R1 _.</b>

Subgoal 8:

Variables: N Known N2 C Rest ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause ID ID Rest) N @@
IsP : is_proof (relocateClause ID ID Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : mem (ID, C) Known
R3 : &lt;checkProof {ES}&gt; Known Rest N2 **
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H1 : is_integer N2
L : N2 &lt; N
============================
 &lt;checkProof {P}&gt; Known (relocateClause ID ID Rest)
</pre>
<pre class="code extensibella"id="408">
 &lt; <b>apply ext_size_pos_checkProof to R3.</b>

Subgoal 8:

Variables: N Known N2 C Rest ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause ID ID Rest) N @@
IsP : is_proof (relocateClause ID ID Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : mem (ID, C) Known
R3 : &lt;checkProof {ES}&gt; Known Rest N2 **
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H1 : is_integer N2
L : N2 &lt; N
H2 : 0 &lt;= N2
============================
 &lt;checkProof {P}&gt; Known (relocateClause ID ID Rest)
</pre>
<pre class="code extensibella"id="409">
 &lt; <b>A: apply Acc to _ L.</b>

Subgoal 8:

Variables: N Known N2 C Rest ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause ID ID Rest) N @@
IsP : is_proof (relocateClause ID ID Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : mem (ID, C) Known
R3 : &lt;checkProof {ES}&gt; Known Rest N2 **
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H1 : is_integer N2
L : N2 &lt; N
H2 : 0 &lt;= N2
A : acc N2 *
============================
 &lt;checkProof {P}&gt; Known (relocateClause ID ID Rest)
</pre>
<pre class="code extensibella"id="410">
 &lt; <b>case IsP.</b>

Subgoal 8:

Variables: N Known N2 C Rest ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause ID ID Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : mem (ID, C) Known
R3 : &lt;checkProof {ES}&gt; Known Rest N2 **
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H1 : is_integer N2
L : N2 &lt; N
H2 : 0 &lt;= N2
A : acc N2 *
H3 : is_integer ID
H4 : is_integer ID
H5 : is_proof Rest
============================
 &lt;checkProof {P}&gt; Known (relocateClause ID ID Rest)
</pre>
<pre class="code extensibella"id="411">
 &lt; <b>apply IH to R3 A _ _ _.</b>

Subgoal 8:

Variables: N Known N2 C Rest ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause ID ID Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : mem (ID, C) Known
R3 : &lt;checkProof {ES}&gt; Known Rest N2 **
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H1 : is_integer N2
L : N2 &lt; N
H2 : 0 &lt;= N2
A : acc N2 *
H3 : is_integer ID
H4 : is_integer ID
H5 : is_proof Rest
H6 : &lt;checkProof {P}&gt; Known Rest
============================
 &lt;checkProof {P}&gt; Known (relocateClause ID ID Rest)
</pre>
<pre class="code extensibella"id="412">
 &lt; <b>Proj: assert Known |{proof}- relocateClause ID ID Rest ~~&gt; Rest.</b>

Subgoal 8:

Variables: N Known N2 C Rest ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (relocateClause ID ID Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : mem (ID, C) Known
R3 : &lt;checkProof {ES}&gt; Known Rest N2 **
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H1 : is_integer N2
L : N2 &lt; N
H2 : 0 &lt;= N2
A : acc N2 *
H3 : is_integer ID
H4 : is_integer ID
H5 : is_proof Rest
H6 : &lt;checkProof {P}&gt; Known Rest
Proj : Known |{proof}- relocateClause ID ID Rest ~~&gt; Rest
============================
 &lt;checkProof {P}&gt; Known (relocateClause ID ID Rest)
</pre>
<pre class="code extensibella"id="413">
 &lt; <b>search.</b>

Subgoal 9:

Variables: N Known N2 KRest Rest C ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (deleteFrat ID C Rest) N @@
Acc : acc N @
IsP : is_proof (deleteFrat ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : select (ID, C) KRest Known
R3 : &lt;checkProof {ES}&gt; KRest Rest N2 **
============================
 &lt;checkProof {P}&gt; Known (deleteFrat ID C Rest)
</pre>
<pre class="code extensibella"id="414">
 &lt; <b>Proj: assert Known |{proof}- deleteFrat ID C Rest ~~&gt; deleteLratProof ID Rest.</b>

Subgoal 9:

Variables: N Known N2 KRest Rest C ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (deleteFrat ID C Rest) N @@
Acc : acc N @
IsP : is_proof (deleteFrat ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : select (ID, C) KRest Known
R3 : &lt;checkProof {ES}&gt; KRest Rest N2 **
Proj : Known |{proof}- deleteFrat ID C Rest ~~&gt; deleteLratProof ID Rest
============================
 &lt;checkProof {P}&gt; Known (deleteFrat ID C Rest)
</pre>
<pre class="code extensibella"id="415">
 &lt; <b>Acc: case Acc.</b>

Subgoal 9:

Variables: N Known N2 KRest Rest C ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (deleteFrat ID C Rest) N @@
IsP : is_proof (deleteFrat ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : select (ID, C) KRest Known
R3 : &lt;checkProof {ES}&gt; KRest Rest N2 **
Proj : Known |{proof}- deleteFrat ID C Rest ~~&gt; deleteLratProof ID Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
============================
 &lt;checkProof {P}&gt; Known (deleteFrat ID C Rest)
</pre>
<pre class="code extensibella"id="416">
 &lt; <b>apply ext_size_is_int_checkProof to R3.</b>

Subgoal 9:

Variables: N Known N2 KRest Rest C ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (deleteFrat ID C Rest) N @@
IsP : is_proof (deleteFrat ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : select (ID, C) KRest Known
R3 : &lt;checkProof {ES}&gt; KRest Rest N2 **
Proj : Known |{proof}- deleteFrat ID C Rest ~~&gt; deleteLratProof ID Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H1 : is_integer N2
============================
 &lt;checkProof {P}&gt; Known (deleteFrat ID C Rest)
</pre>
<pre class="code extensibella"id="417">
 &lt; <b>L: apply lt_plus_one to R1 _.</b>

Subgoal 9:

Variables: N Known N2 KRest Rest C ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (deleteFrat ID C Rest) N @@
IsP : is_proof (deleteFrat ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : select (ID, C) KRest Known
R3 : &lt;checkProof {ES}&gt; KRest Rest N2 **
Proj : Known |{proof}- deleteFrat ID C Rest ~~&gt; deleteLratProof ID Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H1 : is_integer N2
L : N2 &lt; N
============================
 &lt;checkProof {P}&gt; Known (deleteFrat ID C Rest)
</pre>
<pre class="code extensibella"id="418">
 &lt; <b>apply ext_size_pos_checkProof to R3.</b>

Subgoal 9:

Variables: N Known N2 KRest Rest C ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (deleteFrat ID C Rest) N @@
IsP : is_proof (deleteFrat ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : select (ID, C) KRest Known
R3 : &lt;checkProof {ES}&gt; KRest Rest N2 **
Proj : Known |{proof}- deleteFrat ID C Rest ~~&gt; deleteLratProof ID Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H1 : is_integer N2
L : N2 &lt; N
H2 : 0 &lt;= N2
============================
 &lt;checkProof {P}&gt; Known (deleteFrat ID C Rest)
</pre>
<pre class="code extensibella"id="419">
 &lt; <b>A: apply Acc to _ L.</b>

Subgoal 9:

Variables: N Known N2 KRest Rest C ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (deleteFrat ID C Rest) N @@
IsP : is_proof (deleteFrat ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : select (ID, C) KRest Known
R3 : &lt;checkProof {ES}&gt; KRest Rest N2 **
Proj : Known |{proof}- deleteFrat ID C Rest ~~&gt; deleteLratProof ID Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H1 : is_integer N2
L : N2 &lt; N
H2 : 0 &lt;= N2
A : acc N2 *
============================
 &lt;checkProof {P}&gt; Known (deleteFrat ID C Rest)
</pre>
<pre class="code extensibella"id="420">
 &lt; <b>case IsP.</b>

Subgoal 9:

Variables: N Known N2 KRest Rest C ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (deleteFrat ID C Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : select (ID, C) KRest Known
R3 : &lt;checkProof {ES}&gt; KRest Rest N2 **
Proj : Known |{proof}- deleteFrat ID C Rest ~~&gt; deleteLratProof ID Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H1 : is_integer N2
L : N2 &lt; N
H2 : 0 &lt;= N2
A : acc N2 *
H3 : is_integer ID
H4 : is_clause C
H5 : is_proof Rest
============================
 &lt;checkProof {P}&gt; Known (deleteFrat ID C Rest)
</pre>
<pre class="code extensibella"id="421">
 &lt; <b>apply select_is to _ R2.</b>

Subgoal 9:

Variables: N Known N2 KRest Rest C ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (deleteFrat ID C Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : select (ID, C) KRest Known
R3 : &lt;checkProof {ES}&gt; KRest Rest N2 **
Proj : Known |{proof}- deleteFrat ID C Rest ~~&gt; deleteLratProof ID Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H1 : is_integer N2
L : N2 &lt; N
H2 : 0 &lt;= N2
A : acc N2 *
H3 : is_integer ID
H4 : is_clause C
H5 : is_proof Rest
H6 : is_list (is_pair is_integer is_clause) KRest
============================
 &lt;checkProof {P}&gt; Known (deleteFrat ID C Rest)
</pre>
<pre class="code extensibella"id="422">
 &lt; <b>apply good_clause_list_select to GCL R2.</b>

Subgoal 9:

Variables: N Known N2 KRest Rest C ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (deleteFrat ID C Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : select (ID, C) KRest Known
R3 : &lt;checkProof {ES}&gt; KRest Rest N2 **
Proj : Known |{proof}- deleteFrat ID C Rest ~~&gt; deleteLratProof ID Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H1 : is_integer N2
L : N2 &lt; N
H2 : 0 &lt;= N2
A : acc N2 *
H3 : is_integer ID
H4 : is_clause C
H5 : is_proof Rest
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : good_clause_list KRest
============================
 &lt;checkProof {P}&gt; Known (deleteFrat ID C Rest)
</pre>
<pre class="code extensibella"id="423">
 &lt; <b>apply IH to R3 A _ _ _.</b>

Subgoal 9:

Variables: N Known N2 KRest Rest C ID
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (deleteFrat ID C Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : select (ID, C) KRest Known
R3 : &lt;checkProof {ES}&gt; KRest Rest N2 **
Proj : Known |{proof}- deleteFrat ID C Rest ~~&gt; deleteLratProof ID Rest
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H1 : is_integer N2
L : N2 &lt; N
H2 : 0 &lt;= N2
A : acc N2 *
H3 : is_integer ID
H4 : is_clause C
H5 : is_proof Rest
H6 : is_list (is_pair is_integer is_clause) KRest
H7 : good_clause_list KRest
H8 : &lt;checkProof {P}&gt; KRest Rest
============================
 &lt;checkProof {P}&gt; Known (deleteFrat ID C Rest)
</pre>
<pre class="code extensibella"id="424">
 &lt; <b>search.</b>

Subgoal 10:

Variables: N Known N2 Rest Comment
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (commentProof Comment Rest) N @@
Acc : acc N @
IsP : is_proof (commentProof Comment Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : &lt;checkProof {ES}&gt; Known Rest N2 **
============================
 &lt;checkProof {P}&gt; Known (commentProof Comment Rest)
</pre>
<pre class="code extensibella"id="425">
 &lt; <b>Acc: case Acc.</b>

Subgoal 10:

Variables: N Known N2 Rest Comment
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (commentProof Comment Rest) N @@
IsP : is_proof (commentProof Comment Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : &lt;checkProof {ES}&gt; Known Rest N2 **
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
============================
 &lt;checkProof {P}&gt; Known (commentProof Comment Rest)
</pre>
<pre class="code extensibella"id="426">
 &lt; <b>apply ext_size_is_int_checkProof to R2.</b>

Subgoal 10:

Variables: N Known N2 Rest Comment
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (commentProof Comment Rest) N @@
IsP : is_proof (commentProof Comment Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : &lt;checkProof {ES}&gt; Known Rest N2 **
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H1 : is_integer N2
============================
 &lt;checkProof {P}&gt; Known (commentProof Comment Rest)
</pre>
<pre class="code extensibella"id="427">
 &lt; <b>L: apply lt_plus_one to R1 _.</b>

Subgoal 10:

Variables: N Known N2 Rest Comment
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (commentProof Comment Rest) N @@
IsP : is_proof (commentProof Comment Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : &lt;checkProof {ES}&gt; Known Rest N2 **
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H1 : is_integer N2
L : N2 &lt; N
============================
 &lt;checkProof {P}&gt; Known (commentProof Comment Rest)
</pre>
<pre class="code extensibella"id="428">
 &lt; <b>apply ext_size_pos_checkProof to R2.</b>

Subgoal 10:

Variables: N Known N2 Rest Comment
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (commentProof Comment Rest) N @@
IsP : is_proof (commentProof Comment Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : &lt;checkProof {ES}&gt; Known Rest N2 **
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H1 : is_integer N2
L : N2 &lt; N
H2 : 0 &lt;= N2
============================
 &lt;checkProof {P}&gt; Known (commentProof Comment Rest)
</pre>
<pre class="code extensibella"id="429">
 &lt; <b>A: apply Acc to _ L.</b>

Subgoal 10:

Variables: N Known N2 Rest Comment
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (commentProof Comment Rest) N @@
IsP : is_proof (commentProof Comment Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : &lt;checkProof {ES}&gt; Known Rest N2 **
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H1 : is_integer N2
L : N2 &lt; N
H2 : 0 &lt;= N2
A : acc N2 *
============================
 &lt;checkProof {P}&gt; Known (commentProof Comment Rest)
</pre>
<pre class="code extensibella"id="430">
 &lt; <b>case IsP.</b>

Subgoal 10:

Variables: N Known N2 Rest Comment
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (commentProof Comment Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : &lt;checkProof {ES}&gt; Known Rest N2 **
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H1 : is_integer N2
L : N2 &lt; N
H2 : 0 &lt;= N2
A : acc N2 *
H3 : is_string Comment
H4 : is_proof Rest
============================
 &lt;checkProof {P}&gt; Known (commentProof Comment Rest)
</pre>
<pre class="code extensibella"id="431">
 &lt; <b>apply IH to R2 A _ _ _.</b>

Subgoal 10:

Variables: N Known N2 Rest Comment
IH : forall N Known P,
       &lt;checkProof {ES}&gt; Known P N -&gt; acc N * -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
IH1 : forall N Known P,
        &lt;checkProof {ES}&gt; Known P N ** -&gt; acc N @ -&gt; is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Known -&gt; &lt;checkProof {P}&gt; Known P
R : &lt;checkProof {ES}&gt; Known (commentProof Comment Rest) N @@
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
R1 : 1 + N2 = N
R2 : &lt;checkProof {ES}&gt; Known Rest N2 **
Acc : forall M, 0 &lt;= M -&gt; M &lt; N -&gt; acc M *
H1 : is_integer N2
L : N2 &lt; N
H2 : 0 &lt;= N2
A : acc N2 *
H3 : is_string Comment
H4 : is_proof Rest
H5 : &lt;checkProof {P}&gt; Known Rest
============================
 &lt;checkProof {P}&gt; Known (commentProof Comment Rest)
</pre>
<pre class="code extensibella"id="432">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="433">
 &lt; <b>Prove_Constraint unsat_proofs:lrat:proj_checkProof.</b>

Subgoal 1:

Variables: Known Prf ID FC
Hyp : Known |{proof}- endFrat ID FC ~~&gt; emptyLrat ID Prf
Hyp1 : checkProof Known (endFrat ID FC)
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
Hyp4 : rupProof Known emptyClause Prf
============================
 checkProof Known (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="434">
 &lt; <b>case Hyp1.</b>

Subgoal 1:

Variables: Known Prf ID FC KRest Prf1
Hyp : Known |{proof}- endFrat ID FC ~~&gt; emptyLrat ID Prf
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
Hyp4 : rupProof Known emptyClause Prf
H1 : remove_all Known ID KRest
H2 : rupProof Known emptyClause Prf1
H3 : checkFinalClauses ((ID, emptyClause)::KRest) FC
============================
 checkProof Known (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="435">
 &lt; <b>search.</b>

Subgoal 2:

Variables: Known Prf ID FC
Hyp : Known |{proof}- endFratPrf ID Prf FC ~~&gt; emptyLrat ID Prf
Hyp1 : checkProof Known (endFratPrf ID Prf FC)
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
============================
 checkProof Known (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="436">
 &lt; <b>case Hyp1.</b>

Subgoal 2:

Variables: Known Prf ID FC KRest
Hyp : Known |{proof}- endFratPrf ID Prf FC ~~&gt; emptyLrat ID Prf
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
H1 : remove_all Known ID KRest
H2 : rupProof Known emptyClause Prf
H3 : checkFinalClauses ((ID, emptyClause)::KRest) FC
============================
 checkProof Known (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="437">
 &lt; <b>search.</b>

Subgoal 3:

Variables: Known Rest Prf C ID
Hyp : Known |{proof}- addProofless ID C Rest ~~&gt; addLrupProof ID C Prf Rest
Hyp1 : checkProof Known (addProofless ID C Rest)
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
Hyp4 : rupProof Known C Prf
============================
 checkProof Known (addLrupProof ID C Prf Rest)
</pre>
<pre class="code extensibella"id="438">
 &lt; <b>case Hyp1.</b>

Subgoal 3:

Variables: Known Rest Prf C ID KRest Prf1
Hyp : Known |{proof}- addProofless ID C Rest ~~&gt; addLrupProof ID C Prf Rest
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
Hyp4 : rupProof Known C Prf
H1 : remove_all Known ID KRest
H2 : rupProof Known C Prf1
H3 : checkProof ((ID, C)::KRest) Rest
============================
 checkProof Known (addLrupProof ID C Prf Rest)
</pre>
<pre class="code extensibella"id="439">
 &lt; <b>search.</b>

Subgoal 4:

Variables: Known Rest F C T
Hyp : Known |{proof}- relocateClause F T Rest ~~&gt; addLrupProof T C [F] (deleteLratProof F Rest)
Hyp1 : checkProof Known (relocateClause F T Rest)
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
Hyp4 : T = F -&gt; false
Hyp5 : mem (F, C) Known
============================
 checkProof Known (addLrupProof T C [F] (deleteLratProof F Rest))
</pre>
<pre class="code extensibella"id="440">
 &lt; <b>Prf: case Hyp1.</b>

Subgoal 4.1:

Variables: Known Rest F C T KRest C1 KRest2
Hyp : Known |{proof}- relocateClause F T Rest ~~&gt; addLrupProof T C [F] (deleteLratProof F Rest)
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
Hyp4 : T = F -&gt; false
Hyp5 : mem (F, C) Known
Prf : T = F -&gt; false
Prf1 : remove_all Known T KRest
Prf2 : select (F, C1) KRest2 KRest
Prf3 : checkProof ((T, C1)::KRest2) Rest
============================
 checkProof Known (addLrupProof T C [F] (deleteLratProof F Rest))
</pre>
<pre class="code extensibella"id="441">
 &lt; <b>M: apply select_mem to Prf2.</b>

Subgoal 4.1:

Variables: Known Rest F C T KRest C1 KRest2
Hyp : Known |{proof}- relocateClause F T Rest ~~&gt; addLrupProof T C [F] (deleteLratProof F Rest)
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
Hyp4 : T = F -&gt; false
Hyp5 : mem (F, C) Known
Prf : T = F -&gt; false
Prf1 : remove_all Known T KRest
Prf2 : select (F, C1) KRest2 KRest
Prf3 : checkProof ((T, C1)::KRest2) Rest
M : mem (F, C1) KRest
============================
 checkProof Known (addLrupProof T C [F] (deleteLratProof F Rest))
</pre>
<pre class="code extensibella"id="442">
 &lt; <b>M': apply remove_all_mem_after to Prf1 M.</b>

Subgoal 4.1:

Variables: Known Rest F C T KRest C1 KRest2
Hyp : Known |{proof}- relocateClause F T Rest ~~&gt; addLrupProof T C [F] (deleteLratProof F Rest)
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
Hyp4 : T = F -&gt; false
Hyp5 : mem (F, C) Known
Prf : T = F -&gt; false
Prf1 : remove_all Known T KRest
Prf2 : select (F, C1) KRest2 KRest
Prf3 : checkProof ((T, C1)::KRest2) Rest
M : mem (F, C1) KRest
M' : mem (F, C1) Known
============================
 checkProof Known (addLrupProof T C [F] (deleteLratProof F Rest))
</pre>
<pre class="code extensibella"id="443">
 &lt; <b>apply good_clause_list_mems to _ Hyp5 M'.</b>

Subgoal 4.1:

Variables: Known Rest F T KRest C1 KRest2
Hyp : Known |{proof}- relocateClause F T Rest ~~&gt; addLrupProof T C1 [F] (deleteLratProof F Rest)
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
Hyp4 : T = F -&gt; false
Hyp5 : mem (F, C1) Known
Prf : T = F -&gt; false
Prf1 : remove_all Known T KRest
Prf2 : select (F, C1) KRest2 KRest
Prf3 : checkProof ((T, C1)::KRest2) Rest
M : mem (F, C1) KRest
M' : mem (F, C1) Known
============================
 checkProof Known (addLrupProof T C1 [F] (deleteLratProof F Rest))
</pre>
<pre class="code extensibella"id="444">
 &lt; <b>Is: apply mem_is to _ M'.</b>

Subgoal 4.1:

Variables: Known Rest T KRest KRest2 ID C2
Hyp : Known |{proof}- relocateClause ID T Rest ~~&gt; addLrupProof T C2 [ID] (deleteLratProof ID Rest)
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
Hyp4 : T = ID -&gt; false
Hyp5 : mem (ID, C2) Known
Prf : T = ID -&gt; false
Prf1 : remove_all Known T KRest
Prf2 : select (ID, C2) KRest2 KRest
Prf3 : checkProof ((T, C2)::KRest2) Rest
M : mem (ID, C2) KRest
M' : mem (ID, C2) Known
Is : is_integer ID
Is1 : is_clause C2
============================
 checkProof Known (addLrupProof T C2 [ID] (deleteLratProof ID Rest))
</pre>
<pre class="code extensibella"id="445">
 &lt; <b>apply remove_all_is to _ Prf1.</b>

Subgoal 4.1:

Variables: Known Rest T KRest KRest2 ID C2
Hyp : Known |{proof}- relocateClause ID T Rest ~~&gt; addLrupProof T C2 [ID] (deleteLratProof ID Rest)
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
Hyp4 : T = ID -&gt; false
Hyp5 : mem (ID, C2) Known
Prf : T = ID -&gt; false
Prf1 : remove_all Known T KRest
Prf2 : select (ID, C2) KRest2 KRest
Prf3 : checkProof ((T, C2)::KRest2) Rest
M : mem (ID, C2) KRest
M' : mem (ID, C2) Known
Is : is_integer ID
Is1 : is_clause C2
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof Known (addLrupProof T C2 [ID] (deleteLratProof ID Rest))
</pre>
<pre class="code extensibella"id="446">
 &lt; <b>L: apply is_list_mem_lookup to _ M _.</b>

Subgoal 4.1:

Variables: Known Rest T KRest KRest2 ID C2 C'
Hyp : Known |{proof}- relocateClause ID T Rest ~~&gt; addLrupProof T C2 [ID] (deleteLratProof ID Rest)
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
Hyp4 : T = ID -&gt; false
Hyp5 : mem (ID, C2) Known
Prf : T = ID -&gt; false
Prf1 : remove_all Known T KRest
Prf2 : select (ID, C2) KRest2 KRest
Prf3 : checkProof ((T, C2)::KRest2) Rest
M : mem (ID, C2) KRest
M' : mem (ID, C2) Known
Is : is_integer ID
Is1 : is_clause C2
H1 : is_list (is_pair is_integer is_clause) KRest
L : lookup KRest ID C'
============================
 checkProof Known (addLrupProof T C2 [ID] (deleteLratProof ID Rest))
</pre>
<pre class="code extensibella"id="447">
 &lt; <b>M2: apply lookup_mem to L.</b>

Subgoal 4.1:

Variables: Known Rest T KRest KRest2 ID C2 C'
Hyp : Known |{proof}- relocateClause ID T Rest ~~&gt; addLrupProof T C2 [ID] (deleteLratProof ID Rest)
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
Hyp4 : T = ID -&gt; false
Hyp5 : mem (ID, C2) Known
Prf : T = ID -&gt; false
Prf1 : remove_all Known T KRest
Prf2 : select (ID, C2) KRest2 KRest
Prf3 : checkProof ((T, C2)::KRest2) Rest
M : mem (ID, C2) KRest
M' : mem (ID, C2) Known
Is : is_integer ID
Is1 : is_clause C2
H1 : is_list (is_pair is_integer is_clause) KRest
L : lookup KRest ID C'
M2 : mem (ID, C') KRest
============================
 checkProof Known (addLrupProof T C2 [ID] (deleteLratProof ID Rest))
</pre>
<pre class="code extensibella"id="448">
 &lt; <b>apply good_clause_list_remove_all to _ Prf1.</b>

Subgoal 4.1:

Variables: Known Rest T KRest KRest2 ID C2 C'
Hyp : Known |{proof}- relocateClause ID T Rest ~~&gt; addLrupProof T C2 [ID] (deleteLratProof ID Rest)
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
Hyp4 : T = ID -&gt; false
Hyp5 : mem (ID, C2) Known
Prf : T = ID -&gt; false
Prf1 : remove_all Known T KRest
Prf2 : select (ID, C2) KRest2 KRest
Prf3 : checkProof ((T, C2)::KRest2) Rest
M : mem (ID, C2) KRest
M' : mem (ID, C2) Known
Is : is_integer ID
Is1 : is_clause C2
H1 : is_list (is_pair is_integer is_clause) KRest
L : lookup KRest ID C'
M2 : mem (ID, C') KRest
H2 : good_clause_list KRest
============================
 checkProof Known (addLrupProof T C2 [ID] (deleteLratProof ID Rest))
</pre>
<pre class="code extensibella"id="449">
 &lt; <b>apply good_clause_list_mems to _ M2 M.</b>

Subgoal 4.1:

Variables: Known Rest T KRest KRest2 ID C2
Hyp : Known |{proof}- relocateClause ID T Rest ~~&gt; addLrupProof T C2 [ID] (deleteLratProof ID Rest)
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
Hyp4 : T = ID -&gt; false
Hyp5 : mem (ID, C2) Known
Prf : T = ID -&gt; false
Prf1 : remove_all Known T KRest
Prf2 : select (ID, C2) KRest2 KRest
Prf3 : checkProof ((T, C2)::KRest2) Rest
M : mem (ID, C2) KRest
M' : mem (ID, C2) Known
Is : is_integer ID
Is1 : is_clause C2
H1 : is_list (is_pair is_integer is_clause) KRest
L : lookup KRest ID C2
M2 : mem (ID, C2) KRest
H2 : good_clause_list KRest
============================
 checkProof Known (addLrupProof T C2 [ID] (deleteLratProof ID Rest))
</pre>
<pre class="code extensibella"id="450">
 &lt; <b>L': apply remove_all_lookup_after to Prf1 L.</b>

Subgoal 4.1:

Variables: Known Rest T KRest KRest2 ID C2
Hyp : Known |{proof}- relocateClause ID T Rest ~~&gt; addLrupProof T C2 [ID] (deleteLratProof ID Rest)
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
Hyp4 : T = ID -&gt; false
Hyp5 : mem (ID, C2) Known
Prf : T = ID -&gt; false
Prf1 : remove_all Known T KRest
Prf2 : select (ID, C2) KRest2 KRest
Prf3 : checkProof ((T, C2)::KRest2) Rest
M : mem (ID, C2) KRest
M' : mem (ID, C2) Known
Is : is_integer ID
Is1 : is_clause C2
H1 : is_list (is_pair is_integer is_clause) KRest
L : lookup KRest ID C2
M2 : mem (ID, C2) KRest
H2 : good_clause_list KRest
L' : lookup Known ID C2
============================
 checkProof Known (addLrupProof T C2 [ID] (deleteLratProof ID Rest))
</pre>
<pre class="code extensibella"id="451">
 &lt; <b>RUP: apply rupProof_self to Is1 L'.</b>

Subgoal 4.1:

Variables: Known Rest T KRest KRest2 ID C2
Hyp : Known |{proof}- relocateClause ID T Rest ~~&gt; addLrupProof T C2 [ID] (deleteLratProof ID Rest)
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
Hyp4 : T = ID -&gt; false
Hyp5 : mem (ID, C2) Known
Prf : T = ID -&gt; false
Prf1 : remove_all Known T KRest
Prf2 : select (ID, C2) KRest2 KRest
Prf3 : checkProof ((T, C2)::KRest2) Rest
M : mem (ID, C2) KRest
M' : mem (ID, C2) Known
Is : is_integer ID
Is1 : is_clause C2
H1 : is_list (is_pair is_integer is_clause) KRest
L : lookup KRest ID C2
M2 : mem (ID, C2) KRest
H2 : good_clause_list KRest
L' : lookup Known ID C2
RUP : rupProof Known C2 [ID]
============================
 checkProof Known (addLrupProof T C2 [ID] (deleteLratProof ID Rest))
</pre>
<pre class="code extensibella"id="452">
 &lt; <b>search.</b>

Subgoal 4.2:

Variables: Known Rest C T C1
Hyp : Known |{proof}- relocateClause T T Rest ~~&gt; addLrupProof T C [T] (deleteLratProof T Rest)
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
Hyp4 : T = T -&gt; false
Hyp5 : mem (T, C) Known
Prf : mem (T, C1) Known
Prf1 : checkProof Known Rest
============================
 checkProof Known (addLrupProof T C [T] (deleteLratProof T Rest))
</pre>
<pre class="code extensibella"id="453">
 &lt; <b>apply Hyp4 to _.</b>

Subgoal 5:

Variables: Known P' ID
Hyp : Known |{proof}- relocateClause ID ID P' ~~&gt; P'
Hyp1 : checkProof Known (relocateClause ID ID P')
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
============================
 checkProof Known P'
</pre>
<pre class="code extensibella"id="454">
 &lt; <b>Prf: case Hyp1.</b>

Subgoal 5.1:

Variables: Known P' ID KRest C KRest2
Hyp : Known |{proof}- relocateClause ID ID P' ~~&gt; P'
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
Prf : ID = ID -&gt; false
Prf1 : remove_all Known ID KRest
Prf2 : select (ID, C) KRest2 KRest
Prf3 : checkProof ((ID, C)::KRest2) P'
============================
 checkProof Known P'
</pre>
<pre class="code extensibella"id="455">
 &lt; <b>apply Prf to _.</b>

Subgoal 5.2:

Variables: Known P' ID C
Hyp : Known |{proof}- relocateClause ID ID P' ~~&gt; P'
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
Prf : mem (ID, C) Known
Prf1 : checkProof Known P'
============================
 checkProof Known P'
</pre>
<pre class="code extensibella"id="456">
 &lt; <b>search.</b>

Subgoal 6:

Variables: Known Rest ID C
Hyp : Known |{proof}- deleteFrat ID C Rest ~~&gt; deleteLratProof ID Rest
Hyp1 : checkProof Known (deleteFrat ID C Rest)
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
============================
 checkProof Known (deleteLratProof ID Rest)
</pre>
<pre class="code extensibella"id="457">
 &lt; <b>case Hyp1.</b>

Subgoal 6:

Variables: Known Rest ID C KRest
Hyp : Known |{proof}- deleteFrat ID C Rest ~~&gt; deleteLratProof ID Rest
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
H1 : select (ID, C) KRest Known
H2 : checkProof KRest Rest
============================
 checkProof Known (deleteLratProof ID Rest)
</pre>
<pre class="code extensibella"id="458">
 &lt; <b>search.</b>

Subgoal 7:

Variables: Known P' Comment
Hyp : Known |{proof}- commentProof Comment P' ~~&gt; P'
Hyp1 : checkProof Known (commentProof Comment P')
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
============================
 checkProof Known P'
</pre>
<pre class="code extensibella"id="459">
 &lt; <b>case Hyp1.</b>

Subgoal 7:

Variables: Known P' Comment
Hyp : Known |{proof}- commentProof Comment P' ~~&gt; P'
Hyp2 : is_list (is_pair is_integer is_clause) Known
Hyp3 : good_clause_list Known
H1 : checkProof Known P'
============================
 checkProof Known P'
</pre>
<pre class="code extensibella"id="460">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="461">
 &lt; <b>Prove unsat_proofs:lrat:formulaToKnown_unique.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="462">
 &lt; <b>Prove unsat_proofs:lrat:formulaToKnown_all_greater.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="463">
 &lt; <b>Prove unsat_proofs:lrat:formulaToKnown_all_unique.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="464">
 &lt; <b>Prove unsat_proofs:lrat:formulaToKnown_sat_formula.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="465">
 &lt; <b>Prove unsat_proofs:lrat:formulaToKnown_is.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="466">
 &lt; <b>Extensible_Theorem
      checkFratProof_correct : forall FormulaClauses Known FP Sat,
         IsFP : is_fratProof FP -&gt;
         IsSat : is_list is_lit Sat -&gt;
         GA_Sat : good_assignment Sat -&gt;
         GCL_K : good_clause_list Known -&gt;
         GCL_FC : good_clause_list FormulaClauses -&gt;
         IsKnown : is_list (is_pair is_integer is_clause) Known -&gt;
         IsFC : is_list (is_pair is_integer is_clause) FormulaClauses -&gt;
         NoMem : (forall ID CK CFC,
           mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt;
         CFP : checkFratProof FormulaClauses Known FP -&gt;
         SatK : (forall CID C,
           lookup Known CID C -&gt; sat_clause Sat C) -&gt;
         SatFC : (forall CID C,
           lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt;
         false
      on CFP.</b>

Subgoal 1:

Variables: FormulaClauses Known Sat CRest Rest C ID
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsFP : is_fratProof (addOriginal ID C Rest)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
============================
 false
</pre>
<pre class="code extensibella"id="467">
 &lt; <b>IsFP: case IsFP.</b>

Subgoal 1:

Variables: FormulaClauses Known Sat CRest Rest C ID
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
============================
 false
</pre>
<pre class="code extensibella"id="468">
 &lt; <b>SatC: assert sat_clause Sat C.</b>

Subgoal 1.1:

Variables: FormulaClauses Known Sat CRest Rest C ID
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
============================
 sat_clause Sat C
</pre>
<pre class="code extensibella"id="469">
 &lt; <b>M1: apply select_mem to CFP1.</b>

Subgoal 1.1:

Variables: FormulaClauses Known Sat CRest Rest C ID
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
M1 : mem (ID, C) FormulaClauses
============================
 sat_clause Sat C
</pre>
<pre class="code extensibella"id="470">
 &lt; <b>Is: apply select_is_picked to _ CFP1.</b>

Subgoal 1.1:

Variables: FormulaClauses Known Sat CRest Rest C ID
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
M1 : mem (ID, C) FormulaClauses
Is : is_pair is_integer is_clause (ID, C)
============================
 sat_clause Sat C
</pre>
<pre class="code extensibella"id="471">
 &lt; <b>Is: case Is.</b>

Subgoal 1.1:

Variables: FormulaClauses Known Sat CRest Rest C ID
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
M1 : mem (ID, C) FormulaClauses
Is : is_integer ID
Is1 : is_clause C
============================
 sat_clause Sat C
</pre>
<pre class="code extensibella"id="472">
 &lt; <b>Lkp: apply is_list_mem_lookup to IsFC M1 _.</b>

Subgoal 1.1:

Variables: FormulaClauses Known Sat CRest Rest C ID C'
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
M1 : mem (ID, C) FormulaClauses
Is : is_integer ID
Is1 : is_clause C
Lkp : lookup FormulaClauses ID C'
============================
 sat_clause Sat C
</pre>
<pre class="code extensibella"id="473">
 &lt; <b>M2: apply lookup_mem to Lkp.</b>

Subgoal 1.1:

Variables: FormulaClauses Known Sat CRest Rest C ID C'
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
M1 : mem (ID, C) FormulaClauses
Is : is_integer ID
Is1 : is_clause C
Lkp : lookup FormulaClauses ID C'
M2 : mem (ID, C') FormulaClauses
============================
 sat_clause Sat C
</pre>
<pre class="code extensibella"id="474">
 &lt; <b>apply good_clause_list_mems to _ M1 M2.</b>

Subgoal 1.1:

Variables: FormulaClauses Known Sat CRest Rest ID C'
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C' Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C') CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C')::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C'
IsFP2 : is_fratProof Rest
M1 : mem (ID, C') FormulaClauses
Is : is_integer ID
Is1 : is_clause C'
Lkp : lookup FormulaClauses ID C'
M2 : mem (ID, C') FormulaClauses
============================
 sat_clause Sat C'
</pre>
<pre class="code extensibella"id="475">
 &lt; <b>apply SatFC to Lkp.</b>

Subgoal 1.1:

Variables: FormulaClauses Known Sat CRest Rest ID C'
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C' Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C') CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C')::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C'
IsFP2 : is_fratProof Rest
M1 : mem (ID, C') FormulaClauses
Is : is_integer ID
Is1 : is_clause C'
Lkp : lookup FormulaClauses ID C'
M2 : mem (ID, C') FormulaClauses
H1 : sat_clause Sat C'
============================
 sat_clause Sat C'
</pre>
<pre class="code extensibella"id="476">
 &lt; <b>search.</b>

Subgoal 1:

Variables: FormulaClauses Known Sat CRest Rest C ID
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
============================
 false
</pre>
<pre class="code extensibella"id="477">
 &lt; <b>assert forall CID C,
     lookup CRest CID C -&gt; sat_clause Sat C.</b>

Subgoal 1.2:

Variables: FormulaClauses Known Sat CRest Rest C ID
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
============================
 forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
</pre>
<pre class="code extensibella"id="478">
 &lt; <b>intros Lkp.</b>

Subgoal 1.2:

Variables: FormulaClauses Known Sat CRest Rest C ID CID C1
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
Lkp : lookup CRest CID C1
============================
 sat_clause Sat C1
</pre>
<pre class="code extensibella"id="479">
 &lt; <b>M: apply lookup_mem to Lkp.</b>

Subgoal 1.2:

Variables: FormulaClauses Known Sat CRest Rest C ID CID C1
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
Lkp : lookup CRest CID C1
M : mem (CID, C1) CRest
============================
 sat_clause Sat C1
</pre>
<pre class="code extensibella"id="480">
 &lt; <b>apply select_is to _ CFP1.</b>

Subgoal 1.2:

Variables: FormulaClauses Known Sat CRest Rest C ID CID C1
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
Lkp : lookup CRest CID C1
M : mem (CID, C1) CRest
H1 : is_list (is_pair is_integer is_clause) CRest
============================
 sat_clause Sat C1
</pre>
<pre class="code extensibella"id="481">
 &lt; <b>apply mem_is to _ M.</b>

Subgoal 1.2:

Variables: FormulaClauses Known Sat CRest Rest C ID ID1 C2
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
Lkp : lookup CRest ID1 C2
M : mem (ID1, C2) CRest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C2
============================
 sat_clause Sat C2
</pre>
<pre class="code extensibella"id="482">
 &lt; <b>assert forall I C1 C2,
     mem (I, C1) FormulaClauses -&gt; mem (I, C2) FormulaClauses -&gt; C1 = C2.</b>

Subgoal 1.2.1:

Variables: FormulaClauses Known Sat CRest Rest C ID ID1 C2
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
Lkp : lookup CRest ID1 C2
M : mem (ID1, C2) CRest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C2
============================
 forall I C1 C2,
   mem (I, C1) FormulaClauses -&gt; mem (I, C2) FormulaClauses -&gt; C1 = C2
</pre>
<pre class="code extensibella"id="483">
 &lt; <b>intros MA MB.</b>

Subgoal 1.2.1:

Variables: FormulaClauses Known Sat CRest Rest C ID ID1 C2 I C3 C4
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
Lkp : lookup CRest ID1 C2
M : mem (ID1, C2) CRest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C2
MA : mem (I, C3) FormulaClauses
MB : mem (I, C4) FormulaClauses
============================
 C3 = C4
</pre>
<pre class="code extensibella"id="484">
 &lt; <b>apply good_clause_list_mems to _ MA MB.</b>

Subgoal 1.2.1:

Variables: FormulaClauses Known Sat CRest Rest C ID ID1 C2 I C4
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
Lkp : lookup CRest ID1 C2
M : mem (ID1, C2) CRest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C2
MA : mem (I, C4) FormulaClauses
MB : mem (I, C4) FormulaClauses
============================
 C4 = C4
</pre>
<pre class="code extensibella"id="485">
 &lt; <b>search.</b>

Subgoal 1.2:

Variables: FormulaClauses Known Sat CRest Rest C ID ID1 C2
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
Lkp : lookup CRest ID1 C2
M : mem (ID1, C2) CRest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C2
H4 : forall I C1 C2,
       mem (I, C1) FormulaClauses -&gt; mem (I, C2) FormulaClauses -&gt; C1 = C2
============================
 sat_clause Sat C2
</pre>
<pre class="code extensibella"id="486">
 &lt; <b>Lkp': apply lookup_after_select to IsFC _ _ CFP1 Lkp.</b>

Subgoal 1.2:

Variables: FormulaClauses Known Sat CRest Rest C ID ID1 C2
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
Lkp : lookup CRest ID1 C2
M : mem (ID1, C2) CRest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C2
H4 : forall I C1 C2,
       mem (I, C1) FormulaClauses -&gt; mem (I, C2) FormulaClauses -&gt; C1 = C2
Lkp' : lookup FormulaClauses ID1 C2
============================
 sat_clause Sat C2
</pre>
<pre class="code extensibella"id="487">
 &lt; <b>apply SatFC to Lkp'.</b>

Subgoal 1.2:

Variables: FormulaClauses Known Sat CRest Rest C ID ID1 C2
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
Lkp : lookup CRest ID1 C2
M : mem (ID1, C2) CRest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C2
H4 : forall I C1 C2,
       mem (I, C1) FormulaClauses -&gt; mem (I, C2) FormulaClauses -&gt; C1 = C2
Lkp' : lookup FormulaClauses ID1 C2
H5 : sat_clause Sat C2
============================
 sat_clause Sat C2
</pre>
<pre class="code extensibella"id="488">
 &lt; <b>search.</b>

Subgoal 1:

Variables: FormulaClauses Known Sat CRest Rest C ID
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
============================
 false
</pre>
<pre class="code extensibella"id="489">
 &lt; <b>assert forall CID C1,
     lookup ((ID, C)::Known) CID C1 -&gt; sat_clause Sat C1.</b>

Subgoal 1.3:

Variables: FormulaClauses Known Sat CRest Rest C ID
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
============================
 forall CID C1, lookup ((ID, C)::Known) CID C1 -&gt; sat_clause Sat C1
</pre>
<pre class="code extensibella"id="490">
 &lt; <b>intros Lkp.</b>

Subgoal 1.3:

Variables: FormulaClauses Known Sat CRest Rest C ID CID C1
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
Lkp : lookup ((ID, C)::Known) CID C1
============================
 sat_clause Sat C1
</pre>
<pre class="code extensibella"id="491">
 &lt; <b>Lkp: case Lkp.</b>

Subgoal 1.3.1:

Variables: FormulaClauses Known Sat CRest Rest CID C1
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal CID C1 Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (CID, C1) CRest FormulaClauses
CFP2 : checkFratProof CRest ((CID, C1)::Known) Rest *
IsFP : is_integer CID
IsFP1 : is_clause C1
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C1
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
============================
 sat_clause Sat C1
</pre>
<pre class="code extensibella"id="492">
 &lt; <b>search.</b>

Subgoal 1.3.2:

Variables: FormulaClauses Known Sat CRest Rest C ID CID C1
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
Lkp : ID = CID -&gt; false
Lkp1 : lookup Known CID C1
============================
 sat_clause Sat C1
</pre>
<pre class="code extensibella"id="493">
 &lt; <b>apply SatK to Lkp1.</b>

Subgoal 1.3.2:

Variables: FormulaClauses Known Sat CRest Rest C ID CID C1
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
Lkp : ID = CID -&gt; false
Lkp1 : lookup Known CID C1
H2 : sat_clause Sat C1
============================
 sat_clause Sat C1
</pre>
<pre class="code extensibella"id="494">
 &lt; <b>search.</b>

Subgoal 1:

Variables: FormulaClauses Known Sat CRest Rest C ID
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
H2 : forall CID C1, lookup ((ID, C)::Known) CID C1 -&gt; sat_clause Sat C1
============================
 false
</pre>
<pre class="code extensibella"id="495">
 &lt; <b>apply select_is to _ CFP1.</b>

Subgoal 1:

Variables: FormulaClauses Known Sat CRest Rest C ID
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
H2 : forall CID C1, lookup ((ID, C)::Known) CID C1 -&gt; sat_clause Sat C1
H3 : is_list (is_pair is_integer is_clause) CRest
============================
 false
</pre>
<pre class="code extensibella"id="496">
 &lt; <b>apply good_clause_list_select to _ CFP1.</b>

Subgoal 1:

Variables: FormulaClauses Known Sat CRest Rest C ID
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
H2 : forall CID C1, lookup ((ID, C)::Known) CID C1 -&gt; sat_clause Sat C1
H3 : is_list (is_pair is_integer is_clause) CRest
H4 : good_clause_list CRest
============================
 false
</pre>
<pre class="code extensibella"id="497">
 &lt; <b>assert good_clause_list ((ID, C)::Known).</b>

Subgoal 1.4:

Variables: FormulaClauses Known Sat CRest Rest C ID
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
H2 : forall CID C1, lookup ((ID, C)::Known) CID C1 -&gt; sat_clause Sat C1
H3 : is_list (is_pair is_integer is_clause) CRest
H4 : good_clause_list CRest
============================
 good_clause_list ((ID, C)::Known)
</pre>
<pre class="code extensibella"id="498">
 &lt; <b>unfold .</b>

Subgoal 1.4:

Variables: FormulaClauses Known Sat CRest Rest C ID
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
H2 : forall CID C1, lookup ((ID, C)::Known) CID C1 -&gt; sat_clause Sat C1
H3 : is_list (is_pair is_integer is_clause) CRest
H4 : good_clause_list CRest
============================
 forall ID1 C1 KRest C2,
   select (ID1, C1) KRest ((ID, C)::Known) -&gt; mem (ID1, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="499">
 &lt; <b>intros S M.</b>

Subgoal 1.4:

Variables: FormulaClauses Known Sat CRest Rest C ID ID1 C1 KRest C2
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
H2 : forall CID C1, lookup ((ID, C)::Known) CID C1 -&gt; sat_clause Sat C1
H3 : is_list (is_pair is_integer is_clause) CRest
H4 : good_clause_list CRest
S : select (ID1, C1) KRest ((ID, C)::Known)
M : mem (ID1, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="500">
 &lt; <b>S: case S.</b>

Subgoal 1.4.1:

Variables: FormulaClauses Known Sat CRest Rest C ID C2
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
H2 : forall CID C1, lookup ((ID, C)::Known) CID C1 -&gt; sat_clause Sat C1
H3 : is_list (is_pair is_integer is_clause) CRest
H4 : good_clause_list CRest
M : mem (ID, C2) Known
============================
 false
</pre>
<pre class="code extensibella"id="501">
 &lt; <b>M': apply select_mem to CFP1.</b>

Subgoal 1.4.1:

Variables: FormulaClauses Known Sat CRest Rest C ID C2
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
H2 : forall CID C1, lookup ((ID, C)::Known) CID C1 -&gt; sat_clause Sat C1
H3 : is_list (is_pair is_integer is_clause) CRest
H4 : good_clause_list CRest
M : mem (ID, C2) Known
M' : mem (ID, C) FormulaClauses
============================
 false
</pre>
<pre class="code extensibella"id="502">
 &lt; <b>apply NoMem to M M'.</b>

Subgoal 1.4.2:

Variables: FormulaClauses Known Sat CRest Rest C ID ID1 C1 C2 L1
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
H2 : forall CID C1, lookup ((ID, C)::Known) CID C1 -&gt; sat_clause Sat C1
H3 : is_list (is_pair is_integer is_clause) CRest
H4 : good_clause_list CRest
M : mem (ID1, C2) ((ID, C)::L1)
S : select (ID1, C1) L1 Known
============================
 false
</pre>
<pre class="code extensibella"id="503">
 &lt; <b>M: case M.</b>

Subgoal 1.4.2.1:

Variables: FormulaClauses Known Sat CRest Rest C ID C1 L1
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
H2 : forall CID C1, lookup ((ID, C)::Known) CID C1 -&gt; sat_clause Sat C1
H3 : is_list (is_pair is_integer is_clause) CRest
H4 : good_clause_list CRest
S : select (ID, C1) L1 Known
============================
 false
</pre>
<pre class="code extensibella"id="504">
 &lt; <b>MS: apply select_mem to S.</b>

Subgoal 1.4.2.1:

Variables: FormulaClauses Known Sat CRest Rest C ID C1 L1
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
H2 : forall CID C1, lookup ((ID, C)::Known) CID C1 -&gt; sat_clause Sat C1
H3 : is_list (is_pair is_integer is_clause) CRest
H4 : good_clause_list CRest
S : select (ID, C1) L1 Known
MS : mem (ID, C1) Known
============================
 false
</pre>
<pre class="code extensibella"id="505">
 &lt; <b>M': apply select_mem to CFP1.</b>

Subgoal 1.4.2.1:

Variables: FormulaClauses Known Sat CRest Rest C ID C1 L1
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
H2 : forall CID C1, lookup ((ID, C)::Known) CID C1 -&gt; sat_clause Sat C1
H3 : is_list (is_pair is_integer is_clause) CRest
H4 : good_clause_list CRest
S : select (ID, C1) L1 Known
MS : mem (ID, C1) Known
M' : mem (ID, C) FormulaClauses
============================
 false
</pre>
<pre class="code extensibella"id="506">
 &lt; <b>apply NoMem to MS M'.</b>

Subgoal 1.4.2.2:

Variables: FormulaClauses Known Sat CRest Rest C ID ID1 C1 C2 L1
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
H2 : forall CID C1, lookup ((ID, C)::Known) CID C1 -&gt; sat_clause Sat C1
H3 : is_list (is_pair is_integer is_clause) CRest
H4 : good_clause_list CRest
S : select (ID1, C1) L1 Known
M : mem (ID1, C2) L1
============================
 false
</pre>
<pre class="code extensibella"id="507">
 &lt; <b>GCL: case GCL_K.</b>

Subgoal 1.4.2.2:

Variables: FormulaClauses Known Sat CRest Rest C ID ID1 C1 C2 L1
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
H2 : forall CID C1, lookup ((ID, C)::Known) CID C1 -&gt; sat_clause Sat C1
H3 : is_list (is_pair is_integer is_clause) CRest
H4 : good_clause_list CRest
S : select (ID1, C1) L1 Known
M : mem (ID1, C2) L1
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest Known -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="508">
 &lt; <b>apply GCL to S M.</b>

Subgoal 1:

Variables: FormulaClauses Known Sat CRest Rest C ID
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
H2 : forall CID C1, lookup ((ID, C)::Known) CID C1 -&gt; sat_clause Sat C1
H3 : is_list (is_pair is_integer is_clause) CRest
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
============================
 false
</pre>
<pre class="code extensibella"id="509">
 &lt; <b>assert forall ID1 CK CFC,
     mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CFC) CRest -&gt; false.</b>

Subgoal 1.5:

Variables: FormulaClauses Known Sat CRest Rest C ID
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
H2 : forall CID C1, lookup ((ID, C)::Known) CID C1 -&gt; sat_clause Sat C1
H3 : is_list (is_pair is_integer is_clause) CRest
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
============================
 forall ID1 CK CFC,
   mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CFC) CRest -&gt; false
</pre>
<pre class="code extensibella"id="510">
 &lt; <b>intros MA MB.</b>

Subgoal 1.5:

Variables: FormulaClauses Known Sat CRest Rest C ID ID1 CK CFC
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
H2 : forall CID C1, lookup ((ID, C)::Known) CID C1 -&gt; sat_clause Sat C1
H3 : is_list (is_pair is_integer is_clause) CRest
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
MA : mem (ID1, CK) ((ID, C)::Known)
MB : mem (ID1, CFC) CRest
============================
 false
</pre>
<pre class="code extensibella"id="511">
 &lt; <b>MA: case MA.</b>

Subgoal 1.5.1:

Variables: FormulaClauses Known Sat CRest Rest C ID CFC
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
H2 : forall CID C1, lookup ((ID, C)::Known) CID C1 -&gt; sat_clause Sat C1
H3 : is_list (is_pair is_integer is_clause) CRest
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
MB : mem (ID, CFC) CRest
============================
 false
</pre>
<pre class="code extensibella"id="512">
 &lt; <b>GCL: case GCL_FC.</b>

Subgoal 1.5.1:

Variables: FormulaClauses Known Sat CRest Rest C ID CFC
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
H2 : forall CID C1, lookup ((ID, C)::Known) CID C1 -&gt; sat_clause Sat C1
H3 : is_list (is_pair is_integer is_clause) CRest
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
MB : mem (ID, CFC) CRest
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest FormulaClauses -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="513">
 &lt; <b>apply GCL to CFP1 MB.</b>

Subgoal 1.5.2:

Variables: FormulaClauses Known Sat CRest Rest C ID ID1 CK CFC
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
H2 : forall CID C1, lookup ((ID, C)::Known) CID C1 -&gt; sat_clause Sat C1
H3 : is_list (is_pair is_integer is_clause) CRest
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
MB : mem (ID1, CFC) CRest
MA : mem (ID1, CK) Known
============================
 false
</pre>
<pre class="code extensibella"id="514">
 &lt; <b>MFC: apply mem_after_select_before to CFP1 MB.</b>

Subgoal 1.5.2:

Variables: FormulaClauses Known Sat CRest Rest C ID ID1 CK CFC
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
H2 : forall CID C1, lookup ((ID, C)::Known) CID C1 -&gt; sat_clause Sat C1
H3 : is_list (is_pair is_integer is_clause) CRest
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
MB : mem (ID1, CFC) CRest
MA : mem (ID1, CK) Known
MFC : mem (ID1, CFC) FormulaClauses
============================
 false
</pre>
<pre class="code extensibella"id="515">
 &lt; <b>apply NoMem to MA MFC.</b>

Subgoal 1:

Variables: FormulaClauses Known Sat CRest Rest C ID
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (addOriginal ID C Rest) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : select (ID, C) CRest FormulaClauses
CFP2 : checkFratProof CRest ((ID, C)::Known) Rest *
IsFP : is_integer ID
IsFP1 : is_clause C
IsFP2 : is_fratProof Rest
SatC : sat_clause Sat C
H1 : forall CID C1, lookup CRest CID C1 -&gt; sat_clause Sat C1
H2 : forall CID C1, lookup ((ID, C)::Known) CID C1 -&gt; sat_clause Sat C1
H3 : is_list (is_pair is_integer is_clause) CRest
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CFC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CFC) CRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="516">
 &lt; <b>apply IH to IsFP2 _ GA_Sat _ _ _ _ _ CFP2 _ _.</b>

Subgoal 2:

Variables: FormulaClauses Known Sat Prf
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsFP : is_fratProof (endOriginal Prf)
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (endOriginal Prf) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : checkProof Known Prf
============================
 false
</pre>
<pre class="code extensibella"id="517">
 &lt; <b>IsP: case IsFP.</b>

Subgoal 2:

Variables: FormulaClauses Known Sat Prf
IH : forall FormulaClauses Known FP Sat,
       is_fratProof FP -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt; good_clause_list Known -&gt;
       good_clause_list FormulaClauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) FormulaClauses -&gt; (forall ID CK CFC,
         mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false) -&gt; checkFratProof FormulaClauses Known FP * -&gt;
       (forall CID C, lookup Known CID C -&gt; sat_clause Sat C) -&gt; (forall CID C,
         lookup FormulaClauses CID C -&gt; sat_clause Sat C) -&gt; false
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
GCL_K : good_clause_list Known
GCL_FC : good_clause_list FormulaClauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsFC : is_list (is_pair is_integer is_clause) FormulaClauses
NoMem : forall ID CK CFC,
          mem (ID, CK) Known -&gt; mem (ID, CFC) FormulaClauses -&gt; false
CFP : checkFratProof FormulaClauses Known (endOriginal Prf) @
SatK : forall CID C, lookup Known CID C -&gt; sat_clause Sat C
SatFC : forall CID C, lookup FormulaClauses CID C -&gt; sat_clause Sat C
CFP1 : checkProof Known Prf
IsP : is_proof Prf
============================
 false
</pre>
<pre class="code extensibella"id="518">
 &lt; <b>apply check_proof_correct to IsP IsSat GA_Sat GCL_K IsKnown CFP1 SatK.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="519">
 &lt; <b>Theorem fratProveFormula_correct :
     forall F FPrf Sat,
       is_formula F -&gt; is_fratProof FPrf -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt;
       fratProveFormula F FPrf -&gt; sat_formula Sat F -&gt; false.</b>

============================
 forall F FPrf Sat,
   is_formula F -&gt; is_fratProof FPrf -&gt; is_list is_lit Sat -&gt; good_assignment Sat -&gt;
   fratProveFormula F FPrf -&gt; sat_formula Sat F -&gt; false
</pre>
<pre class="code extensibella"id="520">
 &lt; <b>intros IsF IsFPrf IsSat GA_Sat FPF SatF.</b>

Variables: F FPrf Sat
IsF : is_formula F
IsFPrf : is_fratProof FPrf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
FPF : fratProveFormula F FPrf
SatF : sat_formula Sat F
============================
 false
</pre>
<pre class="code extensibella"id="521">
 &lt; <b>Check: case FPF.</b>

Variables: F FPrf Sat KnownClauses
IsF : is_formula F
IsFPrf : is_fratProof FPrf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
SatF : sat_formula Sat F
Check : formulaToKnown 1 F KnownClauses
Check1 : checkFratProof KnownClauses [] FPrf
============================
 false
</pre>
<pre class="code extensibella"id="522">
 &lt; <b>assert forall CID C,
     lookup KnownClauses CID C -&gt; sat_clause Sat C.</b>

Subgoal 1:

Variables: F FPrf Sat KnownClauses
IsF : is_formula F
IsFPrf : is_fratProof FPrf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
SatF : sat_formula Sat F
Check : formulaToKnown 1 F KnownClauses
Check1 : checkFratProof KnownClauses [] FPrf
============================
 forall CID C, lookup KnownClauses CID C -&gt; sat_clause Sat C
</pre>
<pre class="code extensibella"id="523">
 &lt; <b>intros Lkp.</b>

Subgoal 1:

Variables: F FPrf Sat KnownClauses CID C
IsF : is_formula F
IsFPrf : is_fratProof FPrf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
SatF : sat_formula Sat F
Check : formulaToKnown 1 F KnownClauses
Check1 : checkFratProof KnownClauses [] FPrf
Lkp : lookup KnownClauses CID C
============================
 sat_clause Sat C
</pre>
<pre class="code extensibella"id="524">
 &lt; <b>M: apply lookup_mem to Lkp.</b>

Subgoal 1:

Variables: F FPrf Sat KnownClauses CID C
IsF : is_formula F
IsFPrf : is_fratProof FPrf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
SatF : sat_formula Sat F
Check : formulaToKnown 1 F KnownClauses
Check1 : checkFratProof KnownClauses [] FPrf
Lkp : lookup KnownClauses CID C
M : mem (CID, C) KnownClauses
============================
 sat_clause Sat C
</pre>
<pre class="code extensibella"id="525">
 &lt; <b>apply formulaToKnown_sat_formula to Check SatF M.</b>

Subgoal 1:

Variables: F FPrf Sat KnownClauses CID C
IsF : is_formula F
IsFPrf : is_fratProof FPrf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
SatF : sat_formula Sat F
Check : formulaToKnown 1 F KnownClauses
Check1 : checkFratProof KnownClauses [] FPrf
Lkp : lookup KnownClauses CID C
M : mem (CID, C) KnownClauses
H1 : sat_clause Sat C
============================
 sat_clause Sat C
</pre>
<pre class="code extensibella"id="526">
 &lt; <b>search.</b>

Variables: F FPrf Sat KnownClauses
IsF : is_formula F
IsFPrf : is_fratProof FPrf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
SatF : sat_formula Sat F
Check : formulaToKnown 1 F KnownClauses
Check1 : checkFratProof KnownClauses [] FPrf
H1 : forall CID C, lookup KnownClauses CID C -&gt; sat_clause Sat C
============================
 false
</pre>
<pre class="code extensibella"id="527">
 &lt; <b>assert forall (CID : integer) C,
     lookup [] CID C -&gt; sat_clause Sat C.</b>

Subgoal 2:

Variables: F FPrf Sat KnownClauses
IsF : is_formula F
IsFPrf : is_fratProof FPrf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
SatF : sat_formula Sat F
Check : formulaToKnown 1 F KnownClauses
Check1 : checkFratProof KnownClauses [] FPrf
H1 : forall CID C, lookup KnownClauses CID C -&gt; sat_clause Sat C
============================
 forall CID C, lookup [] CID C -&gt; sat_clause Sat C
</pre>
<pre class="code extensibella"id="528">
 &lt; <b>intros Lkp.</b>

Subgoal 2:

Variables: F FPrf Sat KnownClauses CID C
IsF : is_formula F
IsFPrf : is_fratProof FPrf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
SatF : sat_formula Sat F
Check : formulaToKnown 1 F KnownClauses
Check1 : checkFratProof KnownClauses [] FPrf
H1 : forall CID C, lookup KnownClauses CID C -&gt; sat_clause Sat C
Lkp : lookup [] CID C
============================
 sat_clause Sat C
</pre>
<pre class="code extensibella"id="529">
 &lt; <b>case Lkp.</b>

Variables: F FPrf Sat KnownClauses
IsF : is_formula F
IsFPrf : is_fratProof FPrf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
SatF : sat_formula Sat F
Check : formulaToKnown 1 F KnownClauses
Check1 : checkFratProof KnownClauses [] FPrf
H1 : forall CID C, lookup KnownClauses CID C -&gt; sat_clause Sat C
H2 : forall CID C, lookup [] CID C -&gt; sat_clause Sat C
============================
 false
</pre>
<pre class="code extensibella"id="530">
 &lt; <b>assert forall ID (CK : clause) CFC,
     mem (ID, CK) [] -&gt; mem (ID, CFC) KnownClauses -&gt; false.</b>

Subgoal 3:

Variables: F FPrf Sat KnownClauses
IsF : is_formula F
IsFPrf : is_fratProof FPrf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
SatF : sat_formula Sat F
Check : formulaToKnown 1 F KnownClauses
Check1 : checkFratProof KnownClauses [] FPrf
H1 : forall CID C, lookup KnownClauses CID C -&gt; sat_clause Sat C
H2 : forall CID C, lookup [] CID C -&gt; sat_clause Sat C
============================
 forall ID CK CFC, mem (ID, CK) [] -&gt; mem (ID, CFC) KnownClauses -&gt; false
</pre>
<pre class="code extensibella"id="531">
 &lt; <b>intros M.</b>

Subgoal 3:

Variables: F FPrf Sat KnownClauses ID CK CFC
IsF : is_formula F
IsFPrf : is_fratProof FPrf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
SatF : sat_formula Sat F
Check : formulaToKnown 1 F KnownClauses
Check1 : checkFratProof KnownClauses [] FPrf
H1 : forall CID C, lookup KnownClauses CID C -&gt; sat_clause Sat C
H2 : forall CID C, lookup [] CID C -&gt; sat_clause Sat C
M : mem (ID, CK) []
H3 : mem (ID, CFC) KnownClauses
============================
 false
</pre>
<pre class="code extensibella"id="532">
 &lt; <b>case M.</b>

Variables: F FPrf Sat KnownClauses
IsF : is_formula F
IsFPrf : is_fratProof FPrf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
SatF : sat_formula Sat F
Check : formulaToKnown 1 F KnownClauses
Check1 : checkFratProof KnownClauses [] FPrf
H1 : forall CID C, lookup KnownClauses CID C -&gt; sat_clause Sat C
H2 : forall CID C, lookup [] CID C -&gt; sat_clause Sat C
H3 : forall ID CK CFC, mem (ID, CK) [] -&gt; mem (ID, CFC) KnownClauses -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="533">
 &lt; <b>apply formulaToKnown_is to IsF _ Check.</b>

Variables: F FPrf Sat KnownClauses
IsF : is_formula F
IsFPrf : is_fratProof FPrf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
SatF : sat_formula Sat F
Check : formulaToKnown 1 F KnownClauses
Check1 : checkFratProof KnownClauses [] FPrf
H1 : forall CID C, lookup KnownClauses CID C -&gt; sat_clause Sat C
H2 : forall CID C, lookup [] CID C -&gt; sat_clause Sat C
H3 : forall ID CK CFC, mem (ID, CK) [] -&gt; mem (ID, CFC) KnownClauses -&gt; false
H4 : is_list (is_pair is_integer is_clause) KnownClauses
============================
 false
</pre>
<pre class="code extensibella"id="534">
 &lt; <b>assert good_clause_list KnownClauses.</b>

Subgoal 4:

Variables: F FPrf Sat KnownClauses
IsF : is_formula F
IsFPrf : is_fratProof FPrf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
SatF : sat_formula Sat F
Check : formulaToKnown 1 F KnownClauses
Check1 : checkFratProof KnownClauses [] FPrf
H1 : forall CID C, lookup KnownClauses CID C -&gt; sat_clause Sat C
H2 : forall CID C, lookup [] CID C -&gt; sat_clause Sat C
H3 : forall ID CK CFC, mem (ID, CK) [] -&gt; mem (ID, CFC) KnownClauses -&gt; false
H4 : is_list (is_pair is_integer is_clause) KnownClauses
============================
 good_clause_list KnownClauses
</pre>
<pre class="code extensibella"id="535">
 &lt; <b>unfold .</b>

Subgoal 4:

Variables: F FPrf Sat KnownClauses
IsF : is_formula F
IsFPrf : is_fratProof FPrf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
SatF : sat_formula Sat F
Check : formulaToKnown 1 F KnownClauses
Check1 : checkFratProof KnownClauses [] FPrf
H1 : forall CID C, lookup KnownClauses CID C -&gt; sat_clause Sat C
H2 : forall CID C, lookup [] CID C -&gt; sat_clause Sat C
H3 : forall ID CK CFC, mem (ID, CK) [] -&gt; mem (ID, CFC) KnownClauses -&gt; false
H4 : is_list (is_pair is_integer is_clause) KnownClauses
============================
 forall ID C1 KRest C2,
   select (ID, C1) KRest KnownClauses -&gt; mem (ID, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="536">
 &lt; <b>intros MA MB.</b>

Subgoal 4:

Variables: F FPrf Sat KnownClauses ID C1 KRest C2
IsF : is_formula F
IsFPrf : is_fratProof FPrf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
SatF : sat_formula Sat F
Check : formulaToKnown 1 F KnownClauses
Check1 : checkFratProof KnownClauses [] FPrf
H1 : forall CID C, lookup KnownClauses CID C -&gt; sat_clause Sat C
H2 : forall CID C, lookup [] CID C -&gt; sat_clause Sat C
H3 : forall ID CK CFC, mem (ID, CK) [] -&gt; mem (ID, CFC) KnownClauses -&gt; false
H4 : is_list (is_pair is_integer is_clause) KnownClauses
MA : select (ID, C1) KRest KnownClauses
MB : mem (ID, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="537">
 &lt; <b>backchain formulaToKnown_all_unique.</b>

Variables: F FPrf Sat KnownClauses
IsF : is_formula F
IsFPrf : is_fratProof FPrf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
SatF : sat_formula Sat F
Check : formulaToKnown 1 F KnownClauses
Check1 : checkFratProof KnownClauses [] FPrf
H1 : forall CID C, lookup KnownClauses CID C -&gt; sat_clause Sat C
H2 : forall CID C, lookup [] CID C -&gt; sat_clause Sat C
H3 : forall ID CK CFC, mem (ID, CK) [] -&gt; mem (ID, CFC) KnownClauses -&gt; false
H4 : is_list (is_pair is_integer is_clause) KnownClauses
H5 : good_clause_list KnownClauses
============================
 false
</pre>
<pre class="code extensibella"id="538">
 &lt; <b>assert good_clause_list [].</b>

Subgoal 5:

Variables: F FPrf Sat KnownClauses
IsF : is_formula F
IsFPrf : is_fratProof FPrf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
SatF : sat_formula Sat F
Check : formulaToKnown 1 F KnownClauses
Check1 : checkFratProof KnownClauses [] FPrf
H1 : forall CID C, lookup KnownClauses CID C -&gt; sat_clause Sat C
H2 : forall CID C, lookup [] CID C -&gt; sat_clause Sat C
H3 : forall ID CK CFC, mem (ID, CK) [] -&gt; mem (ID, CFC) KnownClauses -&gt; false
H4 : is_list (is_pair is_integer is_clause) KnownClauses
H5 : good_clause_list KnownClauses
============================
 good_clause_list []
</pre>
<pre class="code extensibella"id="539">
 &lt; <b>unfold .</b>

Subgoal 5:

Variables: F FPrf Sat KnownClauses
IsF : is_formula F
IsFPrf : is_fratProof FPrf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
SatF : sat_formula Sat F
Check : formulaToKnown 1 F KnownClauses
Check1 : checkFratProof KnownClauses [] FPrf
H1 : forall CID C, lookup KnownClauses CID C -&gt; sat_clause Sat C
H2 : forall CID C, lookup [] CID C -&gt; sat_clause Sat C
H3 : forall ID CK CFC, mem (ID, CK) [] -&gt; mem (ID, CFC) KnownClauses -&gt; false
H4 : is_list (is_pair is_integer is_clause) KnownClauses
H5 : good_clause_list KnownClauses
============================
 forall ID C1 KRest C2, select (ID, C1) KRest [] -&gt; mem (ID, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="540">
 &lt; <b>intros M.</b>

Subgoal 5:

Variables: F FPrf Sat KnownClauses ID C1 KRest C2
IsF : is_formula F
IsFPrf : is_fratProof FPrf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
SatF : sat_formula Sat F
Check : formulaToKnown 1 F KnownClauses
Check1 : checkFratProof KnownClauses [] FPrf
H1 : forall CID C, lookup KnownClauses CID C -&gt; sat_clause Sat C
H2 : forall CID C, lookup [] CID C -&gt; sat_clause Sat C
H3 : forall ID CK CFC, mem (ID, CK) [] -&gt; mem (ID, CFC) KnownClauses -&gt; false
H4 : is_list (is_pair is_integer is_clause) KnownClauses
H5 : good_clause_list KnownClauses
M : select (ID, C1) KRest []
H6 : mem (ID, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="541">
 &lt; <b>case M.</b>

Variables: F FPrf Sat KnownClauses
IsF : is_formula F
IsFPrf : is_fratProof FPrf
IsSat : is_list is_lit Sat
GA_Sat : good_assignment Sat
SatF : sat_formula Sat F
Check : formulaToKnown 1 F KnownClauses
Check1 : checkFratProof KnownClauses [] FPrf
H1 : forall CID C, lookup KnownClauses CID C -&gt; sat_clause Sat C
H2 : forall CID C, lookup [] CID C -&gt; sat_clause Sat C
H3 : forall ID CK CFC, mem (ID, CK) [] -&gt; mem (ID, CFC) KnownClauses -&gt; false
H4 : is_list (is_pair is_integer is_clause) KnownClauses
H5 : good_clause_list KnownClauses
H6 : good_clause_list []
============================
 false
</pre>
<pre class="code extensibella"id="542">
 &lt; <b>apply checkFratProof_correct to IsFPrf IsSat GA_Sat _ _ _ _ _ Check1 _ _.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="543">
 &lt; <b>Theorem select_is_clauseUsedness :
     forall L X Rest,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; select X Rest L -&gt; is_list (is_pair is_integer is_clauseUsedness) Rest.</b>

============================
 forall L X Rest,
   is_list (is_pair is_integer is_clauseUsedness) L -&gt; select X Rest L -&gt; is_list (is_pair is_integer is_clauseUsedness) Rest
</pre>
<pre class="code extensibella"id="544">
 &lt; <b>induction on 2.</b>

IH : forall L X Rest,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; select X Rest L * -&gt; is_list (is_pair is_integer is_clauseUsedness) Rest
============================
 forall L X Rest,
   is_list (is_pair is_integer is_clauseUsedness) L -&gt; select X Rest L @ -&gt; is_list (is_pair is_integer is_clauseUsedness) Rest
</pre>
<pre class="code extensibella"id="545">
 &lt; <b>intros Is S.</b>

Variables: L X Rest
IH : forall L X Rest,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; select X Rest L * -&gt; is_list (is_pair is_integer is_clauseUsedness) Rest
Is : is_list (is_pair is_integer is_clauseUsedness) L
S : select X Rest L @
============================
 is_list (is_pair is_integer is_clauseUsedness) Rest
</pre>
<pre class="code extensibella"id="546">
 &lt; <b>S: case S.</b>

Subgoal 1:

Variables: X Rest
IH : forall L X Rest,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; select X Rest L * -&gt; is_list (is_pair is_integer is_clauseUsedness) Rest
Is : is_list (is_pair is_integer is_clauseUsedness) (X::Rest)
============================
 is_list (is_pair is_integer is_clauseUsedness) Rest
</pre>
<pre class="code extensibella"id="547">
 &lt; <b>case Is.</b>

Subgoal 1:

Variables: X Rest
IH : forall L X Rest,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; select X Rest L * -&gt; is_list (is_pair is_integer is_clauseUsedness) Rest
H1 : is_pair is_integer is_clauseUsedness X
H2 : is_list (is_pair is_integer is_clauseUsedness) Rest
============================
 is_list (is_pair is_integer is_clauseUsedness) Rest
</pre>
<pre class="code extensibella"id="548">
 &lt; <b>search.</b>

Subgoal 2:

Variables: X L2 I L1
IH : forall L X Rest,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; select X Rest L * -&gt; is_list (is_pair is_integer is_clauseUsedness) Rest
Is : is_list (is_pair is_integer is_clauseUsedness) (I::L2)
S : select X L1 L2 *
============================
 is_list (is_pair is_integer is_clauseUsedness) (I::L1)
</pre>
<pre class="code extensibella"id="549">
 &lt; <b>case Is.</b>

Subgoal 2:

Variables: X L2 I L1
IH : forall L X Rest,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; select X Rest L * -&gt; is_list (is_pair is_integer is_clauseUsedness) Rest
S : select X L1 L2 *
H1 : is_pair is_integer is_clauseUsedness I
H2 : is_list (is_pair is_integer is_clauseUsedness) L2
============================
 is_list (is_pair is_integer is_clauseUsedness) (I::L1)
</pre>
<pre class="code extensibella"id="550">
 &lt; <b>apply IH to _ S.</b>

Subgoal 2:

Variables: X L2 I L1
IH : forall L X Rest,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; select X Rest L * -&gt; is_list (is_pair is_integer is_clauseUsedness) Rest
S : select X L1 L2 *
H1 : is_pair is_integer is_clauseUsedness I
H2 : is_list (is_pair is_integer is_clauseUsedness) L2
H3 : is_list (is_pair is_integer is_clauseUsedness) L1
============================
 is_list (is_pair is_integer is_clauseUsedness) (I::L1)
</pre>
<pre class="code extensibella"id="551">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="552">
 &lt; <b>Theorem select_is_clauseUsedness_item :
     forall L X Rest,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; select X Rest L -&gt; is_pair is_integer is_clauseUsedness X.</b>

============================
 forall L X Rest,
   is_list (is_pair is_integer is_clauseUsedness) L -&gt; select X Rest L -&gt; is_pair is_integer is_clauseUsedness X
</pre>
<pre class="code extensibella"id="553">
 &lt; <b>induction on 2.</b>

IH : forall L X Rest,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; select X Rest L * -&gt; is_pair is_integer is_clauseUsedness X
============================
 forall L X Rest,
   is_list (is_pair is_integer is_clauseUsedness) L -&gt; select X Rest L @ -&gt; is_pair is_integer is_clauseUsedness X
</pre>
<pre class="code extensibella"id="554">
 &lt; <b>intros Is S.</b>

Variables: L X Rest
IH : forall L X Rest,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; select X Rest L * -&gt; is_pair is_integer is_clauseUsedness X
Is : is_list (is_pair is_integer is_clauseUsedness) L
S : select X Rest L @
============================
 is_pair is_integer is_clauseUsedness X
</pre>
<pre class="code extensibella"id="555">
 &lt; <b>S: case S.</b>

Subgoal 1:

Variables: X Rest
IH : forall L X Rest,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; select X Rest L * -&gt; is_pair is_integer is_clauseUsedness X
Is : is_list (is_pair is_integer is_clauseUsedness) (X::Rest)
============================
 is_pair is_integer is_clauseUsedness X
</pre>
<pre class="code extensibella"id="556">
 &lt; <b>case Is.</b>

Subgoal 1:

Variables: X Rest
IH : forall L X Rest,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; select X Rest L * -&gt; is_pair is_integer is_clauseUsedness X
H1 : is_pair is_integer is_clauseUsedness X
H2 : is_list (is_pair is_integer is_clauseUsedness) Rest
============================
 is_pair is_integer is_clauseUsedness X
</pre>
<pre class="code extensibella"id="557">
 &lt; <b>search.</b>

Subgoal 2:

Variables: X L2 I L1
IH : forall L X Rest,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; select X Rest L * -&gt; is_pair is_integer is_clauseUsedness X
Is : is_list (is_pair is_integer is_clauseUsedness) (I::L2)
S : select X L1 L2 *
============================
 is_pair is_integer is_clauseUsedness X
</pre>
<pre class="code extensibella"id="558">
 &lt; <b>case Is.</b>

Subgoal 2:

Variables: X L2 I L1
IH : forall L X Rest,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; select X Rest L * -&gt; is_pair is_integer is_clauseUsedness X
S : select X L1 L2 *
H1 : is_pair is_integer is_clauseUsedness I
H2 : is_list (is_pair is_integer is_clauseUsedness) L2
============================
 is_pair is_integer is_clauseUsedness X
</pre>
<pre class="code extensibella"id="559">
 &lt; <b>apply IH to _ S.</b>

Subgoal 2:

Variables: X L2 I L1
IH : forall L X Rest,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; select X Rest L * -&gt; is_pair is_integer is_clauseUsedness X
S : select X L1 L2 *
H1 : is_pair is_integer is_clauseUsedness I
H2 : is_list (is_pair is_integer is_clauseUsedness) L2
H3 : is_pair is_integer is_clauseUsedness X
============================
 is_pair is_integer is_clauseUsedness X
</pre>
<pre class="code extensibella"id="560">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="561">
 &lt; <b>Theorem makeUsed_is :
     forall L P U,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; makeUsed L P U -&gt; is_list (is_pair is_integer is_clauseUsedness) U.</b>

============================
 forall L P U,
   is_list (is_pair is_integer is_clauseUsedness) L -&gt; makeUsed L P U -&gt; is_list (is_pair is_integer is_clauseUsedness) U
</pre>
<pre class="code extensibella"id="562">
 &lt; <b>induction on 2.</b>

IH : forall L P U,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; makeUsed L P U * -&gt; is_list (is_pair is_integer is_clauseUsedness) U
============================
 forall L P U,
   is_list (is_pair is_integer is_clauseUsedness) L -&gt; makeUsed L P U @ -&gt; is_list (is_pair is_integer is_clauseUsedness) U
</pre>
<pre class="code extensibella"id="563">
 &lt; <b>intros Is MU.</b>

Variables: L P U
IH : forall L P U,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; makeUsed L P U * -&gt; is_list (is_pair is_integer is_clauseUsedness) U
Is : is_list (is_pair is_integer is_clauseUsedness) L
MU : makeUsed L P U @
============================
 is_list (is_pair is_integer is_clauseUsedness) U
</pre>
<pre class="code extensibella"id="564">
 &lt; <b>MU: case MU.</b>

Subgoal 1:

Variables: U
IH : forall L P U,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; makeUsed L P U * -&gt; is_list (is_pair is_integer is_clauseUsedness) U
Is : is_list (is_pair is_integer is_clauseUsedness) U
============================
 is_list (is_pair is_integer is_clauseUsedness) U
</pre>
<pre class="code extensibella"id="565">
 &lt; <b>search.</b>

Subgoal 2:

Variables: L KRest KOut ID Rest
IH : forall L P U,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; makeUsed L P U * -&gt; is_list (is_pair is_integer is_clauseUsedness) U
Is : is_list (is_pair is_integer is_clauseUsedness) L
MU : select (ID, needed) KRest L
MU1 : makeUsed KRest Rest KOut *
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, needed)::KOut)
</pre>
<pre class="code extensibella"id="566">
 &lt; <b>apply select_is_clauseUsedness to _ MU.</b>

Subgoal 2:

Variables: L KRest KOut ID Rest
IH : forall L P U,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; makeUsed L P U * -&gt; is_list (is_pair is_integer is_clauseUsedness) U
Is : is_list (is_pair is_integer is_clauseUsedness) L
MU : select (ID, needed) KRest L
MU1 : makeUsed KRest Rest KOut *
H1 : is_list (is_pair is_integer is_clauseUsedness) KRest
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, needed)::KOut)
</pre>
<pre class="code extensibella"id="567">
 &lt; <b>apply IH to _ MU1.</b>

Subgoal 2:

Variables: L KRest KOut ID Rest
IH : forall L P U,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; makeUsed L P U * -&gt; is_list (is_pair is_integer is_clauseUsedness) U
Is : is_list (is_pair is_integer is_clauseUsedness) L
MU : select (ID, needed) KRest L
MU1 : makeUsed KRest Rest KOut *
H1 : is_list (is_pair is_integer is_clauseUsedness) KRest
H2 : is_list (is_pair is_integer is_clauseUsedness) KOut
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, needed)::KOut)
</pre>
<pre class="code extensibella"id="568">
 &lt; <b>apply select_is_clauseUsedness_item to _ MU.</b>

Subgoal 2:

Variables: L KRest KOut ID Rest
IH : forall L P U,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; makeUsed L P U * -&gt; is_list (is_pair is_integer is_clauseUsedness) U
Is : is_list (is_pair is_integer is_clauseUsedness) L
MU : select (ID, needed) KRest L
MU1 : makeUsed KRest Rest KOut *
H1 : is_list (is_pair is_integer is_clauseUsedness) KRest
H2 : is_list (is_pair is_integer is_clauseUsedness) KOut
H3 : is_pair is_integer is_clauseUsedness (ID, needed)
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, needed)::KOut)
</pre>
<pre class="code extensibella"id="569">
 &lt; <b>search.</b>

Subgoal 3:

Variables: L KRest KOut ID Rest
IH : forall L P U,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; makeUsed L P U * -&gt; is_list (is_pair is_integer is_clauseUsedness) U
Is : is_list (is_pair is_integer is_clauseUsedness) L
MU : select (ID, unknown) KRest L
MU1 : makeUsed KRest Rest KOut *
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, needed)::KOut)
</pre>
<pre class="code extensibella"id="570">
 &lt; <b>IsPair: apply select_is_clauseUsedness_item to Is MU.</b>

Subgoal 3:

Variables: L KRest KOut ID Rest
IH : forall L P U,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; makeUsed L P U * -&gt; is_list (is_pair is_integer is_clauseUsedness) U
Is : is_list (is_pair is_integer is_clauseUsedness) L
MU : select (ID, unknown) KRest L
MU1 : makeUsed KRest Rest KOut *
IsPair : is_pair is_integer is_clauseUsedness (ID, unknown)
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, needed)::KOut)
</pre>
<pre class="code extensibella"id="571">
 &lt; <b>I: case IsPair.</b>

Subgoal 3:

Variables: L KRest KOut ID Rest
IH : forall L P U,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; makeUsed L P U * -&gt; is_list (is_pair is_integer is_clauseUsedness) U
Is : is_list (is_pair is_integer is_clauseUsedness) L
MU : select (ID, unknown) KRest L
MU1 : makeUsed KRest Rest KOut *
I : is_integer ID
I1 : is_clauseUsedness unknown
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, needed)::KOut)
</pre>
<pre class="code extensibella"id="572">
 &lt; <b>case I1.</b>

Subgoal 3:

Variables: L KRest KOut ID Rest
IH : forall L P U,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; makeUsed L P U * -&gt; is_list (is_pair is_integer is_clauseUsedness) U
Is : is_list (is_pair is_integer is_clauseUsedness) L
MU : select (ID, unknown) KRest L
MU1 : makeUsed KRest Rest KOut *
I : is_integer ID
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, needed)::KOut)
</pre>
<pre class="code extensibella"id="573">
 &lt; <b>apply select_is_clauseUsedness to Is MU.</b>

Subgoal 3:

Variables: L KRest KOut ID Rest
IH : forall L P U,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; makeUsed L P U * -&gt; is_list (is_pair is_integer is_clauseUsedness) U
Is : is_list (is_pair is_integer is_clauseUsedness) L
MU : select (ID, unknown) KRest L
MU1 : makeUsed KRest Rest KOut *
I : is_integer ID
H1 : is_list (is_pair is_integer is_clauseUsedness) KRest
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, needed)::KOut)
</pre>
<pre class="code extensibella"id="574">
 &lt; <b>apply IH to _ MU1.</b>

Subgoal 3:

Variables: L KRest KOut ID Rest
IH : forall L P U,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; makeUsed L P U * -&gt; is_list (is_pair is_integer is_clauseUsedness) U
Is : is_list (is_pair is_integer is_clauseUsedness) L
MU : select (ID, unknown) KRest L
MU1 : makeUsed KRest Rest KOut *
I : is_integer ID
H1 : is_list (is_pair is_integer is_clauseUsedness) KRest
H2 : is_list (is_pair is_integer is_clauseUsedness) KOut
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, needed)::KOut)
</pre>
<pre class="code extensibella"id="575">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="576">
 &lt; <b>Theorem makeUsed_needed :
     forall L P U ID, makeUsed L P U -&gt; mem ID P -&gt; mem (ID, needed) U.</b>

============================
 forall L P U ID, makeUsed L P U -&gt; mem ID P -&gt; mem (ID, needed) U
</pre>
<pre class="code extensibella"id="577">
 &lt; <b>induction on 1.</b>

IH : forall L P U ID, makeUsed L P U * -&gt; mem ID P -&gt; mem (ID, needed) U
============================
 forall L P U ID, makeUsed L P U @ -&gt; mem ID P -&gt; mem (ID, needed) U
</pre>
<pre class="code extensibella"id="578">
 &lt; <b>intros MU Mem.</b>

Variables: L P U ID
IH : forall L P U ID, makeUsed L P U * -&gt; mem ID P -&gt; mem (ID, needed) U
MU : makeUsed L P U @
Mem : mem ID P
============================
 mem (ID, needed) U
</pre>
<pre class="code extensibella"id="579">
 &lt; <b>MU: case MU.</b>

Subgoal 1:

Variables: U ID
IH : forall L P U ID, makeUsed L P U * -&gt; mem ID P -&gt; mem (ID, needed) U
Mem : mem ID []
============================
 mem (ID, needed) U
</pre>
<pre class="code extensibella"id="580">
 &lt; <b>case Mem.</b>

Subgoal 2:

Variables: L ID KRest KOut ID1 Rest
IH : forall L P U ID, makeUsed L P U * -&gt; mem ID P -&gt; mem (ID, needed) U
Mem : mem ID (ID1::Rest)
MU : select (ID1, needed) KRest L
MU1 : makeUsed KRest Rest KOut *
============================
 mem (ID, needed) ((ID1, needed)::KOut)
</pre>
<pre class="code extensibella"id="581">
 &lt; <b>Mem: case Mem.</b>

Subgoal 2.1:

Variables: L KRest KOut ID1 Rest
IH : forall L P U ID, makeUsed L P U * -&gt; mem ID P -&gt; mem (ID, needed) U
MU : select (ID1, needed) KRest L
MU1 : makeUsed KRest Rest KOut *
============================
 mem (ID1, needed) ((ID1, needed)::KOut)
</pre>
<pre class="code extensibella"id="582">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: L ID KRest KOut ID1 Rest
IH : forall L P U ID, makeUsed L P U * -&gt; mem ID P -&gt; mem (ID, needed) U
MU : select (ID1, needed) KRest L
MU1 : makeUsed KRest Rest KOut *
Mem : mem ID Rest
============================
 mem (ID, needed) ((ID1, needed)::KOut)
</pre>
<pre class="code extensibella"id="583">
 &lt; <b>apply IH to MU1 Mem.</b>

Subgoal 2.2:

Variables: L ID KRest KOut ID1 Rest
IH : forall L P U ID, makeUsed L P U * -&gt; mem ID P -&gt; mem (ID, needed) U
MU : select (ID1, needed) KRest L
MU1 : makeUsed KRest Rest KOut *
Mem : mem ID Rest
H1 : mem (ID, needed) KOut
============================
 mem (ID, needed) ((ID1, needed)::KOut)
</pre>
<pre class="code extensibella"id="584">
 &lt; <b>search.</b>

Subgoal 3:

Variables: L ID KRest KOut ID1 Rest
IH : forall L P U ID, makeUsed L P U * -&gt; mem ID P -&gt; mem (ID, needed) U
Mem : mem ID (ID1::Rest)
MU : select (ID1, unknown) KRest L
MU1 : makeUsed KRest Rest KOut *
============================
 mem (ID, needed) ((ID1, needed)::KOut)
</pre>
<pre class="code extensibella"id="585">
 &lt; <b>Mem: case Mem.</b>

Subgoal 3.1:

Variables: L KRest KOut ID1 Rest
IH : forall L P U ID, makeUsed L P U * -&gt; mem ID P -&gt; mem (ID, needed) U
MU : select (ID1, unknown) KRest L
MU1 : makeUsed KRest Rest KOut *
============================
 mem (ID1, needed) ((ID1, needed)::KOut)
</pre>
<pre class="code extensibella"id="586">
 &lt; <b>search.</b>

Subgoal 3.2:

Variables: L ID KRest KOut ID1 Rest
IH : forall L P U ID, makeUsed L P U * -&gt; mem ID P -&gt; mem (ID, needed) U
MU : select (ID1, unknown) KRest L
MU1 : makeUsed KRest Rest KOut *
Mem : mem ID Rest
============================
 mem (ID, needed) ((ID1, needed)::KOut)
</pre>
<pre class="code extensibella"id="587">
 &lt; <b>apply IH to MU1 Mem.</b>

Subgoal 3.2:

Variables: L ID KRest KOut ID1 Rest
IH : forall L P U ID, makeUsed L P U * -&gt; mem ID P -&gt; mem (ID, needed) U
MU : select (ID1, unknown) KRest L
MU1 : makeUsed KRest Rest KOut *
Mem : mem ID Rest
H1 : mem (ID, needed) KOut
============================
 mem (ID, needed) ((ID1, needed)::KOut)
</pre>
<pre class="code extensibella"id="588">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="589">
 &lt; <b>Extensible_Theorem
      endKnownClauses_is : forall F K,
         IsF : is_finalClauses F -&gt;
         EKC : endKnownClauses F K -&gt;
         is_list (is_pair is_integer is_clauseUsedness) K
      on EKC.</b>

Subgoal 1:

IH : forall F K,
       is_finalClauses F -&gt; endKnownClauses F K * -&gt; is_list (is_pair is_integer is_clauseUsedness) K
IsF : is_finalClauses endFClause
EKC : endKnownClauses endFClause [] @
============================
 is_list (is_pair is_integer is_clauseUsedness) []
</pre>
<pre class="code extensibella"id="590">
 &lt; <b>search.</b>

Subgoal 2:

Variables: KRest ID Rest C
IH : forall F K,
       is_finalClauses F -&gt; endKnownClauses F K * -&gt; is_list (is_pair is_integer is_clauseUsedness) K
IsF : is_finalClauses (addFClause ID C Rest)
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, needed)::KRest)
</pre>
<pre class="code extensibella"id="591">
 &lt; <b>case IsF.</b>

Subgoal 2:

Variables: KRest ID Rest C
IH : forall F K,
       is_finalClauses F -&gt; endKnownClauses F K * -&gt; is_list (is_pair is_integer is_clauseUsedness) K
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
H1 : is_integer ID
H2 : is_clause C
H3 : is_finalClauses Rest
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, needed)::KRest)
</pre>
<pre class="code extensibella"id="592">
 &lt; <b>apply IH to _ EKC2.</b>

Subgoal 2:

Variables: KRest ID Rest C
IH : forall F K,
       is_finalClauses F -&gt; endKnownClauses F K * -&gt; is_list (is_pair is_integer is_clauseUsedness) K
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
H1 : is_integer ID
H2 : is_clause C
H3 : is_finalClauses Rest
H4 : is_list (is_pair is_integer is_clauseUsedness) KRest
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, needed)::KRest)
</pre>
<pre class="code extensibella"id="593">
 &lt; <b>search.</b>

Subgoal 3:

Variables: KRest ID Rest C
IH : forall F K,
       is_finalClauses F -&gt; endKnownClauses F K * -&gt; is_list (is_pair is_integer is_clauseUsedness) K
IsF : is_finalClauses (addFClause ID C Rest)
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, unknown)::KRest)
</pre>
<pre class="code extensibella"id="594">
 &lt; <b>case IsF.</b>

Subgoal 3:

Variables: KRest ID Rest C
IH : forall F K,
       is_finalClauses F -&gt; endKnownClauses F K * -&gt; is_list (is_pair is_integer is_clauseUsedness) K
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
H1 : is_integer ID
H2 : is_clause C
H3 : is_finalClauses Rest
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, unknown)::KRest)
</pre>
<pre class="code extensibella"id="595">
 &lt; <b>apply IH to _ EKC2.</b>

Subgoal 3:

Variables: KRest ID Rest C
IH : forall F K,
       is_finalClauses F -&gt; endKnownClauses F K * -&gt; is_list (is_pair is_integer is_clauseUsedness) K
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
H1 : is_integer ID
H2 : is_clause C
H3 : is_finalClauses Rest
H4 : is_list (is_pair is_integer is_clauseUsedness) KRest
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, unknown)::KRest)
</pre>
<pre class="code extensibella"id="596">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="597">
 &lt; <b>Extensible_Theorem
      elaboration_is_needed : forall Known P Needed E,
         IsKnown : is_list (is_pair is_integer is_clause) Known -&gt;
         GCL : good_clause_list Known -&gt;
         IsP : is_proof P -&gt;
         Ela : elaborate Known P Needed E -&gt;
         is_list (is_pair is_integer is_clauseUsedness) Needed
      on Ela.</b>

Subgoal 1:

Variables: Known Needed Needed1 NRest Prf ID FC
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof (endFrat ID FC)
Ela : elaborate Known (endFrat ID FC) Needed (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf Needed
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="598">
 &lt; <b>Is: case IsP.</b>

Subgoal 1:

Variables: Known Needed Needed1 NRest Prf ID FC
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (endFrat ID FC) Needed (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_finalClauses FC
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="599">
 &lt; <b>IsNeeded: apply endKnownClauses_is to _ Ela1.</b>

Subgoal 1:

Variables: Known Needed Needed1 NRest Prf ID FC
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (endFrat ID FC) Needed (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_finalClauses FC
IsNeeded : is_list (is_pair is_integer is_clauseUsedness) Needed1
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="600">
 &lt; <b>apply select_is_clauseUsedness to _ Ela2.</b>

Subgoal 1:

Variables: Known Needed Needed1 NRest Prf ID FC
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (endFrat ID FC) Needed (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_finalClauses FC
IsNeeded : is_list (is_pair is_integer is_clauseUsedness) Needed1
H1 : is_list (is_pair is_integer is_clauseUsedness) NRest
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="601">
 &lt; <b>apply makeUsed_is to _ Ela4.</b>

Subgoal 1:

Variables: Known Needed Needed1 NRest Prf ID FC
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (endFrat ID FC) Needed (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_finalClauses FC
IsNeeded : is_list (is_pair is_integer is_clauseUsedness) Needed1
H1 : is_list (is_pair is_integer is_clauseUsedness) NRest
H2 : is_list (is_pair is_integer is_clauseUsedness) Needed
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="602">
 &lt; <b>search.</b>

Subgoal 2:

Variables: Known Needed Needed1 NRest Prf ID FC
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof (endFratPrf ID Prf FC)
Ela : elaborate Known (endFratPrf ID Prf FC) Needed (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : makeUsed NRest Prf Needed
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="603">
 &lt; <b>Is: case IsP.</b>

Subgoal 2:

Variables: Known Needed Needed1 NRest Prf ID FC
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (endFratPrf ID Prf FC) Needed (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_list is_integer Prf
Is2 : is_finalClauses FC
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="604">
 &lt; <b>IsNeeded: apply endKnownClauses_is to _ Ela1.</b>

Subgoal 2:

Variables: Known Needed Needed1 NRest Prf ID FC
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (endFratPrf ID Prf FC) Needed (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_list is_integer Prf
Is2 : is_finalClauses FC
IsNeeded : is_list (is_pair is_integer is_clauseUsedness) Needed1
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="605">
 &lt; <b>apply select_is_clauseUsedness to _ Ela2.</b>

Subgoal 2:

Variables: Known Needed Needed1 NRest Prf ID FC
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (endFratPrf ID Prf FC) Needed (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_list is_integer Prf
Is2 : is_finalClauses FC
IsNeeded : is_list (is_pair is_integer is_clauseUsedness) Needed1
H1 : is_list (is_pair is_integer is_clauseUsedness) NRest
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="606">
 &lt; <b>apply makeUsed_is to _ Ela3.</b>

Subgoal 2:

Variables: Known Needed Needed1 NRest Prf ID FC
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (endFratPrf ID Prf FC) Needed (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_list is_integer Prf
Is2 : is_finalClauses FC
IsNeeded : is_list (is_pair is_integer is_clauseUsedness) Needed1
H1 : is_list (is_pair is_integer is_clauseUsedness) NRest
H2 : is_list (is_pair is_integer is_clauseUsedness) Needed
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="607">
 &lt; <b>search.</b>

Subgoal 3:

Variables: Known E KRest Needed1 ID Rest C
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof (deleteFrat ID C Rest)
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed1) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, unknown)::Needed1)
</pre>
<pre class="code extensibella"id="608">
 &lt; <b>Is: case IsP.</b>

Subgoal 3:

Variables: Known E KRest Needed1 ID Rest C
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed1) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, unknown)::Needed1)
</pre>
<pre class="code extensibella"id="609">
 &lt; <b>apply select_is to _ Ela1.</b>

Subgoal 3:

Variables: Known E KRest Needed1 ID Rest C
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed1) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, unknown)::Needed1)
</pre>
<pre class="code extensibella"id="610">
 &lt; <b>apply good_clause_list_select to _ Ela1.</b>

Subgoal 3:

Variables: Known E KRest Needed1 ID Rest C
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed1) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, unknown)::Needed1)
</pre>
<pre class="code extensibella"id="611">
 &lt; <b>apply IH to _ _ _ Ela2.</b>

Subgoal 3:

Variables: Known E KRest Needed1 ID Rest C
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed1) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, unknown)::Needed1)
</pre>
<pre class="code extensibella"id="612">
 &lt; <b>search.</b>

Subgoal 4:

Variables: Known E C KRest Needed1 ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof (deleteLratProof ID Rest)
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed1) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, unknown)::Needed1)
</pre>
<pre class="code extensibella"id="613">
 &lt; <b>Is: case IsP.</b>

Subgoal 4:

Variables: Known E C KRest Needed1 ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed1) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
Is : is_integer ID
Is1 : is_proof Rest
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, unknown)::Needed1)
</pre>
<pre class="code extensibella"id="614">
 &lt; <b>apply select_is to _ Ela1.</b>

Subgoal 4:

Variables: Known E C KRest Needed1 ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed1) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
Is : is_integer ID
Is1 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, unknown)::Needed1)
</pre>
<pre class="code extensibella"id="615">
 &lt; <b>apply good_clause_list_select to _ Ela1.</b>

Subgoal 4:

Variables: Known E C KRest Needed1 ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed1) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
Is : is_integer ID
Is1 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, unknown)::Needed1)
</pre>
<pre class="code extensibella"id="616">
 &lt; <b>apply IH to _ _ _ Ela2.</b>

Subgoal 4:

Variables: Known E C KRest Needed1 ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed1) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
Is : is_integer ID
Is1 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, unknown)::Needed1)
</pre>
<pre class="code extensibella"id="617">
 &lt; <b>search.</b>

Subgoal 5:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf Needed
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="618">
 &lt; <b>Is: case IsP.</b>

Subgoal 5:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="619">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 5:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="620">
 &lt; <b>apply good_clause_list_remove_all_add to _ Ela1 with
     C = C.</b>

Subgoal 5:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="621">
 &lt; <b>apply IH to _ _ _ Ela2.</b>

Subgoal 5:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="622">
 &lt; <b>apply select_is_clauseUsedness to _ Ela3.</b>

Subgoal 5:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="623">
 &lt; <b>apply makeUsed_is to _ Ela4.</b>

Subgoal 5:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
H5 : is_list (is_pair is_integer is_clauseUsedness) Needed
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="624">
 &lt; <b>search.</b>

Subgoal 6:

Variables: Known Needed E KRest Needed1 Rest Prf C ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) Needed E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) Needed Needed1
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="625">
 &lt; <b>Is: case IsP.</b>

Subgoal 6:

Variables: Known Needed E KRest Needed1 Rest Prf C ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) Needed E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) Needed Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="626">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 6:

Variables: Known Needed E KRest Needed1 Rest Prf C ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) Needed E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) Needed Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="627">
 &lt; <b>apply good_clause_list_remove_all_add to _ Ela1 with
     C = C.</b>

Subgoal 6:

Variables: Known Needed E KRest Needed1 Rest Prf C ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) Needed E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) Needed Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="628">
 &lt; <b>apply IH to _ _ _ Ela2.</b>

Subgoal 6:

Variables: Known Needed E KRest Needed1 Rest Prf C ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) Needed E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) Needed Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="629">
 &lt; <b>apply select_is_clauseUsedness to _ Ela3.</b>

Subgoal 6:

Variables: Known Needed E KRest Needed1 Rest Prf C ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) Needed E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) Needed Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) Needed
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="630">
 &lt; <b>search.</b>

Subgoal 7:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf Needed
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="631">
 &lt; <b>Is: case IsP.</b>

Subgoal 7:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="632">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 7:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="633">
 &lt; <b>apply good_clause_list_remove_all_add to _ Ela1 with
     C = C.</b>

Subgoal 7:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="634">
 &lt; <b>apply IH to _ _ _ Ela2.</b>

Subgoal 7:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="635">
 &lt; <b>apply select_is_clauseUsedness to _ Ela3.</b>

Subgoal 7:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="636">
 &lt; <b>apply makeUsed_is to _ Ela5.</b>

Subgoal 7:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
H5 : is_list (is_pair is_integer is_clauseUsedness) Needed
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="637">
 &lt; <b>search.</b>

Subgoal 8:

Variables: Known Needed E KRest Needed1 Rest C ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) Needed E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) Needed Needed1
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="638">
 &lt; <b>Is: case IsP.</b>

Subgoal 8:

Variables: Known Needed E KRest Needed1 Rest C ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) Needed E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) Needed Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="639">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 8:

Variables: Known Needed E KRest Needed1 Rest C ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) Needed E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) Needed Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="640">
 &lt; <b>apply good_clause_list_remove_all_add to _ Ela1 with
     C = C.</b>

Subgoal 8:

Variables: Known Needed E KRest Needed1 Rest C ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) Needed E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) Needed Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="641">
 &lt; <b>apply IH to _ _ _ Ela2.</b>

Subgoal 8:

Variables: Known Needed E KRest Needed1 Rest C ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) Needed E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) Needed Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="642">
 &lt; <b>apply select_is_clauseUsedness to _ Ela3.</b>

Subgoal 8:

Variables: Known Needed E KRest Needed1 Rest C ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) Needed E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) Needed Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) Needed
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="643">
 &lt; <b>search.</b>

Subgoal 9:

Variables: Known KRest C KRest2 Needed1 ERest To From NRest Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
============================
 is_list (is_pair is_integer is_clauseUsedness) ((From, needed)::NRest)
</pre>
<pre class="code extensibella"id="644">
 &lt; <b>Is: case IsP.</b>

Subgoal 9:

Variables: Known KRest C KRest2 Needed1 ERest To From NRest Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
============================
 is_list (is_pair is_integer is_clauseUsedness) ((From, needed)::NRest)
</pre>
<pre class="code extensibella"id="645">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 9:

Variables: Known KRest C KRest2 Needed1 ERest To From NRest Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 is_list (is_pair is_integer is_clauseUsedness) ((From, needed)::NRest)
</pre>
<pre class="code extensibella"id="646">
 &lt; <b>apply select_is to _ Ela2.</b>

Subgoal 9:

Variables: Known KRest C KRest2 Needed1 ERest To From NRest Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
============================
 is_list (is_pair is_integer is_clauseUsedness) ((From, needed)::NRest)
</pre>
<pre class="code extensibella"id="647">
 &lt; <b>M: apply select_mem to Ela2.</b>

Subgoal 9:

Variables: Known KRest C KRest2 Needed1 ERest To From NRest Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
============================
 is_list (is_pair is_integer is_clauseUsedness) ((From, needed)::NRest)
</pre>
<pre class="code extensibella"id="648">
 &lt; <b>GCLR: apply good_clause_list_remove_all to _ Ela1.</b>

Subgoal 9:

Variables: Known KRest C KRest2 Needed1 ERest To From NRest Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
============================
 is_list (is_pair is_integer is_clauseUsedness) ((From, needed)::NRest)
</pre>
<pre class="code extensibella"id="649">
 &lt; <b>GCLS: apply good_clause_list_select to GCLR Ela2.</b>

Subgoal 9:

Variables: Known KRest C KRest2 Needed1 ERest To From NRest Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
============================
 is_list (is_pair is_integer is_clauseUsedness) ((From, needed)::NRest)
</pre>
<pre class="code extensibella"id="650">
 &lt; <b>apply good_clause_list_add to GCLS _ with
     ID = To C = C.</b>

Subgoal 9.1:

Variables: Known KRest C KRest2 Needed1 ERest To From NRest Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
============================
 (exists C', mem (To, C') KRest2) -&gt; false
</pre>
<pre class="code extensibella"id="651">
 &lt; <b>intros M'.</b>

Subgoal 9.1:

Variables: Known KRest C KRest2 Needed1 ERest To From NRest Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
M' : exists C', mem (To, C') KRest2
============================
 false
</pre>
<pre class="code extensibella"id="652">
 &lt; <b>M': case M'.</b>

Subgoal 9.1:

Variables: Known KRest C KRest2 Needed1 ERest To From NRest Rest C'
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
M' : mem (To, C') KRest2
============================
 false
</pre>
<pre class="code extensibella"id="653">
 &lt; <b>M'': apply mem_after_select_before to Ela2 M'.</b>

Subgoal 9.1:

Variables: Known KRest C KRest2 Needed1 ERest To From NRest Rest C'
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
M' : mem (To, C') KRest2
M'' : mem (To, C') KRest
============================
 false
</pre>
<pre class="code extensibella"id="654">
 &lt; <b>apply remove_all_no_mem to Ela1 M''.</b>

Subgoal 9:

Variables: Known KRest C KRest2 Needed1 ERest To From NRest Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
H3 : good_clause_list ((To, C)::KRest2)
============================
 is_list (is_pair is_integer is_clauseUsedness) ((From, needed)::NRest)
</pre>
<pre class="code extensibella"id="655">
 &lt; <b>apply mem_is to _ M.</b>

Subgoal 9:

Variables: Known KRest KRest2 Needed1 ERest To NRest Rest ID C1
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (ID, C1) KRest2 KRest
Ela3 : elaborate ((To, C1)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (ID, C1) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
H3 : good_clause_list ((To, C1)::KRest2)
H4 : is_integer ID
H5 : is_clause C1
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, needed)::NRest)
</pre>
<pre class="code extensibella"id="656">
 &lt; <b>apply IH to _ _ _ Ela3.</b>

Subgoal 9:

Variables: Known KRest KRest2 Needed1 ERest To NRest Rest ID C1
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (ID, C1) KRest2 KRest
Ela3 : elaborate ((To, C1)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (ID, C1) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
H3 : good_clause_list ((To, C1)::KRest2)
H4 : is_integer ID
H5 : is_clause C1
H6 : is_list (is_pair is_integer is_clauseUsedness) Needed1
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, needed)::NRest)
</pre>
<pre class="code extensibella"id="657">
 &lt; <b>apply select_is_clauseUsedness to _ Ela4.</b>

Subgoal 9:

Variables: Known KRest KRest2 Needed1 ERest To NRest Rest ID C1
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (ID, C1) KRest2 KRest
Ela3 : elaborate ((To, C1)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (ID, C1) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
H3 : good_clause_list ((To, C1)::KRest2)
H4 : is_integer ID
H5 : is_clause C1
H6 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H7 : is_list (is_pair is_integer is_clauseUsedness) NRest
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, needed)::NRest)
</pre>
<pre class="code extensibella"id="658">
 &lt; <b>search.</b>

Subgoal 10:

Variables: Known Needed E Rest ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof (relocateClause ID ID Rest)
Ela : elaborate Known (relocateClause ID ID Rest) Needed E @
Ela1 : elaborate Known Rest Needed E *
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="659">
 &lt; <b>Is: case IsP.</b>

Subgoal 10:

Variables: Known Needed E Rest ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause ID ID Rest) Needed E @
Ela1 : elaborate Known Rest Needed E *
Is : is_integer ID
Is1 : is_integer ID
Is2 : is_proof Rest
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="660">
 &lt; <b>apply IH to _ _ _ Ela1.</b>

Subgoal 10:

Variables: Known Needed E Rest ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause ID ID Rest) Needed E @
Ela1 : elaborate Known Rest Needed E *
Is : is_integer ID
Is1 : is_integer ID
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clauseUsedness) Needed
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="661">
 &lt; <b>search.</b>

Subgoal 11:

Variables: Known E KRest C KRest2 Needed1 NRest From Rest To
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
============================
 is_list (is_pair is_integer is_clauseUsedness) ((From, unknown)::NRest)
</pre>
<pre class="code extensibella"id="662">
 &lt; <b>Is: case IsP.</b>

Subgoal 11:

Variables: Known E KRest C KRest2 Needed1 NRest From Rest To
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
============================
 is_list (is_pair is_integer is_clauseUsedness) ((From, unknown)::NRest)
</pre>
<pre class="code extensibella"id="663">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 11:

Variables: Known E KRest C KRest2 Needed1 NRest From Rest To
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 is_list (is_pair is_integer is_clauseUsedness) ((From, unknown)::NRest)
</pre>
<pre class="code extensibella"id="664">
 &lt; <b>apply select_is to _ Ela2.</b>

Subgoal 11:

Variables: Known E KRest C KRest2 Needed1 NRest From Rest To
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
============================
 is_list (is_pair is_integer is_clauseUsedness) ((From, unknown)::NRest)
</pre>
<pre class="code extensibella"id="665">
 &lt; <b>M: apply select_mem to Ela2.</b>

Subgoal 11:

Variables: Known E KRest C KRest2 Needed1 NRest From Rest To
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
============================
 is_list (is_pair is_integer is_clauseUsedness) ((From, unknown)::NRest)
</pre>
<pre class="code extensibella"id="666">
 &lt; <b>GCLR: apply good_clause_list_remove_all to _ Ela1.</b>

Subgoal 11:

Variables: Known E KRest C KRest2 Needed1 NRest From Rest To
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
============================
 is_list (is_pair is_integer is_clauseUsedness) ((From, unknown)::NRest)
</pre>
<pre class="code extensibella"id="667">
 &lt; <b>GCLS: apply good_clause_list_select to GCLR Ela2.</b>

Subgoal 11:

Variables: Known E KRest C KRest2 Needed1 NRest From Rest To
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
============================
 is_list (is_pair is_integer is_clauseUsedness) ((From, unknown)::NRest)
</pre>
<pre class="code extensibella"id="668">
 &lt; <b>apply good_clause_list_add to GCLS _ with
     ID = To C = C.</b>

Subgoal 11.1:

Variables: Known E KRest C KRest2 Needed1 NRest From Rest To
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
============================
 (exists C', mem (To, C') KRest2) -&gt; false
</pre>
<pre class="code extensibella"id="669">
 &lt; <b>intros M'.</b>

Subgoal 11.1:

Variables: Known E KRest C KRest2 Needed1 NRest From Rest To
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
M' : exists C', mem (To, C') KRest2
============================
 false
</pre>
<pre class="code extensibella"id="670">
 &lt; <b>M': case M'.</b>

Subgoal 11.1:

Variables: Known E KRest C KRest2 Needed1 NRest From Rest To C'
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
M' : mem (To, C') KRest2
============================
 false
</pre>
<pre class="code extensibella"id="671">
 &lt; <b>M'': apply mem_after_select_before to Ela2 M'.</b>

Subgoal 11.1:

Variables: Known E KRest C KRest2 Needed1 NRest From Rest To C'
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
M' : mem (To, C') KRest2
M'' : mem (To, C') KRest
============================
 false
</pre>
<pre class="code extensibella"id="672">
 &lt; <b>apply remove_all_no_mem to Ela1 M''.</b>

Subgoal 11:

Variables: Known E KRest C KRest2 Needed1 NRest From Rest To
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
H3 : good_clause_list ((To, C)::KRest2)
============================
 is_list (is_pair is_integer is_clauseUsedness) ((From, unknown)::NRest)
</pre>
<pre class="code extensibella"id="673">
 &lt; <b>apply mem_is to _ M.</b>

Subgoal 11:

Variables: Known E KRest KRest2 Needed1 NRest Rest To ID C1
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause ID To Rest) ((ID, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (ID, C1) KRest2 KRest
Ela3 : elaborate ((To, C1)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (ID, C1) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
H3 : good_clause_list ((To, C1)::KRest2)
H4 : is_integer ID
H5 : is_clause C1
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, unknown)::NRest)
</pre>
<pre class="code extensibella"id="674">
 &lt; <b>apply IH to _ _ _ Ela3.</b>

Subgoal 11:

Variables: Known E KRest KRest2 Needed1 NRest Rest To ID C1
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause ID To Rest) ((ID, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (ID, C1) KRest2 KRest
Ela3 : elaborate ((To, C1)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (ID, C1) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
H3 : good_clause_list ((To, C1)::KRest2)
H4 : is_integer ID
H5 : is_clause C1
H6 : is_list (is_pair is_integer is_clauseUsedness) Needed1
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, unknown)::NRest)
</pre>
<pre class="code extensibella"id="675">
 &lt; <b>apply select_is_clauseUsedness to _ Ela4.</b>

Subgoal 11:

Variables: Known E KRest KRest2 Needed1 NRest Rest To ID C1
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause ID To Rest) ((ID, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (ID, C1) KRest2 KRest
Ela3 : elaborate ((To, C1)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (ID, C1) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
H3 : good_clause_list ((To, C1)::KRest2)
H4 : is_integer ID
H5 : is_clause C1
H6 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H7 : is_list (is_pair is_integer is_clauseUsedness) NRest
============================
 is_list (is_pair is_integer is_clauseUsedness) ((ID, unknown)::NRest)
</pre>
<pre class="code extensibella"id="676">
 &lt; <b>search.</b>

Subgoal 12:

Variables: Known Needed E Rest Comment
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof (commentProof Comment Rest)
Ela : elaborate Known (commentProof Comment Rest) Needed E @
Ela1 : elaborate Known Rest Needed E *
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="677">
 &lt; <b>case IsP.</b>

Subgoal 12:

Variables: Known Needed E Rest Comment
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (commentProof Comment Rest) Needed E @
Ela1 : elaborate Known Rest Needed E *
H1 : is_string Comment
H2 : is_proof Rest
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="678">
 &lt; <b>apply IH to _ _ _ Ela1.</b>

Subgoal 12:

Variables: Known Needed E Rest Comment
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (commentProof Comment Rest) Needed E @
Ela1 : elaborate Known Rest Needed E *
H1 : is_string Comment
H2 : is_proof Rest
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="679">
 &lt; <b>search.</b>

Subgoal 13:

Variables: Known Needed E PT
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof &lt;unknown I proof&gt;
Ela : elaborate Known &lt;unknown I proof&gt; Needed E @
Ela1 : Known |{proof}- &lt;unknown I proof&gt; ~~&gt; PT
Ela2 : elaborate Known PT Needed E *
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="680">
 &lt; <b>apply proj_proof_is to Ela1 _ _ _.</b>

Subgoal 13:

Variables: Known Needed E PT
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof &lt;unknown I proof&gt;
Ela : elaborate Known &lt;unknown I proof&gt; Needed E @
Ela1 : Known |{proof}- &lt;unknown I proof&gt; ~~&gt; PT
Ela2 : elaborate Known PT Needed E *
H1 : is_proof PT
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="681">
 &lt; <b>apply IH to _ _ _ Ela2.</b>

Subgoal 13:

Variables: Known Needed E PT
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_list (is_pair is_integer is_clauseUsedness) Needed
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof &lt;unknown I proof&gt;
Ela : elaborate Known &lt;unknown I proof&gt; Needed E @
Ela1 : Known |{proof}- &lt;unknown I proof&gt; ~~&gt; PT
Ela2 : elaborate Known PT Needed E *
H1 : is_proof PT
H2 : is_list (is_pair is_integer is_clauseUsedness) Needed
============================
 is_list (is_pair is_integer is_clauseUsedness) Needed
</pre>
<pre class="code extensibella"id="682">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="683">
 &lt; <b>Extensible_Theorem
      elaboration_is : forall Known P Needed E,
         IsKnown : is_list (is_pair is_integer is_clause) Known -&gt;
         GCL : good_clause_list Known -&gt;
         IsP : is_proof P -&gt;
         Ela : elaborate Known P Needed E -&gt;
         is_proof E
      on Ela.</b>

Subgoal 1:

Variables: Known Needed Needed1 NRest Prf ID FC
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof (endFrat ID FC)
Ela : elaborate Known (endFrat ID FC) Needed (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf Needed
============================
 is_proof (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="684">
 &lt; <b>Is: case IsP.</b>

Subgoal 1:

Variables: Known Needed Needed1 NRest Prf ID FC
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (endFrat ID FC) Needed (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_finalClauses FC
============================
 is_proof (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="685">
 &lt; <b>apply rupProof_is to Ela3 _.</b>

Subgoal 1:

Variables: Known Needed Needed1 NRest Prf ID FC
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (endFrat ID FC) Needed (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_finalClauses FC
H1 : is_list is_integer Prf
============================
 is_proof (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="686">
 &lt; <b>search.</b>

Subgoal 2:

Variables: Known Needed Needed1 NRest Prf ID FC
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof (endFratPrf ID Prf FC)
Ela : elaborate Known (endFratPrf ID Prf FC) Needed (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : makeUsed NRest Prf Needed
============================
 is_proof (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="687">
 &lt; <b>Is: case IsP.</b>

Subgoal 2:

Variables: Known Needed Needed1 NRest Prf ID FC
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (endFratPrf ID Prf FC) Needed (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_list is_integer Prf
Is2 : is_finalClauses FC
============================
 is_proof (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="688">
 &lt; <b>search.</b>

Subgoal 3:

Variables: Known E KRest Needed1 ID Rest C
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof (deleteFrat ID C Rest)
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed1) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
============================
 is_proof E
</pre>
<pre class="code extensibella"id="689">
 &lt; <b>Is: case IsP.</b>

Subgoal 3:

Variables: Known E KRest Needed1 ID Rest C
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed1) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
============================
 is_proof E
</pre>
<pre class="code extensibella"id="690">
 &lt; <b>apply select_is to _ Ela1.</b>

Subgoal 3:

Variables: Known E KRest Needed1 ID Rest C
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed1) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 is_proof E
</pre>
<pre class="code extensibella"id="691">
 &lt; <b>apply good_clause_list_select to _ Ela1.</b>

Subgoal 3:

Variables: Known E KRest Needed1 ID Rest C
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed1) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
============================
 is_proof E
</pre>
<pre class="code extensibella"id="692">
 &lt; <b>apply IH to _ _ _ Ela2.</b>

Subgoal 3:

Variables: Known E KRest Needed1 ID Rest C
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed1) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_proof E
============================
 is_proof E
</pre>
<pre class="code extensibella"id="693">
 &lt; <b>search.</b>

Subgoal 4:

Variables: Known E C KRest Needed1 ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof (deleteLratProof ID Rest)
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed1) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
============================
 is_proof E
</pre>
<pre class="code extensibella"id="694">
 &lt; <b>Is: case IsP.</b>

Subgoal 4:

Variables: Known E C KRest Needed1 ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed1) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
Is : is_integer ID
Is1 : is_proof Rest
============================
 is_proof E
</pre>
<pre class="code extensibella"id="695">
 &lt; <b>apply select_is to _ Ela1.</b>

Subgoal 4:

Variables: Known E C KRest Needed1 ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed1) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
Is : is_integer ID
Is1 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 is_proof E
</pre>
<pre class="code extensibella"id="696">
 &lt; <b>apply good_clause_list_select to _ Ela1.</b>

Subgoal 4:

Variables: Known E C KRest Needed1 ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed1) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
Is : is_integer ID
Is1 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
============================
 is_proof E
</pre>
<pre class="code extensibella"id="697">
 &lt; <b>apply IH to _ _ _ Ela2.</b>

Subgoal 4:

Variables: Known E C KRest Needed1 ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed1) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
Is : is_integer ID
Is1 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_proof E
============================
 is_proof E
</pre>
<pre class="code extensibella"id="698">
 &lt; <b>search.</b>

Subgoal 5:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf Needed
============================
 is_proof (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="699">
 &lt; <b>Is: case IsP.</b>

Subgoal 5:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
============================
 is_proof (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="700">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 5:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 is_proof (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="701">
 &lt; <b>apply good_clause_list_remove_all_add to _ Ela1 with
     C = C.</b>

Subgoal 5:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
============================
 is_proof (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="702">
 &lt; <b>apply IH to _ _ _ Ela2.</b>

Subgoal 5:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_proof ERest
============================
 is_proof (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="703">
 &lt; <b>search.</b>

Subgoal 6:

Variables: Known Needed E KRest Needed1 Rest Prf C ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) Needed E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) Needed Needed1
============================
 is_proof E
</pre>
<pre class="code extensibella"id="704">
 &lt; <b>Is: case IsP.</b>

Subgoal 6:

Variables: Known Needed E KRest Needed1 Rest Prf C ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) Needed E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) Needed Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
============================
 is_proof E
</pre>
<pre class="code extensibella"id="705">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 6:

Variables: Known Needed E KRest Needed1 Rest Prf C ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) Needed E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) Needed Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 is_proof E
</pre>
<pre class="code extensibella"id="706">
 &lt; <b>apply good_clause_list_remove_all_add to _ Ela1 with
     C = C.</b>

Subgoal 6:

Variables: Known Needed E KRest Needed1 Rest Prf C ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) Needed E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) Needed Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
============================
 is_proof E
</pre>
<pre class="code extensibella"id="707">
 &lt; <b>apply IH to _ _ _ Ela2.</b>

Subgoal 6:

Variables: Known Needed E KRest Needed1 Rest Prf C ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) Needed E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) Needed Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_proof E
============================
 is_proof E
</pre>
<pre class="code extensibella"id="708">
 &lt; <b>search.</b>

Subgoal 7:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf Needed
============================
 is_proof (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="709">
 &lt; <b>Is: case IsP.</b>

Subgoal 7:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
============================
 is_proof (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="710">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 7:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 is_proof (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="711">
 &lt; <b>apply good_clause_list_remove_all_add to _ Ela1 with
     C = C.</b>

Subgoal 7:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
============================
 is_proof (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="712">
 &lt; <b>apply IH to _ _ _ Ela2.</b>

Subgoal 7:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_proof ERest
============================
 is_proof (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="713">
 &lt; <b>apply rupProof_is to Ela4 _.</b>

Subgoal 7:

Variables: Known Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) Needed (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_proof ERest
H4 : is_list is_integer Prf
============================
 is_proof (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="714">
 &lt; <b>search.</b>

Subgoal 8:

Variables: Known Needed E KRest Needed1 Rest C ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) Needed E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) Needed Needed1
============================
 is_proof E
</pre>
<pre class="code extensibella"id="715">
 &lt; <b>Is: case IsP.</b>

Subgoal 8:

Variables: Known Needed E KRest Needed1 Rest C ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) Needed E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) Needed Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
============================
 is_proof E
</pre>
<pre class="code extensibella"id="716">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 8:

Variables: Known Needed E KRest Needed1 Rest C ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) Needed E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) Needed Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 is_proof E
</pre>
<pre class="code extensibella"id="717">
 &lt; <b>apply good_clause_list_remove_all_add to _ Ela1 with
     C = C.</b>

Subgoal 8:

Variables: Known Needed E KRest Needed1 Rest C ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) Needed E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) Needed Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
============================
 is_proof E
</pre>
<pre class="code extensibella"id="718">
 &lt; <b>apply IH to _ _ _ Ela2.</b>

Subgoal 8:

Variables: Known Needed E KRest Needed1 Rest C ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) Needed E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) Needed Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_proof E
============================
 is_proof E
</pre>
<pre class="code extensibella"id="719">
 &lt; <b>search.</b>

Subgoal 9:

Variables: Known KRest C KRest2 Needed1 ERest To From NRest Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
============================
 is_proof (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="720">
 &lt; <b>Is: case IsP.</b>

Subgoal 9:

Variables: Known KRest C KRest2 Needed1 ERest To From NRest Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
============================
 is_proof (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="721">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 9:

Variables: Known KRest C KRest2 Needed1 ERest To From NRest Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 is_proof (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="722">
 &lt; <b>apply select_is to _ Ela2.</b>

Subgoal 9:

Variables: Known KRest C KRest2 Needed1 ERest To From NRest Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
============================
 is_proof (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="723">
 &lt; <b>M: apply select_mem to Ela2.</b>

Subgoal 9:

Variables: Known KRest C KRest2 Needed1 ERest To From NRest Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
============================
 is_proof (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="724">
 &lt; <b>GCLR: apply good_clause_list_remove_all to _ Ela1.</b>

Subgoal 9:

Variables: Known KRest C KRest2 Needed1 ERest To From NRest Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
============================
 is_proof (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="725">
 &lt; <b>GCLS: apply good_clause_list_select to GCLR Ela2.</b>

Subgoal 9:

Variables: Known KRest C KRest2 Needed1 ERest To From NRest Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
============================
 is_proof (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="726">
 &lt; <b>apply good_clause_list_add to GCLS _ with
     ID = To C = C.</b>

Subgoal 9.1:

Variables: Known KRest C KRest2 Needed1 ERest To From NRest Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
============================
 (exists C', mem (To, C') KRest2) -&gt; false
</pre>
<pre class="code extensibella"id="727">
 &lt; <b>intros M'.</b>

Subgoal 9.1:

Variables: Known KRest C KRest2 Needed1 ERest To From NRest Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
M' : exists C', mem (To, C') KRest2
============================
 false
</pre>
<pre class="code extensibella"id="728">
 &lt; <b>M': case M'.</b>

Subgoal 9.1:

Variables: Known KRest C KRest2 Needed1 ERest To From NRest Rest C'
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
M' : mem (To, C') KRest2
============================
 false
</pre>
<pre class="code extensibella"id="729">
 &lt; <b>M'': apply mem_after_select_before to Ela2 M'.</b>

Subgoal 9.1:

Variables: Known KRest C KRest2 Needed1 ERest To From NRest Rest C'
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
M' : mem (To, C') KRest2
M'' : mem (To, C') KRest
============================
 false
</pre>
<pre class="code extensibella"id="730">
 &lt; <b>apply remove_all_no_mem to Ela1 M''.</b>

Subgoal 9:

Variables: Known KRest C KRest2 Needed1 ERest To From NRest Rest
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
H3 : good_clause_list ((To, C)::KRest2)
============================
 is_proof (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="731">
 &lt; <b>apply mem_is to _ M.</b>

Subgoal 9:

Variables: Known KRest KRest2 Needed1 ERest To NRest Rest ID C1
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (ID, C1) KRest2 KRest
Ela3 : elaborate ((To, C1)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (ID, C1) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
H3 : good_clause_list ((To, C1)::KRest2)
H4 : is_integer ID
H5 : is_clause C1
============================
 is_proof (relocateClause ID To ERest)
</pre>
<pre class="code extensibella"id="732">
 &lt; <b>apply IH to _ _ _ Ela3.</b>

Subgoal 9:

Variables: Known KRest KRest2 Needed1 ERest To NRest Rest ID C1
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (ID, C1) KRest2 KRest
Ela3 : elaborate ((To, C1)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (ID, C1) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
H3 : good_clause_list ((To, C1)::KRest2)
H4 : is_integer ID
H5 : is_clause C1
H6 : is_proof ERest
============================
 is_proof (relocateClause ID To ERest)
</pre>
<pre class="code extensibella"id="733">
 &lt; <b>search.</b>

Subgoal 10:

Variables: Known Needed E Rest ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof (relocateClause ID ID Rest)
Ela : elaborate Known (relocateClause ID ID Rest) Needed E @
Ela1 : elaborate Known Rest Needed E *
============================
 is_proof E
</pre>
<pre class="code extensibella"id="734">
 &lt; <b>case IsP.</b>

Subgoal 10:

Variables: Known Needed E Rest ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause ID ID Rest) Needed E @
Ela1 : elaborate Known Rest Needed E *
H1 : is_integer ID
H2 : is_integer ID
H3 : is_proof Rest
============================
 is_proof E
</pre>
<pre class="code extensibella"id="735">
 &lt; <b>apply IH to _ _ _ Ela1.</b>

Subgoal 10:

Variables: Known Needed E Rest ID
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause ID ID Rest) Needed E @
Ela1 : elaborate Known Rest Needed E *
H1 : is_integer ID
H2 : is_integer ID
H3 : is_proof Rest
H4 : is_proof E
============================
 is_proof E
</pre>
<pre class="code extensibella"id="736">
 &lt; <b>search.</b>

Subgoal 11:

Variables: Known E KRest C KRest2 Needed1 NRest From Rest To
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
============================
 is_proof E
</pre>
<pre class="code extensibella"id="737">
 &lt; <b>Is: case IsP.</b>

Subgoal 11:

Variables: Known E KRest C KRest2 Needed1 NRest From Rest To
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
============================
 is_proof E
</pre>
<pre class="code extensibella"id="738">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 11:

Variables: Known E KRest C KRest2 Needed1 NRest From Rest To
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 is_proof E
</pre>
<pre class="code extensibella"id="739">
 &lt; <b>apply select_is to _ Ela2.</b>

Subgoal 11:

Variables: Known E KRest C KRest2 Needed1 NRest From Rest To
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
============================
 is_proof E
</pre>
<pre class="code extensibella"id="740">
 &lt; <b>M: apply select_mem to Ela2.</b>

Subgoal 11:

Variables: Known E KRest C KRest2 Needed1 NRest From Rest To
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
============================
 is_proof E
</pre>
<pre class="code extensibella"id="741">
 &lt; <b>GCLR: apply good_clause_list_remove_all to _ Ela1.</b>

Subgoal 11:

Variables: Known E KRest C KRest2 Needed1 NRest From Rest To
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
============================
 is_proof E
</pre>
<pre class="code extensibella"id="742">
 &lt; <b>GCLS: apply good_clause_list_select to GCLR Ela2.</b>

Subgoal 11:

Variables: Known E KRest C KRest2 Needed1 NRest From Rest To
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
============================
 is_proof E
</pre>
<pre class="code extensibella"id="743">
 &lt; <b>apply good_clause_list_add to GCLS _ with
     ID = To C = C.</b>

Subgoal 11.1:

Variables: Known E KRest C KRest2 Needed1 NRest From Rest To
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
============================
 (exists C', mem (To, C') KRest2) -&gt; false
</pre>
<pre class="code extensibella"id="744">
 &lt; <b>intros M'.</b>

Subgoal 11.1:

Variables: Known E KRest C KRest2 Needed1 NRest From Rest To
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
M' : exists C', mem (To, C') KRest2
============================
 false
</pre>
<pre class="code extensibella"id="745">
 &lt; <b>M': case M'.</b>

Subgoal 11.1:

Variables: Known E KRest C KRest2 Needed1 NRest From Rest To C'
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
M' : mem (To, C') KRest2
============================
 false
</pre>
<pre class="code extensibella"id="746">
 &lt; <b>M'': apply mem_after_select_before to Ela2 M'.</b>

Subgoal 11.1:

Variables: Known E KRest C KRest2 Needed1 NRest From Rest To C'
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
M' : mem (To, C') KRest2
M'' : mem (To, C') KRest
============================
 false
</pre>
<pre class="code extensibella"id="747">
 &lt; <b>apply remove_all_no_mem to Ela1 M''.</b>

Subgoal 11:

Variables: Known E KRest C KRest2 Needed1 NRest From Rest To
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (From, C) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
H3 : good_clause_list ((To, C)::KRest2)
============================
 is_proof E
</pre>
<pre class="code extensibella"id="748">
 &lt; <b>apply mem_is to _ M.</b>

Subgoal 11:

Variables: Known E KRest KRest2 Needed1 NRest Rest To ID C1
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause ID To Rest) ((ID, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (ID, C1) KRest2 KRest
Ela3 : elaborate ((To, C1)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (ID, C1) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
H3 : good_clause_list ((To, C1)::KRest2)
H4 : is_integer ID
H5 : is_clause C1
============================
 is_proof E
</pre>
<pre class="code extensibella"id="749">
 &lt; <b>apply IH to _ _ _ Ela3.</b>

Subgoal 11:

Variables: Known E KRest KRest2 Needed1 NRest Rest To ID C1
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause ID To Rest) ((ID, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (ID, C1) KRest2 KRest
Ela3 : elaborate ((To, C1)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (ID, C1) KRest
GCLR : good_clause_list KRest
GCLS : good_clause_list KRest2
H3 : good_clause_list ((To, C1)::KRest2)
H4 : is_integer ID
H5 : is_clause C1
H6 : is_proof E
============================
 is_proof E
</pre>
<pre class="code extensibella"id="750">
 &lt; <b>search.</b>

Subgoal 12:

Variables: Known Needed E Rest Comment
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof (commentProof Comment Rest)
Ela : elaborate Known (commentProof Comment Rest) Needed E @
Ela1 : elaborate Known Rest Needed E *
============================
 is_proof E
</pre>
<pre class="code extensibella"id="751">
 &lt; <b>Is: case IsP.</b>

Subgoal 12:

Variables: Known Needed E Rest Comment
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (commentProof Comment Rest) Needed E @
Ela1 : elaborate Known Rest Needed E *
Is : is_string Comment
Is1 : is_proof Rest
============================
 is_proof E
</pre>
<pre class="code extensibella"id="752">
 &lt; <b>apply IH to _ _ _ Ela1.</b>

Subgoal 12:

Variables: Known Needed E Rest Comment
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (commentProof Comment Rest) Needed E @
Ela1 : elaborate Known Rest Needed E *
Is : is_string Comment
Is1 : is_proof Rest
H1 : is_proof E
============================
 is_proof E
</pre>
<pre class="code extensibella"id="753">
 &lt; <b>search.</b>

Subgoal 13:

Variables: Known Needed E PT
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof &lt;unknown I proof&gt;
Ela : elaborate Known &lt;unknown I proof&gt; Needed E @
Ela1 : Known |{proof}- &lt;unknown I proof&gt; ~~&gt; PT
Ela2 : elaborate Known PT Needed E *
============================
 is_proof E
</pre>
<pre class="code extensibella"id="754">
 &lt; <b>apply proj_proof_is to Ela1 _ _ _.</b>

Subgoal 13:

Variables: Known Needed E PT
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof &lt;unknown I proof&gt;
Ela : elaborate Known &lt;unknown I proof&gt; Needed E @
Ela1 : Known |{proof}- &lt;unknown I proof&gt; ~~&gt; PT
Ela2 : elaborate Known PT Needed E *
H1 : is_proof PT
============================
 is_proof E
</pre>
<pre class="code extensibella"id="755">
 &lt; <b>apply IH to _ _ _ Ela2.</b>

Subgoal 13:

Variables: Known Needed E PT
IH : forall Known P Needed E,
       is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       is_proof P -&gt; elaborate Known P Needed E * -&gt; is_proof E
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
IsP : is_proof &lt;unknown I proof&gt;
Ela : elaborate Known &lt;unknown I proof&gt; Needed E @
Ela1 : Known |{proof}- &lt;unknown I proof&gt; ~~&gt; PT
Ela2 : elaborate Known PT Needed E *
H1 : is_proof PT
H2 : is_proof E
============================
 is_proof E
</pre>
<pre class="code extensibella"id="756">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="757">
 &lt; <b>Define gatherNeeded :
             (list (pair integer clause)) -&gt;
             (list (pair integer clauseUsedness)) -&gt;
             (list (pair integer clause)) -&gt;
             prop by
   gatherNeeded K [] [];
   gatherNeeded K ((ID, needed)::CURest) ((ID, C)::NRest) :=
     mem (ID, C) K /\ gatherNeeded K CURest NRest;
   gatherNeeded K ((ID, NotNeeded)::CURest) NRest :=
     gatherNeeded K CURest NRest /\ (NotNeeded = needed -&gt; false).</b>


</pre>
<pre class="code extensibella"id="758">
 &lt; <b>Define good_used_list : (list (pair integer clauseUsedness)) -&gt; prop by
   good_used_list CU :=
     forall ID U1 CURest U2,
       select (ID, U1) CURest CU -&gt; mem (ID, U2) CURest -&gt; false.</b>


</pre>
<pre class="code extensibella"id="759">
 &lt; <b>Theorem good_used_list_drop :
     forall L IDN, good_used_list (IDN::L) -&gt; good_used_list L.</b>

============================
 forall L IDN, good_used_list (IDN::L) -&gt; good_used_list L
</pre>
<pre class="code extensibella"id="760">
 &lt; <b>intros GCL.</b>

Variables: L IDN
GCL : good_used_list (IDN::L)
============================
 good_used_list L
</pre>
<pre class="code extensibella"id="761">
 &lt; <b>GCL: case GCL.</b>

Variables: L IDN
GCL : forall ID U1 CURest U2,
        select (ID, U1) CURest (IDN::L) -&gt; mem (ID, U2) CURest -&gt; false
============================
 good_used_list L
</pre>
<pre class="code extensibella"id="762">
 &lt; <b>unfold .</b>

Variables: L IDN
GCL : forall ID U1 CURest U2,
        select (ID, U1) CURest (IDN::L) -&gt; mem (ID, U2) CURest -&gt; false
============================
 forall ID U1 CURest U2,
   select (ID, U1) CURest L -&gt; mem (ID, U2) CURest -&gt; false
</pre>
<pre class="code extensibella"id="763">
 &lt; <b>intros S M.</b>

Variables: L IDN ID U1 CURest U2
GCL : forall ID U1 CURest U2,
        select (ID, U1) CURest (IDN::L) -&gt; mem (ID, U2) CURest -&gt; false
S : select (ID, U1) CURest L
M : mem (ID, U2) CURest
============================
 false
</pre>
<pre class="code extensibella"id="764">
 &lt; <b>backchain GCL to
   ID = ID
   U1 = U1.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="765">
 &lt; <b>Theorem good_used_list_select :
     forall L Rest ID U,
       good_used_list L -&gt; select (ID, U) Rest L -&gt; good_used_list Rest.</b>

============================
 forall L Rest ID U,
   good_used_list L -&gt; select (ID, U) Rest L -&gt; good_used_list Rest
</pre>
<pre class="code extensibella"id="766">
 &lt; <b>induction on 2.</b>

IH : forall L Rest ID U,
       good_used_list L -&gt; select (ID, U) Rest L * -&gt; good_used_list Rest
============================
 forall L Rest ID U,
   good_used_list L -&gt; select (ID, U) Rest L @ -&gt; good_used_list Rest
</pre>
<pre class="code extensibella"id="767">
 &lt; <b>intros GCL S.</b>

Variables: L Rest ID U
IH : forall L Rest ID U,
       good_used_list L -&gt; select (ID, U) Rest L * -&gt; good_used_list Rest
GCL : good_used_list L
S : select (ID, U) Rest L @
============================
 good_used_list Rest
</pre>
<pre class="code extensibella"id="768">
 &lt; <b>S: case S.</b>

Subgoal 1:

Variables: Rest ID U
IH : forall L Rest ID U,
       good_used_list L -&gt; select (ID, U) Rest L * -&gt; good_used_list Rest
GCL : good_used_list ((ID, U)::Rest)
============================
 good_used_list Rest
</pre>
<pre class="code extensibella"id="769">
 &lt; <b>apply good_used_list_drop to GCL.</b>

Subgoal 1:

Variables: Rest ID U
IH : forall L Rest ID U,
       good_used_list L -&gt; select (ID, U) Rest L * -&gt; good_used_list Rest
GCL : good_used_list ((ID, U)::Rest)
H1 : good_used_list Rest
============================
 good_used_list Rest
</pre>
<pre class="code extensibella"id="770">
 &lt; <b>search.</b>

Subgoal 2:

Variables: ID U L2 I L1
IH : forall L Rest ID U,
       good_used_list L -&gt; select (ID, U) Rest L * -&gt; good_used_list Rest
GCL : good_used_list (I::L2)
S : select (ID, U) L1 L2 *
============================
 good_used_list (I::L1)
</pre>
<pre class="code extensibella"id="771">
 &lt; <b>GCL': apply good_used_list_drop to GCL.</b>

Subgoal 2:

Variables: ID U L2 I L1
IH : forall L Rest ID U,
       good_used_list L -&gt; select (ID, U) Rest L * -&gt; good_used_list Rest
GCL : good_used_list (I::L2)
S : select (ID, U) L1 L2 *
GCL' : good_used_list L2
============================
 good_used_list (I::L1)
</pre>
<pre class="code extensibella"id="772">
 &lt; <b>GCL1: apply IH to GCL' S.</b>

Subgoal 2:

Variables: ID U L2 I L1
IH : forall L Rest ID U,
       good_used_list L -&gt; select (ID, U) Rest L * -&gt; good_used_list Rest
GCL : good_used_list (I::L2)
S : select (ID, U) L1 L2 *
GCL' : good_used_list L2
GCL1 : good_used_list L1
============================
 good_used_list (I::L1)
</pre>
<pre class="code extensibella"id="773">
 &lt; <b>unfold .</b>

Subgoal 2:

Variables: ID U L2 I L1
IH : forall L Rest ID U,
       good_used_list L -&gt; select (ID, U) Rest L * -&gt; good_used_list Rest
GCL : good_used_list (I::L2)
S : select (ID, U) L1 L2 *
GCL' : good_used_list L2
GCL1 : good_used_list L1
============================
 forall ID U1 CURest U2,
   select (ID, U1) CURest (I::L1) -&gt; mem (ID, U2) CURest -&gt; false
</pre>
<pre class="code extensibella"id="774">
 &lt; <b>intros Slct M.</b>

Subgoal 2:

Variables: ID U L2 I L1 ID1 U1 CURest U2
IH : forall L Rest ID U,
       good_used_list L -&gt; select (ID, U) Rest L * -&gt; good_used_list Rest
GCL : good_used_list (I::L2)
S : select (ID, U) L1 L2 *
GCL' : good_used_list L2
GCL1 : good_used_list L1
Slct : select (ID1, U1) CURest (I::L1)
M : mem (ID1, U2) CURest
============================
 false
</pre>
<pre class="code extensibella"id="775">
 &lt; <b>Slct: case Slct.</b>

Subgoal 2.1:

Variables: ID U L2 L1 ID1 U1 U2
IH : forall L Rest ID U,
       good_used_list L -&gt; select (ID, U) Rest L * -&gt; good_used_list Rest
GCL : good_used_list ((ID1, U1)::L2)
S : select (ID, U) L1 L2 *
GCL' : good_used_list L2
GCL1 : good_used_list L1
M : mem (ID1, U2) L1
============================
 false
</pre>
<pre class="code extensibella"id="776">
 &lt; <b>M': apply mem_after_select_before to S M.</b>

Subgoal 2.1:

Variables: ID U L2 L1 ID1 U1 U2
IH : forall L Rest ID U,
       good_used_list L -&gt; select (ID, U) Rest L * -&gt; good_used_list Rest
GCL : good_used_list ((ID1, U1)::L2)
S : select (ID, U) L1 L2 *
GCL' : good_used_list L2
GCL1 : good_used_list L1
M : mem (ID1, U2) L1
M' : mem (ID1, U2) L2
============================
 false
</pre>
<pre class="code extensibella"id="777">
 &lt; <b>GCL: case GCL.</b>

Subgoal 2.1:

Variables: ID U L2 L1 ID1 U1 U2
IH : forall L Rest ID U,
       good_used_list L -&gt; select (ID, U) Rest L * -&gt; good_used_list Rest
S : select (ID, U) L1 L2 *
GCL' : good_used_list L2
GCL1 : good_used_list L1
M : mem (ID1, U2) L1
M' : mem (ID1, U2) L2
GCL : forall ID U2 CURest U3,
        select (ID, U2) CURest ((ID1, U1)::L2) -&gt; mem (ID, U3) CURest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="778">
 &lt; <b>apply GCL to _ M'.</b>

Subgoal 2.2:

Variables: ID U L2 I L1 ID1 U1 U2 L3
IH : forall L Rest ID U,
       good_used_list L -&gt; select (ID, U) Rest L * -&gt; good_used_list Rest
GCL : good_used_list (I::L2)
S : select (ID, U) L1 L2 *
GCL' : good_used_list L2
GCL1 : good_used_list L1
M : mem (ID1, U2) (I::L3)
Slct : select (ID1, U1) L3 L1
============================
 false
</pre>
<pre class="code extensibella"id="779">
 &lt; <b>M: case M.</b>

Subgoal 2.2.1:

Variables: ID U L2 L1 ID1 U1 U2 L3
IH : forall L Rest ID U,
       good_used_list L -&gt; select (ID, U) Rest L * -&gt; good_used_list Rest
GCL : good_used_list ((ID1, U2)::L2)
S : select (ID, U) L1 L2 *
GCL' : good_used_list L2
GCL1 : good_used_list L1
Slct : select (ID1, U1) L3 L1
============================
 false
</pre>
<pre class="code extensibella"id="780">
 &lt; <b>MS: apply select_mem to Slct.</b>

Subgoal 2.2.1:

Variables: ID U L2 L1 ID1 U1 U2 L3
IH : forall L Rest ID U,
       good_used_list L -&gt; select (ID, U) Rest L * -&gt; good_used_list Rest
GCL : good_used_list ((ID1, U2)::L2)
S : select (ID, U) L1 L2 *
GCL' : good_used_list L2
GCL1 : good_used_list L1
Slct : select (ID1, U1) L3 L1
MS : mem (ID1, U1) L1
============================
 false
</pre>
<pre class="code extensibella"id="781">
 &lt; <b>M': apply mem_after_select_before to S MS.</b>

Subgoal 2.2.1:

Variables: ID U L2 L1 ID1 U1 U2 L3
IH : forall L Rest ID U,
       good_used_list L -&gt; select (ID, U) Rest L * -&gt; good_used_list Rest
GCL : good_used_list ((ID1, U2)::L2)
S : select (ID, U) L1 L2 *
GCL' : good_used_list L2
GCL1 : good_used_list L1
Slct : select (ID1, U1) L3 L1
MS : mem (ID1, U1) L1
M' : mem (ID1, U1) L2
============================
 false
</pre>
<pre class="code extensibella"id="782">
 &lt; <b>GCL: case GCL.</b>

Subgoal 2.2.1:

Variables: ID U L2 L1 ID1 U1 U2 L3
IH : forall L Rest ID U,
       good_used_list L -&gt; select (ID, U) Rest L * -&gt; good_used_list Rest
S : select (ID, U) L1 L2 *
GCL' : good_used_list L2
GCL1 : good_used_list L1
Slct : select (ID1, U1) L3 L1
MS : mem (ID1, U1) L1
M' : mem (ID1, U1) L2
GCL : forall ID U1 CURest U3,
        select (ID, U1) CURest ((ID1, U2)::L2) -&gt; mem (ID, U3) CURest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="783">
 &lt; <b>backchain GCL.</b>

Subgoal 2.2.2:

Variables: ID U L2 I L1 ID1 U1 U2 L3
IH : forall L Rest ID U,
       good_used_list L -&gt; select (ID, U) Rest L * -&gt; good_used_list Rest
GCL : good_used_list (I::L2)
S : select (ID, U) L1 L2 *
GCL' : good_used_list L2
GCL1 : good_used_list L1
Slct : select (ID1, U1) L3 L1
M : mem (ID1, U2) L3
============================
 false
</pre>
<pre class="code extensibella"id="784">
 &lt; <b>GCL1: case GCL1.</b>

Subgoal 2.2.2:

Variables: ID U L2 I L1 ID1 U1 U2 L3
IH : forall L Rest ID U,
       good_used_list L -&gt; select (ID, U) Rest L * -&gt; good_used_list Rest
GCL : good_used_list (I::L2)
S : select (ID, U) L1 L2 *
GCL' : good_used_list L2
Slct : select (ID1, U1) L3 L1
M : mem (ID1, U2) L3
GCL1 : forall ID U1 CURest U2,
         select (ID, U1) CURest L1 -&gt; mem (ID, U2) CURest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="785">
 &lt; <b>apply GCL1 to Slct M.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="786">
 &lt; <b>Theorem makeUsed_member :
     forall Needed Prf Updated ID U,
       makeUsed Needed Prf Updated -&gt; mem (ID, U) Updated -&gt; exists U',
         mem (ID, U') Needed.</b>

============================
 forall Needed Prf Updated ID U,
   makeUsed Needed Prf Updated -&gt; mem (ID, U) Updated -&gt; exists U',
     mem (ID, U') Needed
</pre>
<pre class="code extensibella"id="787">
 &lt; <b>induction on 1.</b>

IH : forall Needed Prf Updated ID U,
       makeUsed Needed Prf Updated * -&gt; mem (ID, U) Updated -&gt; exists U',
         mem (ID, U') Needed
============================
 forall Needed Prf Updated ID U,
   makeUsed Needed Prf Updated @ -&gt; mem (ID, U) Updated -&gt; exists U',
     mem (ID, U') Needed
</pre>
<pre class="code extensibella"id="788">
 &lt; <b>intros MU M.</b>

Variables: Needed Prf Updated ID U
IH : forall Needed Prf Updated ID U,
       makeUsed Needed Prf Updated * -&gt; mem (ID, U) Updated -&gt; exists U',
         mem (ID, U') Needed
MU : makeUsed Needed Prf Updated @
M : mem (ID, U) Updated
============================
 exists U', mem (ID, U') Needed
</pre>
<pre class="code extensibella"id="789">
 &lt; <b>MU: case MU.</b>

Subgoal 1:

Variables: Updated ID U
IH : forall Needed Prf Updated ID U,
       makeUsed Needed Prf Updated * -&gt; mem (ID, U) Updated -&gt; exists U',
         mem (ID, U') Needed
M : mem (ID, U) Updated
============================
 exists U', mem (ID, U') Updated
</pre>
<pre class="code extensibella"id="790">
 &lt; <b>search.</b>

Subgoal 2:

Variables: Needed ID U KRest KOut ID1 Rest
IH : forall Needed Prf Updated ID U,
       makeUsed Needed Prf Updated * -&gt; mem (ID, U) Updated -&gt; exists U',
         mem (ID, U') Needed
M : mem (ID, U) ((ID1, needed)::KOut)
MU : select (ID1, needed) KRest Needed
MU1 : makeUsed KRest Rest KOut *
============================
 exists U', mem (ID, U') Needed
</pre>
<pre class="code extensibella"id="791">
 &lt; <b>M: case M.</b>

Subgoal 2.1:

Variables: Needed KRest KOut ID1 Rest
IH : forall Needed Prf Updated ID U,
       makeUsed Needed Prf Updated * -&gt; mem (ID, U) Updated -&gt; exists U',
         mem (ID, U') Needed
MU : select (ID1, needed) KRest Needed
MU1 : makeUsed KRest Rest KOut *
============================
 exists U', mem (ID1, U') Needed
</pre>
<pre class="code extensibella"id="792">
 &lt; <b>apply select_mem to MU.</b>

Subgoal 2.1:

Variables: Needed KRest KOut ID1 Rest
IH : forall Needed Prf Updated ID U,
       makeUsed Needed Prf Updated * -&gt; mem (ID, U) Updated -&gt; exists U',
         mem (ID, U') Needed
MU : select (ID1, needed) KRest Needed
MU1 : makeUsed KRest Rest KOut *
H1 : mem (ID1, needed) Needed
============================
 exists U', mem (ID1, U') Needed
</pre>
<pre class="code extensibella"id="793">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: Needed ID U KRest KOut ID1 Rest
IH : forall Needed Prf Updated ID U,
       makeUsed Needed Prf Updated * -&gt; mem (ID, U) Updated -&gt; exists U',
         mem (ID, U') Needed
MU : select (ID1, needed) KRest Needed
MU1 : makeUsed KRest Rest KOut *
M : mem (ID, U) KOut
============================
 exists U', mem (ID, U') Needed
</pre>
<pre class="code extensibella"id="794">
 &lt; <b>M': apply IH to MU1 M.</b>

Subgoal 2.2:

Variables: Needed ID U KRest KOut ID1 Rest U'
IH : forall Needed Prf Updated ID U,
       makeUsed Needed Prf Updated * -&gt; mem (ID, U) Updated -&gt; exists U',
         mem (ID, U') Needed
MU : select (ID1, needed) KRest Needed
MU1 : makeUsed KRest Rest KOut *
M : mem (ID, U) KOut
M' : mem (ID, U') KRest
============================
 exists U', mem (ID, U') Needed
</pre>
<pre class="code extensibella"id="795">
 &lt; <b>apply mem_after_select_before to MU M'.</b>

Subgoal 2.2:

Variables: Needed ID U KRest KOut ID1 Rest U'
IH : forall Needed Prf Updated ID U,
       makeUsed Needed Prf Updated * -&gt; mem (ID, U) Updated -&gt; exists U',
         mem (ID, U') Needed
MU : select (ID1, needed) KRest Needed
MU1 : makeUsed KRest Rest KOut *
M : mem (ID, U) KOut
M' : mem (ID, U') KRest
H1 : mem (ID, U') Needed
============================
 exists U', mem (ID, U') Needed
</pre>
<pre class="code extensibella"id="796">
 &lt; <b>search.</b>

Subgoal 3:

Variables: Needed ID U KRest KOut ID1 Rest
IH : forall Needed Prf Updated ID U,
       makeUsed Needed Prf Updated * -&gt; mem (ID, U) Updated -&gt; exists U',
         mem (ID, U') Needed
M : mem (ID, U) ((ID1, needed)::KOut)
MU : select (ID1, unknown) KRest Needed
MU1 : makeUsed KRest Rest KOut *
============================
 exists U', mem (ID, U') Needed
</pre>
<pre class="code extensibella"id="797">
 &lt; <b>M: case M.</b>

Subgoal 3.1:

Variables: Needed KRest KOut ID1 Rest
IH : forall Needed Prf Updated ID U,
       makeUsed Needed Prf Updated * -&gt; mem (ID, U) Updated -&gt; exists U',
         mem (ID, U') Needed
MU : select (ID1, unknown) KRest Needed
MU1 : makeUsed KRest Rest KOut *
============================
 exists U', mem (ID1, U') Needed
</pre>
<pre class="code extensibella"id="798">
 &lt; <b>apply select_mem to MU.</b>

Subgoal 3.1:

Variables: Needed KRest KOut ID1 Rest
IH : forall Needed Prf Updated ID U,
       makeUsed Needed Prf Updated * -&gt; mem (ID, U) Updated -&gt; exists U',
         mem (ID, U') Needed
MU : select (ID1, unknown) KRest Needed
MU1 : makeUsed KRest Rest KOut *
H1 : mem (ID1, unknown) Needed
============================
 exists U', mem (ID1, U') Needed
</pre>
<pre class="code extensibella"id="799">
 &lt; <b>search.</b>

Subgoal 3.2:

Variables: Needed ID U KRest KOut ID1 Rest
IH : forall Needed Prf Updated ID U,
       makeUsed Needed Prf Updated * -&gt; mem (ID, U) Updated -&gt; exists U',
         mem (ID, U') Needed
MU : select (ID1, unknown) KRest Needed
MU1 : makeUsed KRest Rest KOut *
M : mem (ID, U) KOut
============================
 exists U', mem (ID, U') Needed
</pre>
<pre class="code extensibella"id="800">
 &lt; <b>M': apply IH to MU1 M.</b>

Subgoal 3.2:

Variables: Needed ID U KRest KOut ID1 Rest U'
IH : forall Needed Prf Updated ID U,
       makeUsed Needed Prf Updated * -&gt; mem (ID, U) Updated -&gt; exists U',
         mem (ID, U') Needed
MU : select (ID1, unknown) KRest Needed
MU1 : makeUsed KRest Rest KOut *
M : mem (ID, U) KOut
M' : mem (ID, U') KRest
============================
 exists U', mem (ID, U') Needed
</pre>
<pre class="code extensibella"id="801">
 &lt; <b>apply mem_after_select_before to MU M'.</b>

Subgoal 3.2:

Variables: Needed ID U KRest KOut ID1 Rest U'
IH : forall Needed Prf Updated ID U,
       makeUsed Needed Prf Updated * -&gt; mem (ID, U) Updated -&gt; exists U',
         mem (ID, U') Needed
MU : select (ID1, unknown) KRest Needed
MU1 : makeUsed KRest Rest KOut *
M : mem (ID, U) KOut
M' : mem (ID, U') KRest
H1 : mem (ID, U') Needed
============================
 exists U', mem (ID, U') Needed
</pre>
<pre class="code extensibella"id="802">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="803">
 &lt; <b>Theorem makeUsed_good_used_list :
     forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated -&gt; good_used_list Updated.</b>

============================
 forall Needed Prf Updated,
   good_used_list Needed -&gt; makeUsed Needed Prf Updated -&gt; good_used_list Updated
</pre>
<pre class="code extensibella"id="804">
 &lt; <b>induction on 2.</b>

IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
============================
 forall Needed Prf Updated,
   good_used_list Needed -&gt; makeUsed Needed Prf Updated @ -&gt; good_used_list Updated
</pre>
<pre class="code extensibella"id="805">
 &lt; <b>intros GUL MU.</b>

Variables: Needed Prf Updated
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : makeUsed Needed Prf Updated @
============================
 good_used_list Updated
</pre>
<pre class="code extensibella"id="806">
 &lt; <b>MU: case MU.</b>

Subgoal 1:

Variables: Updated
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Updated
============================
 good_used_list Updated
</pre>
<pre class="code extensibella"id="807">
 &lt; <b>search.</b>

Subgoal 2:

Variables: Needed KRest KOut ID Rest
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, needed) KRest Needed
MU1 : makeUsed KRest Rest KOut *
============================
 good_used_list ((ID, needed)::KOut)
</pre>
<pre class="code extensibella"id="808">
 &lt; <b>GUL': apply good_used_list_select to GUL MU.</b>

Subgoal 2:

Variables: Needed KRest KOut ID Rest
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, needed) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
============================
 good_used_list ((ID, needed)::KOut)
</pre>
<pre class="code extensibella"id="809">
 &lt; <b>GUL'': apply IH to _ MU1.</b>

Subgoal 2:

Variables: Needed KRest KOut ID Rest
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, needed) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
============================
 good_used_list ((ID, needed)::KOut)
</pre>
<pre class="code extensibella"id="810">
 &lt; <b>unfold .</b>

Subgoal 2:

Variables: Needed KRest KOut ID Rest
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, needed) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
============================
 forall ID1 U1 CURest U2,
   select (ID1, U1) CURest ((ID, needed)::KOut) -&gt; mem (ID1, U2) CURest -&gt; false
</pre>
<pre class="code extensibella"id="811">
 &lt; <b>intros S M.</b>

Subgoal 2:

Variables: Needed KRest KOut ID Rest ID1 U1 CURest U2
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, needed) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
S : select (ID1, U1) CURest ((ID, needed)::KOut)
M : mem (ID1, U2) CURest
============================
 false
</pre>
<pre class="code extensibella"id="812">
 &lt; <b>S: case S.</b>

Subgoal 2.1:

Variables: Needed KRest KOut ID Rest U2
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, needed) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
M : mem (ID, U2) KOut
============================
 false
</pre>
<pre class="code extensibella"id="813">
 &lt; <b>M': apply makeUsed_member to MU1 M.</b>

Subgoal 2.1:

Variables: Needed KRest KOut ID Rest U2 U'
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, needed) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
M : mem (ID, U2) KOut
M' : mem (ID, U') KRest
============================
 false
</pre>
<pre class="code extensibella"id="814">
 &lt; <b>GUL: case GUL.</b>

Subgoal 2.1:

Variables: Needed KRest KOut ID Rest U2 U'
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
MU : select (ID, needed) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
M : mem (ID, U2) KOut
M' : mem (ID, U') KRest
GUL : forall ID U1 CURest U2,
        select (ID, U1) CURest Needed -&gt; mem (ID, U2) CURest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="815">
 &lt; <b>apply GUL to MU M'.</b>

Subgoal 2.2:

Variables: Needed KRest KOut ID Rest ID1 U1 U2 L1
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, needed) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
M : mem (ID1, U2) ((ID, needed)::L1)
S : select (ID1, U1) L1 KOut
============================
 false
</pre>
<pre class="code extensibella"id="816">
 &lt; <b>M: case M.</b>

Subgoal 2.2.1:

Variables: Needed KRest KOut ID Rest U1 L1
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, needed) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
S : select (ID, U1) L1 KOut
============================
 false
</pre>
<pre class="code extensibella"id="817">
 &lt; <b>M': apply select_mem to S.</b>

Subgoal 2.2.1:

Variables: Needed KRest KOut ID Rest U1 L1
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, needed) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
S : select (ID, U1) L1 KOut
M' : mem (ID, U1) KOut
============================
 false
</pre>
<pre class="code extensibella"id="818">
 &lt; <b>M'': apply makeUsed_member to MU1 M'.</b>

Subgoal 2.2.1:

Variables: Needed KRest KOut ID Rest U1 L1 U'
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, needed) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
S : select (ID, U1) L1 KOut
M' : mem (ID, U1) KOut
M'' : mem (ID, U') KRest
============================
 false
</pre>
<pre class="code extensibella"id="819">
 &lt; <b>GUL: case GUL.</b>

Subgoal 2.2.1:

Variables: Needed KRest KOut ID Rest U1 L1 U'
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
MU : select (ID, needed) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
S : select (ID, U1) L1 KOut
M' : mem (ID, U1) KOut
M'' : mem (ID, U') KRest
GUL : forall ID U1 CURest U2,
        select (ID, U1) CURest Needed -&gt; mem (ID, U2) CURest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="820">
 &lt; <b>apply GUL to MU M''.</b>

Subgoal 2.2.2:

Variables: Needed KRest KOut ID Rest ID1 U1 U2 L1
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, needed) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
S : select (ID1, U1) L1 KOut
M : mem (ID1, U2) L1
============================
 false
</pre>
<pre class="code extensibella"id="821">
 &lt; <b>GUL_Sub: apply IH to _ MU1.</b>

Subgoal 2.2.2:

Variables: Needed KRest KOut ID Rest ID1 U1 U2 L1
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, needed) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
S : select (ID1, U1) L1 KOut
M : mem (ID1, U2) L1
GUL_Sub : good_used_list KOut
============================
 false
</pre>
<pre class="code extensibella"id="822">
 &lt; <b>GUL_Sub: case GUL_Sub.</b>

Subgoal 2.2.2:

Variables: Needed KRest KOut ID Rest ID1 U1 U2 L1
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, needed) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
S : select (ID1, U1) L1 KOut
M : mem (ID1, U2) L1
GUL_Sub : forall ID U1 CURest U2,
            select (ID, U1) CURest KOut -&gt; mem (ID, U2) CURest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="823">
 &lt; <b>backchain GUL_Sub.</b>

Subgoal 3:

Variables: Needed KRest KOut ID Rest
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, unknown) KRest Needed
MU1 : makeUsed KRest Rest KOut *
============================
 good_used_list ((ID, needed)::KOut)
</pre>
<pre class="code extensibella"id="824">
 &lt; <b>GUL': apply good_used_list_select to GUL MU.</b>

Subgoal 3:

Variables: Needed KRest KOut ID Rest
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, unknown) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
============================
 good_used_list ((ID, needed)::KOut)
</pre>
<pre class="code extensibella"id="825">
 &lt; <b>GUL'': apply IH to _ MU1.</b>

Subgoal 3:

Variables: Needed KRest KOut ID Rest
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, unknown) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
============================
 good_used_list ((ID, needed)::KOut)
</pre>
<pre class="code extensibella"id="826">
 &lt; <b>unfold .</b>

Subgoal 3:

Variables: Needed KRest KOut ID Rest
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, unknown) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
============================
 forall ID1 U1 CURest U2,
   select (ID1, U1) CURest ((ID, needed)::KOut) -&gt; mem (ID1, U2) CURest -&gt; false
</pre>
<pre class="code extensibella"id="827">
 &lt; <b>intros S M.</b>

Subgoal 3:

Variables: Needed KRest KOut ID Rest ID1 U1 CURest U2
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, unknown) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
S : select (ID1, U1) CURest ((ID, needed)::KOut)
M : mem (ID1, U2) CURest
============================
 false
</pre>
<pre class="code extensibella"id="828">
 &lt; <b>S: case S.</b>

Subgoal 3.1:

Variables: Needed KRest KOut ID Rest U2
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, unknown) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
M : mem (ID, U2) KOut
============================
 false
</pre>
<pre class="code extensibella"id="829">
 &lt; <b>M': apply makeUsed_member to MU1 M.</b>

Subgoal 3.1:

Variables: Needed KRest KOut ID Rest U2 U'
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, unknown) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
M : mem (ID, U2) KOut
M' : mem (ID, U') KRest
============================
 false
</pre>
<pre class="code extensibella"id="830">
 &lt; <b>GUL: case GUL.</b>

Subgoal 3.1:

Variables: Needed KRest KOut ID Rest U2 U'
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
MU : select (ID, unknown) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
M : mem (ID, U2) KOut
M' : mem (ID, U') KRest
GUL : forall ID U1 CURest U2,
        select (ID, U1) CURest Needed -&gt; mem (ID, U2) CURest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="831">
 &lt; <b>apply GUL to MU M'.</b>

Subgoal 3.2:

Variables: Needed KRest KOut ID Rest ID1 U1 U2 L1
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, unknown) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
M : mem (ID1, U2) ((ID, needed)::L1)
S : select (ID1, U1) L1 KOut
============================
 false
</pre>
<pre class="code extensibella"id="832">
 &lt; <b>M: case M.</b>

Subgoal 3.2.1:

Variables: Needed KRest KOut ID Rest U1 L1
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, unknown) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
S : select (ID, U1) L1 KOut
============================
 false
</pre>
<pre class="code extensibella"id="833">
 &lt; <b>M': apply select_mem to S.</b>

Subgoal 3.2.1:

Variables: Needed KRest KOut ID Rest U1 L1
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, unknown) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
S : select (ID, U1) L1 KOut
M' : mem (ID, U1) KOut
============================
 false
</pre>
<pre class="code extensibella"id="834">
 &lt; <b>M'': apply makeUsed_member to MU1 M'.</b>

Subgoal 3.2.1:

Variables: Needed KRest KOut ID Rest U1 L1 U'
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, unknown) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
S : select (ID, U1) L1 KOut
M' : mem (ID, U1) KOut
M'' : mem (ID, U') KRest
============================
 false
</pre>
<pre class="code extensibella"id="835">
 &lt; <b>GUL: case GUL.</b>

Subgoal 3.2.1:

Variables: Needed KRest KOut ID Rest U1 L1 U'
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
MU : select (ID, unknown) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
S : select (ID, U1) L1 KOut
M' : mem (ID, U1) KOut
M'' : mem (ID, U') KRest
GUL : forall ID U1 CURest U2,
        select (ID, U1) CURest Needed -&gt; mem (ID, U2) CURest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="836">
 &lt; <b>apply GUL to MU M''.</b>

Subgoal 3.2.2:

Variables: Needed KRest KOut ID Rest ID1 U1 U2 L1
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, unknown) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
S : select (ID1, U1) L1 KOut
M : mem (ID1, U2) L1
============================
 false
</pre>
<pre class="code extensibella"id="837">
 &lt; <b>GUL_Sub: apply IH to _ MU1.</b>

Subgoal 3.2.2:

Variables: Needed KRest KOut ID Rest ID1 U1 U2 L1
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, unknown) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
S : select (ID1, U1) L1 KOut
M : mem (ID1, U2) L1
GUL_Sub : good_used_list KOut
============================
 false
</pre>
<pre class="code extensibella"id="838">
 &lt; <b>GUL_Sub: case GUL_Sub.</b>

Subgoal 3.2.2:

Variables: Needed KRest KOut ID Rest ID1 U1 U2 L1
IH : forall Needed Prf Updated,
       good_used_list Needed -&gt; makeUsed Needed Prf Updated * -&gt; good_used_list Updated
GUL : good_used_list Needed
MU : select (ID, unknown) KRest Needed
MU1 : makeUsed KRest Rest KOut *
GUL' : good_used_list KRest
GUL'' : good_used_list KOut
S : select (ID1, U1) L1 KOut
M : mem (ID1, U2) L1
GUL_Sub : forall ID U1 CURest U2,
            select (ID, U1) CURest KOut -&gt; mem (ID, U2) CURest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="839">
 &lt; <b>backchain GUL_Sub.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="840">
 &lt; <b>Theorem domain_is :
     forall L D,
       is_list (is_pair is_integer is_clause) L -&gt; domain L D -&gt; is_list is_integer D.</b>

============================
 forall L D,
   is_list (is_pair is_integer is_clause) L -&gt; domain L D -&gt; is_list is_integer D
</pre>
<pre class="code extensibella"id="841">
 &lt; <b>induction on 2.</b>

IH : forall L D,
       is_list (is_pair is_integer is_clause) L -&gt; domain L D * -&gt; is_list is_integer D
============================
 forall L D,
   is_list (is_pair is_integer is_clause) L -&gt; domain L D @ -&gt; is_list is_integer D
</pre>
<pre class="code extensibella"id="842">
 &lt; <b>intros Is D.</b>

Variables: L D
IH : forall L D,
       is_list (is_pair is_integer is_clause) L -&gt; domain L D * -&gt; is_list is_integer D
Is : is_list (is_pair is_integer is_clause) L
D : domain L D @
============================
 is_list is_integer D
</pre>
<pre class="code extensibella"id="843">
 &lt; <b>D: case D.</b>

Subgoal 1:

IH : forall L D,
       is_list (is_pair is_integer is_clause) L -&gt; domain L D * -&gt; is_list is_integer D
Is : is_list (is_pair is_integer is_clause) []
============================
 is_list is_integer []
</pre>
<pre class="code extensibella"id="844">
 &lt; <b>search.</b>

Subgoal 2:

Variables: DRest A Rest B
IH : forall L D,
       is_list (is_pair is_integer is_clause) L -&gt; domain L D * -&gt; is_list is_integer D
Is : is_list (is_pair is_integer is_clause) ((A, B)::Rest)
D : domain Rest DRest *
============================
 is_list is_integer (A::DRest)
</pre>
<pre class="code extensibella"id="845">
 &lt; <b>Is: case Is.</b>

Subgoal 2:

Variables: DRest A Rest B
IH : forall L D,
       is_list (is_pair is_integer is_clause) L -&gt; domain L D * -&gt; is_list is_integer D
D : domain Rest DRest *
Is : is_pair is_integer is_clause (A, B)
Is1 : is_list (is_pair is_integer is_clause) Rest
============================
 is_list is_integer (A::DRest)
</pre>
<pre class="code extensibella"id="846">
 &lt; <b>case Is.</b>

Subgoal 2:

Variables: DRest A Rest B
IH : forall L D,
       is_list (is_pair is_integer is_clause) L -&gt; domain L D * -&gt; is_list is_integer D
D : domain Rest DRest *
Is1 : is_list (is_pair is_integer is_clause) Rest
H1 : is_integer A
H2 : is_clause B
============================
 is_list is_integer (A::DRest)
</pre>
<pre class="code extensibella"id="847">
 &lt; <b>apply IH to _ D.</b>

Subgoal 2:

Variables: DRest A Rest B
IH : forall L D,
       is_list (is_pair is_integer is_clause) L -&gt; domain L D * -&gt; is_list is_integer D
D : domain Rest DRest *
Is1 : is_list (is_pair is_integer is_clause) Rest
H1 : is_integer A
H2 : is_clause B
H3 : is_list is_integer DRest
============================
 is_list is_integer (A::DRest)
</pre>
<pre class="code extensibella"id="848">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="849">
 &lt; <b>Extensible_Theorem
      endKnownClauses_related : forall Known FC CU DK DCU,
         IsFC : is_finalClauses FC -&gt;
         IsKnown : is_list (is_pair is_integer is_clause) Known -&gt;
         CFC : checkFinalClauses Known FC -&gt;
         EKC : endKnownClauses FC CU -&gt;
         DmnCU : domain CU DCU -&gt;
         DmnK : domain Known DK -&gt;
         permutation DCU DK
      on EKC.</b>

Subgoal 1:

Variables: Known DK DCU
IH : forall Known FC CU DK DCU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; checkFinalClauses Known FC -&gt;
       endKnownClauses FC CU * -&gt; domain CU DCU -&gt; domain Known DK -&gt; permutation DCU DK
IsFC : is_finalClauses endFClause
IsKnown : is_list (is_pair is_integer is_clause) Known
CFC : checkFinalClauses Known endFClause
EKC : endKnownClauses endFClause [] @
DmnCU : domain [] DCU
DmnK : domain Known DK
============================
 permutation DCU DK
</pre>
<pre class="code extensibella"id="850">
 &lt; <b>CFC: case CFC.</b>

Subgoal 1:

Variables: DK DCU
IH : forall Known FC CU DK DCU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; checkFinalClauses Known FC -&gt;
       endKnownClauses FC CU * -&gt; domain CU DCU -&gt; domain Known DK -&gt; permutation DCU DK
IsFC : is_finalClauses endFClause
IsKnown : is_list (is_pair is_integer is_clause) []
EKC : endKnownClauses endFClause [] @
DmnCU : domain [] DCU
DmnK : domain [] DK
============================
 permutation DCU DK
</pre>
<pre class="code extensibella"id="851">
 &lt; <b>case DmnCU.</b>

Subgoal 1:

Variables: DK
IH : forall Known FC CU DK DCU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; checkFinalClauses Known FC -&gt;
       endKnownClauses FC CU * -&gt; domain CU DCU -&gt; domain Known DK -&gt; permutation DCU DK
IsFC : is_finalClauses endFClause
IsKnown : is_list (is_pair is_integer is_clause) []
EKC : endKnownClauses endFClause [] @
DmnK : domain [] DK
============================
 permutation [] DK
</pre>
<pre class="code extensibella"id="852">
 &lt; <b>case DmnK.</b>

Subgoal 1:

IH : forall Known FC CU DK DCU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; checkFinalClauses Known FC -&gt;
       endKnownClauses FC CU * -&gt; domain CU DCU -&gt; domain Known DK -&gt; permutation DCU DK
IsFC : is_finalClauses endFClause
IsKnown : is_list (is_pair is_integer is_clause) []
EKC : endKnownClauses endFClause [] @
============================
 permutation [] []
</pre>
<pre class="code extensibella"id="853">
 &lt; <b>search.</b>

Subgoal 2:

Variables: Known DK DCU KRest ID Rest C
IH : forall Known FC CU DK DCU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; checkFinalClauses Known FC -&gt;
       endKnownClauses FC CU * -&gt; domain CU DCU -&gt; domain Known DK -&gt; permutation DCU DK
IsFC : is_finalClauses (addFClause ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
CFC : checkFinalClauses Known (addFClause ID C Rest)
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
DmnCU : domain ((ID, needed)::KRest) DCU
DmnK : domain Known DK
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
============================
 permutation DCU DK
</pre>
<pre class="code extensibella"id="854">
 &lt; <b>CFC: case CFC.</b>

Subgoal 2:

Variables: Known DK DCU KRest ID Rest C KRest1
IH : forall Known FC CU DK DCU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; checkFinalClauses Known FC -&gt;
       endKnownClauses FC CU * -&gt; domain CU DCU -&gt; domain Known DK -&gt; permutation DCU DK
IsFC : is_finalClauses (addFClause ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
DmnCU : domain ((ID, needed)::KRest) DCU
DmnK : domain Known DK
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
============================
 permutation DCU DK
</pre>
<pre class="code extensibella"id="855">
 &lt; <b>Is: case IsFC.</b>

Subgoal 2:

Variables: Known DK DCU KRest ID Rest C KRest1
IH : forall Known FC CU DK DCU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; checkFinalClauses Known FC -&gt;
       endKnownClauses FC CU * -&gt; domain CU DCU -&gt; domain Known DK -&gt; permutation DCU DK
IsKnown : is_list (is_pair is_integer is_clause) Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
DmnCU : domain ((ID, needed)::KRest) DCU
DmnK : domain Known DK
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_finalClauses Rest
============================
 permutation DCU DK
</pre>
<pre class="code extensibella"id="856">
 &lt; <b>DmnCU: case DmnCU.</b>

Subgoal 2:

Variables: Known DK KRest ID Rest C KRest1 DRest
IH : forall Known FC CU DK DCU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; checkFinalClauses Known FC -&gt;
       endKnownClauses FC CU * -&gt; domain CU DCU -&gt; domain Known DK -&gt; permutation DCU DK
IsKnown : is_list (is_pair is_integer is_clause) Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
DmnK : domain Known DK
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_finalClauses Rest
DmnCU : domain KRest DRest
============================
 permutation (ID::DRest) DK
</pre>
<pre class="code extensibella"id="857">
 &lt; <b>DmnK': apply domain_select to DmnK CFC.</b>

Subgoal 2:

Variables: Known DK KRest ID Rest C KRest1 DRest DRest1
IH : forall Known FC CU DK DCU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; checkFinalClauses Known FC -&gt;
       endKnownClauses FC CU * -&gt; domain CU DCU -&gt; domain Known DK -&gt; permutation DCU DK
IsKnown : is_list (is_pair is_integer is_clause) Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
DmnK : domain Known DK
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_finalClauses Rest
DmnCU : domain KRest DRest
DmnK' : select ID DRest1 DK
DmnK'1 : domain KRest1 DRest1
============================
 permutation (ID::DRest) DK
</pre>
<pre class="code extensibella"id="858">
 &lt; <b>IsKRest1: apply select_is to _ CFC.</b>

Subgoal 2:

Variables: Known DK KRest ID Rest C KRest1 DRest DRest1
IH : forall Known FC CU DK DCU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; checkFinalClauses Known FC -&gt;
       endKnownClauses FC CU * -&gt; domain CU DCU -&gt; domain Known DK -&gt; permutation DCU DK
IsKnown : is_list (is_pair is_integer is_clause) Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
DmnK : domain Known DK
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_finalClauses Rest
DmnCU : domain KRest DRest
DmnK' : select ID DRest1 DK
DmnK'1 : domain KRest1 DRest1
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
============================
 permutation (ID::DRest) DK
</pre>
<pre class="code extensibella"id="859">
 &lt; <b>P: apply IH to Is2 IsKRest1 CFC1 EKC2 DmnCU DmnK'1.</b>

Subgoal 2:

Variables: Known DK KRest ID Rest C KRest1 DRest DRest1
IH : forall Known FC CU DK DCU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; checkFinalClauses Known FC -&gt;
       endKnownClauses FC CU * -&gt; domain CU DCU -&gt; domain Known DK -&gt; permutation DCU DK
IsKnown : is_list (is_pair is_integer is_clause) Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
DmnK : domain Known DK
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_finalClauses Rest
DmnCU : domain KRest DRest
DmnK' : select ID DRest1 DK
DmnK'1 : domain KRest1 DRest1
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
P : permutation DRest DRest1
============================
 permutation (ID::DRest) DK
</pre>
<pre class="code extensibella"id="860">
 &lt; <b>IsDK: apply domain_is to _ DmnK.</b>

Subgoal 2:

Variables: Known DK KRest ID Rest C KRest1 DRest DRest1
IH : forall Known FC CU DK DCU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; checkFinalClauses Known FC -&gt;
       endKnownClauses FC CU * -&gt; domain CU DCU -&gt; domain Known DK -&gt; permutation DCU DK
IsKnown : is_list (is_pair is_integer is_clause) Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
DmnK : domain Known DK
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_finalClauses Rest
DmnCU : domain KRest DRest
DmnK' : select ID DRest1 DK
DmnK'1 : domain KRest1 DRest1
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
P : permutation DRest DRest1
IsDK : is_list is_integer DK
============================
 permutation (ID::DRest) DK
</pre>
<pre class="code extensibella"id="861">
 &lt; <b>search.</b>

Subgoal 3:

Variables: Known DK DCU KRest ID Rest C
IH : forall Known FC CU DK DCU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; checkFinalClauses Known FC -&gt;
       endKnownClauses FC CU * -&gt; domain CU DCU -&gt; domain Known DK -&gt; permutation DCU DK
IsFC : is_finalClauses (addFClause ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
CFC : checkFinalClauses Known (addFClause ID C Rest)
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
DmnCU : domain ((ID, unknown)::KRest) DCU
DmnK : domain Known DK
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
============================
 permutation DCU DK
</pre>
<pre class="code extensibella"id="862">
 &lt; <b>CFC: case CFC.</b>

Subgoal 3:

Variables: Known DK DCU KRest ID Rest C KRest1
IH : forall Known FC CU DK DCU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; checkFinalClauses Known FC -&gt;
       endKnownClauses FC CU * -&gt; domain CU DCU -&gt; domain Known DK -&gt; permutation DCU DK
IsFC : is_finalClauses (addFClause ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
DmnCU : domain ((ID, unknown)::KRest) DCU
DmnK : domain Known DK
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
============================
 permutation DCU DK
</pre>
<pre class="code extensibella"id="863">
 &lt; <b>Is: case IsFC.</b>

Subgoal 3:

Variables: Known DK DCU KRest ID Rest C KRest1
IH : forall Known FC CU DK DCU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; checkFinalClauses Known FC -&gt;
       endKnownClauses FC CU * -&gt; domain CU DCU -&gt; domain Known DK -&gt; permutation DCU DK
IsKnown : is_list (is_pair is_integer is_clause) Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
DmnCU : domain ((ID, unknown)::KRest) DCU
DmnK : domain Known DK
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_finalClauses Rest
============================
 permutation DCU DK
</pre>
<pre class="code extensibella"id="864">
 &lt; <b>DmnCU: case DmnCU.</b>

Subgoal 3:

Variables: Known DK KRest ID Rest C KRest1 DRest
IH : forall Known FC CU DK DCU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; checkFinalClauses Known FC -&gt;
       endKnownClauses FC CU * -&gt; domain CU DCU -&gt; domain Known DK -&gt; permutation DCU DK
IsKnown : is_list (is_pair is_integer is_clause) Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
DmnK : domain Known DK
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_finalClauses Rest
DmnCU : domain KRest DRest
============================
 permutation (ID::DRest) DK
</pre>
<pre class="code extensibella"id="865">
 &lt; <b>DmnK': apply domain_select to DmnK CFC.</b>

Subgoal 3:

Variables: Known DK KRest ID Rest C KRest1 DRest DRest1
IH : forall Known FC CU DK DCU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; checkFinalClauses Known FC -&gt;
       endKnownClauses FC CU * -&gt; domain CU DCU -&gt; domain Known DK -&gt; permutation DCU DK
IsKnown : is_list (is_pair is_integer is_clause) Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
DmnK : domain Known DK
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_finalClauses Rest
DmnCU : domain KRest DRest
DmnK' : select ID DRest1 DK
DmnK'1 : domain KRest1 DRest1
============================
 permutation (ID::DRest) DK
</pre>
<pre class="code extensibella"id="866">
 &lt; <b>IsKRest1: apply select_is to _ CFC.</b>

Subgoal 3:

Variables: Known DK KRest ID Rest C KRest1 DRest DRest1
IH : forall Known FC CU DK DCU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; checkFinalClauses Known FC -&gt;
       endKnownClauses FC CU * -&gt; domain CU DCU -&gt; domain Known DK -&gt; permutation DCU DK
IsKnown : is_list (is_pair is_integer is_clause) Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
DmnK : domain Known DK
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_finalClauses Rest
DmnCU : domain KRest DRest
DmnK' : select ID DRest1 DK
DmnK'1 : domain KRest1 DRest1
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
============================
 permutation (ID::DRest) DK
</pre>
<pre class="code extensibella"id="867">
 &lt; <b>P: apply IH to Is2 IsKRest1 CFC1 EKC2 DmnCU DmnK'1.</b>

Subgoal 3:

Variables: Known DK KRest ID Rest C KRest1 DRest DRest1
IH : forall Known FC CU DK DCU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; checkFinalClauses Known FC -&gt;
       endKnownClauses FC CU * -&gt; domain CU DCU -&gt; domain Known DK -&gt; permutation DCU DK
IsKnown : is_list (is_pair is_integer is_clause) Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
DmnK : domain Known DK
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_finalClauses Rest
DmnCU : domain KRest DRest
DmnK' : select ID DRest1 DK
DmnK'1 : domain KRest1 DRest1
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
P : permutation DRest DRest1
============================
 permutation (ID::DRest) DK
</pre>
<pre class="code extensibella"id="868">
 &lt; <b>IsDK: apply domain_is to _ DmnK.</b>

Subgoal 3:

Variables: Known DK KRest ID Rest C KRest1 DRest DRest1
IH : forall Known FC CU DK DCU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; checkFinalClauses Known FC -&gt;
       endKnownClauses FC CU * -&gt; domain CU DCU -&gt; domain Known DK -&gt; permutation DCU DK
IsKnown : is_list (is_pair is_integer is_clause) Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
DmnK : domain Known DK
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_integer ID
Is1 : is_clause C
Is2 : is_finalClauses Rest
DmnCU : domain KRest DRest
DmnK' : select ID DRest1 DK
DmnK'1 : domain KRest1 DRest1
IsKRest1 : is_list (is_pair is_integer is_clause) KRest1
P : permutation DRest DRest1
IsDK : is_list is_integer DK
============================
 permutation (ID::DRest) DK
</pre>
<pre class="code extensibella"id="869">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="870">
 &lt; <b>Theorem mem_is_clauseUsedness :
     forall CU IDC,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; mem IDC CU -&gt; exists ID C,
         (IDC = (ID, C) /\ is_integer ID) /\ is_clauseUsedness C.</b>

============================
 forall CU IDC,
   is_list (is_pair is_integer is_clauseUsedness) CU -&gt; mem IDC CU -&gt; exists ID C,
     (IDC = (ID, C) /\ is_integer ID) /\ is_clauseUsedness C
</pre>
<pre class="code extensibella"id="871">
 &lt; <b>induction on 2.</b>

IH : forall CU IDC,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; mem IDC CU * -&gt; exists ID C,
         (IDC = (ID, C) /\ is_integer ID) /\ is_clauseUsedness C
============================
 forall CU IDC,
   is_list (is_pair is_integer is_clauseUsedness) CU -&gt; mem IDC CU @ -&gt; exists ID C,
     (IDC = (ID, C) /\ is_integer ID) /\ is_clauseUsedness C
</pre>
<pre class="code extensibella"id="872">
 &lt; <b>intros Is Mem.</b>

Variables: CU IDC
IH : forall CU IDC,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; mem IDC CU * -&gt; exists ID C,
         (IDC = (ID, C) /\ is_integer ID) /\ is_clauseUsedness C
Is : is_list (is_pair is_integer is_clauseUsedness) CU
Mem : mem IDC CU @
============================
 exists ID C, (IDC = (ID, C) /\ is_integer ID) /\ is_clauseUsedness C
</pre>
<pre class="code extensibella"id="873">
 &lt; <b>Mem: case Mem.</b>

Subgoal 1:

Variables: IDC Rest
IH : forall CU IDC,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; mem IDC CU * -&gt; exists ID C,
         (IDC = (ID, C) /\ is_integer ID) /\ is_clauseUsedness C
Is : is_list (is_pair is_integer is_clauseUsedness) (IDC::Rest)
============================
 exists ID C, (IDC = (ID, C) /\ is_integer ID) /\ is_clauseUsedness C
</pre>
<pre class="code extensibella"id="874">
 &lt; <b>Is: case Is.</b>

Subgoal 1:

Variables: IDC Rest
IH : forall CU IDC,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; mem IDC CU * -&gt; exists ID C,
         (IDC = (ID, C) /\ is_integer ID) /\ is_clauseUsedness C
Is : is_pair is_integer is_clauseUsedness IDC
Is1 : is_list (is_pair is_integer is_clauseUsedness) Rest
============================
 exists ID C, (IDC = (ID, C) /\ is_integer ID) /\ is_clauseUsedness C
</pre>
<pre class="code extensibella"id="875">
 &lt; <b>case Is.</b>

Subgoal 1:

Variables: Rest B A
IH : forall CU IDC,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; mem IDC CU * -&gt; exists ID C,
         (IDC = (ID, C) /\ is_integer ID) /\ is_clauseUsedness C
Is1 : is_list (is_pair is_integer is_clauseUsedness) Rest
H1 : is_integer A
H2 : is_clauseUsedness B
============================
 exists ID C, ((A, B) = (ID, C) /\ is_integer ID) /\ is_clauseUsedness C
</pre>
<pre class="code extensibella"id="876">
 &lt; <b>search.</b>

Subgoal 2:

Variables: IDC Rest I
IH : forall CU IDC,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; mem IDC CU * -&gt; exists ID C,
         (IDC = (ID, C) /\ is_integer ID) /\ is_clauseUsedness C
Is : is_list (is_pair is_integer is_clauseUsedness) (I::Rest)
Mem : mem IDC Rest *
============================
 exists ID C, (IDC = (ID, C) /\ is_integer ID) /\ is_clauseUsedness C
</pre>
<pre class="code extensibella"id="877">
 &lt; <b>Is: case Is.</b>

Subgoal 2:

Variables: IDC Rest I
IH : forall CU IDC,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; mem IDC CU * -&gt; exists ID C,
         (IDC = (ID, C) /\ is_integer ID) /\ is_clauseUsedness C
Mem : mem IDC Rest *
Is : is_pair is_integer is_clauseUsedness I
Is1 : is_list (is_pair is_integer is_clauseUsedness) Rest
============================
 exists ID C, (IDC = (ID, C) /\ is_integer ID) /\ is_clauseUsedness C
</pre>
<pre class="code extensibella"id="878">
 &lt; <b>apply IH to _ Mem.</b>

Subgoal 2:

Variables: Rest I ID C
IH : forall CU IDC,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; mem IDC CU * -&gt; exists ID C,
         (IDC = (ID, C) /\ is_integer ID) /\ is_clauseUsedness C
Mem : mem (ID, C) Rest *
Is : is_pair is_integer is_clauseUsedness I
Is1 : is_list (is_pair is_integer is_clauseUsedness) Rest
H1 : is_integer ID
H2 : is_clauseUsedness C
============================
 exists ID1 C1, ((ID, C) = (ID1, C1) /\ is_integer ID1) /\ is_clauseUsedness C1
</pre>
<pre class="code extensibella"id="879">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="880">
 &lt; <b>Theorem makeUsed_subset :
     forall CU Prf CU' ID,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; is_integer ID -&gt; makeUsed CU Prf CU' -&gt;
       mem (ID, needed) CU -&gt; mem (ID, needed) CU'.</b>

============================
 forall CU Prf CU' ID,
   is_list (is_pair is_integer is_clauseUsedness) CU -&gt; is_integer ID -&gt; makeUsed CU Prf CU' -&gt;
   mem (ID, needed) CU -&gt; mem (ID, needed) CU'
</pre>
<pre class="code extensibella"id="881">
 &lt; <b>induction on 3.</b>

IH : forall CU Prf CU' ID,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; is_integer ID -&gt; makeUsed CU Prf CU' * -&gt;
       mem (ID, needed) CU -&gt; mem (ID, needed) CU'
============================
 forall CU Prf CU' ID,
   is_list (is_pair is_integer is_clauseUsedness) CU -&gt; is_integer ID -&gt; makeUsed CU Prf CU' @ -&gt;
   mem (ID, needed) CU -&gt; mem (ID, needed) CU'
</pre>
<pre class="code extensibella"id="882">
 &lt; <b>intros IsCU IsID MU Mem.</b>

Variables: CU Prf CU' ID
IH : forall CU Prf CU' ID,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; is_integer ID -&gt; makeUsed CU Prf CU' * -&gt;
       mem (ID, needed) CU -&gt; mem (ID, needed) CU'
IsCU : is_list (is_pair is_integer is_clauseUsedness) CU
IsID : is_integer ID
MU : makeUsed CU Prf CU' @
Mem : mem (ID, needed) CU
============================
 mem (ID, needed) CU'
</pre>
<pre class="code extensibella"id="883">
 &lt; <b>MU: case MU.</b>

Subgoal 1:

Variables: CU' ID
IH : forall CU Prf CU' ID,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; is_integer ID -&gt; makeUsed CU Prf CU' * -&gt;
       mem (ID, needed) CU -&gt; mem (ID, needed) CU'
IsCU : is_list (is_pair is_integer is_clauseUsedness) CU'
IsID : is_integer ID
Mem : mem (ID, needed) CU'
============================
 mem (ID, needed) CU'
</pre>
<pre class="code extensibella"id="884">
 &lt; <b>search.</b>

Subgoal 2:

Variables: CU ID KRest KOut ID1 Rest
IH : forall CU Prf CU' ID,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; is_integer ID -&gt; makeUsed CU Prf CU' * -&gt;
       mem (ID, needed) CU -&gt; mem (ID, needed) CU'
IsCU : is_list (is_pair is_integer is_clauseUsedness) CU
IsID : is_integer ID
Mem : mem (ID, needed) CU
MU : select (ID1, needed) KRest CU
MU1 : makeUsed KRest Rest KOut *
============================
 mem (ID, needed) ((ID1, needed)::KOut)
</pre>
<pre class="code extensibella"id="885">
 &lt; <b>MemCU: apply select_mem to MU.</b>

Subgoal 2:

Variables: CU ID KRest KOut ID1 Rest
IH : forall CU Prf CU' ID,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; is_integer ID -&gt; makeUsed CU Prf CU' * -&gt;
       mem (ID, needed) CU -&gt; mem (ID, needed) CU'
IsCU : is_list (is_pair is_integer is_clauseUsedness) CU
IsID : is_integer ID
Mem : mem (ID, needed) CU
MU : select (ID1, needed) KRest CU
MU1 : makeUsed KRest Rest KOut *
MemCU : mem (ID1, needed) CU
============================
 mem (ID, needed) ((ID1, needed)::KOut)
</pre>
<pre class="code extensibella"id="886">
 &lt; <b>Is: apply mem_is_clauseUsedness to _ MemCU.</b>

Subgoal 2:

Variables: CU ID KRest KOut Rest ID2
IH : forall CU Prf CU' ID,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; is_integer ID -&gt; makeUsed CU Prf CU' * -&gt;
       mem (ID, needed) CU -&gt; mem (ID, needed) CU'
IsCU : is_list (is_pair is_integer is_clauseUsedness) CU
IsID : is_integer ID
Mem : mem (ID, needed) CU
MU : select (ID2, needed) KRest CU
MU1 : makeUsed KRest Rest KOut *
MemCU : mem (ID2, needed) CU
Is : is_integer ID2
Is1 : is_clauseUsedness needed
============================
 mem (ID, needed) ((ID2, needed)::KOut)
</pre>
<pre class="code extensibella"id="887">
 &lt; <b>Or: apply is_integer_eq_or_not to Is IsID.</b>

Subgoal 2:

Variables: CU ID KRest KOut Rest ID2
IH : forall CU Prf CU' ID,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; is_integer ID -&gt; makeUsed CU Prf CU' * -&gt;
       mem (ID, needed) CU -&gt; mem (ID, needed) CU'
IsCU : is_list (is_pair is_integer is_clauseUsedness) CU
IsID : is_integer ID
Mem : mem (ID, needed) CU
MU : select (ID2, needed) KRest CU
MU1 : makeUsed KRest Rest KOut *
MemCU : mem (ID2, needed) CU
Is : is_integer ID2
Is1 : is_clauseUsedness needed
Or : ID2 = ID \/ (ID2 = ID -&gt; false)
============================
 mem (ID, needed) ((ID2, needed)::KOut)
</pre>
<pre class="code extensibella"id="888">
 &lt; <b>E: case Or.</b>

Subgoal 2.1:

Variables: CU ID KRest KOut Rest
IH : forall CU Prf CU' ID,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; is_integer ID -&gt; makeUsed CU Prf CU' * -&gt;
       mem (ID, needed) CU -&gt; mem (ID, needed) CU'
IsCU : is_list (is_pair is_integer is_clauseUsedness) CU
IsID : is_integer ID
Mem : mem (ID, needed) CU
MU : select (ID, needed) KRest CU
MU1 : makeUsed KRest Rest KOut *
MemCU : mem (ID, needed) CU
Is : is_integer ID
Is1 : is_clauseUsedness needed
============================
 mem (ID, needed) ((ID, needed)::KOut)
</pre>
<pre class="code extensibella"id="889">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: CU ID KRest KOut Rest ID2
IH : forall CU Prf CU' ID,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; is_integer ID -&gt; makeUsed CU Prf CU' * -&gt;
       mem (ID, needed) CU -&gt; mem (ID, needed) CU'
IsCU : is_list (is_pair is_integer is_clauseUsedness) CU
IsID : is_integer ID
Mem : mem (ID, needed) CU
MU : select (ID2, needed) KRest CU
MU1 : makeUsed KRest Rest KOut *
MemCU : mem (ID2, needed) CU
Is : is_integer ID2
Is1 : is_clauseUsedness needed
E : ID2 = ID -&gt; false
============================
 mem (ID, needed) ((ID2, needed)::KOut)
</pre>
<pre class="code extensibella"id="890">
 &lt; <b>NEq: assert (ID2, needed) = (ID, needed) -&gt; false.</b>

Subgoal 2.2.1:

Variables: CU ID KRest KOut Rest ID2
IH : forall CU Prf CU' ID,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; is_integer ID -&gt; makeUsed CU Prf CU' * -&gt;
       mem (ID, needed) CU -&gt; mem (ID, needed) CU'
IsCU : is_list (is_pair is_integer is_clauseUsedness) CU
IsID : is_integer ID
Mem : mem (ID, needed) CU
MU : select (ID2, needed) KRest CU
MU1 : makeUsed KRest Rest KOut *
MemCU : mem (ID2, needed) CU
Is : is_integer ID2
Is1 : is_clauseUsedness needed
E : ID2 = ID -&gt; false
============================
 (ID2, needed) = (ID, needed) -&gt; false
</pre>
<pre class="code extensibella"id="891">
 &lt; <b>intros Eq.</b>

Subgoal 2.2.1:

Variables: CU ID KRest KOut Rest ID2
IH : forall CU Prf CU' ID,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; is_integer ID -&gt; makeUsed CU Prf CU' * -&gt;
       mem (ID, needed) CU -&gt; mem (ID, needed) CU'
IsCU : is_list (is_pair is_integer is_clauseUsedness) CU
IsID : is_integer ID
Mem : mem (ID, needed) CU
MU : select (ID2, needed) KRest CU
MU1 : makeUsed KRest Rest KOut *
MemCU : mem (ID2, needed) CU
Is : is_integer ID2
Is1 : is_clauseUsedness needed
E : ID2 = ID -&gt; false
Eq : (ID2, needed) = (ID, needed)
============================
 false
</pre>
<pre class="code extensibella"id="892">
 &lt; <b>case Eq.</b>

Subgoal 2.2.1:

Variables: CU ID KRest KOut Rest
IH : forall CU Prf CU' ID,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; is_integer ID -&gt; makeUsed CU Prf CU' * -&gt;
       mem (ID, needed) CU -&gt; mem (ID, needed) CU'
IsCU : is_list (is_pair is_integer is_clauseUsedness) CU
IsID : is_integer ID
Mem : mem (ID, needed) CU
MU : select (ID, needed) KRest CU
MU1 : makeUsed KRest Rest KOut *
MemCU : mem (ID, needed) CU
Is : is_integer ID
Is1 : is_clauseUsedness needed
E : ID = ID -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="893">
 &lt; <b>backchain E.</b>

Subgoal 2.2:

Variables: CU ID KRest KOut Rest ID2
IH : forall CU Prf CU' ID,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; is_integer ID -&gt; makeUsed CU Prf CU' * -&gt;
       mem (ID, needed) CU -&gt; mem (ID, needed) CU'
IsCU : is_list (is_pair is_integer is_clauseUsedness) CU
IsID : is_integer ID
Mem : mem (ID, needed) CU
MU : select (ID2, needed) KRest CU
MU1 : makeUsed KRest Rest KOut *
MemCU : mem (ID2, needed) CU
Is : is_integer ID2
Is1 : is_clauseUsedness needed
E : ID2 = ID -&gt; false
NEq : (ID2, needed) = (ID, needed) -&gt; false
============================
 mem (ID, needed) ((ID2, needed)::KOut)
</pre>
<pre class="code extensibella"id="894">
 &lt; <b>MemKRest: apply mem_before_select_after to MU Mem _.</b>

Subgoal 2.2:

Variables: CU ID KRest KOut Rest ID2
IH : forall CU Prf CU' ID,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; is_integer ID -&gt; makeUsed CU Prf CU' * -&gt;
       mem (ID, needed) CU -&gt; mem (ID, needed) CU'
IsCU : is_list (is_pair is_integer is_clauseUsedness) CU
IsID : is_integer ID
Mem : mem (ID, needed) CU
MU : select (ID2, needed) KRest CU
MU1 : makeUsed KRest Rest KOut *
MemCU : mem (ID2, needed) CU
Is : is_integer ID2
Is1 : is_clauseUsedness needed
E : ID2 = ID -&gt; false
NEq : (ID2, needed) = (ID, needed) -&gt; false
MemKRest : mem (ID, needed) KRest
============================
 mem (ID, needed) ((ID2, needed)::KOut)
</pre>
<pre class="code extensibella"id="895">
 &lt; <b>apply select_is_clauseUsedness to _ MU.</b>

Subgoal 2.2:

Variables: CU ID KRest KOut Rest ID2
IH : forall CU Prf CU' ID,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; is_integer ID -&gt; makeUsed CU Prf CU' * -&gt;
       mem (ID, needed) CU -&gt; mem (ID, needed) CU'
IsCU : is_list (is_pair is_integer is_clauseUsedness) CU
IsID : is_integer ID
Mem : mem (ID, needed) CU
MU : select (ID2, needed) KRest CU
MU1 : makeUsed KRest Rest KOut *
MemCU : mem (ID2, needed) CU
Is : is_integer ID2
Is1 : is_clauseUsedness needed
E : ID2 = ID -&gt; false
NEq : (ID2, needed) = (ID, needed) -&gt; false
MemKRest : mem (ID, needed) KRest
H1 : is_list (is_pair is_integer is_clauseUsedness) KRest
============================
 mem (ID, needed) ((ID2, needed)::KOut)
</pre>
<pre class="code extensibella"id="896">
 &lt; <b>apply IH to _ IsID MU1 MemKRest.</b>

Subgoal 2.2:

Variables: CU ID KRest KOut Rest ID2
IH : forall CU Prf CU' ID,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; is_integer ID -&gt; makeUsed CU Prf CU' * -&gt;
       mem (ID, needed) CU -&gt; mem (ID, needed) CU'
IsCU : is_list (is_pair is_integer is_clauseUsedness) CU
IsID : is_integer ID
Mem : mem (ID, needed) CU
MU : select (ID2, needed) KRest CU
MU1 : makeUsed KRest Rest KOut *
MemCU : mem (ID2, needed) CU
Is : is_integer ID2
Is1 : is_clauseUsedness needed
E : ID2 = ID -&gt; false
NEq : (ID2, needed) = (ID, needed) -&gt; false
MemKRest : mem (ID, needed) KRest
H1 : is_list (is_pair is_integer is_clauseUsedness) KRest
H2 : mem (ID, needed) KOut
============================
 mem (ID, needed) ((ID2, needed)::KOut)
</pre>
<pre class="code extensibella"id="897">
 &lt; <b>search.</b>

Subgoal 3:

Variables: CU ID KRest KOut ID1 Rest
IH : forall CU Prf CU' ID,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; is_integer ID -&gt; makeUsed CU Prf CU' * -&gt;
       mem (ID, needed) CU -&gt; mem (ID, needed) CU'
IsCU : is_list (is_pair is_integer is_clauseUsedness) CU
IsID : is_integer ID
Mem : mem (ID, needed) CU
MU : select (ID1, unknown) KRest CU
MU1 : makeUsed KRest Rest KOut *
============================
 mem (ID, needed) ((ID1, needed)::KOut)
</pre>
<pre class="code extensibella"id="898">
 &lt; <b>apply select_is_clauseUsedness to _ MU.</b>

Subgoal 3:

Variables: CU ID KRest KOut ID1 Rest
IH : forall CU Prf CU' ID,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; is_integer ID -&gt; makeUsed CU Prf CU' * -&gt;
       mem (ID, needed) CU -&gt; mem (ID, needed) CU'
IsCU : is_list (is_pair is_integer is_clauseUsedness) CU
IsID : is_integer ID
Mem : mem (ID, needed) CU
MU : select (ID1, unknown) KRest CU
MU1 : makeUsed KRest Rest KOut *
H1 : is_list (is_pair is_integer is_clauseUsedness) KRest
============================
 mem (ID, needed) ((ID1, needed)::KOut)
</pre>
<pre class="code extensibella"id="899">
 &lt; <b>apply mem_before_select_after to MU Mem _.</b>

Subgoal 3:

Variables: CU ID KRest KOut ID1 Rest
IH : forall CU Prf CU' ID,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; is_integer ID -&gt; makeUsed CU Prf CU' * -&gt;
       mem (ID, needed) CU -&gt; mem (ID, needed) CU'
IsCU : is_list (is_pair is_integer is_clauseUsedness) CU
IsID : is_integer ID
Mem : mem (ID, needed) CU
MU : select (ID1, unknown) KRest CU
MU1 : makeUsed KRest Rest KOut *
H1 : is_list (is_pair is_integer is_clauseUsedness) KRest
H2 : mem (ID, needed) KRest
============================
 mem (ID, needed) ((ID1, needed)::KOut)
</pre>
<pre class="code extensibella"id="900">
 &lt; <b>apply IH to _ IsID MU1 _.</b>

Subgoal 3:

Variables: CU ID KRest KOut ID1 Rest
IH : forall CU Prf CU' ID,
       is_list (is_pair is_integer is_clauseUsedness) CU -&gt; is_integer ID -&gt; makeUsed CU Prf CU' * -&gt;
       mem (ID, needed) CU -&gt; mem (ID, needed) CU'
IsCU : is_list (is_pair is_integer is_clauseUsedness) CU
IsID : is_integer ID
Mem : mem (ID, needed) CU
MU : select (ID1, unknown) KRest CU
MU1 : makeUsed KRest Rest KOut *
H1 : is_list (is_pair is_integer is_clauseUsedness) KRest
H2 : mem (ID, needed) KRest
H3 : mem (ID, needed) KOut
============================
 mem (ID, needed) ((ID1, needed)::KOut)
</pre>
<pre class="code extensibella"id="901">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="902">
 &lt; <b>Extensible_Theorem
      clauseUsedness_is_needed_or_not : forall CU,
         Is : is_clauseUsedness CU -&gt;
         CU = needed \/
         (CU = needed -&gt; false)
      on Is.</b>

Subgoal 1:

IH : forall CU, is_clauseUsedness CU * -&gt; CU = needed \/ (CU = needed -&gt; false)
Is : is_clauseUsedness needed @
============================
 needed = needed \/ (needed = needed -&gt; false)
</pre>
<pre class="code extensibella"id="903">
 &lt; <b>search.</b>

Subgoal 2:

IH : forall CU, is_clauseUsedness CU * -&gt; CU = needed \/ (CU = needed -&gt; false)
Is : is_clauseUsedness unknown @
============================
 unknown = needed \/ (unknown = needed -&gt; false)
</pre>
<pre class="code extensibella"id="904">
 &lt; <b>right.</b>

Subgoal 2:

IH : forall CU, is_clauseUsedness CU * -&gt; CU = needed \/ (CU = needed -&gt; false)
Is : is_clauseUsedness unknown @
============================
 unknown = needed -&gt; false
</pre>
<pre class="code extensibella"id="905">
 &lt; <b>intros E.</b>

Subgoal 2:

IH : forall CU, is_clauseUsedness CU * -&gt; CU = needed \/ (CU = needed -&gt; false)
Is : is_clauseUsedness unknown @
E : unknown = needed
============================
 false
</pre>
<pre class="code extensibella"id="906">
 &lt; <b>case E.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="907">
 &lt; <b>Extensible_Theorem
      endKnownClauses_all_mem : forall Known FC CU ID U,
         CFC : checkFinalClauses Known FC -&gt;
         EKC : endKnownClauses FC CU -&gt;
         Mem : mem (ID, U) CU -&gt;
         exists C,
           mem (ID, C) Known
      on EKC.</b>

Subgoal 1:

Variables: Known ID U
IH : forall Known FC CU ID U,
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; mem (ID, U) CU -&gt;
       exists C, mem (ID, C) Known
CFC : checkFinalClauses Known endFClause
EKC : endKnownClauses endFClause [] @
Mem : mem (ID, U) []
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="908">
 &lt; <b>case Mem.</b>

Subgoal 2:

Variables: Known ID U KRest ID1 Rest C
IH : forall Known FC CU ID U,
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; mem (ID, U) CU -&gt;
       exists C, mem (ID, C) Known
CFC : checkFinalClauses Known (addFClause ID1 C Rest)
EKC : endKnownClauses (addFClause ID1 C Rest) ((ID1, needed)::KRest) @
Mem : mem (ID, U) ((ID1, needed)::KRest)
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="909">
 &lt; <b>Mem: case Mem.</b>

Subgoal 2.1:

Variables: Known KRest ID1 Rest C
IH : forall Known FC CU ID U,
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; mem (ID, U) CU -&gt;
       exists C, mem (ID, C) Known
CFC : checkFinalClauses Known (addFClause ID1 C Rest)
EKC : endKnownClauses (addFClause ID1 C Rest) ((ID1, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="910">
 &lt; <b>CFC: case CFC.</b>

Subgoal 2.1:

Variables: Known KRest ID1 Rest C KRest1
IH : forall Known FC CU ID U,
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; mem (ID, U) CU -&gt;
       exists C, mem (ID, C) Known
EKC : endKnownClauses (addFClause ID1 C Rest) ((ID1, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
CFC : select (ID1, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="911">
 &lt; <b>apply select_mem to CFC.</b>

Subgoal 2.1:

Variables: Known KRest ID1 Rest C KRest1
IH : forall Known FC CU ID U,
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; mem (ID, U) CU -&gt;
       exists C, mem (ID, C) Known
EKC : endKnownClauses (addFClause ID1 C Rest) ((ID1, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
CFC : select (ID1, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
H1 : mem (ID1, C) Known
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="912">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: Known ID U KRest ID1 Rest C
IH : forall Known FC CU ID U,
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; mem (ID, U) CU -&gt;
       exists C, mem (ID, C) Known
CFC : checkFinalClauses Known (addFClause ID1 C Rest)
EKC : endKnownClauses (addFClause ID1 C Rest) ((ID1, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
Mem : mem (ID, U) KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="913">
 &lt; <b>CFC: case CFC.</b>

Subgoal 2.2:

Variables: Known ID U KRest ID1 Rest C KRest1
IH : forall Known FC CU ID U,
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; mem (ID, U) CU -&gt;
       exists C, mem (ID, C) Known
EKC : endKnownClauses (addFClause ID1 C Rest) ((ID1, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
Mem : mem (ID, U) KRest
CFC : select (ID1, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="914">
 &lt; <b>M: apply IH to CFC1 EKC2 _.</b>

Subgoal 2.2:

Variables: Known ID U KRest ID1 Rest C KRest1 C1
IH : forall Known FC CU ID U,
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; mem (ID, U) CU -&gt;
       exists C, mem (ID, C) Known
EKC : endKnownClauses (addFClause ID1 C Rest) ((ID1, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
Mem : mem (ID, U) KRest
CFC : select (ID1, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
M : mem (ID, C1) KRest1
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="915">
 &lt; <b>apply mem_after_select_before to CFC M.</b>

Subgoal 2.2:

Variables: Known ID U KRest ID1 Rest C KRest1 C1
IH : forall Known FC CU ID U,
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; mem (ID, U) CU -&gt;
       exists C, mem (ID, C) Known
EKC : endKnownClauses (addFClause ID1 C Rest) ((ID1, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
Mem : mem (ID, U) KRest
CFC : select (ID1, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
M : mem (ID, C1) KRest1
H1 : mem (ID, C1) Known
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="916">
 &lt; <b>search.</b>

Subgoal 3:

Variables: Known ID U KRest ID1 Rest C
IH : forall Known FC CU ID U,
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; mem (ID, U) CU -&gt;
       exists C, mem (ID, C) Known
CFC : checkFinalClauses Known (addFClause ID1 C Rest)
EKC : endKnownClauses (addFClause ID1 C Rest) ((ID1, unknown)::KRest) @
Mem : mem (ID, U) ((ID1, unknown)::KRest)
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="917">
 &lt; <b>Mem: case Mem.</b>

Subgoal 3.1:

Variables: Known KRest ID1 Rest C
IH : forall Known FC CU ID U,
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; mem (ID, U) CU -&gt;
       exists C, mem (ID, C) Known
CFC : checkFinalClauses Known (addFClause ID1 C Rest)
EKC : endKnownClauses (addFClause ID1 C Rest) ((ID1, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="918">
 &lt; <b>CFC: case CFC.</b>

Subgoal 3.1:

Variables: Known KRest ID1 Rest C KRest1
IH : forall Known FC CU ID U,
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; mem (ID, U) CU -&gt;
       exists C, mem (ID, C) Known
EKC : endKnownClauses (addFClause ID1 C Rest) ((ID1, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
CFC : select (ID1, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="919">
 &lt; <b>apply select_mem to CFC.</b>

Subgoal 3.1:

Variables: Known KRest ID1 Rest C KRest1
IH : forall Known FC CU ID U,
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; mem (ID, U) CU -&gt;
       exists C, mem (ID, C) Known
EKC : endKnownClauses (addFClause ID1 C Rest) ((ID1, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
CFC : select (ID1, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
H1 : mem (ID1, C) Known
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="920">
 &lt; <b>search.</b>

Subgoal 3.2:

Variables: Known ID U KRest ID1 Rest C
IH : forall Known FC CU ID U,
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; mem (ID, U) CU -&gt;
       exists C, mem (ID, C) Known
CFC : checkFinalClauses Known (addFClause ID1 C Rest)
EKC : endKnownClauses (addFClause ID1 C Rest) ((ID1, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
Mem : mem (ID, U) KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="921">
 &lt; <b>CFC: case CFC.</b>

Subgoal 3.2:

Variables: Known ID U KRest ID1 Rest C KRest1
IH : forall Known FC CU ID U,
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; mem (ID, U) CU -&gt;
       exists C, mem (ID, C) Known
EKC : endKnownClauses (addFClause ID1 C Rest) ((ID1, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
Mem : mem (ID, U) KRest
CFC : select (ID1, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="922">
 &lt; <b>M: apply IH to CFC1 EKC2 _.</b>

Subgoal 3.2:

Variables: Known ID U KRest ID1 Rest C KRest1 C1
IH : forall Known FC CU ID U,
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; mem (ID, U) CU -&gt;
       exists C, mem (ID, C) Known
EKC : endKnownClauses (addFClause ID1 C Rest) ((ID1, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
Mem : mem (ID, U) KRest
CFC : select (ID1, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
M : mem (ID, C1) KRest1
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="923">
 &lt; <b>apply mem_after_select_before to CFC M.</b>

Subgoal 3.2:

Variables: Known ID U KRest ID1 Rest C KRest1 C1
IH : forall Known FC CU ID U,
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; mem (ID, U) CU -&gt;
       exists C, mem (ID, C) Known
EKC : endKnownClauses (addFClause ID1 C Rest) ((ID1, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
Mem : mem (ID, U) KRest
CFC : select (ID1, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
M : mem (ID, C1) KRest1
H1 : mem (ID, C1) Known
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="924">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="925">
 &lt; <b>Extensible_Theorem
      endKnownClauses_good_used_list : forall Known FC CU,
         IsFC : is_finalClauses FC -&gt;
         IsKnown : is_list (is_pair is_integer is_clause) Known -&gt;
         GCL : good_clause_list Known -&gt;
         CFC : checkFinalClauses Known FC -&gt;
         EKC : endKnownClauses FC CU -&gt;
         good_used_list CU
      on EKC.</b>

Subgoal 1:

Variables: Known
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsFC : is_finalClauses endFClause
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CFC : checkFinalClauses Known endFClause
EKC : endKnownClauses endFClause [] @
============================
 good_used_list []
</pre>
<pre class="code extensibella"id="926">
 &lt; <b>unfold .</b>

Subgoal 1:

Variables: Known
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsFC : is_finalClauses endFClause
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CFC : checkFinalClauses Known endFClause
EKC : endKnownClauses endFClause [] @
============================
 forall ID U1 CURest U2,
   select (ID, U1) CURest [] -&gt; mem (ID, U2) CURest -&gt; false
</pre>
<pre class="code extensibella"id="927">
 &lt; <b>intros S.</b>

Subgoal 1:

Variables: Known ID U1 CURest U2
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsFC : is_finalClauses endFClause
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CFC : checkFinalClauses Known endFClause
EKC : endKnownClauses endFClause [] @
S : select (ID, U1) CURest []
H1 : mem (ID, U2) CURest
============================
 false
</pre>
<pre class="code extensibella"id="928">
 &lt; <b>case S.</b>

Subgoal 2:

Variables: Known KRest ID Rest C
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsFC : is_finalClauses (addFClause ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CFC : checkFinalClauses Known (addFClause ID C Rest)
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
============================
 good_used_list ((ID, needed)::KRest)
</pre>
<pre class="code extensibella"id="929">
 &lt; <b>IsFC: case IsFC.</b>

Subgoal 2:

Variables: Known KRest ID Rest C
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CFC : checkFinalClauses Known (addFClause ID C Rest)
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
============================
 good_used_list ((ID, needed)::KRest)
</pre>
<pre class="code extensibella"id="930">
 &lt; <b>CFC: case CFC.</b>

Subgoal 2:

Variables: Known KRest ID Rest C KRest1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
============================
 good_used_list ((ID, needed)::KRest)
</pre>
<pre class="code extensibella"id="931">
 &lt; <b>Is: apply select_is to _ CFC.</b>

Subgoal 2:

Variables: Known KRest ID Rest C KRest1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
============================
 good_used_list ((ID, needed)::KRest)
</pre>
<pre class="code extensibella"id="932">
 &lt; <b>GCL': apply good_clause_list_select to _ CFC.</b>

Subgoal 2:

Variables: Known KRest ID Rest C KRest1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
============================
 good_used_list ((ID, needed)::KRest)
</pre>
<pre class="code extensibella"id="933">
 &lt; <b>GUL: apply IH to _ _ _ CFC1 EKC2.</b>

Subgoal 2:

Variables: Known KRest ID Rest C KRest1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
GUL : good_used_list KRest
============================
 good_used_list ((ID, needed)::KRest)
</pre>
<pre class="code extensibella"id="934">
 &lt; <b>unfold .</b>

Subgoal 2:

Variables: Known KRest ID Rest C KRest1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
GUL : good_used_list KRest
============================
 forall ID1 U1 CURest U2,
   select (ID1, U1) CURest ((ID, needed)::KRest) -&gt; mem (ID1, U2) CURest -&gt; false
</pre>
<pre class="code extensibella"id="935">
 &lt; <b>intros S M.</b>

Subgoal 2:

Variables: Known KRest ID Rest C KRest1 ID1 U1 CURest U2
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
GUL : good_used_list KRest
S : select (ID1, U1) CURest ((ID, needed)::KRest)
M : mem (ID1, U2) CURest
============================
 false
</pre>
<pre class="code extensibella"id="936">
 &lt; <b>S: case S.</b>

Subgoal 2.1:

Variables: Known KRest ID Rest C KRest1 U2
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
GUL : good_used_list KRest
M : mem (ID, U2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="937">
 &lt; <b>MKR1: apply endKnownClauses_all_mem to CFC1 EKC2 M.</b>

Subgoal 2.1:

Variables: Known KRest ID Rest C KRest1 U2 C1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
GUL : good_used_list KRest
M : mem (ID, U2) KRest
MKR1 : mem (ID, C1) KRest1
============================
 false
</pre>
<pre class="code extensibella"id="938">
 &lt; <b>GCL: case GCL.</b>

Subgoal 2.1:

Variables: Known KRest ID Rest C KRest1 U2 C1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
GUL : good_used_list KRest
M : mem (ID, U2) KRest
MKR1 : mem (ID, C1) KRest1
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest Known -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="939">
 &lt; <b>apply GCL to CFC MKR1.</b>

Subgoal 2.2:

Variables: Known KRest ID Rest C KRest1 ID1 U1 U2 L1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
GUL : good_used_list KRest
M : mem (ID1, U2) ((ID, needed)::L1)
S : select (ID1, U1) L1 KRest
============================
 false
</pre>
<pre class="code extensibella"id="940">
 &lt; <b>M: case M.</b>

Subgoal 2.2.1:

Variables: Known KRest ID Rest C KRest1 U1 L1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
GUL : good_used_list KRest
S : select (ID, U1) L1 KRest
============================
 false
</pre>
<pre class="code extensibella"id="941">
 &lt; <b>M: apply select_mem to S.</b>

Subgoal 2.2.1:

Variables: Known KRest ID Rest C KRest1 U1 L1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
GUL : good_used_list KRest
S : select (ID, U1) L1 KRest
M : mem (ID, U1) KRest
============================
 false
</pre>
<pre class="code extensibella"id="942">
 &lt; <b>GCL: case GCL.</b>

Subgoal 2.2.1:

Variables: Known KRest ID Rest C KRest1 U1 L1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
GUL : good_used_list KRest
S : select (ID, U1) L1 KRest
M : mem (ID, U1) KRest
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest Known -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="943">
 &lt; <b>MKR1: apply endKnownClauses_all_mem to CFC1 EKC2 M.</b>

Subgoal 2.2.1:

Variables: Known KRest ID Rest C KRest1 U1 L1 C1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
GUL : good_used_list KRest
S : select (ID, U1) L1 KRest
M : mem (ID, U1) KRest
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest Known -&gt; mem (ID, C2) KRest -&gt; false
MKR1 : mem (ID, C1) KRest1
============================
 false
</pre>
<pre class="code extensibella"id="944">
 &lt; <b>apply GCL to CFC MKR1.</b>

Subgoal 2.2.2:

Variables: Known KRest ID Rest C KRest1 ID1 U1 U2 L1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
GUL : good_used_list KRest
S : select (ID1, U1) L1 KRest
M : mem (ID1, U2) L1
============================
 false
</pre>
<pre class="code extensibella"id="945">
 &lt; <b>GUL: case GUL.</b>

Subgoal 2.2.2:

Variables: Known KRest ID Rest C KRest1 ID1 U1 U2 L1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, needed)::KRest) @
EKC1 : isEmpty C
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
S : select (ID1, U1) L1 KRest
M : mem (ID1, U2) L1
GUL : forall ID U1 CURest U2,
        select (ID, U1) CURest KRest -&gt; mem (ID, U2) CURest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="946">
 &lt; <b>backchain GUL.</b>

Subgoal 3:

Variables: Known KRest ID Rest C
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsFC : is_finalClauses (addFClause ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CFC : checkFinalClauses Known (addFClause ID C Rest)
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
============================
 good_used_list ((ID, unknown)::KRest)
</pre>
<pre class="code extensibella"id="947">
 &lt; <b>IsFC: case IsFC.</b>

Subgoal 3:

Variables: Known KRest ID Rest C
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CFC : checkFinalClauses Known (addFClause ID C Rest)
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
============================
 good_used_list ((ID, unknown)::KRest)
</pre>
<pre class="code extensibella"id="948">
 &lt; <b>CFC: case CFC.</b>

Subgoal 3:

Variables: Known KRest ID Rest C KRest1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
============================
 good_used_list ((ID, unknown)::KRest)
</pre>
<pre class="code extensibella"id="949">
 &lt; <b>Is: apply select_is to _ CFC.</b>

Subgoal 3:

Variables: Known KRest ID Rest C KRest1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
============================
 good_used_list ((ID, unknown)::KRest)
</pre>
<pre class="code extensibella"id="950">
 &lt; <b>GCL': apply good_clause_list_select to _ CFC.</b>

Subgoal 3:

Variables: Known KRest ID Rest C KRest1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
============================
 good_used_list ((ID, unknown)::KRest)
</pre>
<pre class="code extensibella"id="951">
 &lt; <b>GUL: apply IH to _ _ _ CFC1 EKC2.</b>

Subgoal 3:

Variables: Known KRest ID Rest C KRest1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
GUL : good_used_list KRest
============================
 good_used_list ((ID, unknown)::KRest)
</pre>
<pre class="code extensibella"id="952">
 &lt; <b>unfold .</b>

Subgoal 3:

Variables: Known KRest ID Rest C KRest1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
GUL : good_used_list KRest
============================
 forall ID1 U1 CURest U2,
   select (ID1, U1) CURest ((ID, unknown)::KRest) -&gt; mem (ID1, U2) CURest -&gt; false
</pre>
<pre class="code extensibella"id="953">
 &lt; <b>intros S M.</b>

Subgoal 3:

Variables: Known KRest ID Rest C KRest1 ID1 U1 CURest U2
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
GUL : good_used_list KRest
S : select (ID1, U1) CURest ((ID, unknown)::KRest)
M : mem (ID1, U2) CURest
============================
 false
</pre>
<pre class="code extensibella"id="954">
 &lt; <b>S: case S.</b>

Subgoal 3.1:

Variables: Known KRest ID Rest C KRest1 U2
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
GUL : good_used_list KRest
M : mem (ID, U2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="955">
 &lt; <b>MKR1: apply endKnownClauses_all_mem to CFC1 EKC2 M.</b>

Subgoal 3.1:

Variables: Known KRest ID Rest C KRest1 U2 C1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
GUL : good_used_list KRest
M : mem (ID, U2) KRest
MKR1 : mem (ID, C1) KRest1
============================
 false
</pre>
<pre class="code extensibella"id="956">
 &lt; <b>GCL: case GCL.</b>

Subgoal 3.1:

Variables: Known KRest ID Rest C KRest1 U2 C1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
GUL : good_used_list KRest
M : mem (ID, U2) KRest
MKR1 : mem (ID, C1) KRest1
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest Known -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="957">
 &lt; <b>apply GCL to CFC MKR1.</b>

Subgoal 3.2:

Variables: Known KRest ID Rest C KRest1 ID1 U1 U2 L1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
GUL : good_used_list KRest
M : mem (ID1, U2) ((ID, unknown)::L1)
S : select (ID1, U1) L1 KRest
============================
 false
</pre>
<pre class="code extensibella"id="958">
 &lt; <b>M: case M.</b>

Subgoal 3.2.1:

Variables: Known KRest ID Rest C KRest1 U1 L1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
GUL : good_used_list KRest
S : select (ID, U1) L1 KRest
============================
 false
</pre>
<pre class="code extensibella"id="959">
 &lt; <b>M: apply select_mem to S.</b>

Subgoal 3.2.1:

Variables: Known KRest ID Rest C KRest1 U1 L1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
GUL : good_used_list KRest
S : select (ID, U1) L1 KRest
M : mem (ID, U1) KRest
============================
 false
</pre>
<pre class="code extensibella"id="960">
 &lt; <b>GCL: case GCL.</b>

Subgoal 3.2.1:

Variables: Known KRest ID Rest C KRest1 U1 L1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
GUL : good_used_list KRest
S : select (ID, U1) L1 KRest
M : mem (ID, U1) KRest
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest Known -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="961">
 &lt; <b>MKR1: apply endKnownClauses_all_mem to CFC1 EKC2 M.</b>

Subgoal 3.2.1:

Variables: Known KRest ID Rest C KRest1 U1 L1 C1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
GUL : good_used_list KRest
S : select (ID, U1) L1 KRest
M : mem (ID, U1) KRest
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest Known -&gt; mem (ID, C2) KRest -&gt; false
MKR1 : mem (ID, C1) KRest1
============================
 false
</pre>
<pre class="code extensibella"id="962">
 &lt; <b>apply GCL to CFC MKR1.</b>

Subgoal 3.2.2:

Variables: Known KRest ID Rest C KRest1 ID1 U1 U2 L1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
GUL : good_used_list KRest
S : select (ID1, U1) L1 KRest
M : mem (ID1, U2) L1
============================
 false
</pre>
<pre class="code extensibella"id="963">
 &lt; <b>GUL: case GUL.</b>

Subgoal 3.2.2:

Variables: Known KRest ID Rest C KRest1 ID1 U1 U2 L1
IH : forall Known FC CU,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
       checkFinalClauses Known FC -&gt; endKnownClauses FC CU * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
EKC : endKnownClauses (addFClause ID C Rest) ((ID, unknown)::KRest) @
EKC1 : isEmpty C -&gt; false
EKC2 : endKnownClauses Rest KRest *
IsFC : is_integer ID
IsFC1 : is_clause C
IsFC2 : is_finalClauses Rest
CFC : select (ID, C) KRest1 Known
CFC1 : checkFinalClauses KRest1 Rest
Is : is_list (is_pair is_integer is_clause) KRest1
GCL' : good_clause_list KRest1
S : select (ID1, U1) L1 KRest
M : mem (ID1, U2) L1
GUL : forall ID U1 CURest U2,
        select (ID, U1) CURest KRest -&gt; mem (ID, U2) CURest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="964">
 &lt; <b>backchain GUL.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="965">
 &lt; <b>Theorem good_clause_list_double_select :
     forall K ID CA CB RA RB,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; select (ID, CA) RA K -&gt;
       select (ID, CB) RB K -&gt; CA = CB /\ RA = RB.</b>

============================
 forall K ID CA CB RA RB,
   is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; select (ID, CA) RA K -&gt;
   select (ID, CB) RB K -&gt; CA = CB /\ RA = RB
</pre>
<pre class="code extensibella"id="966">
 &lt; <b>induction on 3.</b>

IH : forall K ID CA CB RA RB,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; select (ID, CA) RA K * -&gt;
       select (ID, CB) RB K -&gt; CA = CB /\ RA = RB
============================
 forall K ID CA CB RA RB,
   is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; select (ID, CA) RA K @ -&gt;
   select (ID, CB) RB K -&gt; CA = CB /\ RA = RB
</pre>
<pre class="code extensibella"id="967">
 &lt; <b>intros Is GCL SA SB.</b>

Variables: K ID CA CB RA RB
IH : forall K ID CA CB RA RB,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; select (ID, CA) RA K * -&gt;
       select (ID, CB) RB K -&gt; CA = CB /\ RA = RB
Is : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
SA : select (ID, CA) RA K @
SB : select (ID, CB) RB K
============================
 CA = CB /\ RA = RB
</pre>
<pre class="code extensibella"id="968">
 &lt; <b>SA: case SA.</b>

Subgoal 1:

Variables: ID CA CB RA RB
IH : forall K ID CA CB RA RB,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; select (ID, CA) RA K * -&gt;
       select (ID, CB) RB K -&gt; CA = CB /\ RA = RB
Is : is_list (is_pair is_integer is_clause) ((ID, CA)::RA)
GCL : good_clause_list ((ID, CA)::RA)
SB : select (ID, CB) RB ((ID, CA)::RA)
============================
 CA = CB /\ RA = RB
</pre>
<pre class="code extensibella"id="969">
 &lt; <b>SB: case SB.</b>

Subgoal 1.1:

Variables: ID CA RA
IH : forall K ID CA CB RA RB,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; select (ID, CA) RA K * -&gt;
       select (ID, CB) RB K -&gt; CA = CB /\ RA = RB
Is : is_list (is_pair is_integer is_clause) ((ID, CA)::RA)
GCL : good_clause_list ((ID, CA)::RA)
============================
 CA = CA /\ RA = RA
</pre>
<pre class="code extensibella"id="970">
 &lt; <b>search.</b>

Subgoal 1.2:

Variables: ID CA CB RA L1
IH : forall K ID CA CB RA RB,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; select (ID, CA) RA K * -&gt;
       select (ID, CB) RB K -&gt; CA = CB /\ RA = RB
Is : is_list (is_pair is_integer is_clause) ((ID, CA)::RA)
GCL : good_clause_list ((ID, CA)::RA)
SB : select (ID, CB) L1 RA
============================
 CA = CB /\ RA = (ID, CA)::L1
</pre>
<pre class="code extensibella"id="971">
 &lt; <b>M: apply select_mem to SB.</b>

Subgoal 1.2:

Variables: ID CA CB RA L1
IH : forall K ID CA CB RA RB,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; select (ID, CA) RA K * -&gt;
       select (ID, CB) RB K -&gt; CA = CB /\ RA = RB
Is : is_list (is_pair is_integer is_clause) ((ID, CA)::RA)
GCL : good_clause_list ((ID, CA)::RA)
SB : select (ID, CB) L1 RA
M : mem (ID, CB) RA
============================
 CA = CB /\ RA = (ID, CA)::L1
</pre>
<pre class="code extensibella"id="972">
 &lt; <b>GCL: case GCL.</b>

Subgoal 1.2:

Variables: ID CA CB RA L1
IH : forall K ID CA CB RA RB,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; select (ID, CA) RA K * -&gt;
       select (ID, CB) RB K -&gt; CA = CB /\ RA = RB
Is : is_list (is_pair is_integer is_clause) ((ID, CA)::RA)
SB : select (ID, CB) L1 RA
M : mem (ID, CB) RA
GCL : forall ID1 C1 KRest C2,
        select (ID1, C1) KRest ((ID, CA)::RA) -&gt; mem (ID1, C2) KRest -&gt; false
============================
 CA = CB /\ RA = (ID, CA)::L1
</pre>
<pre class="code extensibella"id="973">
 &lt; <b>apply GCL to _ M.</b>

Subgoal 2:

Variables: ID CA CB RB L2 I L1
IH : forall K ID CA CB RA RB,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; select (ID, CA) RA K * -&gt;
       select (ID, CB) RB K -&gt; CA = CB /\ RA = RB
Is : is_list (is_pair is_integer is_clause) (I::L2)
GCL : good_clause_list (I::L2)
SB : select (ID, CB) RB (I::L2)
SA : select (ID, CA) L1 L2 *
============================
 CA = CB /\ I::L1 = RB
</pre>
<pre class="code extensibella"id="974">
 &lt; <b>SB: case SB.</b>

Subgoal 2.1:

Variables: ID CA CB L2 L1
IH : forall K ID CA CB RA RB,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; select (ID, CA) RA K * -&gt;
       select (ID, CB) RB K -&gt; CA = CB /\ RA = RB
Is : is_list (is_pair is_integer is_clause) ((ID, CB)::L2)
GCL : good_clause_list ((ID, CB)::L2)
SA : select (ID, CA) L1 L2 *
============================
 CA = CB /\ (ID, CB)::L1 = L2
</pre>
<pre class="code extensibella"id="975">
 &lt; <b>M: apply select_mem to SA.</b>

Subgoal 2.1:

Variables: ID CA CB L2 L1
IH : forall K ID CA CB RA RB,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; select (ID, CA) RA K * -&gt;
       select (ID, CB) RB K -&gt; CA = CB /\ RA = RB
Is : is_list (is_pair is_integer is_clause) ((ID, CB)::L2)
GCL : good_clause_list ((ID, CB)::L2)
SA : select (ID, CA) L1 L2 *
M : mem (ID, CA) L2
============================
 CA = CB /\ (ID, CB)::L1 = L2
</pre>
<pre class="code extensibella"id="976">
 &lt; <b>GCL: case GCL.</b>

Subgoal 2.1:

Variables: ID CA CB L2 L1
IH : forall K ID CA CB RA RB,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; select (ID, CA) RA K * -&gt;
       select (ID, CB) RB K -&gt; CA = CB /\ RA = RB
Is : is_list (is_pair is_integer is_clause) ((ID, CB)::L2)
SA : select (ID, CA) L1 L2 *
M : mem (ID, CA) L2
GCL : forall ID1 C1 KRest C2,
        select (ID1, C1) KRest ((ID, CB)::L2) -&gt; mem (ID1, C2) KRest -&gt; false
============================
 CA = CB /\ (ID, CB)::L1 = L2
</pre>
<pre class="code extensibella"id="977">
 &lt; <b>apply GCL to _ M.</b>

Subgoal 2.2:

Variables: ID CA CB L2 I L1 L3
IH : forall K ID CA CB RA RB,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; select (ID, CA) RA K * -&gt;
       select (ID, CB) RB K -&gt; CA = CB /\ RA = RB
Is : is_list (is_pair is_integer is_clause) (I::L2)
GCL : good_clause_list (I::L2)
SA : select (ID, CA) L1 L2 *
SB : select (ID, CB) L3 L2
============================
 CA = CB /\ I::L1 = I::L3
</pre>
<pre class="code extensibella"id="978">
 &lt; <b>Is: case Is.</b>

Subgoal 2.2:

Variables: ID CA CB L2 I L1 L3
IH : forall K ID CA CB RA RB,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; select (ID, CA) RA K * -&gt;
       select (ID, CB) RB K -&gt; CA = CB /\ RA = RB
GCL : good_clause_list (I::L2)
SA : select (ID, CA) L1 L2 *
SB : select (ID, CB) L3 L2
Is : is_pair is_integer is_clause I
Is1 : is_list (is_pair is_integer is_clause) L2
============================
 CA = CB /\ I::L1 = I::L3
</pre>
<pre class="code extensibella"id="979">
 &lt; <b>case Is.</b>

Subgoal 2.2:

Variables: ID CA CB L2 L1 L3 B A
IH : forall K ID CA CB RA RB,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; select (ID, CA) RA K * -&gt;
       select (ID, CB) RB K -&gt; CA = CB /\ RA = RB
GCL : good_clause_list ((A, B)::L2)
SA : select (ID, CA) L1 L2 *
SB : select (ID, CB) L3 L2
Is1 : is_list (is_pair is_integer is_clause) L2
H1 : is_integer A
H2 : is_clause B
============================
 CA = CB /\ (A, B)::L1 = (A, B)::L3
</pre>
<pre class="code extensibella"id="980">
 &lt; <b>apply good_clause_list_select to GCL _.</b>

Subgoal 2.2:

Variables: ID CA CB L2 L1 L3 B A
IH : forall K ID CA CB RA RB,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; select (ID, CA) RA K * -&gt;
       select (ID, CB) RB K -&gt; CA = CB /\ RA = RB
GCL : good_clause_list ((A, B)::L2)
SA : select (ID, CA) L1 L2 *
SB : select (ID, CB) L3 L2
Is1 : is_list (is_pair is_integer is_clause) L2
H1 : is_integer A
H2 : is_clause B
H3 : good_clause_list L2
============================
 CA = CB /\ (A, B)::L1 = (A, B)::L3
</pre>
<pre class="code extensibella"id="981">
 &lt; <b>apply IH to _ _ SA SB.</b>

Subgoal 2.2:

Variables: ID CB L2 L3 B A
IH : forall K ID CA CB RA RB,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; select (ID, CA) RA K * -&gt;
       select (ID, CB) RB K -&gt; CA = CB /\ RA = RB
GCL : good_clause_list ((A, B)::L2)
SA : select (ID, CB) L3 L2 *
SB : select (ID, CB) L3 L2
Is1 : is_list (is_pair is_integer is_clause) L2
H1 : is_integer A
H2 : is_clause B
H3 : good_clause_list L2
============================
 CB = CB /\ (A, B)::L3 = (A, B)::L3
</pre>
<pre class="code extensibella"id="982">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="983">
 &lt; <b>Theorem remove_all_unique :
     forall K ID RA RB, remove_all K ID RA -&gt; remove_all K ID RB -&gt; RA = RB.</b>

============================
 forall K ID RA RB, remove_all K ID RA -&gt; remove_all K ID RB -&gt; RA = RB
</pre>
<pre class="code extensibella"id="984">
 &lt; <b>induction on 1.</b>

IH : forall K ID RA RB, remove_all K ID RA * -&gt; remove_all K ID RB -&gt; RA = RB
============================
 forall K ID RA RB, remove_all K ID RA @ -&gt; remove_all K ID RB -&gt; RA = RB
</pre>
<pre class="code extensibella"id="985">
 &lt; <b>intros RA RB.</b>

Variables: K ID RA RB
IH : forall K ID RA RB, remove_all K ID RA * -&gt; remove_all K ID RB -&gt; RA = RB
RA : remove_all K ID RA @
RB : remove_all K ID RB
============================
 RA = RB
</pre>
<pre class="code extensibella"id="986">
 &lt; <b>RA: case RA.</b>

Subgoal 1:

Variables: ID RB
IH : forall K ID RA RB, remove_all K ID RA * -&gt; remove_all K ID RB -&gt; RA = RB
RB : remove_all [] ID RB
============================
 [] = RB
</pre>
<pre class="code extensibella"id="987">
 &lt; <b>case RB.</b>

Subgoal 1:

Variables: ID
IH : forall K ID RA RB, remove_all K ID RA * -&gt; remove_all K ID RB -&gt; RA = RB
============================
 [] = []
</pre>
<pre class="code extensibella"id="988">
 &lt; <b>search.</b>

Subgoal 2:

Variables: ID RA RB IRest C
IH : forall K ID RA RB, remove_all K ID RA * -&gt; remove_all K ID RB -&gt; RA = RB
RB : remove_all ((ID, C)::IRest) ID RB
RA : remove_all IRest ID RA *
============================
 RA = RB
</pre>
<pre class="code extensibella"id="989">
 &lt; <b>RB: case RB.</b>

Subgoal 2.1:

Variables: ID RA RB IRest C
IH : forall K ID RA RB, remove_all K ID RA * -&gt; remove_all K ID RB -&gt; RA = RB
RA : remove_all IRest ID RA *
RB : remove_all IRest ID RB
============================
 RA = RB
</pre>
<pre class="code extensibella"id="990">
 &lt; <b>apply IH to RA RB.</b>

Subgoal 2.1:

Variables: ID RB IRest C
IH : forall K ID RA RB, remove_all K ID RA * -&gt; remove_all K ID RB -&gt; RA = RB
RA : remove_all IRest ID RB *
RB : remove_all IRest ID RB
============================
 RB = RB
</pre>
<pre class="code extensibella"id="991">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: ID RA IRest C Rest
IH : forall K ID RA RB, remove_all K ID RA * -&gt; remove_all K ID RB -&gt; RA = RB
RA : remove_all IRest ID RA *
RB : ID = ID -&gt; false
RB1 : remove_all IRest ID Rest
============================
 RA = (ID, C)::Rest
</pre>
<pre class="code extensibella"id="992">
 &lt; <b>apply RB to _.</b>

Subgoal 3:

Variables: ID RB Rest C A IRest
IH : forall K ID RA RB, remove_all K ID RA * -&gt; remove_all K ID RB -&gt; RA = RB
RB : remove_all ((A, C)::IRest) ID RB
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
============================
 (A, C)::Rest = RB
</pre>
<pre class="code extensibella"id="993">
 &lt; <b>RB: case RB.</b>

Subgoal 3.1:

Variables: ID RB Rest C IRest
IH : forall K ID RA RB, remove_all K ID RA * -&gt; remove_all K ID RB -&gt; RA = RB
RA : ID = ID -&gt; false
RA1 : remove_all IRest ID Rest *
RB : remove_all IRest ID RB
============================
 (ID, C)::Rest = RB
</pre>
<pre class="code extensibella"id="994">
 &lt; <b>apply RA to _.</b>

Subgoal 3.2:

Variables: ID Rest C A IRest Rest1
IH : forall K ID RA RB, remove_all K ID RA * -&gt; remove_all K ID RB -&gt; RA = RB
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest *
RB : A = ID -&gt; false
RB1 : remove_all IRest ID Rest1
============================
 (A, C)::Rest = (A, C)::Rest1
</pre>
<pre class="code extensibella"id="995">
 &lt; <b>apply IH to RA1 RB1.</b>

Subgoal 3.2:

Variables: ID C A IRest Rest1
IH : forall K ID RA RB, remove_all K ID RA * -&gt; remove_all K ID RB -&gt; RA = RB
RA : A = ID -&gt; false
RA1 : remove_all IRest ID Rest1 *
RB : A = ID -&gt; false
RB1 : remove_all IRest ID Rest1
============================
 (A, C)::Rest1 = (A, C)::Rest1
</pre>
<pre class="code extensibella"id="996">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="997">
 &lt; <b>Theorem good_clause_list_selects :
     forall L X CA CB LA LB,
       good_clause_list L -&gt; select (X, CA) LA L -&gt; select (X, CB) LB L -&gt; LA = LB /\
       CA = CB.</b>

============================
 forall L X CA CB LA LB,
   good_clause_list L -&gt; select (X, CA) LA L -&gt; select (X, CB) LB L -&gt; LA = LB /\
   CA = CB
</pre>
<pre class="code extensibella"id="998">
 &lt; <b>induction on 2.</b>

IH : forall L X CA CB LA LB,
       good_clause_list L -&gt; select (X, CA) LA L * -&gt; select (X, CB) LB L -&gt; LA = LB /\
       CA = CB
============================
 forall L X CA CB LA LB,
   good_clause_list L -&gt; select (X, CA) LA L @ -&gt; select (X, CB) LB L -&gt; LA = LB /\
   CA = CB
</pre>
<pre class="code extensibella"id="999">
 &lt; <b>intros GCL SA SB.</b>

Variables: L X CA CB LA LB
IH : forall L X CA CB LA LB,
       good_clause_list L -&gt; select (X, CA) LA L * -&gt; select (X, CB) LB L -&gt; LA = LB /\
       CA = CB
GCL : good_clause_list L
SA : select (X, CA) LA L @
SB : select (X, CB) LB L
============================
 LA = LB /\ CA = CB
</pre>
<pre class="code extensibella"id="1000">
 &lt; <b>SA: case SA.</b>

Subgoal 1:

Variables: X CA CB LA LB
IH : forall L X CA CB LA LB,
       good_clause_list L -&gt; select (X, CA) LA L * -&gt; select (X, CB) LB L -&gt; LA = LB /\
       CA = CB
GCL : good_clause_list ((X, CA)::LA)
SB : select (X, CB) LB ((X, CA)::LA)
============================
 LA = LB /\ CA = CB
</pre>
<pre class="code extensibella"id="1001">
 &lt; <b>SB: case SB.</b>

Subgoal 1.1:

Variables: X CA LA
IH : forall L X CA CB LA LB,
       good_clause_list L -&gt; select (X, CA) LA L * -&gt; select (X, CB) LB L -&gt; LA = LB /\
       CA = CB
GCL : good_clause_list ((X, CA)::LA)
============================
 LA = LA /\ CA = CA
</pre>
<pre class="code extensibella"id="1002">
 &lt; <b>search.</b>

Subgoal 1.2:

Variables: X CA CB LA L1
IH : forall L X CA CB LA LB,
       good_clause_list L -&gt; select (X, CA) LA L * -&gt; select (X, CB) LB L -&gt; LA = LB /\
       CA = CB
GCL : good_clause_list ((X, CA)::LA)
SB : select (X, CB) L1 LA
============================
 LA = (X, CA)::L1 /\ CA = CB
</pre>
<pre class="code extensibella"id="1003">
 &lt; <b>M: apply select_mem to SB.</b>

Subgoal 1.2:

Variables: X CA CB LA L1
IH : forall L X CA CB LA LB,
       good_clause_list L -&gt; select (X, CA) LA L * -&gt; select (X, CB) LB L -&gt; LA = LB /\
       CA = CB
GCL : good_clause_list ((X, CA)::LA)
SB : select (X, CB) L1 LA
M : mem (X, CB) LA
============================
 LA = (X, CA)::L1 /\ CA = CB
</pre>
<pre class="code extensibella"id="1004">
 &lt; <b>GCL: case GCL.</b>

Subgoal 1.2:

Variables: X CA CB LA L1
IH : forall L X CA CB LA LB,
       good_clause_list L -&gt; select (X, CA) LA L * -&gt; select (X, CB) LB L -&gt; LA = LB /\
       CA = CB
SB : select (X, CB) L1 LA
M : mem (X, CB) LA
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest ((X, CA)::LA) -&gt; mem (ID, C2) KRest -&gt; false
============================
 LA = (X, CA)::L1 /\ CA = CB
</pre>
<pre class="code extensibella"id="1005">
 &lt; <b>apply GCL to _ M.</b>

Subgoal 2:

Variables: X CA CB LB L2 I L1
IH : forall L X CA CB LA LB,
       good_clause_list L -&gt; select (X, CA) LA L * -&gt; select (X, CB) LB L -&gt; LA = LB /\
       CA = CB
GCL : good_clause_list (I::L2)
SB : select (X, CB) LB (I::L2)
SA : select (X, CA) L1 L2 *
============================
 I::L1 = LB /\ CA = CB
</pre>
<pre class="code extensibella"id="1006">
 &lt; <b>SB: case SB.</b>

Subgoal 2.1:

Variables: X CA CB L2 L1
IH : forall L X CA CB LA LB,
       good_clause_list L -&gt; select (X, CA) LA L * -&gt; select (X, CB) LB L -&gt; LA = LB /\
       CA = CB
GCL : good_clause_list ((X, CB)::L2)
SA : select (X, CA) L1 L2 *
============================
 (X, CB)::L1 = L2 /\ CA = CB
</pre>
<pre class="code extensibella"id="1007">
 &lt; <b>M: apply select_mem to SA.</b>

Subgoal 2.1:

Variables: X CA CB L2 L1
IH : forall L X CA CB LA LB,
       good_clause_list L -&gt; select (X, CA) LA L * -&gt; select (X, CB) LB L -&gt; LA = LB /\
       CA = CB
GCL : good_clause_list ((X, CB)::L2)
SA : select (X, CA) L1 L2 *
M : mem (X, CA) L2
============================
 (X, CB)::L1 = L2 /\ CA = CB
</pre>
<pre class="code extensibella"id="1008">
 &lt; <b>GCL: case GCL.</b>

Subgoal 2.1:

Variables: X CA CB L2 L1
IH : forall L X CA CB LA LB,
       good_clause_list L -&gt; select (X, CA) LA L * -&gt; select (X, CB) LB L -&gt; LA = LB /\
       CA = CB
SA : select (X, CA) L1 L2 *
M : mem (X, CA) L2
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest ((X, CB)::L2) -&gt; mem (ID, C2) KRest -&gt; false
============================
 (X, CB)::L1 = L2 /\ CA = CB
</pre>
<pre class="code extensibella"id="1009">
 &lt; <b>apply GCL to _ M.</b>

Subgoal 2.2:

Variables: X CA CB L2 I L1 L3
IH : forall L X CA CB LA LB,
       good_clause_list L -&gt; select (X, CA) LA L * -&gt; select (X, CB) LB L -&gt; LA = LB /\
       CA = CB
GCL : good_clause_list (I::L2)
SA : select (X, CA) L1 L2 *
SB : select (X, CB) L3 L2
============================
 I::L1 = I::L3 /\ CA = CB
</pre>
<pre class="code extensibella"id="1010">
 &lt; <b>apply good_clause_list_drop to GCL.</b>

Subgoal 2.2:

Variables: X CA CB L2 I L1 L3
IH : forall L X CA CB LA LB,
       good_clause_list L -&gt; select (X, CA) LA L * -&gt; select (X, CB) LB L -&gt; LA = LB /\
       CA = CB
GCL : good_clause_list (I::L2)
SA : select (X, CA) L1 L2 *
SB : select (X, CB) L3 L2
H1 : good_clause_list L2
============================
 I::L1 = I::L3 /\ CA = CB
</pre>
<pre class="code extensibella"id="1011">
 &lt; <b>apply IH to _ SA SB.</b>

Subgoal 2.2:

Variables: X CB L2 I L3
IH : forall L X CA CB LA LB,
       good_clause_list L -&gt; select (X, CA) LA L * -&gt; select (X, CB) LB L -&gt; LA = LB /\
       CA = CB
GCL : good_clause_list (I::L2)
SA : select (X, CB) L3 L2 *
SB : select (X, CB) L3 L2
H1 : good_clause_list L2
============================
 I::L3 = I::L3 /\ CB = CB
</pre>
<pre class="code extensibella"id="1012">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="1013">
 &lt; <b>Theorem mem_needed_is :
     forall L I,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; mem I L -&gt; is_pair is_integer is_clauseUsedness I.</b>

============================
 forall L I,
   is_list (is_pair is_integer is_clauseUsedness) L -&gt; mem I L -&gt; is_pair is_integer is_clauseUsedness I
</pre>
<pre class="code extensibella"id="1014">
 &lt; <b>induction on 2.</b>

IH : forall L I,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; mem I L * -&gt; is_pair is_integer is_clauseUsedness I
============================
 forall L I,
   is_list (is_pair is_integer is_clauseUsedness) L -&gt; mem I L @ -&gt; is_pair is_integer is_clauseUsedness I
</pre>
<pre class="code extensibella"id="1015">
 &lt; <b>intros IsL M.</b>

Variables: L I
IH : forall L I,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; mem I L * -&gt; is_pair is_integer is_clauseUsedness I
IsL : is_list (is_pair is_integer is_clauseUsedness) L
M : mem I L @
============================
 is_pair is_integer is_clauseUsedness I
</pre>
<pre class="code extensibella"id="1016">
 &lt; <b>M: case M.</b>

Subgoal 1:

Variables: I Rest
IH : forall L I,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; mem I L * -&gt; is_pair is_integer is_clauseUsedness I
IsL : is_list (is_pair is_integer is_clauseUsedness) (I::Rest)
============================
 is_pair is_integer is_clauseUsedness I
</pre>
<pre class="code extensibella"id="1017">
 &lt; <b>case IsL.</b>

Subgoal 1:

Variables: I Rest
IH : forall L I,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; mem I L * -&gt; is_pair is_integer is_clauseUsedness I
H1 : is_pair is_integer is_clauseUsedness I
H2 : is_list (is_pair is_integer is_clauseUsedness) Rest
============================
 is_pair is_integer is_clauseUsedness I
</pre>
<pre class="code extensibella"id="1018">
 &lt; <b>search.</b>

Subgoal 2:

Variables: I Rest I1
IH : forall L I,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; mem I L * -&gt; is_pair is_integer is_clauseUsedness I
IsL : is_list (is_pair is_integer is_clauseUsedness) (I1::Rest)
M : mem I Rest *
============================
 is_pair is_integer is_clauseUsedness I
</pre>
<pre class="code extensibella"id="1019">
 &lt; <b>case IsL.</b>

Subgoal 2:

Variables: I Rest I1
IH : forall L I,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; mem I L * -&gt; is_pair is_integer is_clauseUsedness I
M : mem I Rest *
H1 : is_pair is_integer is_clauseUsedness I1
H2 : is_list (is_pair is_integer is_clauseUsedness) Rest
============================
 is_pair is_integer is_clauseUsedness I
</pre>
<pre class="code extensibella"id="1020">
 &lt; <b>apply IH to _ M.</b>

Subgoal 2:

Variables: I Rest I1
IH : forall L I,
       is_list (is_pair is_integer is_clauseUsedness) L -&gt; mem I L * -&gt; is_pair is_integer is_clauseUsedness I
M : mem I Rest *
H1 : is_pair is_integer is_clauseUsedness I1
H2 : is_list (is_pair is_integer is_clauseUsedness) Rest
H3 : is_pair is_integer is_clauseUsedness I
============================
 is_pair is_integer is_clauseUsedness I
</pre>
<pre class="code extensibella"id="1021">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="1022">
 &lt; <b>Extensible_Theorem
      elaboration_all_mem : forall Known P CU E ID U,
         IsP : is_proof P -&gt;
         GCL : good_clause_list Known -&gt;
         IsKnown : is_list (is_pair is_integer is_clause) Known -&gt;
         CP : checkProof Known P -&gt;
         Ela : elaborate Known P CU E -&gt;
         Mem : mem (ID, U) CU -&gt;
         exists C,
           mem (ID, C) Known
      on Ela,
      elaboration_good_used_list : forall Known P CU E,
         IsP : is_proof P -&gt;
         IsKnown : is_list (is_pair is_integer is_clause) Known -&gt;
         GCL : good_clause_list Known -&gt;
         CP : checkProof Known P -&gt;
         Ela : elaborate Known P CU E -&gt;
         good_used_list CU
      on Ela.</b>

Subgoal 1.1:

Variables: Known CU ID U Needed NRest Prf ID1 FC
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof (endFrat ID1 FC)
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (endFrat ID1 FC)
Ela : elaborate Known (endFrat ID1 FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1023">
 &lt; <b>Is: case IsP.</b>

Subgoal 1.1:

Variables: Known CU ID U Needed NRest Prf ID1 FC
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (endFrat ID1 FC)
Ela : elaborate Known (endFrat ID1 FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_finalClauses FC
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1024">
 &lt; <b>CP: case CP.</b>

Subgoal 1.1:

Variables: Known CU ID U Needed NRest Prf ID1 FC KRest Prf1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (endFrat ID1 FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_finalClauses FC
CP : remove_all Known ID1 KRest
CP1 : rupProof Known emptyClause Prf1
CP2 : checkFinalClauses ((ID1, emptyClause)::KRest) FC
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1025">
 &lt; <b>M: apply makeUsed_member to Ela4 Mem.</b>

Subgoal 1.1:

Variables: Known CU ID U Needed NRest Prf ID1 FC KRest Prf1 U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (endFrat ID1 FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_finalClauses FC
CP : remove_all Known ID1 KRest
CP1 : rupProof Known emptyClause Prf1
CP2 : checkFinalClauses ((ID1, emptyClause)::KRest) FC
M : mem (ID, U') NRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1026">
 &lt; <b>M': apply mem_after_select_before to Ela2 M.</b>

Subgoal 1.1:

Variables: Known CU ID U Needed NRest Prf ID1 FC KRest Prf1 U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (endFrat ID1 FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_finalClauses FC
CP : remove_all Known ID1 KRest
CP1 : rupProof Known emptyClause Prf1
CP2 : checkFinalClauses ((ID1, emptyClause)::KRest) FC
M : mem (ID, U') NRest
M' : mem (ID, U') Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1027">
 &lt; <b>M+: apply endKnownClauses_all_mem to CP2 Ela1 M'.</b>

Subgoal 1.1:

Variables: Known CU ID U Needed NRest Prf ID1 FC KRest Prf1 U' C
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (endFrat ID1 FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_finalClauses FC
CP : remove_all Known ID1 KRest
CP1 : rupProof Known emptyClause Prf1
CP2 : checkFinalClauses ((ID1, emptyClause)::KRest) FC
M : mem (ID, U') NRest
M' : mem (ID, U') Needed
M+ : mem (ID, C) ((ID1, emptyClause)::KRest)
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1028">
 &lt; <b>M2: case M+.</b>

Subgoal 1.1.1:

Variables: Known CU U Needed NRest Prf ID1 FC KRest Prf1 U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (endFrat ID1 FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID1, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_finalClauses FC
CP : remove_all Known ID1 KRest
CP1 : rupProof Known emptyClause Prf1
CP2 : checkFinalClauses ((ID1, emptyClause)::KRest) FC
M : mem (ID1, U') NRest
M' : mem (ID1, U') Needed
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1029">
 &lt; <b>apply good_clause_list_remove_all_add to _ CP with
     C = emptyClause.</b>

Subgoal 1.1.1:

Variables: Known CU U Needed NRest Prf ID1 FC KRest Prf1 U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (endFrat ID1 FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID1, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_finalClauses FC
CP : remove_all Known ID1 KRest
CP1 : rupProof Known emptyClause Prf1
CP2 : checkFinalClauses ((ID1, emptyClause)::KRest) FC
M : mem (ID1, U') NRest
M' : mem (ID1, U') Needed
H1 : good_clause_list ((ID1, emptyClause)::KRest)
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1030">
 &lt; <b>apply remove_all_is to _ CP.</b>

Subgoal 1.1.1:

Variables: Known CU U Needed NRest Prf ID1 FC KRest Prf1 U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (endFrat ID1 FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID1, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_finalClauses FC
CP : remove_all Known ID1 KRest
CP1 : rupProof Known emptyClause Prf1
CP2 : checkFinalClauses ((ID1, emptyClause)::KRest) FC
M : mem (ID1, U') NRest
M' : mem (ID1, U') Needed
H1 : good_clause_list ((ID1, emptyClause)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1031">
 &lt; <b>GUL: apply endKnownClauses_good_used_list to _ _ _ CP2 Ela1.</b>

Subgoal 1.1.1:

Variables: Known CU U Needed NRest Prf ID1 FC KRest Prf1 U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (endFrat ID1 FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID1, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_finalClauses FC
CP : remove_all Known ID1 KRest
CP1 : rupProof Known emptyClause Prf1
CP2 : checkFinalClauses ((ID1, emptyClause)::KRest) FC
M : mem (ID1, U') NRest
M' : mem (ID1, U') Needed
H1 : good_clause_list ((ID1, emptyClause)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
GUL : good_used_list Needed
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1032">
 &lt; <b>GUL: case GUL.</b>

Subgoal 1.1.1:

Variables: Known CU U Needed NRest Prf ID1 FC KRest Prf1 U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (endFrat ID1 FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID1, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_finalClauses FC
CP : remove_all Known ID1 KRest
CP1 : rupProof Known emptyClause Prf1
CP2 : checkFinalClauses ((ID1, emptyClause)::KRest) FC
M : mem (ID1, U') NRest
M' : mem (ID1, U') Needed
H1 : good_clause_list ((ID1, emptyClause)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
GUL : forall ID U1 CURest U2,
        select (ID, U1) CURest Needed -&gt; mem (ID, U2) CURest -&gt; false
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1033">
 &lt; <b>apply GUL to Ela2 M.</b>

Subgoal 1.1.2:

Variables: Known CU ID U Needed NRest Prf ID1 FC KRest Prf1 U' C
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (endFrat ID1 FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_finalClauses FC
CP : remove_all Known ID1 KRest
CP1 : rupProof Known emptyClause Prf1
CP2 : checkFinalClauses ((ID1, emptyClause)::KRest) FC
M : mem (ID, U') NRest
M' : mem (ID, U') Needed
M2 : mem (ID, C) KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1034">
 &lt; <b>apply remove_all_mem_after to CP M2.</b>

Subgoal 1.1.2:

Variables: Known CU ID U Needed NRest Prf ID1 FC KRest Prf1 U' C
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (endFrat ID1 FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_finalClauses FC
CP : remove_all Known ID1 KRest
CP1 : rupProof Known emptyClause Prf1
CP2 : checkFinalClauses ((ID1, emptyClause)::KRest) FC
M : mem (ID, U') NRest
M' : mem (ID, U') Needed
M2 : mem (ID, C) KRest
H1 : mem (ID, C) Known
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1035">
 &lt; <b>search.</b>

Subgoal 1.2:

Variables: Known CU ID U Needed NRest Prf ID1 FC
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof (endFratPrf ID1 Prf FC)
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (endFratPrf ID1 Prf FC)
Ela : elaborate Known (endFratPrf ID1 Prf FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : makeUsed NRest Prf CU
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1036">
 &lt; <b>Is: case IsP.</b>

Subgoal 1.2:

Variables: Known CU ID U Needed NRest Prf ID1 FC
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (endFratPrf ID1 Prf FC)
Ela : elaborate Known (endFratPrf ID1 Prf FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_list is_integer Prf
Is2 : is_finalClauses FC
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1037">
 &lt; <b>CP: case CP.</b>

Subgoal 1.2:

Variables: Known CU ID U Needed NRest Prf ID1 FC KRest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (endFratPrf ID1 Prf FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_list is_integer Prf
Is2 : is_finalClauses FC
CP : remove_all Known ID1 KRest
CP1 : rupProof Known emptyClause Prf
CP2 : checkFinalClauses ((ID1, emptyClause)::KRest) FC
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1038">
 &lt; <b>M: apply makeUsed_member to Ela3 Mem.</b>

Subgoal 1.2:

Variables: Known CU ID U Needed NRest Prf ID1 FC KRest U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (endFratPrf ID1 Prf FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_list is_integer Prf
Is2 : is_finalClauses FC
CP : remove_all Known ID1 KRest
CP1 : rupProof Known emptyClause Prf
CP2 : checkFinalClauses ((ID1, emptyClause)::KRest) FC
M : mem (ID, U') NRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1039">
 &lt; <b>M': apply mem_after_select_before to Ela2 M.</b>

Subgoal 1.2:

Variables: Known CU ID U Needed NRest Prf ID1 FC KRest U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (endFratPrf ID1 Prf FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_list is_integer Prf
Is2 : is_finalClauses FC
CP : remove_all Known ID1 KRest
CP1 : rupProof Known emptyClause Prf
CP2 : checkFinalClauses ((ID1, emptyClause)::KRest) FC
M : mem (ID, U') NRest
M' : mem (ID, U') Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1040">
 &lt; <b>M+: apply endKnownClauses_all_mem to CP2 Ela1 M'.</b>

Subgoal 1.2:

Variables: Known CU ID U Needed NRest Prf ID1 FC KRest U' C
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (endFratPrf ID1 Prf FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_list is_integer Prf
Is2 : is_finalClauses FC
CP : remove_all Known ID1 KRest
CP1 : rupProof Known emptyClause Prf
CP2 : checkFinalClauses ((ID1, emptyClause)::KRest) FC
M : mem (ID, U') NRest
M' : mem (ID, U') Needed
M+ : mem (ID, C) ((ID1, emptyClause)::KRest)
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1041">
 &lt; <b>M2: case M+.</b>

Subgoal 1.2.1:

Variables: Known CU U Needed NRest Prf ID1 FC KRest U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (endFratPrf ID1 Prf FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID1, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_list is_integer Prf
Is2 : is_finalClauses FC
CP : remove_all Known ID1 KRest
CP1 : rupProof Known emptyClause Prf
CP2 : checkFinalClauses ((ID1, emptyClause)::KRest) FC
M : mem (ID1, U') NRest
M' : mem (ID1, U') Needed
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1042">
 &lt; <b>apply good_clause_list_remove_all_add to _ CP with
     C = emptyClause.</b>

Subgoal 1.2.1:

Variables: Known CU U Needed NRest Prf ID1 FC KRest U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (endFratPrf ID1 Prf FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID1, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_list is_integer Prf
Is2 : is_finalClauses FC
CP : remove_all Known ID1 KRest
CP1 : rupProof Known emptyClause Prf
CP2 : checkFinalClauses ((ID1, emptyClause)::KRest) FC
M : mem (ID1, U') NRest
M' : mem (ID1, U') Needed
H1 : good_clause_list ((ID1, emptyClause)::KRest)
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1043">
 &lt; <b>apply remove_all_is to _ CP.</b>

Subgoal 1.2.1:

Variables: Known CU U Needed NRest Prf ID1 FC KRest U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (endFratPrf ID1 Prf FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID1, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_list is_integer Prf
Is2 : is_finalClauses FC
CP : remove_all Known ID1 KRest
CP1 : rupProof Known emptyClause Prf
CP2 : checkFinalClauses ((ID1, emptyClause)::KRest) FC
M : mem (ID1, U') NRest
M' : mem (ID1, U') Needed
H1 : good_clause_list ((ID1, emptyClause)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1044">
 &lt; <b>GUL: apply endKnownClauses_good_used_list to _ _ _ CP2 Ela1.</b>

Subgoal 1.2.1:

Variables: Known CU U Needed NRest Prf ID1 FC KRest U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (endFratPrf ID1 Prf FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID1, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_list is_integer Prf
Is2 : is_finalClauses FC
CP : remove_all Known ID1 KRest
CP1 : rupProof Known emptyClause Prf
CP2 : checkFinalClauses ((ID1, emptyClause)::KRest) FC
M : mem (ID1, U') NRest
M' : mem (ID1, U') Needed
H1 : good_clause_list ((ID1, emptyClause)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
GUL : good_used_list Needed
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1045">
 &lt; <b>GUL: case GUL.</b>

Subgoal 1.2.1:

Variables: Known CU U Needed NRest Prf ID1 FC KRest U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (endFratPrf ID1 Prf FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID1, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_list is_integer Prf
Is2 : is_finalClauses FC
CP : remove_all Known ID1 KRest
CP1 : rupProof Known emptyClause Prf
CP2 : checkFinalClauses ((ID1, emptyClause)::KRest) FC
M : mem (ID1, U') NRest
M' : mem (ID1, U') Needed
H1 : good_clause_list ((ID1, emptyClause)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
GUL : forall ID U1 CURest U2,
        select (ID, U1) CURest Needed -&gt; mem (ID, U2) CURest -&gt; false
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1046">
 &lt; <b>apply GUL to Ela2 M.</b>

Subgoal 1.2.2:

Variables: Known CU ID U Needed NRest Prf ID1 FC KRest U' C
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (endFratPrf ID1 Prf FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_list is_integer Prf
Is2 : is_finalClauses FC
CP : remove_all Known ID1 KRest
CP1 : rupProof Known emptyClause Prf
CP2 : checkFinalClauses ((ID1, emptyClause)::KRest) FC
M : mem (ID, U') NRest
M' : mem (ID, U') Needed
M2 : mem (ID, C) KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1047">
 &lt; <b>apply remove_all_mem_after to CP M2.</b>

Subgoal 1.2.2:

Variables: Known CU ID U Needed NRest Prf ID1 FC KRest U' C
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (endFratPrf ID1 Prf FC) CU (emptyLrat ID1 Prf) @
Mem : mem (ID, U) CU
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID1, needed) NRest Needed
Ela3 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_list is_integer Prf
Is2 : is_finalClauses FC
CP : remove_all Known ID1 KRest
CP1 : rupProof Known emptyClause Prf
CP2 : checkFinalClauses ((ID1, emptyClause)::KRest) FC
M : mem (ID, U') NRest
M' : mem (ID, U') Needed
M2 : mem (ID, C) KRest
H1 : mem (ID, C) Known
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1048">
 &lt; <b>search.</b>

Subgoal 1.3:

Variables: Known E ID U KRest Needed ID1 Rest C
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof (deleteFrat ID1 C Rest)
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteFrat ID1 C Rest)
Ela : elaborate Known (deleteFrat ID1 C Rest) ((ID1, unknown)::Needed) E @
Mem : mem (ID, U) ((ID1, unknown)::Needed)
Ela1 : select (ID1, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1049">
 &lt; <b>Is: case IsP.</b>

Subgoal 1.3:

Variables: Known E ID U KRest Needed ID1 Rest C
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteFrat ID1 C Rest)
Ela : elaborate Known (deleteFrat ID1 C Rest) ((ID1, unknown)::Needed) E @
Mem : mem (ID, U) ((ID1, unknown)::Needed)
Ela1 : select (ID1, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1050">
 &lt; <b>CP: case CP.</b>

Subgoal 1.3:

Variables: Known E ID U KRest Needed ID1 Rest C KRest1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (deleteFrat ID1 C Rest) ((ID1, unknown)::Needed) E @
Mem : mem (ID, U) ((ID1, unknown)::Needed)
Ela1 : select (ID1, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : select (ID1, C) KRest1 Known
CP1 : checkProof KRest1 Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1051">
 &lt; <b>Mem: case Mem.</b>

Subgoal 1.3.1:

Variables: Known E KRest Needed ID1 Rest C KRest1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (deleteFrat ID1 C Rest) ((ID1, unknown)::Needed) E @
Ela1 : select (ID1, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : select (ID1, C) KRest1 Known
CP1 : checkProof KRest1 Rest
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1052">
 &lt; <b>apply select_mem to CP.</b>

Subgoal 1.3.1:

Variables: Known E KRest Needed ID1 Rest C KRest1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (deleteFrat ID1 C Rest) ((ID1, unknown)::Needed) E @
Ela1 : select (ID1, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : select (ID1, C) KRest1 Known
CP1 : checkProof KRest1 Rest
H1 : mem (ID1, C) Known
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1053">
 &lt; <b>search.</b>

Subgoal 1.3.2:

Variables: Known E ID U KRest Needed ID1 Rest C KRest1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (deleteFrat ID1 C Rest) ((ID1, unknown)::Needed) E @
Ela1 : select (ID1, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : select (ID1, C) KRest1 Known
CP1 : checkProof KRest1 Rest
Mem : mem (ID, U) Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1054">
 &lt; <b>apply good_clause_list_double_select to _ _ CP Ela1.</b>

Subgoal 1.3.2:

Variables: Known E ID U KRest Needed ID1 Rest C
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (deleteFrat ID1 C Rest) ((ID1, unknown)::Needed) E @
Ela1 : select (ID1, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : select (ID1, C) KRest Known
CP1 : checkProof KRest Rest
Mem : mem (ID, U) Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1055">
 &lt; <b>apply select_is to _ CP.</b>

Subgoal 1.3.2:

Variables: Known E ID U KRest Needed ID1 Rest C
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (deleteFrat ID1 C Rest) ((ID1, unknown)::Needed) E @
Ela1 : select (ID1, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : select (ID1, C) KRest Known
CP1 : checkProof KRest Rest
Mem : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1056">
 &lt; <b>apply good_clause_list_select to _ CP.</b>

Subgoal 1.3.2:

Variables: Known E ID U KRest Needed ID1 Rest C
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (deleteFrat ID1 C Rest) ((ID1, unknown)::Needed) E @
Ela1 : select (ID1, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : select (ID1, C) KRest Known
CP1 : checkProof KRest Rest
Mem : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1057">
 &lt; <b>M: apply IH to _ _ _ CP1 Ela2 Mem.</b>

Subgoal 1.3.2:

Variables: Known E ID U KRest Needed ID1 Rest C C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (deleteFrat ID1 C Rest) ((ID1, unknown)::Needed) E @
Ela1 : select (ID1, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : select (ID1, C) KRest Known
CP1 : checkProof KRest Rest
Mem : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
M : mem (ID, C1) KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1058">
 &lt; <b>apply mem_after_select_before to CP M.</b>

Subgoal 1.3.2:

Variables: Known E ID U KRest Needed ID1 Rest C C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (deleteFrat ID1 C Rest) ((ID1, unknown)::Needed) E @
Ela1 : select (ID1, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : select (ID1, C) KRest Known
CP1 : checkProof KRest Rest
Mem : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
M : mem (ID, C1) KRest
H3 : mem (ID, C1) Known
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1059">
 &lt; <b>search.</b>

Subgoal 1.4:

Variables: Known E ID U C KRest Needed ID1 Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof (deleteLratProof ID1 Rest)
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteLratProof ID1 Rest)
Ela : elaborate Known (deleteLratProof ID1 Rest) ((ID1, unknown)::Needed) E @
Mem : mem (ID, U) ((ID1, unknown)::Needed)
Ela1 : select (ID1, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1060">
 &lt; <b>Is: case IsP.</b>

Subgoal 1.4:

Variables: Known E ID U C KRest Needed ID1 Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (deleteLratProof ID1 Rest)
Ela : elaborate Known (deleteLratProof ID1 Rest) ((ID1, unknown)::Needed) E @
Mem : mem (ID, U) ((ID1, unknown)::Needed)
Ela1 : select (ID1, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID1
Is1 : is_proof Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1061">
 &lt; <b>CP: case CP.</b>

Subgoal 1.4:

Variables: Known E ID U C KRest Needed ID1 Rest C1 KRest1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (deleteLratProof ID1 Rest) ((ID1, unknown)::Needed) E @
Mem : mem (ID, U) ((ID1, unknown)::Needed)
Ela1 : select (ID1, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID1
Is1 : is_proof Rest
CP : select (ID1, C1) KRest1 Known
CP1 : checkProof KRest1 Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1062">
 &lt; <b>Mem: case Mem.</b>

Subgoal 1.4.1:

Variables: Known E C KRest Needed ID1 Rest C1 KRest1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (deleteLratProof ID1 Rest) ((ID1, unknown)::Needed) E @
Ela1 : select (ID1, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID1
Is1 : is_proof Rest
CP : select (ID1, C1) KRest1 Known
CP1 : checkProof KRest1 Rest
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1063">
 &lt; <b>apply select_mem to CP.</b>

Subgoal 1.4.1:

Variables: Known E C KRest Needed ID1 Rest C1 KRest1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (deleteLratProof ID1 Rest) ((ID1, unknown)::Needed) E @
Ela1 : select (ID1, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID1
Is1 : is_proof Rest
CP : select (ID1, C1) KRest1 Known
CP1 : checkProof KRest1 Rest
H1 : mem (ID1, C1) Known
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1064">
 &lt; <b>search.</b>

Subgoal 1.4.2:

Variables: Known E ID U C KRest Needed ID1 Rest C1 KRest1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (deleteLratProof ID1 Rest) ((ID1, unknown)::Needed) E @
Ela1 : select (ID1, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID1
Is1 : is_proof Rest
CP : select (ID1, C1) KRest1 Known
CP1 : checkProof KRest1 Rest
Mem : mem (ID, U) Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1065">
 &lt; <b>apply good_clause_list_double_select to _ _ CP Ela1.</b>

Subgoal 1.4.2:

Variables: Known E ID U C KRest Needed ID1 Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (deleteLratProof ID1 Rest) ((ID1, unknown)::Needed) E @
Ela1 : select (ID1, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID1
Is1 : is_proof Rest
CP : select (ID1, C) KRest Known
CP1 : checkProof KRest Rest
Mem : mem (ID, U) Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1066">
 &lt; <b>apply select_is to _ CP.</b>

Subgoal 1.4.2:

Variables: Known E ID U C KRest Needed ID1 Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (deleteLratProof ID1 Rest) ((ID1, unknown)::Needed) E @
Ela1 : select (ID1, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID1
Is1 : is_proof Rest
CP : select (ID1, C) KRest Known
CP1 : checkProof KRest Rest
Mem : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1067">
 &lt; <b>apply good_clause_list_select to _ CP.</b>

Subgoal 1.4.2:

Variables: Known E ID U C KRest Needed ID1 Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (deleteLratProof ID1 Rest) ((ID1, unknown)::Needed) E @
Ela1 : select (ID1, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID1
Is1 : is_proof Rest
CP : select (ID1, C) KRest Known
CP1 : checkProof KRest Rest
Mem : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1068">
 &lt; <b>M: apply IH to _ _ _ CP1 Ela2 Mem.</b>

Subgoal 1.4.2:

Variables: Known E ID U C KRest Needed ID1 Rest C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (deleteLratProof ID1 Rest) ((ID1, unknown)::Needed) E @
Ela1 : select (ID1, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID1
Is1 : is_proof Rest
CP : select (ID1, C) KRest Known
CP1 : checkProof KRest Rest
Mem : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
M : mem (ID, C2) KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1069">
 &lt; <b>apply mem_after_select_before to CP M.</b>

Subgoal 1.4.2:

Variables: Known E ID U C KRest Needed ID1 Rest C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (deleteLratProof ID1 Rest) ((ID1, unknown)::Needed) E @
Ela1 : select (ID1, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID1
Is1 : is_proof Rest
CP : select (ID1, C) KRest Known
CP1 : checkProof KRest Rest
Mem : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
M : mem (ID, C2) KRest
H3 : mem (ID, C2) Known
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1070">
 &lt; <b>search.</b>

Subgoal 1.5:

Variables: Known CU ID U KRest Needed NRest ERest Prf C ID1 Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof (addLrupProof ID1 C Prf Rest)
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID1 C Prf Rest)
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1071">
 &lt; <b>Is: case IsP.</b>

Subgoal 1.5:

Variables: Known CU ID U KRest Needed NRest ERest Prf C ID1 Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID1 C Prf Rest)
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1072">
 &lt; <b>CP: case CP.</b>

Subgoal 1.5:

Variables: Known CU ID U KRest Needed NRest ERest Prf C ID1 Rest KRest1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP : remove_all Known ID1 KRest1
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest1) Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1073">
 &lt; <b>apply remove_all_unique to CP Ela1.</b>

Subgoal 1.5:

Variables: Known CU ID U KRest Needed NRest ERest Prf C ID1 Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1074">
 &lt; <b>MNR: apply makeUsed_member to Ela4 Mem.</b>

Subgoal 1.5:

Variables: Known CU ID U KRest Needed NRest ERest Prf C ID1 Rest U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MNR : mem (ID, U') NRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1075">
 &lt; <b>MN: apply mem_after_select_before to Ela3 MNR.</b>

Subgoal 1.5:

Variables: Known CU ID U KRest Needed NRest ERest Prf C ID1 Rest U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MNR : mem (ID, U') NRest
MN : mem (ID, U') Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1076">
 &lt; <b>apply remove_all_is to _ CP.</b>

Subgoal 1.5:

Variables: Known CU ID U KRest Needed NRest ERest Prf C ID1 Rest U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MNR : mem (ID, U') NRest
MN : mem (ID, U') Needed
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1077">
 &lt; <b>apply good_clause_list_remove_all_add to _ CP with
     C = C.</b>

Subgoal 1.5:

Variables: Known CU ID U KRest Needed NRest ERest Prf C ID1 Rest U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MNR : mem (ID, U') NRest
MN : mem (ID, U') Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1078">
 &lt; <b>M: apply IH to _ _ _ CP2 Ela2 MN.</b>

Subgoal 1.5:

Variables: Known CU ID U KRest Needed NRest ERest Prf C ID1 Rest U' C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MNR : mem (ID, U') NRest
MN : mem (ID, U') Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
M : mem (ID, C1) ((ID1, C)::KRest)
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1079">
 &lt; <b>M: case M.</b>

Subgoal 1.5.1:

Variables: Known CU U KRest Needed NRest ERest Prf C ID1 Rest U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID1, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MNR : mem (ID1, U') NRest
MN : mem (ID1, U') Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1080">
 &lt; <b>GUL: apply IH1 to _ _ _ CP2 Ela2.</b>

Subgoal 1.5.1:

Variables: Known CU U KRest Needed NRest ERest Prf C ID1 Rest U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID1, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MNR : mem (ID1, U') NRest
MN : mem (ID1, U') Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
GUL : good_used_list Needed
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1081">
 &lt; <b>GUL: case GUL.</b>

Subgoal 1.5.1:

Variables: Known CU U KRest Needed NRest ERest Prf C ID1 Rest U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID1, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MNR : mem (ID1, U') NRest
MN : mem (ID1, U') Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
GUL : forall ID U1 CURest U2,
        select (ID, U1) CURest Needed -&gt; mem (ID, U2) CURest -&gt; false
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1082">
 &lt; <b>apply GUL to Ela3 MNR.</b>

Subgoal 1.5.2:

Variables: Known CU ID U KRest Needed NRest ERest Prf C ID1 Rest U' C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MNR : mem (ID, U') NRest
MN : mem (ID, U') Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
M : mem (ID, C1) KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1083">
 &lt; <b>apply remove_all_mem_after to CP M.</b>

Subgoal 1.5.2:

Variables: Known CU ID U KRest Needed NRest ERest Prf C ID1 Rest U' C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MNR : mem (ID, U') NRest
MN : mem (ID, U') Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
M : mem (ID, C1) KRest
H3 : mem (ID, C1) Known
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1084">
 &lt; <b>search.</b>

Subgoal 1.6:

Variables: Known CU E ID U KRest Needed Rest Prf C ID1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof (addLrupProof ID1 C Prf Rest)
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID1 C Prf Rest)
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1085">
 &lt; <b>Is: case IsP.</b>

Subgoal 1.6:

Variables: Known CU E ID U KRest Needed Rest Prf C ID1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addLrupProof ID1 C Prf Rest)
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1086">
 &lt; <b>CP: case CP.</b>

Subgoal 1.6:

Variables: Known CU E ID U KRest Needed Rest Prf C ID1 KRest1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP : remove_all Known ID1 KRest1
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest1) Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1087">
 &lt; <b>apply remove_all_unique to CP Ela1.</b>

Subgoal 1.6:

Variables: Known CU E ID U KRest Needed Rest Prf C ID1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1088">
 &lt; <b>MN: apply mem_after_select_before to Ela3 Mem.</b>

Subgoal 1.6:

Variables: Known CU E ID U KRest Needed Rest Prf C ID1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MN : mem (ID, U) Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1089">
 &lt; <b>apply remove_all_is to _ CP.</b>

Subgoal 1.6:

Variables: Known CU E ID U KRest Needed Rest Prf C ID1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MN : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1090">
 &lt; <b>apply good_clause_list_remove_all_add to _ CP with
     C = C.</b>

Subgoal 1.6:

Variables: Known CU E ID U KRest Needed Rest Prf C ID1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MN : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1091">
 &lt; <b>M: apply IH to _ _ _ CP2 Ela2 MN.</b>

Subgoal 1.6:

Variables: Known CU E ID U KRest Needed Rest Prf C ID1 C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MN : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
M : mem (ID, C1) ((ID1, C)::KRest)
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1092">
 &lt; <b>M: case M.</b>

Subgoal 1.6.1:

Variables: Known CU E U KRest Needed Rest Prf C ID1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU E @
Mem : mem (ID1, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MN : mem (ID1, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1093">
 &lt; <b>GUL: apply IH1 to _ _ _ CP2 Ela2.</b>

Subgoal 1.6.1:

Variables: Known CU E U KRest Needed Rest Prf C ID1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU E @
Mem : mem (ID1, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MN : mem (ID1, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
GUL : good_used_list Needed
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1094">
 &lt; <b>GUL: case GUL.</b>

Subgoal 1.6.1:

Variables: Known CU E U KRest Needed Rest Prf C ID1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU E @
Mem : mem (ID1, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MN : mem (ID1, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
GUL : forall ID U1 CURest U2,
        select (ID, U1) CURest Needed -&gt; mem (ID, U2) CURest -&gt; false
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1095">
 &lt; <b>apply GUL to Ela3 Mem.</b>

Subgoal 1.6.2:

Variables: Known CU E ID U KRest Needed Rest Prf C ID1 C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MN : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
M : mem (ID, C1) KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1096">
 &lt; <b>apply remove_all_mem_after to CP M.</b>

Subgoal 1.6.2:

Variables: Known CU E ID U KRest Needed Rest Prf C ID1 C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addLrupProof ID1 C Prf Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MN : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
M : mem (ID, C1) KRest
H3 : mem (ID, C1) Known
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1097">
 &lt; <b>search.</b>

Subgoal 1.7:

Variables: Known CU ID U KRest Needed NRest ERest Prf C ID1 Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof (addProofless ID1 C Rest)
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID1 C Rest)
Ela : elaborate Known (addProofless ID1 C Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1098">
 &lt; <b>Is: case IsP.</b>

Subgoal 1.7:

Variables: Known CU ID U KRest Needed NRest ERest Prf C ID1 Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID1 C Rest)
Ela : elaborate Known (addProofless ID1 C Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1099">
 &lt; <b>CP: case CP.</b>

Subgoal 1.7:

Variables: Known CU ID U KRest Needed NRest ERest Prf C ID1 Rest KRest1 Prf1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addProofless ID1 C Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : remove_all Known ID1 KRest1
CP1 : rupProof Known C Prf1
CP2 : checkProof ((ID1, C)::KRest1) Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1100">
 &lt; <b>apply remove_all_unique to CP Ela1.</b>

Subgoal 1.7:

Variables: Known CU ID U KRest Needed NRest ERest Prf C ID1 Rest Prf1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addProofless ID1 C Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf1
CP2 : checkProof ((ID1, C)::KRest) Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1101">
 &lt; <b>MNR: apply makeUsed_member to Ela5 Mem.</b>

Subgoal 1.7:

Variables: Known CU ID U KRest Needed NRest ERest Prf C ID1 Rest Prf1 U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addProofless ID1 C Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf1
CP2 : checkProof ((ID1, C)::KRest) Rest
MNR : mem (ID, U') NRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1102">
 &lt; <b>MN: apply mem_after_select_before to Ela3 MNR.</b>

Subgoal 1.7:

Variables: Known CU ID U KRest Needed NRest ERest Prf C ID1 Rest Prf1 U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addProofless ID1 C Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf1
CP2 : checkProof ((ID1, C)::KRest) Rest
MNR : mem (ID, U') NRest
MN : mem (ID, U') Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1103">
 &lt; <b>apply remove_all_is to _ CP.</b>

Subgoal 1.7:

Variables: Known CU ID U KRest Needed NRest ERest Prf C ID1 Rest Prf1 U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addProofless ID1 C Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf1
CP2 : checkProof ((ID1, C)::KRest) Rest
MNR : mem (ID, U') NRest
MN : mem (ID, U') Needed
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1104">
 &lt; <b>apply good_clause_list_remove_all_add to _ CP with
     C = C.</b>

Subgoal 1.7:

Variables: Known CU ID U KRest Needed NRest ERest Prf C ID1 Rest Prf1 U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addProofless ID1 C Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf1
CP2 : checkProof ((ID1, C)::KRest) Rest
MNR : mem (ID, U') NRest
MN : mem (ID, U') Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1105">
 &lt; <b>M: apply IH to _ _ _ CP2 Ela2 MN.</b>

Subgoal 1.7:

Variables: Known CU ID U KRest Needed NRest ERest Prf C ID1 Rest Prf1 U' C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addProofless ID1 C Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf1
CP2 : checkProof ((ID1, C)::KRest) Rest
MNR : mem (ID, U') NRest
MN : mem (ID, U') Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
M : mem (ID, C1) ((ID1, C)::KRest)
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1106">
 &lt; <b>M: case M.</b>

Subgoal 1.7.1:

Variables: Known CU U KRest Needed NRest ERest Prf C ID1 Rest Prf1 U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addProofless ID1 C Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID1, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf1
CP2 : checkProof ((ID1, C)::KRest) Rest
MNR : mem (ID1, U') NRest
MN : mem (ID1, U') Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1107">
 &lt; <b>GUL: apply IH1 to _ _ _ CP2 Ela2.</b>

Subgoal 1.7.1:

Variables: Known CU U KRest Needed NRest ERest Prf C ID1 Rest Prf1 U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addProofless ID1 C Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID1, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf1
CP2 : checkProof ((ID1, C)::KRest) Rest
MNR : mem (ID1, U') NRest
MN : mem (ID1, U') Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
GUL : good_used_list Needed
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1108">
 &lt; <b>GUL: case GUL.</b>

Subgoal 1.7.1:

Variables: Known CU U KRest Needed NRest ERest Prf C ID1 Rest Prf1 U'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addProofless ID1 C Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID1, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf1
CP2 : checkProof ((ID1, C)::KRest) Rest
MNR : mem (ID1, U') NRest
MN : mem (ID1, U') Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
GUL : forall ID U1 CURest U2,
        select (ID, U1) CURest Needed -&gt; mem (ID, U2) CURest -&gt; false
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1109">
 &lt; <b>apply GUL to Ela3 MNR.</b>

Subgoal 1.7.2:

Variables: Known CU ID U KRest Needed NRest ERest Prf C ID1 Rest Prf1 U' C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addProofless ID1 C Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf1
CP2 : checkProof ((ID1, C)::KRest) Rest
MNR : mem (ID, U') NRest
MN : mem (ID, U') Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
M : mem (ID, C1) KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1110">
 &lt; <b>apply remove_all_mem_after to CP M.</b>

Subgoal 1.7.2:

Variables: Known CU ID U KRest Needed NRest ERest Prf C ID1 Rest Prf1 U' C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addProofless ID1 C Rest) CU (addLrupProof ID1 C Prf ERest) @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf1
CP2 : checkProof ((ID1, C)::KRest) Rest
MNR : mem (ID, U') NRest
MN : mem (ID, U') Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
M : mem (ID, C1) KRest
H3 : mem (ID, C1) Known
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1111">
 &lt; <b>search.</b>

Subgoal 1.8:

Variables: Known CU E ID U KRest Needed Rest C ID1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof (addProofless ID1 C Rest)
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID1 C Rest)
Ela : elaborate Known (addProofless ID1 C Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1112">
 &lt; <b>Is: case IsP.</b>

Subgoal 1.8:

Variables: Known CU E ID U KRest Needed Rest C ID1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (addProofless ID1 C Rest)
Ela : elaborate Known (addProofless ID1 C Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1113">
 &lt; <b>CP: case CP.</b>

Subgoal 1.8:

Variables: Known CU E ID U KRest Needed Rest C ID1 KRest1 Prf
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addProofless ID1 C Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : remove_all Known ID1 KRest1
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest1) Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1114">
 &lt; <b>apply remove_all_unique to CP Ela1.</b>

Subgoal 1.8:

Variables: Known CU E ID U KRest Needed Rest C ID1 Prf
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addProofless ID1 C Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1115">
 &lt; <b>MN: apply mem_after_select_before to Ela3 Mem.</b>

Subgoal 1.8:

Variables: Known CU E ID U KRest Needed Rest C ID1 Prf
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addProofless ID1 C Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MN : mem (ID, U) Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1116">
 &lt; <b>apply remove_all_is to _ CP.</b>

Subgoal 1.8:

Variables: Known CU E ID U KRest Needed Rest C ID1 Prf
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addProofless ID1 C Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MN : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1117">
 &lt; <b>apply good_clause_list_remove_all_add to _ CP with
     C = C.</b>

Subgoal 1.8:

Variables: Known CU E ID U KRest Needed Rest C ID1 Prf
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addProofless ID1 C Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MN : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1118">
 &lt; <b>M: apply IH to _ _ _ CP2 Ela2 MN.</b>

Subgoal 1.8:

Variables: Known CU E ID U KRest Needed Rest C ID1 Prf C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addProofless ID1 C Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MN : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
M : mem (ID, C1) ((ID1, C)::KRest)
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1119">
 &lt; <b>M: case M.</b>

Subgoal 1.8.1:

Variables: Known CU E U KRest Needed Rest C ID1 Prf
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addProofless ID1 C Rest) CU E @
Mem : mem (ID1, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MN : mem (ID1, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1120">
 &lt; <b>GUL: apply IH1 to _ _ _ CP2 Ela2.</b>

Subgoal 1.8.1:

Variables: Known CU E U KRest Needed Rest C ID1 Prf
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addProofless ID1 C Rest) CU E @
Mem : mem (ID1, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MN : mem (ID1, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
GUL : good_used_list Needed
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1121">
 &lt; <b>GUL: case GUL.</b>

Subgoal 1.8.1:

Variables: Known CU E U KRest Needed Rest C ID1 Prf
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addProofless ID1 C Rest) CU E @
Mem : mem (ID1, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MN : mem (ID1, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
GUL : forall ID U1 CURest U2,
        select (ID, U1) CURest Needed -&gt; mem (ID, U2) CURest -&gt; false
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="1122">
 &lt; <b>apply GUL to Ela3 Mem.</b>

Subgoal 1.8.2:

Variables: Known CU E ID U KRest Needed Rest C ID1 Prf C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addProofless ID1 C Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MN : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
M : mem (ID, C1) KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1123">
 &lt; <b>apply remove_all_mem_after to CP M.</b>

Subgoal 1.8.2:

Variables: Known CU E ID U KRest Needed Rest C ID1 Prf C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (addProofless ID1 C Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : remove_all Known ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP : remove_all Known ID1 KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID1, C)::KRest) Rest
MN : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID1, C)::KRest)
M : mem (ID, C1) KRest
H3 : mem (ID, C1) Known
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1124">
 &lt; <b>search.</b>

Subgoal 1.9:

Variables: Known ID U KRest C KRest2 Needed ERest To From NRest Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof (relocateClause From To Rest)
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Mem : mem (ID, U) ((From, needed)::NRest)
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1125">
 &lt; <b>Is: case IsP.</b>

Subgoal 1.9:

Variables: Known ID U KRest C KRest2 Needed ERest To From NRest Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Mem : mem (ID, U) ((From, needed)::NRest)
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1126">
 &lt; <b>CP: case CP.</b>

Subgoal 1.9.1:

Variables: Known ID U KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Mem : mem (ID, U) ((From, needed)::NRest)
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest1
CP2 : select (From, C1) KRest3 KRest1
CP3 : checkProof ((To, C1)::KRest3) Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1127">
 &lt; <b>Mem: case Mem.</b>

Subgoal 1.9.1.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest1
CP2 : select (From, C1) KRest3 KRest1
CP3 : checkProof ((To, C1)::KRest3) Rest
============================
 exists C, mem (From, C) Known
</pre>
<pre class="code extensibella"id="1128">
 &lt; <b>M: apply select_mem to CP2.</b>

Subgoal 1.9.1.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest1
CP2 : select (From, C1) KRest3 KRest1
CP3 : checkProof ((To, C1)::KRest3) Rest
M : mem (From, C1) KRest1
============================
 exists C, mem (From, C) Known
</pre>
<pre class="code extensibella"id="1129">
 &lt; <b>apply remove_all_mem_after to CP1 M.</b>

Subgoal 1.9.1.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest1
CP2 : select (From, C1) KRest3 KRest1
CP3 : checkProof ((To, C1)::KRest3) Rest
M : mem (From, C1) KRest1
H1 : mem (From, C1) Known
============================
 exists C, mem (From, C) Known
</pre>
<pre class="code extensibella"id="1130">
 &lt; <b>search.</b>

Subgoal 1.9.1.2:

Variables: Known ID U KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest1
CP2 : select (From, C1) KRest3 KRest1
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1131">
 &lt; <b>apply remove_all_unique to CP1 Ela1.</b>

Subgoal 1.9.1.2:

Variables: Known ID U KRest C KRest2 Needed ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1132">
 &lt; <b>GCLR: apply good_clause_list_remove_all to _ Ela1.</b>

Subgoal 1.9.1.2:

Variables: Known ID U KRest C KRest2 Needed ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1133">
 &lt; <b>apply good_clause_list_selects to _ Ela2 CP2.</b>

Subgoal 1.9.1.2:

Variables: Known ID U KRest Needed ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1134">
 &lt; <b>Mem': apply mem_after_select_before to Ela4 Mem.</b>

Subgoal 1.9.1.2:

Variables: Known ID U KRest Needed ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1135">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 1.9.1.2:

Variables: Known ID U KRest Needed ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1136">
 &lt; <b>apply select_is to _ Ela2.</b>

Subgoal 1.9.1.2:

Variables: Known ID U KRest Needed ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1137">
 &lt; <b>Is': apply select_is_picked to _ Ela2.</b>

Subgoal 1.9.1.2:

Variables: Known ID U KRest Needed ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_pair is_integer is_clause (From, C1)
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1138">
 &lt; <b>case Is'.</b>

Subgoal 1.9.1.2:

Variables: Known ID U KRest Needed ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1139">
 &lt; <b>GCLS: apply good_clause_list_select to GCLR Ela2.</b>

Subgoal 1.9.1.2:

Variables: Known ID U KRest Needed ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1140">
 &lt; <b>apply good_clause_list_add to GCLS _ with
     ID = To C = C1.</b>

Subgoal 1.9.1.2.1:

Variables: Known ID U KRest Needed ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
============================
 (exists C', mem (To, C') KRest3) -&gt; false
</pre>
<pre class="code extensibella"id="1141">
 &lt; <b>intros M.</b>

Subgoal 1.9.1.2.1:

Variables: Known ID U KRest Needed ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
M : exists C', mem (To, C') KRest3
============================
 false
</pre>
<pre class="code extensibella"id="1142">
 &lt; <b>M: case M.</b>

Subgoal 1.9.1.2.1:

Variables: Known ID U KRest Needed ERest To From NRest Rest C1 KRest3 C'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
M : mem (To, C') KRest3
============================
 false
</pre>
<pre class="code extensibella"id="1143">
 &lt; <b>M': apply mem_after_select_before to Ela2 M.</b>

Subgoal 1.9.1.2.1:

Variables: Known ID U KRest Needed ERest To From NRest Rest C1 KRest3 C'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
M : mem (To, C') KRest3
M' : mem (To, C') KRest
============================
 false
</pre>
<pre class="code extensibella"id="1144">
 &lt; <b>apply remove_all_no_mem to Ela1 M'.</b>

Subgoal 1.9.1.2:

Variables: Known ID U KRest Needed ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
H5 : good_clause_list ((To, C1)::KRest3)
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1145">
 &lt; <b>IsNeeded: apply elaboration_is_needed to _ _ _ Ela3.</b>

Subgoal 1.9.1.2:

Variables: Known ID U KRest Needed ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
H5 : good_clause_list ((To, C1)::KRest3)
IsNeeded : is_list (is_pair is_integer is_clauseUsedness) Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1146">
 &lt; <b>apply mem_needed_is to IsNeeded Mem'.</b>

Subgoal 1.9.1.2:

Variables: Known ID U KRest Needed ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
H5 : good_clause_list ((To, C1)::KRest3)
IsNeeded : is_list (is_pair is_integer is_clauseUsedness) Needed
H6 : is_pair is_integer is_clauseUsedness (ID, U)
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1147">
 &lt; <b>M: apply IH to _ _ _ CP3 Ela3 Mem'.</b>

Subgoal 1.9.1.2:

Variables: Known ID U KRest Needed ERest To From NRest Rest C1 KRest3 C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
H5 : good_clause_list ((To, C1)::KRest3)
IsNeeded : is_list (is_pair is_integer is_clauseUsedness) Needed
H6 : is_pair is_integer is_clauseUsedness (ID, U)
M : mem (ID, C2) ((To, C1)::KRest3)
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1148">
 &lt; <b>M: case M.</b>

Subgoal 1.9.1.2.2:

Variables: Known U KRest Needed ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (To, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (To, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
H5 : good_clause_list ((To, C1)::KRest3)
IsNeeded : is_list (is_pair is_integer is_clauseUsedness) Needed
H6 : is_pair is_integer is_clauseUsedness (To, U)
============================
 exists C, mem (To, C) Known
</pre>
<pre class="code extensibella"id="1149">
 &lt; <b>GUL: apply IH1 to _ _ _ CP3 Ela3.</b>

Subgoal 1.9.1.2.2:

Variables: Known U KRest Needed ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (To, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (To, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
H5 : good_clause_list ((To, C1)::KRest3)
IsNeeded : is_list (is_pair is_integer is_clauseUsedness) Needed
H6 : is_pair is_integer is_clauseUsedness (To, U)
GUL : good_used_list Needed
============================
 exists C, mem (To, C) Known
</pre>
<pre class="code extensibella"id="1150">
 &lt; <b>GUL: case GUL.</b>

Subgoal 1.9.1.2.2:

Variables: Known U KRest Needed ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (To, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (To, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
H5 : good_clause_list ((To, C1)::KRest3)
IsNeeded : is_list (is_pair is_integer is_clauseUsedness) Needed
H6 : is_pair is_integer is_clauseUsedness (To, U)
GUL : forall ID U1 CURest U2,
        select (ID, U1) CURest Needed -&gt; mem (ID, U2) CURest -&gt; false
============================
 exists C, mem (To, C) Known
</pre>
<pre class="code extensibella"id="1151">
 &lt; <b>apply GUL to Ela4 _.</b>

Subgoal 1.9.1.2.3:

Variables: Known ID U KRest Needed ERest To From NRest Rest C1 KRest3 C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
H5 : good_clause_list ((To, C1)::KRest3)
IsNeeded : is_list (is_pair is_integer is_clauseUsedness) Needed
H6 : is_pair is_integer is_clauseUsedness (ID, U)
M : mem (ID, C2) KRest3
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1152">
 &lt; <b>M': apply mem_after_select_before to Ela2 M.</b>

Subgoal 1.9.1.2.3:

Variables: Known ID U KRest Needed ERest To From NRest Rest C1 KRest3 C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
H5 : good_clause_list ((To, C1)::KRest3)
IsNeeded : is_list (is_pair is_integer is_clauseUsedness) Needed
H6 : is_pair is_integer is_clauseUsedness (ID, U)
M : mem (ID, C2) KRest3
M' : mem (ID, C2) KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1153">
 &lt; <b>apply remove_all_mem_after to Ela1 M'.</b>

Subgoal 1.9.1.2.3:

Variables: Known ID U KRest Needed ERest To From NRest Rest C1 KRest3 C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
H5 : good_clause_list ((To, C1)::KRest3)
IsNeeded : is_list (is_pair is_integer is_clauseUsedness) Needed
H6 : is_pair is_integer is_clauseUsedness (ID, U)
M : mem (ID, C2) KRest3
M' : mem (ID, C2) KRest
H7 : mem (ID, C2) Known
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1154">
 &lt; <b>search.</b>

Subgoal 1.9.2:

Variables: Known ID U KRest C KRest2 Needed ERest To NRest Rest C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause To To Rest) ((To, needed)::NRest) (relocateClause To To ERest) @
Mem : mem (ID, U) ((To, needed)::NRest)
Ela1 : remove_all Known To KRest
Ela2 : select (To, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer To
Is1 : is_integer To
Is2 : is_proof Rest
CP : mem (To, C1) Known
CP1 : checkProof Known Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1155">
 &lt; <b>M: apply select_mem to Ela2.</b>

Subgoal 1.9.2:

Variables: Known ID U KRest C KRest2 Needed ERest To NRest Rest C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause To To Rest) ((To, needed)::NRest) (relocateClause To To ERest) @
Mem : mem (ID, U) ((To, needed)::NRest)
Ela1 : remove_all Known To KRest
Ela2 : select (To, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer To
Is1 : is_integer To
Is2 : is_proof Rest
CP : mem (To, C1) Known
CP1 : checkProof Known Rest
M : mem (To, C) KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1156">
 &lt; <b>apply remove_all_no_mem to Ela1 M.</b>

Subgoal 1.10:

Variables: Known CU E ID U Rest ID1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof (relocateClause ID1 ID1 Rest)
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause ID1 ID1 Rest)
Ela : elaborate Known (relocateClause ID1 ID1 Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : elaborate Known Rest CU E *
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1157">
 &lt; <b>Is: case IsP.</b>

Subgoal 1.10:

Variables: Known CU E ID U Rest ID1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause ID1 ID1 Rest)
Ela : elaborate Known (relocateClause ID1 ID1 Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : elaborate Known Rest CU E *
Is : is_integer ID1
Is1 : is_integer ID1
Is2 : is_proof Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1158">
 &lt; <b>CP: case CP.</b>

Subgoal 1.10.1:

Variables: Known CU E ID U Rest ID1 KRest C KRest2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause ID1 ID1 Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : elaborate Known Rest CU E *
Is : is_integer ID1
Is1 : is_integer ID1
Is2 : is_proof Rest
CP : ID1 = ID1 -&gt; false
CP1 : remove_all Known ID1 KRest
CP2 : select (ID1, C) KRest2 KRest
CP3 : checkProof ((ID1, C)::KRest2) Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1159">
 &lt; <b>apply CP to _.</b>

Subgoal 1.10.2:

Variables: Known CU E ID U Rest ID1 C
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause ID1 ID1 Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : elaborate Known Rest CU E *
Is : is_integer ID1
Is1 : is_integer ID1
Is2 : is_proof Rest
CP : mem (ID1, C) Known
CP1 : checkProof Known Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1160">
 &lt; <b>apply IH to _ _ _ CP1 Ela1 Mem.</b>

Subgoal 1.10.2:

Variables: Known CU E ID U Rest ID1 C C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause ID1 ID1 Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : elaborate Known Rest CU E *
Is : is_integer ID1
Is1 : is_integer ID1
Is2 : is_proof Rest
CP : mem (ID1, C) Known
CP1 : checkProof Known Rest
H1 : mem (ID, C1) Known
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1161">
 &lt; <b>search.</b>

Subgoal 1.11:

Variables: Known E ID U KRest C KRest2 Needed NRest From Rest To
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof (relocateClause From To Rest)
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Mem : mem (ID, U) ((From, unknown)::NRest)
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1162">
 &lt; <b>Is: case IsP.</b>

Subgoal 1.11:

Variables: Known E ID U KRest C KRest2 Needed NRest From Rest To
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Mem : mem (ID, U) ((From, unknown)::NRest)
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1163">
 &lt; <b>CP: case CP.</b>

Subgoal 1.11.1:

Variables: Known E ID U KRest C KRest2 Needed NRest From Rest To KRest1 C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Mem : mem (ID, U) ((From, unknown)::NRest)
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest1
CP2 : select (From, C1) KRest3 KRest1
CP3 : checkProof ((To, C1)::KRest3) Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1164">
 &lt; <b>Mem: case Mem.</b>

Subgoal 1.11.1.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To KRest1 C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest1
CP2 : select (From, C1) KRest3 KRest1
CP3 : checkProof ((To, C1)::KRest3) Rest
============================
 exists C, mem (From, C) Known
</pre>
<pre class="code extensibella"id="1165">
 &lt; <b>M: apply select_mem to CP2.</b>

Subgoal 1.11.1.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To KRest1 C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest1
CP2 : select (From, C1) KRest3 KRest1
CP3 : checkProof ((To, C1)::KRest3) Rest
M : mem (From, C1) KRest1
============================
 exists C, mem (From, C) Known
</pre>
<pre class="code extensibella"id="1166">
 &lt; <b>apply remove_all_mem_after to CP1 M.</b>

Subgoal 1.11.1.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To KRest1 C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest1
CP2 : select (From, C1) KRest3 KRest1
CP3 : checkProof ((To, C1)::KRest3) Rest
M : mem (From, C1) KRest1
H1 : mem (From, C1) Known
============================
 exists C, mem (From, C) Known
</pre>
<pre class="code extensibella"id="1167">
 &lt; <b>search.</b>

Subgoal 1.11.1.2:

Variables: Known E ID U KRest C KRest2 Needed NRest From Rest To KRest1 C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest1
CP2 : select (From, C1) KRest3 KRest1
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1168">
 &lt; <b>apply remove_all_unique to CP1 Ela1.</b>

Subgoal 1.11.1.2:

Variables: Known E ID U KRest C KRest2 Needed NRest From Rest To C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1169">
 &lt; <b>GCLR: apply good_clause_list_remove_all to _ Ela1.</b>

Subgoal 1.11.1.2:

Variables: Known E ID U KRest C KRest2 Needed NRest From Rest To C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1170">
 &lt; <b>apply good_clause_list_selects to _ Ela2 CP2.</b>

Subgoal 1.11.1.2:

Variables: Known E ID U KRest Needed NRest From Rest To C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1171">
 &lt; <b>Mem': apply mem_after_select_before to Ela4 Mem.</b>

Subgoal 1.11.1.2:

Variables: Known E ID U KRest Needed NRest From Rest To C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1172">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 1.11.1.2:

Variables: Known E ID U KRest Needed NRest From Rest To C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1173">
 &lt; <b>apply select_is to _ Ela2.</b>

Subgoal 1.11.1.2:

Variables: Known E ID U KRest Needed NRest From Rest To C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1174">
 &lt; <b>Is': apply select_is_picked to _ Ela2.</b>

Subgoal 1.11.1.2:

Variables: Known E ID U KRest Needed NRest From Rest To C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_pair is_integer is_clause (From, C1)
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1175">
 &lt; <b>case Is'.</b>

Subgoal 1.11.1.2:

Variables: Known E ID U KRest Needed NRest From Rest To C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1176">
 &lt; <b>GCLS: apply good_clause_list_select to GCLR Ela2.</b>

Subgoal 1.11.1.2:

Variables: Known E ID U KRest Needed NRest From Rest To C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1177">
 &lt; <b>apply good_clause_list_add to GCLS _ with
     ID = To C = C1.</b>

Subgoal 1.11.1.2.1:

Variables: Known E ID U KRest Needed NRest From Rest To C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
============================
 (exists C', mem (To, C') KRest3) -&gt; false
</pre>
<pre class="code extensibella"id="1178">
 &lt; <b>intros M.</b>

Subgoal 1.11.1.2.1:

Variables: Known E ID U KRest Needed NRest From Rest To C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
M : exists C', mem (To, C') KRest3
============================
 false
</pre>
<pre class="code extensibella"id="1179">
 &lt; <b>M: case M.</b>

Subgoal 1.11.1.2.1:

Variables: Known E ID U KRest Needed NRest From Rest To C1 KRest3 C'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
M : mem (To, C') KRest3
============================
 false
</pre>
<pre class="code extensibella"id="1180">
 &lt; <b>M': apply mem_after_select_before to Ela2 M.</b>

Subgoal 1.11.1.2.1:

Variables: Known E ID U KRest Needed NRest From Rest To C1 KRest3 C'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
M : mem (To, C') KRest3
M' : mem (To, C') KRest
============================
 false
</pre>
<pre class="code extensibella"id="1181">
 &lt; <b>apply remove_all_no_mem to Ela1 M'.</b>

Subgoal 1.11.1.2:

Variables: Known E ID U KRest Needed NRest From Rest To C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
H5 : good_clause_list ((To, C1)::KRest3)
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1182">
 &lt; <b>IsNeeded: apply elaboration_is_needed to _ _ _ Ela3.</b>

Subgoal 1.11.1.2:

Variables: Known E ID U KRest Needed NRest From Rest To C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
H5 : good_clause_list ((To, C1)::KRest3)
IsNeeded : is_list (is_pair is_integer is_clauseUsedness) Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1183">
 &lt; <b>apply mem_needed_is to IsNeeded Mem'.</b>

Subgoal 1.11.1.2:

Variables: Known E ID U KRest Needed NRest From Rest To C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
H5 : good_clause_list ((To, C1)::KRest3)
IsNeeded : is_list (is_pair is_integer is_clauseUsedness) Needed
H6 : is_pair is_integer is_clauseUsedness (ID, U)
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1184">
 &lt; <b>M: apply IH to _ _ _ CP3 Ela3 Mem'.</b>

Subgoal 1.11.1.2:

Variables: Known E ID U KRest Needed NRest From Rest To C1 KRest3 C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
H5 : good_clause_list ((To, C1)::KRest3)
IsNeeded : is_list (is_pair is_integer is_clauseUsedness) Needed
H6 : is_pair is_integer is_clauseUsedness (ID, U)
M : mem (ID, C2) ((To, C1)::KRest3)
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1185">
 &lt; <b>M: case M.</b>

Subgoal 1.11.1.2.2:

Variables: Known E U KRest Needed NRest From Rest To C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (To, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (To, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
H5 : good_clause_list ((To, C1)::KRest3)
IsNeeded : is_list (is_pair is_integer is_clauseUsedness) Needed
H6 : is_pair is_integer is_clauseUsedness (To, U)
============================
 exists C, mem (To, C) Known
</pre>
<pre class="code extensibella"id="1186">
 &lt; <b>GUL: apply IH1 to _ _ _ CP3 Ela3.</b>

Subgoal 1.11.1.2.2:

Variables: Known E U KRest Needed NRest From Rest To C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (To, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (To, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
H5 : good_clause_list ((To, C1)::KRest3)
IsNeeded : is_list (is_pair is_integer is_clauseUsedness) Needed
H6 : is_pair is_integer is_clauseUsedness (To, U)
GUL : good_used_list Needed
============================
 exists C, mem (To, C) Known
</pre>
<pre class="code extensibella"id="1187">
 &lt; <b>GUL: case GUL.</b>

Subgoal 1.11.1.2.2:

Variables: Known E U KRest Needed NRest From Rest To C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (To, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (To, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
H5 : good_clause_list ((To, C1)::KRest3)
IsNeeded : is_list (is_pair is_integer is_clauseUsedness) Needed
H6 : is_pair is_integer is_clauseUsedness (To, U)
GUL : forall ID U1 CURest U2,
        select (ID, U1) CURest Needed -&gt; mem (ID, U2) CURest -&gt; false
============================
 exists C, mem (To, C) Known
</pre>
<pre class="code extensibella"id="1188">
 &lt; <b>apply GUL to Ela4 _.</b>

Subgoal 1.11.1.2.3:

Variables: Known E ID U KRest Needed NRest From Rest To C1 KRest3 C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
H5 : good_clause_list ((To, C1)::KRest3)
IsNeeded : is_list (is_pair is_integer is_clauseUsedness) Needed
H6 : is_pair is_integer is_clauseUsedness (ID, U)
M : mem (ID, C2) KRest3
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1189">
 &lt; <b>M': apply mem_after_select_before to Ela2 M.</b>

Subgoal 1.11.1.2.3:

Variables: Known E ID U KRest Needed NRest From Rest To C1 KRest3 C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
H5 : good_clause_list ((To, C1)::KRest3)
IsNeeded : is_list (is_pair is_integer is_clauseUsedness) Needed
H6 : is_pair is_integer is_clauseUsedness (ID, U)
M : mem (ID, C2) KRest3
M' : mem (ID, C2) KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1190">
 &lt; <b>apply remove_all_mem_after to Ela1 M'.</b>

Subgoal 1.11.1.2.3:

Variables: Known E ID U KRest Needed NRest From Rest To C1 KRest3 C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
Mem : mem (ID, U) NRest
GCLR : good_clause_list KRest
Mem' : mem (ID, U) Needed
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest3
H3 : is_integer From
H4 : is_clause C1
GCLS : good_clause_list KRest3
H5 : good_clause_list ((To, C1)::KRest3)
IsNeeded : is_list (is_pair is_integer is_clauseUsedness) Needed
H6 : is_pair is_integer is_clauseUsedness (ID, U)
M : mem (ID, C2) KRest3
M' : mem (ID, C2) KRest
H7 : mem (ID, C2) Known
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1191">
 &lt; <b>search.</b>

Subgoal 1.11.2:

Variables: Known E ID U KRest C KRest2 Needed NRest Rest To C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause To To Rest) ((To, unknown)::NRest) E @
Mem : mem (ID, U) ((To, unknown)::NRest)
Ela1 : remove_all Known To KRest
Ela2 : select (To, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer To
Is1 : is_integer To
Is2 : is_proof Rest
CP : mem (To, C1) Known
CP1 : checkProof Known Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1192">
 &lt; <b>M: apply select_mem to Ela2.</b>

Subgoal 1.11.2:

Variables: Known E ID U KRest C KRest2 Needed NRest Rest To C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (relocateClause To To Rest) ((To, unknown)::NRest) E @
Mem : mem (ID, U) ((To, unknown)::NRest)
Ela1 : remove_all Known To KRest
Ela2 : select (To, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer To
Is1 : is_integer To
Is2 : is_proof Rest
CP : mem (To, C1) Known
CP1 : checkProof Known Rest
M : mem (To, C) KRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1193">
 &lt; <b>apply remove_all_no_mem to Ela1 M.</b>

Subgoal 1.12:

Variables: Known CU E ID U Rest Comment
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof (commentProof Comment Rest)
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (commentProof Comment Rest)
Ela : elaborate Known (commentProof Comment Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : elaborate Known Rest CU E *
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1194">
 &lt; <b>Is: case IsP.</b>

Subgoal 1.12:

Variables: Known CU E ID U Rest Comment
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known (commentProof Comment Rest)
Ela : elaborate Known (commentProof Comment Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : elaborate Known Rest CU E *
Is : is_string Comment
Is1 : is_proof Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1195">
 &lt; <b>CP: case CP.</b>

Subgoal 1.12:

Variables: Known CU E ID U Rest Comment
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (commentProof Comment Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : elaborate Known Rest CU E *
Is : is_string Comment
Is1 : is_proof Rest
CP : checkProof Known Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1196">
 &lt; <b>apply IH to _ _ _ CP Ela1 _.</b>

Subgoal 1.12:

Variables: Known CU E ID U Rest Comment C
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (commentProof Comment Rest) CU E @
Mem : mem (ID, U) CU
Ela1 : elaborate Known Rest CU E *
Is : is_string Comment
Is1 : is_proof Rest
CP : checkProof Known Rest
H1 : mem (ID, C) Known
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1197">
 &lt; <b>search.</b>

Subgoal 1.13:

Variables: Known CU E ID U PT
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof &lt;unknown I proof&gt;
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known &lt;unknown I proof&gt;
Ela : elaborate Known &lt;unknown I proof&gt; CU E @
Mem : mem (ID, U) CU
Ela1 : Known |{proof}- &lt;unknown I proof&gt; ~~&gt; PT
Ela2 : elaborate Known PT CU E *
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1198">
 &lt; <b>Is: apply proj_proof_is to Ela1 IsP IsKnown _.</b>

Subgoal 1.13:

Variables: Known CU E ID U PT
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof &lt;unknown I proof&gt;
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known &lt;unknown I proof&gt;
Ela : elaborate Known &lt;unknown I proof&gt; CU E @
Mem : mem (ID, U) CU
Ela1 : Known |{proof}- &lt;unknown I proof&gt; ~~&gt; PT
Ela2 : elaborate Known PT CU E *
Is : is_proof PT
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1199">
 &lt; <b>CP': apply proj_checkProof to Ela1 CP _ _.</b>

Subgoal 1.13:

Variables: Known CU E ID U PT
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof &lt;unknown I proof&gt;
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known &lt;unknown I proof&gt;
Ela : elaborate Known &lt;unknown I proof&gt; CU E @
Mem : mem (ID, U) CU
Ela1 : Known |{proof}- &lt;unknown I proof&gt; ~~&gt; PT
Ela2 : elaborate Known PT CU E *
Is : is_proof PT
CP' : checkProof Known PT
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1200">
 &lt; <b>apply IH to _ _ _ _ Ela2 Mem.</b>

Subgoal 1.13:

Variables: Known CU E ID U PT C
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof &lt;unknown I proof&gt;
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
CP : checkProof Known &lt;unknown I proof&gt;
Ela : elaborate Known &lt;unknown I proof&gt; CU E @
Mem : mem (ID, U) CU
Ela1 : Known |{proof}- &lt;unknown I proof&gt; ~~&gt; PT
Ela2 : elaborate Known PT CU E *
Is : is_proof PT
CP' : checkProof Known PT
H1 : mem (ID, C) Known
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="1201">
 &lt; <b>search.</b>

Subgoal 2.1:

Variables: Known CU Needed NRest Prf ID FC
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof (endFrat ID FC)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known (endFrat ID FC)
Ela : elaborate Known (endFrat ID FC) CU (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID, needed) NRest Needed
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1202">
 &lt; <b>case IsP.</b>

Subgoal 2.1:

Variables: Known CU Needed NRest Prf ID FC
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known (endFrat ID FC)
Ela : elaborate Known (endFrat ID FC) CU (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID, needed) NRest Needed
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_finalClauses FC
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1203">
 &lt; <b>CP: case CP.</b>

Subgoal 2.1:

Variables: Known CU Needed NRest Prf ID FC KRest Prf1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (endFrat ID FC) CU (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID, needed) NRest Needed
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_finalClauses FC
CP : remove_all Known ID KRest
CP1 : rupProof Known emptyClause Prf1
CP2 : checkFinalClauses ((ID, emptyClause)::KRest) FC
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1204">
 &lt; <b>apply good_clause_list_remove_all_add to _ CP with
     C = emptyClause.</b>

Subgoal 2.1:

Variables: Known CU Needed NRest Prf ID FC KRest Prf1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (endFrat ID FC) CU (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID, needed) NRest Needed
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_finalClauses FC
CP : remove_all Known ID KRest
CP1 : rupProof Known emptyClause Prf1
CP2 : checkFinalClauses ((ID, emptyClause)::KRest) FC
H3 : good_clause_list ((ID, emptyClause)::KRest)
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1205">
 &lt; <b>apply remove_all_is to _ CP.</b>

Subgoal 2.1:

Variables: Known CU Needed NRest Prf ID FC KRest Prf1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (endFrat ID FC) CU (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID, needed) NRest Needed
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_finalClauses FC
CP : remove_all Known ID KRest
CP1 : rupProof Known emptyClause Prf1
CP2 : checkFinalClauses ((ID, emptyClause)::KRest) FC
H3 : good_clause_list ((ID, emptyClause)::KRest)
H4 : is_list (is_pair is_integer is_clause) KRest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1206">
 &lt; <b>apply endKnownClauses_good_used_list to _ _ _ CP2 Ela1.</b>

Subgoal 2.1:

Variables: Known CU Needed NRest Prf ID FC KRest Prf1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (endFrat ID FC) CU (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID, needed) NRest Needed
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_finalClauses FC
CP : remove_all Known ID KRest
CP1 : rupProof Known emptyClause Prf1
CP2 : checkFinalClauses ((ID, emptyClause)::KRest) FC
H3 : good_clause_list ((ID, emptyClause)::KRest)
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_used_list Needed
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1207">
 &lt; <b>apply good_used_list_select to _ Ela2.</b>

Subgoal 2.1:

Variables: Known CU Needed NRest Prf ID FC KRest Prf1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (endFrat ID FC) CU (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID, needed) NRest Needed
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_finalClauses FC
CP : remove_all Known ID KRest
CP1 : rupProof Known emptyClause Prf1
CP2 : checkFinalClauses ((ID, emptyClause)::KRest) FC
H3 : good_clause_list ((ID, emptyClause)::KRest)
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_used_list Needed
H6 : good_used_list NRest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1208">
 &lt; <b>apply makeUsed_good_used_list to _ Ela4.</b>

Subgoal 2.1:

Variables: Known CU Needed NRest Prf ID FC KRest Prf1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (endFrat ID FC) CU (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID, needed) NRest Needed
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_finalClauses FC
CP : remove_all Known ID KRest
CP1 : rupProof Known emptyClause Prf1
CP2 : checkFinalClauses ((ID, emptyClause)::KRest) FC
H3 : good_clause_list ((ID, emptyClause)::KRest)
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_used_list Needed
H6 : good_used_list NRest
H7 : good_used_list CU
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1209">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: Known CU Needed NRest Prf ID FC
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof (endFratPrf ID Prf FC)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known (endFratPrf ID Prf FC)
Ela : elaborate Known (endFratPrf ID Prf FC) CU (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID, needed) NRest Needed
Ela3 : makeUsed NRest Prf CU
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1210">
 &lt; <b>case IsP.</b>

Subgoal 2.2:

Variables: Known CU Needed NRest Prf ID FC
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known (endFratPrf ID Prf FC)
Ela : elaborate Known (endFratPrf ID Prf FC) CU (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID, needed) NRest Needed
Ela3 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_list is_integer Prf
H3 : is_finalClauses FC
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1211">
 &lt; <b>CP: case CP.</b>

Subgoal 2.2:

Variables: Known CU Needed NRest Prf ID FC KRest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (endFratPrf ID Prf FC) CU (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID, needed) NRest Needed
Ela3 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_list is_integer Prf
H3 : is_finalClauses FC
CP : remove_all Known ID KRest
CP1 : rupProof Known emptyClause Prf
CP2 : checkFinalClauses ((ID, emptyClause)::KRest) FC
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1212">
 &lt; <b>apply good_clause_list_remove_all_add to _ CP with
     C = emptyClause.</b>

Subgoal 2.2:

Variables: Known CU Needed NRest Prf ID FC KRest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (endFratPrf ID Prf FC) CU (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID, needed) NRest Needed
Ela3 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_list is_integer Prf
H3 : is_finalClauses FC
CP : remove_all Known ID KRest
CP1 : rupProof Known emptyClause Prf
CP2 : checkFinalClauses ((ID, emptyClause)::KRest) FC
H4 : good_clause_list ((ID, emptyClause)::KRest)
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1213">
 &lt; <b>apply remove_all_is to _ CP.</b>

Subgoal 2.2:

Variables: Known CU Needed NRest Prf ID FC KRest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (endFratPrf ID Prf FC) CU (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID, needed) NRest Needed
Ela3 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_list is_integer Prf
H3 : is_finalClauses FC
CP : remove_all Known ID KRest
CP1 : rupProof Known emptyClause Prf
CP2 : checkFinalClauses ((ID, emptyClause)::KRest) FC
H4 : good_clause_list ((ID, emptyClause)::KRest)
H5 : is_list (is_pair is_integer is_clause) KRest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1214">
 &lt; <b>apply endKnownClauses_good_used_list to _ _ _ CP2 Ela1.</b>

Subgoal 2.2:

Variables: Known CU Needed NRest Prf ID FC KRest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (endFratPrf ID Prf FC) CU (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID, needed) NRest Needed
Ela3 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_list is_integer Prf
H3 : is_finalClauses FC
CP : remove_all Known ID KRest
CP1 : rupProof Known emptyClause Prf
CP2 : checkFinalClauses ((ID, emptyClause)::KRest) FC
H4 : good_clause_list ((ID, emptyClause)::KRest)
H5 : is_list (is_pair is_integer is_clause) KRest
H6 : good_used_list Needed
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1215">
 &lt; <b>apply good_used_list_select to _ Ela2.</b>

Subgoal 2.2:

Variables: Known CU Needed NRest Prf ID FC KRest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (endFratPrf ID Prf FC) CU (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID, needed) NRest Needed
Ela3 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_list is_integer Prf
H3 : is_finalClauses FC
CP : remove_all Known ID KRest
CP1 : rupProof Known emptyClause Prf
CP2 : checkFinalClauses ((ID, emptyClause)::KRest) FC
H4 : good_clause_list ((ID, emptyClause)::KRest)
H5 : is_list (is_pair is_integer is_clause) KRest
H6 : good_used_list Needed
H7 : good_used_list NRest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1216">
 &lt; <b>apply makeUsed_good_used_list to _ Ela3.</b>

Subgoal 2.2:

Variables: Known CU Needed NRest Prf ID FC KRest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (endFratPrf ID Prf FC) CU (emptyLrat ID Prf) @
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID, needed) NRest Needed
Ela3 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_list is_integer Prf
H3 : is_finalClauses FC
CP : remove_all Known ID KRest
CP1 : rupProof Known emptyClause Prf
CP2 : checkFinalClauses ((ID, emptyClause)::KRest) FC
H4 : good_clause_list ((ID, emptyClause)::KRest)
H5 : is_list (is_pair is_integer is_clause) KRest
H6 : good_used_list Needed
H7 : good_used_list NRest
H8 : good_used_list CU
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1217">
 &lt; <b>search.</b>

Subgoal 2.3:

Variables: Known E KRest Needed ID Rest C
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof (deleteFrat ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known (deleteFrat ID C Rest)
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
============================
 good_used_list ((ID, unknown)::Needed)
</pre>
<pre class="code extensibella"id="1218">
 &lt; <b>case IsP.</b>

Subgoal 2.3:

Variables: Known E KRest Needed ID Rest C
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known (deleteFrat ID C Rest)
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
============================
 good_used_list ((ID, unknown)::Needed)
</pre>
<pre class="code extensibella"id="1219">
 &lt; <b>CP: case CP.</b>

Subgoal 2.3:

Variables: Known E KRest Needed ID Rest C KRest1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : select (ID, C) KRest1 Known
CP1 : checkProof KRest1 Rest
============================
 good_used_list ((ID, unknown)::Needed)
</pre>
<pre class="code extensibella"id="1220">
 &lt; <b>apply good_clause_list_selects to _ CP Ela1.</b>

Subgoal 2.3:

Variables: Known E KRest Needed ID Rest C
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
============================
 good_used_list ((ID, unknown)::Needed)
</pre>
<pre class="code extensibella"id="1221">
 &lt; <b>apply select_is to _ Ela1.</b>

Subgoal 2.3:

Variables: Known E KRest Needed ID Rest C
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H4 : is_list (is_pair is_integer is_clause) KRest
============================
 good_used_list ((ID, unknown)::Needed)
</pre>
<pre class="code extensibella"id="1222">
 &lt; <b>apply good_clause_list_select to _ CP.</b>

Subgoal 2.3:

Variables: Known E KRest Needed ID Rest C
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list KRest
============================
 good_used_list ((ID, unknown)::Needed)
</pre>
<pre class="code extensibella"id="1223">
 &lt; <b>GUL: apply IH1 to _ _ _ CP1 Ela2.</b>

Subgoal 2.3:

Variables: Known E KRest Needed ID Rest C
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list KRest
GUL : good_used_list Needed
============================
 good_used_list ((ID, unknown)::Needed)
</pre>
<pre class="code extensibella"id="1224">
 &lt; <b>unfold .</b>

Subgoal 2.3:

Variables: Known E KRest Needed ID Rest C
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list KRest
GUL : good_used_list Needed
============================
 forall ID1 U1 CURest U2,
   select (ID1, U1) CURest ((ID, unknown)::Needed) -&gt; mem (ID1, U2) CURest -&gt; false
</pre>
<pre class="code extensibella"id="1225">
 &lt; <b>intros S M.</b>

Subgoal 2.3:

Variables: Known E KRest Needed ID Rest C ID1 U1 CURest U2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list KRest
GUL : good_used_list Needed
S : select (ID1, U1) CURest ((ID, unknown)::Needed)
M : mem (ID1, U2) CURest
============================
 false
</pre>
<pre class="code extensibella"id="1226">
 &lt; <b>S: case S.</b>

Subgoal 2.3.1:

Variables: Known E KRest Needed ID Rest C U2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list KRest
GUL : good_used_list Needed
M : mem (ID, U2) Needed
============================
 false
</pre>
<pre class="code extensibella"id="1227">
 &lt; <b>MKR: apply IH to _ _ _ CP1 Ela2 M.</b>

Subgoal 2.3.1:

Variables: Known E KRest Needed ID Rest C U2 C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list KRest
GUL : good_used_list Needed
M : mem (ID, U2) Needed
MKR : mem (ID, C1) KRest
============================
 false
</pre>
<pre class="code extensibella"id="1228">
 &lt; <b>GCL: case GCL.</b>

Subgoal 2.3.1:

Variables: Known E KRest Needed ID Rest C U2 C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list KRest
GUL : good_used_list Needed
M : mem (ID, U2) Needed
MKR : mem (ID, C1) KRest
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest Known -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="1229">
 &lt; <b>apply GCL to Ela1 MKR.</b>

Subgoal 2.3.2:

Variables: Known E KRest Needed ID Rest C ID1 U1 U2 L1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list KRest
GUL : good_used_list Needed
M : mem (ID1, U2) ((ID, unknown)::L1)
S : select (ID1, U1) L1 Needed
============================
 false
</pre>
<pre class="code extensibella"id="1230">
 &lt; <b>M: case M.</b>

Subgoal 2.3.2.1:

Variables: Known E KRest Needed ID Rest C U1 L1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list KRest
GUL : good_used_list Needed
S : select (ID, U1) L1 Needed
============================
 false
</pre>
<pre class="code extensibella"id="1231">
 &lt; <b>Mem: apply select_mem to S.</b>

Subgoal 2.3.2.1:

Variables: Known E KRest Needed ID Rest C U1 L1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list KRest
GUL : good_used_list Needed
S : select (ID, U1) L1 Needed
Mem : mem (ID, U1) Needed
============================
 false
</pre>
<pre class="code extensibella"id="1232">
 &lt; <b>MKR: apply IH to _ _ _ CP1 Ela2 Mem.</b>

Subgoal 2.3.2.1:

Variables: Known E KRest Needed ID Rest C U1 L1 C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list KRest
GUL : good_used_list Needed
S : select (ID, U1) L1 Needed
Mem : mem (ID, U1) Needed
MKR : mem (ID, C1) KRest
============================
 false
</pre>
<pre class="code extensibella"id="1233">
 &lt; <b>GCL: case GCL.</b>

Subgoal 2.3.2.1:

Variables: Known E KRest Needed ID Rest C U1 L1 C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list KRest
GUL : good_used_list Needed
S : select (ID, U1) L1 Needed
Mem : mem (ID, U1) Needed
MKR : mem (ID, C1) KRest
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest Known -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="1234">
 &lt; <b>apply GCL to Ela1 MKR.</b>

Subgoal 2.3.2.2:

Variables: Known E KRest Needed ID Rest C ID1 U1 U2 L1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list KRest
GUL : good_used_list Needed
S : select (ID1, U1) L1 Needed
M : mem (ID1, U2) L1
============================
 false
</pre>
<pre class="code extensibella"id="1235">
 &lt; <b>GUL: case GUL.</b>

Subgoal 2.3.2.2:

Variables: Known E KRest Needed ID Rest C ID1 U1 U2 L1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list KRest
S : select (ID1, U1) L1 Needed
M : mem (ID1, U2) L1
GUL : forall ID U1 CURest U2,
        select (ID, U1) CURest Needed -&gt; mem (ID, U2) CURest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="1236">
 &lt; <b>apply GUL to S M.</b>

Subgoal 2.4:

Variables: Known E C KRest Needed ID Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof (deleteLratProof ID Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known (deleteLratProof ID Rest)
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
============================
 good_used_list ((ID, unknown)::Needed)
</pre>
<pre class="code extensibella"id="1237">
 &lt; <b>case IsP.</b>

Subgoal 2.4:

Variables: Known E C KRest Needed ID Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known (deleteLratProof ID Rest)
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_proof Rest
============================
 good_used_list ((ID, unknown)::Needed)
</pre>
<pre class="code extensibella"id="1238">
 &lt; <b>CP: case CP.</b>

Subgoal 2.4:

Variables: Known E C KRest Needed ID Rest C1 KRest1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_proof Rest
CP : select (ID, C1) KRest1 Known
CP1 : checkProof KRest1 Rest
============================
 good_used_list ((ID, unknown)::Needed)
</pre>
<pre class="code extensibella"id="1239">
 &lt; <b>apply good_clause_list_selects to _ CP Ela1.</b>

Subgoal 2.4:

Variables: Known E C KRest Needed ID Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
============================
 good_used_list ((ID, unknown)::Needed)
</pre>
<pre class="code extensibella"id="1240">
 &lt; <b>apply good_clause_list_select to _ Ela1.</b>

Subgoal 2.4:

Variables: Known E C KRest Needed ID Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H3 : good_clause_list KRest
============================
 good_used_list ((ID, unknown)::Needed)
</pre>
<pre class="code extensibella"id="1241">
 &lt; <b>apply select_is to _ Ela1.</b>

Subgoal 2.4:

Variables: Known E C KRest Needed ID Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H3 : good_clause_list KRest
H4 : is_list (is_pair is_integer is_clause) KRest
============================
 good_used_list ((ID, unknown)::Needed)
</pre>
<pre class="code extensibella"id="1242">
 &lt; <b>GUL: apply IH1 to _ _ _ CP1 Ela2.</b>

Subgoal 2.4:

Variables: Known E C KRest Needed ID Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H3 : good_clause_list KRest
H4 : is_list (is_pair is_integer is_clause) KRest
GUL : good_used_list Needed
============================
 good_used_list ((ID, unknown)::Needed)
</pre>
<pre class="code extensibella"id="1243">
 &lt; <b>unfold .</b>

Subgoal 2.4:

Variables: Known E C KRest Needed ID Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H3 : good_clause_list KRest
H4 : is_list (is_pair is_integer is_clause) KRest
GUL : good_used_list Needed
============================
 forall ID1 U1 CURest U2,
   select (ID1, U1) CURest ((ID, unknown)::Needed) -&gt; mem (ID1, U2) CURest -&gt; false
</pre>
<pre class="code extensibella"id="1244">
 &lt; <b>intros S M.</b>

Subgoal 2.4:

Variables: Known E C KRest Needed ID Rest ID1 U1 CURest U2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H3 : good_clause_list KRest
H4 : is_list (is_pair is_integer is_clause) KRest
GUL : good_used_list Needed
S : select (ID1, U1) CURest ((ID, unknown)::Needed)
M : mem (ID1, U2) CURest
============================
 false
</pre>
<pre class="code extensibella"id="1245">
 &lt; <b>S: case S.</b>

Subgoal 2.4.1:

Variables: Known E C KRest Needed ID Rest U2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H3 : good_clause_list KRest
H4 : is_list (is_pair is_integer is_clause) KRest
GUL : good_used_list Needed
M : mem (ID, U2) Needed
============================
 false
</pre>
<pre class="code extensibella"id="1246">
 &lt; <b>MKR: apply IH to _ _ _ CP1 Ela2 M.</b>

Subgoal 2.4.1:

Variables: Known E C KRest Needed ID Rest U2 C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H3 : good_clause_list KRest
H4 : is_list (is_pair is_integer is_clause) KRest
GUL : good_used_list Needed
M : mem (ID, U2) Needed
MKR : mem (ID, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="1247">
 &lt; <b>GCL: case GCL.</b>

Subgoal 2.4.1:

Variables: Known E C KRest Needed ID Rest U2 C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H3 : good_clause_list KRest
H4 : is_list (is_pair is_integer is_clause) KRest
GUL : good_used_list Needed
M : mem (ID, U2) Needed
MKR : mem (ID, C2) KRest
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest Known -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="1248">
 &lt; <b>apply GCL to Ela1 MKR.</b>

Subgoal 2.4.2:

Variables: Known E C KRest Needed ID Rest ID1 U1 U2 L1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H3 : good_clause_list KRest
H4 : is_list (is_pair is_integer is_clause) KRest
GUL : good_used_list Needed
M : mem (ID1, U2) ((ID, unknown)::L1)
S : select (ID1, U1) L1 Needed
============================
 false
</pre>
<pre class="code extensibella"id="1249">
 &lt; <b>M: case M.</b>

Subgoal 2.4.2.1:

Variables: Known E C KRest Needed ID Rest U1 L1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H3 : good_clause_list KRest
H4 : is_list (is_pair is_integer is_clause) KRest
GUL : good_used_list Needed
S : select (ID, U1) L1 Needed
============================
 false
</pre>
<pre class="code extensibella"id="1250">
 &lt; <b>Mem: apply select_mem to S.</b>

Subgoal 2.4.2.1:

Variables: Known E C KRest Needed ID Rest U1 L1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H3 : good_clause_list KRest
H4 : is_list (is_pair is_integer is_clause) KRest
GUL : good_used_list Needed
S : select (ID, U1) L1 Needed
Mem : mem (ID, U1) Needed
============================
 false
</pre>
<pre class="code extensibella"id="1251">
 &lt; <b>MKR: apply IH to _ _ _ CP1 Ela2 Mem.</b>

Subgoal 2.4.2.1:

Variables: Known E C KRest Needed ID Rest U1 L1 C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H3 : good_clause_list KRest
H4 : is_list (is_pair is_integer is_clause) KRest
GUL : good_used_list Needed
S : select (ID, U1) L1 Needed
Mem : mem (ID, U1) Needed
MKR : mem (ID, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="1252">
 &lt; <b>GCL: case GCL.</b>

Subgoal 2.4.2.1:

Variables: Known E C KRest Needed ID Rest U1 L1 C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H3 : good_clause_list KRest
H4 : is_list (is_pair is_integer is_clause) KRest
GUL : good_used_list Needed
S : select (ID, U1) L1 Needed
Mem : mem (ID, U1) Needed
MKR : mem (ID, C2) KRest
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest Known -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="1253">
 &lt; <b>apply GCL to Ela1 MKR.</b>

Subgoal 2.4.2.2:

Variables: Known E C KRest Needed ID Rest ID1 U1 U2 L1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H3 : good_clause_list KRest
H4 : is_list (is_pair is_integer is_clause) KRest
GUL : good_used_list Needed
S : select (ID1, U1) L1 Needed
M : mem (ID1, U2) L1
============================
 false
</pre>
<pre class="code extensibella"id="1254">
 &lt; <b>GUL: case GUL.</b>

Subgoal 2.4.2.2:

Variables: Known E C KRest Needed ID Rest ID1 U1 U2 L1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed) E @
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed E *
H1 : is_integer ID
H2 : is_proof Rest
CP : select (ID, C) KRest Known
CP1 : checkProof KRest Rest
H3 : good_clause_list KRest
H4 : is_list (is_pair is_integer is_clause) KRest
S : select (ID1, U1) L1 Needed
M : mem (ID1, U2) L1
GUL : forall ID U1 CURest U2,
        select (ID, U1) CURest Needed -&gt; mem (ID, U2) CURest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="1255">
 &lt; <b>apply GUL to S M.</b>

Subgoal 2.5:

Variables: Known CU KRest Needed NRest ERest Prf C ID Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof (addLrupProof ID C Prf Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1256">
 &lt; <b>case IsP.</b>

Subgoal 2.5:

Variables: Known CU KRest Needed NRest ERest Prf C ID Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_clause C
H3 : is_list is_integer Prf
H4 : is_proof Rest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1257">
 &lt; <b>CP: case CP.</b>

Subgoal 2.5:

Variables: Known CU KRest Needed NRest ERest Prf C ID Rest KRest1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_clause C
H3 : is_list is_integer Prf
H4 : is_proof Rest
CP : remove_all Known ID KRest1
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID, C)::KRest1) Rest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1258">
 &lt; <b>apply remove_all_is to _ CP.</b>

Subgoal 2.5:

Variables: Known CU KRest Needed NRest ERest Prf C ID Rest KRest1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_clause C
H3 : is_list is_integer Prf
H4 : is_proof Rest
CP : remove_all Known ID KRest1
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID, C)::KRest1) Rest
H5 : is_list (is_pair is_integer is_clause) KRest1
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1259">
 &lt; <b>apply good_clause_list_remove_all_add to _ CP with
     C = C.</b>

Subgoal 2.5:

Variables: Known CU KRest Needed NRest ERest Prf C ID Rest KRest1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_clause C
H3 : is_list is_integer Prf
H4 : is_proof Rest
CP : remove_all Known ID KRest1
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID, C)::KRest1) Rest
H5 : is_list (is_pair is_integer is_clause) KRest1
H6 : good_clause_list ((ID, C)::KRest1)
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1260">
 &lt; <b>apply remove_all_unique to CP Ela1.</b>

Subgoal 2.5:

Variables: Known CU KRest Needed NRest ERest Prf C ID Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_clause C
H3 : is_list is_integer Prf
H4 : is_proof Rest
CP : remove_all Known ID KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
H5 : is_list (is_pair is_integer is_clause) KRest
H6 : good_clause_list ((ID, C)::KRest)
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1261">
 &lt; <b>GUL: apply IH1 to _ _ _ CP2 Ela2.</b>

Subgoal 2.5:

Variables: Known CU KRest Needed NRest ERest Prf C ID Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_clause C
H3 : is_list is_integer Prf
H4 : is_proof Rest
CP : remove_all Known ID KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
H5 : is_list (is_pair is_integer is_clause) KRest
H6 : good_clause_list ((ID, C)::KRest)
GUL : good_used_list Needed
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1262">
 &lt; <b>apply good_used_list_select to _ Ela3.</b>

Subgoal 2.5:

Variables: Known CU KRest Needed NRest ERest Prf C ID Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_clause C
H3 : is_list is_integer Prf
H4 : is_proof Rest
CP : remove_all Known ID KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
H5 : is_list (is_pair is_integer is_clause) KRest
H6 : good_clause_list ((ID, C)::KRest)
GUL : good_used_list Needed
H7 : good_used_list NRest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1263">
 &lt; <b>apply makeUsed_good_used_list to _ Ela4.</b>

Subgoal 2.5:

Variables: Known CU KRest Needed NRest ERest Prf C ID Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_clause C
H3 : is_list is_integer Prf
H4 : is_proof Rest
CP : remove_all Known ID KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
H5 : is_list (is_pair is_integer is_clause) KRest
H6 : good_clause_list ((ID, C)::KRest)
GUL : good_used_list Needed
H7 : good_used_list NRest
H8 : good_used_list CU
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1264">
 &lt; <b>search.</b>

Subgoal 2.6:

Variables: Known CU E KRest Needed Rest Prf C ID
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof (addLrupProof ID C Prf Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1265">
 &lt; <b>case IsP.</b>

Subgoal 2.6:

Variables: Known CU E KRest Needed Rest Prf C ID
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
H1 : is_integer ID
H2 : is_clause C
H3 : is_list is_integer Prf
H4 : is_proof Rest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1266">
 &lt; <b>CP: case CP.</b>

Subgoal 2.6:

Variables: Known CU E KRest Needed Rest Prf C ID KRest1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
H1 : is_integer ID
H2 : is_clause C
H3 : is_list is_integer Prf
H4 : is_proof Rest
CP : remove_all Known ID KRest1
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID, C)::KRest1) Rest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1267">
 &lt; <b>apply remove_all_is to _ CP.</b>

Subgoal 2.6:

Variables: Known CU E KRest Needed Rest Prf C ID KRest1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
H1 : is_integer ID
H2 : is_clause C
H3 : is_list is_integer Prf
H4 : is_proof Rest
CP : remove_all Known ID KRest1
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID, C)::KRest1) Rest
H5 : is_list (is_pair is_integer is_clause) KRest1
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1268">
 &lt; <b>apply remove_all_unique to CP Ela1.</b>

Subgoal 2.6:

Variables: Known CU E KRest Needed Rest Prf C ID
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
H1 : is_integer ID
H2 : is_clause C
H3 : is_list is_integer Prf
H4 : is_proof Rest
CP : remove_all Known ID KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
H5 : is_list (is_pair is_integer is_clause) KRest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1269">
 &lt; <b>apply good_clause_list_remove_all_add to _ CP with
     C = C.</b>

Subgoal 2.6:

Variables: Known CU E KRest Needed Rest Prf C ID
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
H1 : is_integer ID
H2 : is_clause C
H3 : is_list is_integer Prf
H4 : is_proof Rest
CP : remove_all Known ID KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
H5 : is_list (is_pair is_integer is_clause) KRest
H6 : good_clause_list ((ID, C)::KRest)
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1270">
 &lt; <b>GUL: apply IH1 to _ _ _ CP2 Ela2.</b>

Subgoal 2.6:

Variables: Known CU E KRest Needed Rest Prf C ID
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
H1 : is_integer ID
H2 : is_clause C
H3 : is_list is_integer Prf
H4 : is_proof Rest
CP : remove_all Known ID KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
H5 : is_list (is_pair is_integer is_clause) KRest
H6 : good_clause_list ((ID, C)::KRest)
GUL : good_used_list Needed
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1271">
 &lt; <b>apply good_used_list_select to _ Ela3.</b>

Subgoal 2.6:

Variables: Known CU E KRest Needed Rest Prf C ID
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
H1 : is_integer ID
H2 : is_clause C
H3 : is_list is_integer Prf
H4 : is_proof Rest
CP : remove_all Known ID KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
H5 : is_list (is_pair is_integer is_clause) KRest
H6 : good_clause_list ((ID, C)::KRest)
GUL : good_used_list Needed
H7 : good_used_list CU
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1272">
 &lt; <b>search.</b>

Subgoal 2.7:

Variables: Known CU KRest Needed NRest ERest Prf C ID Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof (addProofless ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1273">
 &lt; <b>case IsP.</b>

Subgoal 2.7:

Variables: Known CU KRest Needed NRest ERest Prf C ID Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1274">
 &lt; <b>CP: case CP.</b>

Subgoal 2.7:

Variables: Known CU KRest Needed NRest ERest Prf C ID Rest KRest1 Prf1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : remove_all Known ID KRest1
CP1 : rupProof Known C Prf1
CP2 : checkProof ((ID, C)::KRest1) Rest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1275">
 &lt; <b>apply remove_all_is to _ CP.</b>

Subgoal 2.7:

Variables: Known CU KRest Needed NRest ERest Prf C ID Rest KRest1 Prf1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : remove_all Known ID KRest1
CP1 : rupProof Known C Prf1
CP2 : checkProof ((ID, C)::KRest1) Rest
H4 : is_list (is_pair is_integer is_clause) KRest1
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1276">
 &lt; <b>apply good_clause_list_remove_all_add to _ CP with
     C = C.</b>

Subgoal 2.7:

Variables: Known CU KRest Needed NRest ERest Prf C ID Rest KRest1 Prf1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : remove_all Known ID KRest1
CP1 : rupProof Known C Prf1
CP2 : checkProof ((ID, C)::KRest1) Rest
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : good_clause_list ((ID, C)::KRest1)
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1277">
 &lt; <b>apply remove_all_unique to CP Ela1.</b>

Subgoal 2.7:

Variables: Known CU KRest Needed NRest ERest Prf C ID Rest Prf1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : remove_all Known ID KRest
CP1 : rupProof Known C Prf1
CP2 : checkProof ((ID, C)::KRest) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list ((ID, C)::KRest)
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1278">
 &lt; <b>GUL: apply IH1 to _ _ _ CP2 Ela2.</b>

Subgoal 2.7:

Variables: Known CU KRest Needed NRest ERest Prf C ID Rest Prf1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : remove_all Known ID KRest
CP1 : rupProof Known C Prf1
CP2 : checkProof ((ID, C)::KRest) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list ((ID, C)::KRest)
GUL : good_used_list Needed
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1279">
 &lt; <b>apply good_used_list_select to _ Ela3.</b>

Subgoal 2.7:

Variables: Known CU KRest Needed NRest ERest Prf C ID Rest Prf1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : remove_all Known ID KRest
CP1 : rupProof Known C Prf1
CP2 : checkProof ((ID, C)::KRest) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list ((ID, C)::KRest)
GUL : good_used_list Needed
H6 : good_used_list NRest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1280">
 &lt; <b>apply makeUsed_good_used_list to _ Ela5.</b>

Subgoal 2.7:

Variables: Known CU KRest Needed NRest ERest Prf C ID Rest Prf1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : remove_all Known ID KRest
CP1 : rupProof Known C Prf1
CP2 : checkProof ((ID, C)::KRest) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list ((ID, C)::KRest)
GUL : good_used_list Needed
H6 : good_used_list NRest
H7 : good_used_list CU
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1281">
 &lt; <b>search.</b>

Subgoal 2.8:

Variables: Known CU E KRest Needed Rest C ID
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof (addProofless ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1282">
 &lt; <b>case IsP.</b>

Subgoal 2.8:

Variables: Known CU E KRest Needed Rest C ID
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1283">
 &lt; <b>CP: case CP.</b>

Subgoal 2.8:

Variables: Known CU E KRest Needed Rest C ID KRest1 Prf
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : remove_all Known ID KRest1
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID, C)::KRest1) Rest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1284">
 &lt; <b>apply remove_all_is to _ CP.</b>

Subgoal 2.8:

Variables: Known CU E KRest Needed Rest C ID KRest1 Prf
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : remove_all Known ID KRest1
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID, C)::KRest1) Rest
H4 : is_list (is_pair is_integer is_clause) KRest1
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1285">
 &lt; <b>apply remove_all_unique to CP Ela1.</b>

Subgoal 2.8:

Variables: Known CU E KRest Needed Rest C ID Prf
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : remove_all Known ID KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1286">
 &lt; <b>apply good_clause_list_remove_all_add to _ CP with
     C = C.</b>

Subgoal 2.8:

Variables: Known CU E KRest Needed Rest C ID Prf
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : remove_all Known ID KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list ((ID, C)::KRest)
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1287">
 &lt; <b>GUL: apply IH1 to _ _ _ CP2 Ela2.</b>

Subgoal 2.8:

Variables: Known CU E KRest Needed Rest C ID Prf
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : remove_all Known ID KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list ((ID, C)::KRest)
GUL : good_used_list Needed
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1288">
 &lt; <b>apply good_used_list_select to _ Ela3.</b>

Subgoal 2.8:

Variables: Known CU E KRest Needed Rest C ID Prf
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (addProofless ID C Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP : remove_all Known ID KRest
CP1 : rupProof Known C Prf
CP2 : checkProof ((ID, C)::KRest) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list ((ID, C)::KRest)
GUL : good_used_list Needed
H6 : good_used_list CU
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1289">
 &lt; <b>search.</b>

Subgoal 2.9:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof (relocateClause From To Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
============================
 good_used_list ((From, needed)::NRest)
</pre>
<pre class="code extensibella"id="1290">
 &lt; <b>case IsP.</b>

Subgoal 2.9:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
============================
 good_used_list ((From, needed)::NRest)
</pre>
<pre class="code extensibella"id="1291">
 &lt; <b>CP: case CP.</b>

Subgoal 2.9.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest1
CP2 : select (From, C1) KRest3 KRest1
CP3 : checkProof ((To, C1)::KRest3) Rest
============================
 good_used_list ((From, needed)::NRest)
</pre>
<pre class="code extensibella"id="1292">
 &lt; <b>apply remove_all_unique to CP1 Ela1.</b>

Subgoal 2.9.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
============================
 good_used_list ((From, needed)::NRest)
</pre>
<pre class="code extensibella"id="1293">
 &lt; <b>apply remove_all_is to _ CP1.</b>

Subgoal 2.9.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
============================
 good_used_list ((From, needed)::NRest)
</pre>
<pre class="code extensibella"id="1294">
 &lt; <b>GCL': apply good_clause_list_remove_all to _ Ela1.</b>

Subgoal 2.9.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
============================
 good_used_list ((From, needed)::NRest)
</pre>
<pre class="code extensibella"id="1295">
 &lt; <b>apply good_clause_list_selects to _ CP2 Ela2.</b>

Subgoal 2.9.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
============================
 good_used_list ((From, needed)::NRest)
</pre>
<pre class="code extensibella"id="1296">
 &lt; <b>apply select_is to _ CP2.</b>

Subgoal 2.9.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
============================
 good_used_list ((From, needed)::NRest)
</pre>
<pre class="code extensibella"id="1297">
 &lt; <b>GCLS: apply good_clause_list_select to _ CP2.</b>

Subgoal 2.9.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
============================
 good_used_list ((From, needed)::NRest)
</pre>
<pre class="code extensibella"id="1298">
 &lt; <b>apply good_clause_list_add to GCLS _ with
     ID = To C = C.</b>

Subgoal 2.9.1.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
============================
 (exists C', mem (To, C') KRest2) -&gt; false
</pre>
<pre class="code extensibella"id="1299">
 &lt; <b>intros M.</b>

Subgoal 2.9.1.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
M : exists C', mem (To, C') KRest2
============================
 false
</pre>
<pre class="code extensibella"id="1300">
 &lt; <b>M: case M.</b>

Subgoal 2.9.1.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest C'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
M : mem (To, C') KRest2
============================
 false
</pre>
<pre class="code extensibella"id="1301">
 &lt; <b>M': apply mem_after_select_before to Ela2 M.</b>

Subgoal 2.9.1.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest C'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
M : mem (To, C') KRest2
M' : mem (To, C') KRest
============================
 false
</pre>
<pre class="code extensibella"id="1302">
 &lt; <b>apply remove_all_no_mem to Ela1 M'.</b>

Subgoal 2.9.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
============================
 good_used_list ((From, needed)::NRest)
</pre>
<pre class="code extensibella"id="1303">
 &lt; <b>IsPr: apply select_is_picked to _ Ela2.</b>

Subgoal 2.9.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
IsPr : is_pair is_integer is_clause (From, C)
============================
 good_used_list ((From, needed)::NRest)
</pre>
<pre class="code extensibella"id="1304">
 &lt; <b>case IsPr.</b>

Subgoal 2.9.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
============================
 good_used_list ((From, needed)::NRest)
</pre>
<pre class="code extensibella"id="1305">
 &lt; <b>GUL: apply IH1 to _ _ _ CP3 Ela3.</b>

Subgoal 2.9.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
============================
 good_used_list ((From, needed)::NRest)
</pre>
<pre class="code extensibella"id="1306">
 &lt; <b>GUL': apply good_used_list_select to _ Ela4.</b>

Subgoal 2.9.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
============================
 good_used_list ((From, needed)::NRest)
</pre>
<pre class="code extensibella"id="1307">
 &lt; <b>unfold .</b>

Subgoal 2.9.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
============================
 forall ID U1 CURest U2,
   select (ID, U1) CURest ((From, needed)::NRest) -&gt; mem (ID, U2) CURest -&gt; false
</pre>
<pre class="code extensibella"id="1308">
 &lt; <b>intros S M.</b>

Subgoal 2.9.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest ID U1 CURest U2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
S : select (ID, U1) CURest ((From, needed)::NRest)
M : mem (ID, U2) CURest
============================
 false
</pre>
<pre class="code extensibella"id="1309">
 &lt; <b>S: case S.</b>

Subgoal 2.9.1.2:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest U2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
M : mem (From, U2) NRest
============================
 false
</pre>
<pre class="code extensibella"id="1310">
 &lt; <b>MN: apply mem_after_select_before to Ela4 M.</b>

Subgoal 2.9.1.2:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest U2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
M : mem (From, U2) NRest
MN : mem (From, U2) Needed
============================
 false
</pre>
<pre class="code extensibella"id="1311">
 &lt; <b>MKR+: apply IH to _ _ _ CP3 Ela3 MN.</b>

Subgoal 2.9.1.2:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest U2 C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
M : mem (From, U2) NRest
MN : mem (From, U2) Needed
MKR+ : mem (From, C2) ((To, C)::KRest2)
============================
 false
</pre>
<pre class="code extensibella"id="1312">
 &lt; <b>MKR2: case MKR+.</b>

Subgoal 2.9.1.2.1:

Variables: Known KRest C KRest2 Needed ERest To NRest Rest U2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause To To Rest) ((To, needed)::NRest) (relocateClause To To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (To, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer To
H2 : is_integer To
H3 : is_proof Rest
CP : To = To -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (To, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer To
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
M : mem (To, U2) NRest
MN : mem (To, U2) Needed
============================
 false
</pre>
<pre class="code extensibella"id="1313">
 &lt; <b>apply CP to _.</b>

Subgoal 2.9.1.2.2:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest U2 C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
M : mem (From, U2) NRest
MN : mem (From, U2) Needed
MKR2 : mem (From, C2) KRest2
============================
 false
</pre>
<pre class="code extensibella"id="1314">
 &lt; <b>GCL': case GCL'.</b>

Subgoal 2.9.1.2.2:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest U2 C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
M : mem (From, U2) NRest
MN : mem (From, U2) Needed
MKR2 : mem (From, C2) KRest2
GCL' : forall ID C1 KRest1 C2,
         select (ID, C1) KRest1 KRest -&gt; mem (ID, C2) KRest1 -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="1315">
 &lt; <b>apply GCL' to Ela2 MKR2.</b>

Subgoal 2.9.1.3:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest ID U1 U2 L1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
M : mem (ID, U2) ((From, needed)::L1)
S : select (ID, U1) L1 NRest
============================
 false
</pre>
<pre class="code extensibella"id="1316">
 &lt; <b>M: case M.</b>

Subgoal 2.9.1.3.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest U1 L1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
S : select (From, U1) L1 NRest
============================
 false
</pre>
<pre class="code extensibella"id="1317">
 &lt; <b>MNR: apply select_mem to S.</b>

Subgoal 2.9.1.3.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest U1 L1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
S : select (From, U1) L1 NRest
MNR : mem (From, U1) NRest
============================
 false
</pre>
<pre class="code extensibella"id="1318">
 &lt; <b>MN: apply mem_after_select_before to Ela4 MNR.</b>

Subgoal 2.9.1.3.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest U1 L1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
S : select (From, U1) L1 NRest
MNR : mem (From, U1) NRest
MN : mem (From, U1) Needed
============================
 false
</pre>
<pre class="code extensibella"id="1319">
 &lt; <b>MKR+: apply IH to _ _ _ CP3 Ela3 MN.</b>

Subgoal 2.9.1.3.1:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest U1 L1 C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
S : select (From, U1) L1 NRest
MNR : mem (From, U1) NRest
MN : mem (From, U1) Needed
MKR+ : mem (From, C2) ((To, C)::KRest2)
============================
 false
</pre>
<pre class="code extensibella"id="1320">
 &lt; <b>MKR2: case MKR+.</b>

Subgoal 2.9.1.3.1.1:

Variables: Known KRest C KRest2 Needed ERest To NRest Rest U1 L1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause To To Rest) ((To, needed)::NRest) (relocateClause To To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (To, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer To
H2 : is_integer To
H3 : is_proof Rest
CP : To = To -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (To, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer To
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
S : select (To, U1) L1 NRest
MNR : mem (To, U1) NRest
MN : mem (To, U1) Needed
============================
 false
</pre>
<pre class="code extensibella"id="1321">
 &lt; <b>apply CP to _.</b>

Subgoal 2.9.1.3.1.2:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest U1 L1 C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
S : select (From, U1) L1 NRest
MNR : mem (From, U1) NRest
MN : mem (From, U1) Needed
MKR2 : mem (From, C2) KRest2
============================
 false
</pre>
<pre class="code extensibella"id="1322">
 &lt; <b>GCL': case GCL'.</b>

Subgoal 2.9.1.3.1.2:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest U1 L1 C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
S : select (From, U1) L1 NRest
MNR : mem (From, U1) NRest
MN : mem (From, U1) Needed
MKR2 : mem (From, C2) KRest2
GCL' : forall ID C1 KRest1 C2,
         select (ID, C1) KRest1 KRest -&gt; mem (ID, C2) KRest1 -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="1323">
 &lt; <b>apply GCL' to Ela2 MKR2.</b>

Subgoal 2.9.1.3.2:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest ID U1 U2 L1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
S : select (ID, U1) L1 NRest
M : mem (ID, U2) L1
============================
 false
</pre>
<pre class="code extensibella"id="1324">
 &lt; <b>GUL': case GUL'.</b>

Subgoal 2.9.1.3.2:

Variables: Known KRest C KRest2 Needed ERest To From NRest Rest ID U1 U2 L1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
S : select (ID, U1) L1 NRest
M : mem (ID, U2) L1
GUL' : forall ID U1 CURest U2,
         select (ID, U1) CURest NRest -&gt; mem (ID, U2) CURest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="1325">
 &lt; <b>apply GUL' to S M.</b>

Subgoal 2.9.2:

Variables: Known KRest C KRest2 Needed ERest To NRest Rest C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause To To Rest) ((To, needed)::NRest) (relocateClause To To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (To, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer To
H2 : is_integer To
H3 : is_proof Rest
CP : mem (To, C1) Known
CP1 : checkProof Known Rest
============================
 good_used_list ((To, needed)::NRest)
</pre>
<pre class="code extensibella"id="1326">
 &lt; <b>M: apply select_mem to Ela2.</b>

Subgoal 2.9.2:

Variables: Known KRest C KRest2 Needed ERest To NRest Rest C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause To To Rest) ((To, needed)::NRest) (relocateClause To To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (To, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
H1 : is_integer To
H2 : is_integer To
H3 : is_proof Rest
CP : mem (To, C1) Known
CP1 : checkProof Known Rest
M : mem (To, C) KRest
============================
 good_used_list ((To, needed)::NRest)
</pre>
<pre class="code extensibella"id="1327">
 &lt; <b>apply remove_all_no_mem to Ela1 M.</b>

Subgoal 2.10:

Variables: Known CU E Rest ID
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof (relocateClause ID ID Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known (relocateClause ID ID Rest)
Ela : elaborate Known (relocateClause ID ID Rest) CU E @
Ela1 : elaborate Known Rest CU E *
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1328">
 &lt; <b>case IsP.</b>

Subgoal 2.10:

Variables: Known CU E Rest ID
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known (relocateClause ID ID Rest)
Ela : elaborate Known (relocateClause ID ID Rest) CU E @
Ela1 : elaborate Known Rest CU E *
H1 : is_integer ID
H2 : is_integer ID
H3 : is_proof Rest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1329">
 &lt; <b>CP: case CP.</b>

Subgoal 2.10.1:

Variables: Known CU E Rest ID KRest C KRest2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause ID ID Rest) CU E @
Ela1 : elaborate Known Rest CU E *
H1 : is_integer ID
H2 : is_integer ID
H3 : is_proof Rest
CP : ID = ID -&gt; false
CP1 : remove_all Known ID KRest
CP2 : select (ID, C) KRest2 KRest
CP3 : checkProof ((ID, C)::KRest2) Rest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1330">
 &lt; <b>apply CP to _.</b>

Subgoal 2.10.2:

Variables: Known CU E Rest ID C
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause ID ID Rest) CU E @
Ela1 : elaborate Known Rest CU E *
H1 : is_integer ID
H2 : is_integer ID
H3 : is_proof Rest
CP : mem (ID, C) Known
CP1 : checkProof Known Rest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1331">
 &lt; <b>apply IH1 to _ _ _ CP1 Ela1.</b>

Subgoal 2.10.2:

Variables: Known CU E Rest ID C
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause ID ID Rest) CU E @
Ela1 : elaborate Known Rest CU E *
H1 : is_integer ID
H2 : is_integer ID
H3 : is_proof Rest
CP : mem (ID, C) Known
CP1 : checkProof Known Rest
H4 : good_used_list CU
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1332">
 &lt; <b>search.</b>

Subgoal 2.11:

Variables: Known E KRest C KRest2 Needed NRest From Rest To
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof (relocateClause From To Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
============================
 good_used_list ((From, unknown)::NRest)
</pre>
<pre class="code extensibella"id="1333">
 &lt; <b>case IsP.</b>

Subgoal 2.11:

Variables: Known E KRest C KRest2 Needed NRest From Rest To
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
============================
 good_used_list ((From, unknown)::NRest)
</pre>
<pre class="code extensibella"id="1334">
 &lt; <b>CP: case CP.</b>

Subgoal 2.11.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To KRest1 C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest1
CP2 : select (From, C1) KRest3 KRest1
CP3 : checkProof ((To, C1)::KRest3) Rest
============================
 good_used_list ((From, unknown)::NRest)
</pre>
<pre class="code extensibella"id="1335">
 &lt; <b>apply remove_all_unique to CP1 Ela1.</b>

Subgoal 2.11.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
============================
 good_used_list ((From, unknown)::NRest)
</pre>
<pre class="code extensibella"id="1336">
 &lt; <b>apply remove_all_is to _ CP1.</b>

Subgoal 2.11.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
============================
 good_used_list ((From, unknown)::NRest)
</pre>
<pre class="code extensibella"id="1337">
 &lt; <b>GCL': apply good_clause_list_remove_all to _ Ela1.</b>

Subgoal 2.11.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To C1 KRest3
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C1) KRest3 KRest
CP3 : checkProof ((To, C1)::KRest3) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
============================
 good_used_list ((From, unknown)::NRest)
</pre>
<pre class="code extensibella"id="1338">
 &lt; <b>apply good_clause_list_selects to _ CP2 Ela2.</b>

Subgoal 2.11.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
============================
 good_used_list ((From, unknown)::NRest)
</pre>
<pre class="code extensibella"id="1339">
 &lt; <b>apply select_is to _ CP2.</b>

Subgoal 2.11.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
============================
 good_used_list ((From, unknown)::NRest)
</pre>
<pre class="code extensibella"id="1340">
 &lt; <b>GCLS: apply good_clause_list_select to _ CP2.</b>

Subgoal 2.11.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
============================
 good_used_list ((From, unknown)::NRest)
</pre>
<pre class="code extensibella"id="1341">
 &lt; <b>apply good_clause_list_add to GCLS _ with
     ID = To C = C.</b>

Subgoal 2.11.1.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
============================
 (exists C', mem (To, C') KRest2) -&gt; false
</pre>
<pre class="code extensibella"id="1342">
 &lt; <b>intros M.</b>

Subgoal 2.11.1.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
M : exists C', mem (To, C') KRest2
============================
 false
</pre>
<pre class="code extensibella"id="1343">
 &lt; <b>M: case M.</b>

Subgoal 2.11.1.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To C'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
M : mem (To, C') KRest2
============================
 false
</pre>
<pre class="code extensibella"id="1344">
 &lt; <b>M': apply mem_after_select_before to Ela2 M.</b>

Subgoal 2.11.1.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To C'
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
M : mem (To, C') KRest2
M' : mem (To, C') KRest
============================
 false
</pre>
<pre class="code extensibella"id="1345">
 &lt; <b>apply remove_all_no_mem to Ela1 M'.</b>

Subgoal 2.11.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
============================
 good_used_list ((From, unknown)::NRest)
</pre>
<pre class="code extensibella"id="1346">
 &lt; <b>IsPr: apply select_is_picked to _ Ela2.</b>

Subgoal 2.11.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
IsPr : is_pair is_integer is_clause (From, C)
============================
 good_used_list ((From, unknown)::NRest)
</pre>
<pre class="code extensibella"id="1347">
 &lt; <b>case IsPr.</b>

Subgoal 2.11.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
============================
 good_used_list ((From, unknown)::NRest)
</pre>
<pre class="code extensibella"id="1348">
 &lt; <b>GUL: apply IH1 to _ _ _ CP3 Ela3.</b>

Subgoal 2.11.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
============================
 good_used_list ((From, unknown)::NRest)
</pre>
<pre class="code extensibella"id="1349">
 &lt; <b>GUL': apply good_used_list_select to _ Ela4.</b>

Subgoal 2.11.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
============================
 good_used_list ((From, unknown)::NRest)
</pre>
<pre class="code extensibella"id="1350">
 &lt; <b>unfold .</b>

Subgoal 2.11.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
============================
 forall ID U1 CURest U2,
   select (ID, U1) CURest ((From, unknown)::NRest) -&gt; mem (ID, U2) CURest -&gt; false
</pre>
<pre class="code extensibella"id="1351">
 &lt; <b>intros S M.</b>

Subgoal 2.11.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To ID U1 CURest U2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
S : select (ID, U1) CURest ((From, unknown)::NRest)
M : mem (ID, U2) CURest
============================
 false
</pre>
<pre class="code extensibella"id="1352">
 &lt; <b>S: case S.</b>

Subgoal 2.11.1.2:

Variables: Known E KRest C KRest2 Needed NRest From Rest To U2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
M : mem (From, U2) NRest
============================
 false
</pre>
<pre class="code extensibella"id="1353">
 &lt; <b>MN: apply mem_after_select_before to Ela4 M.</b>

Subgoal 2.11.1.2:

Variables: Known E KRest C KRest2 Needed NRest From Rest To U2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
M : mem (From, U2) NRest
MN : mem (From, U2) Needed
============================
 false
</pre>
<pre class="code extensibella"id="1354">
 &lt; <b>MKR+: apply IH to _ _ _ CP3 Ela3 MN.</b>

Subgoal 2.11.1.2:

Variables: Known E KRest C KRest2 Needed NRest From Rest To U2 C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
M : mem (From, U2) NRest
MN : mem (From, U2) Needed
MKR+ : mem (From, C2) ((To, C)::KRest2)
============================
 false
</pre>
<pre class="code extensibella"id="1355">
 &lt; <b>MKR2: case MKR+.</b>

Subgoal 2.11.1.2.1:

Variables: Known E KRest C KRest2 Needed NRest Rest To U2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause To To Rest) ((To, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (To, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer To
H2 : is_integer To
H3 : is_proof Rest
CP : To = To -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (To, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer To
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
M : mem (To, U2) NRest
MN : mem (To, U2) Needed
============================
 false
</pre>
<pre class="code extensibella"id="1356">
 &lt; <b>apply CP to _.</b>

Subgoal 2.11.1.2.2:

Variables: Known E KRest C KRest2 Needed NRest From Rest To U2 C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
M : mem (From, U2) NRest
MN : mem (From, U2) Needed
MKR2 : mem (From, C2) KRest2
============================
 false
</pre>
<pre class="code extensibella"id="1357">
 &lt; <b>GCL': case GCL'.</b>

Subgoal 2.11.1.2.2:

Variables: Known E KRest C KRest2 Needed NRest From Rest To U2 C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
M : mem (From, U2) NRest
MN : mem (From, U2) Needed
MKR2 : mem (From, C2) KRest2
GCL' : forall ID C1 KRest1 C2,
         select (ID, C1) KRest1 KRest -&gt; mem (ID, C2) KRest1 -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="1358">
 &lt; <b>apply GCL' to Ela2 MKR2.</b>

Subgoal 2.11.1.3:

Variables: Known E KRest C KRest2 Needed NRest From Rest To ID U1 U2 L1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
M : mem (ID, U2) ((From, unknown)::L1)
S : select (ID, U1) L1 NRest
============================
 false
</pre>
<pre class="code extensibella"id="1359">
 &lt; <b>M: case M.</b>

Subgoal 2.11.1.3.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To U1 L1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
S : select (From, U1) L1 NRest
============================
 false
</pre>
<pre class="code extensibella"id="1360">
 &lt; <b>MNR: apply select_mem to S.</b>

Subgoal 2.11.1.3.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To U1 L1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
S : select (From, U1) L1 NRest
MNR : mem (From, U1) NRest
============================
 false
</pre>
<pre class="code extensibella"id="1361">
 &lt; <b>MN: apply mem_after_select_before to Ela4 MNR.</b>

Subgoal 2.11.1.3.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To U1 L1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
S : select (From, U1) L1 NRest
MNR : mem (From, U1) NRest
MN : mem (From, U1) Needed
============================
 false
</pre>
<pre class="code extensibella"id="1362">
 &lt; <b>MKR+: apply IH to _ _ _ CP3 Ela3 MN.</b>

Subgoal 2.11.1.3.1:

Variables: Known E KRest C KRest2 Needed NRest From Rest To U1 L1 C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
S : select (From, U1) L1 NRest
MNR : mem (From, U1) NRest
MN : mem (From, U1) Needed
MKR+ : mem (From, C2) ((To, C)::KRest2)
============================
 false
</pre>
<pre class="code extensibella"id="1363">
 &lt; <b>MKR2: case MKR+.</b>

Subgoal 2.11.1.3.1.1:

Variables: Known E KRest C KRest2 Needed NRest Rest To U1 L1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause To To Rest) ((To, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (To, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer To
H2 : is_integer To
H3 : is_proof Rest
CP : To = To -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (To, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer To
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
S : select (To, U1) L1 NRest
MNR : mem (To, U1) NRest
MN : mem (To, U1) Needed
============================
 false
</pre>
<pre class="code extensibella"id="1364">
 &lt; <b>apply CP to _.</b>

Subgoal 2.11.1.3.1.2:

Variables: Known E KRest C KRest2 Needed NRest From Rest To U1 L1 C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
S : select (From, U1) L1 NRest
MNR : mem (From, U1) NRest
MN : mem (From, U1) Needed
MKR2 : mem (From, C2) KRest2
============================
 false
</pre>
<pre class="code extensibella"id="1365">
 &lt; <b>GCL': case GCL'.</b>

Subgoal 2.11.1.3.1.2:

Variables: Known E KRest C KRest2 Needed NRest From Rest To U1 L1 C2
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
S : select (From, U1) L1 NRest
MNR : mem (From, U1) NRest
MN : mem (From, U1) Needed
MKR2 : mem (From, C2) KRest2
GCL' : forall ID C1 KRest1 C2,
         select (ID, C1) KRest1 KRest -&gt; mem (ID, C2) KRest1 -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="1366">
 &lt; <b>apply GCL' to Ela2 MKR2.</b>

Subgoal 2.11.1.3.2:

Variables: Known E KRest C KRest2 Needed NRest From Rest To ID U1 U2 L1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
GUL' : good_used_list NRest
S : select (ID, U1) L1 NRest
M : mem (ID, U2) L1
============================
 false
</pre>
<pre class="code extensibella"id="1367">
 &lt; <b>GUL': case GUL'.</b>

Subgoal 2.11.1.3.2:

Variables: Known E KRest C KRest2 Needed NRest From Rest To ID U1 U2 L1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer From
H2 : is_integer To
H3 : is_proof Rest
CP : To = From -&gt; false
CP1 : remove_all Known To KRest
CP2 : select (From, C) KRest2 KRest
CP3 : checkProof ((To, C)::KRest2) Rest
H4 : is_list (is_pair is_integer is_clause) KRest
GCL' : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest2
GCLS : good_clause_list KRest2
H6 : good_clause_list ((To, C)::KRest2)
H7 : is_integer From
H8 : is_clause C
GUL : good_used_list Needed
S : select (ID, U1) L1 NRest
M : mem (ID, U2) L1
GUL' : forall ID U1 CURest U2,
         select (ID, U1) CURest NRest -&gt; mem (ID, U2) CURest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="1368">
 &lt; <b>apply GUL' to S M.</b>

Subgoal 2.11.2:

Variables: Known E KRest C KRest2 Needed NRest Rest To C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause To To Rest) ((To, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (To, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer To
H2 : is_integer To
H3 : is_proof Rest
CP : mem (To, C1) Known
CP1 : checkProof Known Rest
============================
 good_used_list ((To, unknown)::NRest)
</pre>
<pre class="code extensibella"id="1369">
 &lt; <b>M: apply select_mem to Ela2.</b>

Subgoal 2.11.2:

Variables: Known E KRest C KRest2 Needed NRest Rest To C1
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (relocateClause To To Rest) ((To, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (To, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
H1 : is_integer To
H2 : is_integer To
H3 : is_proof Rest
CP : mem (To, C1) Known
CP1 : checkProof Known Rest
M : mem (To, C) KRest
============================
 good_used_list ((To, unknown)::NRest)
</pre>
<pre class="code extensibella"id="1370">
 &lt; <b>apply remove_all_no_mem to Ela1 M.</b>

Subgoal 2.12:

Variables: Known CU E Rest Comment
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof (commentProof Comment Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known (commentProof Comment Rest)
Ela : elaborate Known (commentProof Comment Rest) CU E @
Ela1 : elaborate Known Rest CU E *
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1371">
 &lt; <b>case IsP.</b>

Subgoal 2.12:

Variables: Known CU E Rest Comment
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known (commentProof Comment Rest)
Ela : elaborate Known (commentProof Comment Rest) CU E @
Ela1 : elaborate Known Rest CU E *
H1 : is_string Comment
H2 : is_proof Rest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1372">
 &lt; <b>CP: case CP.</b>

Subgoal 2.12:

Variables: Known CU E Rest Comment
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (commentProof Comment Rest) CU E @
Ela1 : elaborate Known Rest CU E *
H1 : is_string Comment
H2 : is_proof Rest
CP : checkProof Known Rest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1373">
 &lt; <b>apply IH1 to _ _ _ CP Ela1.</b>

Subgoal 2.12:

Variables: Known CU E Rest Comment
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
Ela : elaborate Known (commentProof Comment Rest) CU E @
Ela1 : elaborate Known Rest CU E *
H1 : is_string Comment
H2 : is_proof Rest
CP : checkProof Known Rest
H3 : good_used_list CU
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1374">
 &lt; <b>search.</b>

Subgoal 2.13:

Variables: Known CU E PT
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof &lt;unknown I proof&gt;
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known &lt;unknown I proof&gt;
Ela : elaborate Known &lt;unknown I proof&gt; CU E @
Ela1 : Known |{proof}- &lt;unknown I proof&gt; ~~&gt; PT
Ela2 : elaborate Known PT CU E *
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1375">
 &lt; <b>Is: apply proj_proof_is to Ela1 IsP IsKnown _.</b>

Subgoal 2.13:

Variables: Known CU E PT
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof &lt;unknown I proof&gt;
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known &lt;unknown I proof&gt;
Ela : elaborate Known &lt;unknown I proof&gt; CU E @
Ela1 : Known |{proof}- &lt;unknown I proof&gt; ~~&gt; PT
Ela2 : elaborate Known PT CU E *
Is : is_proof PT
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1376">
 &lt; <b>CP': apply proj_checkProof to Ela1 CP _ _.</b>

Subgoal 2.13:

Variables: Known CU E PT
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof &lt;unknown I proof&gt;
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known &lt;unknown I proof&gt;
Ela : elaborate Known &lt;unknown I proof&gt; CU E @
Ela1 : Known |{proof}- &lt;unknown I proof&gt; ~~&gt; PT
Ela2 : elaborate Known PT CU E *
Is : is_proof PT
CP' : checkProof Known PT
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1377">
 &lt; <b>apply IH1 to _ _ _ CP' Ela2.</b>

Subgoal 2.13:

Variables: Known CU E PT
IH : forall Known P CU E ID U,
       is_proof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       checkProof Known P -&gt; elaborate Known P CU E * -&gt; mem (ID, U) CU -&gt; exists C,
         mem (ID, C) Known
IH1 : forall Known P CU E,
        is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; good_clause_list Known -&gt;
        checkProof Known P -&gt; elaborate Known P CU E * -&gt; good_used_list CU
IsP : is_proof &lt;unknown I proof&gt;
IsKnown : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
CP : checkProof Known &lt;unknown I proof&gt;
Ela : elaborate Known &lt;unknown I proof&gt; CU E @
Ela1 : Known |{proof}- &lt;unknown I proof&gt; ~~&gt; PT
Ela2 : elaborate Known PT CU E *
Is : is_proof PT
CP' : checkProof Known PT
H1 : good_used_list CU
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="1378">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="1379">
 &lt; <b>Theorem select_mem_or  [A] :
     forall (A : A) (B : A) K KRest,
       select A KRest K -&gt; mem B K -&gt; B = A \/ mem B KRest.</b>

============================
 forall A B K KRest, select A KRest K -&gt; mem B K -&gt; B = A \/ mem B KRest
</pre>
<pre class="code extensibella"id="1380">
 &lt; <b>induction on 1.</b>

IH : forall A B K KRest, select A KRest K * -&gt; mem B K -&gt; B = A \/ mem B KRest
============================
 forall A B K KRest, select A KRest K @ -&gt; mem B K -&gt; B = A \/ mem B KRest
</pre>
<pre class="code extensibella"id="1381">
 &lt; <b>intros S M.</b>

Variables: A B K KRest
IH : forall A B K KRest, select A KRest K * -&gt; mem B K -&gt; B = A \/ mem B KRest
S : select A KRest K @
M : mem B K
============================
 B = A \/ mem B KRest
</pre>
<pre class="code extensibella"id="1382">
 &lt; <b>S: case S.</b>

Subgoal 1:

Variables: A B KRest
IH : forall A B K KRest, select A KRest K * -&gt; mem B K -&gt; B = A \/ mem B KRest
M : mem B (A::KRest)
============================
 B = A \/ mem B KRest
</pre>
<pre class="code extensibella"id="1383">
 &lt; <b>M: case M.</b>

Subgoal 1.1:

Variables: A KRest
IH : forall A B K KRest, select A KRest K * -&gt; mem B K -&gt; B = A \/ mem B KRest
============================
 A = A \/ mem A KRest
</pre>
<pre class="code extensibella"id="1384">
 &lt; <b>search.</b>

Subgoal 1.2:

Variables: A B KRest
IH : forall A B K KRest, select A KRest K * -&gt; mem B K -&gt; B = A \/ mem B KRest
M : mem B KRest
============================
 B = A \/ mem B KRest
</pre>
<pre class="code extensibella"id="1385">
 &lt; <b>search.</b>

Subgoal 2:

Variables: A B L2 I L1
IH : forall A B K KRest, select A KRest K * -&gt; mem B K -&gt; B = A \/ mem B KRest
M : mem B (I::L2)
S : select A L1 L2 *
============================
 B = A \/ mem B (I::L1)
</pre>
<pre class="code extensibella"id="1386">
 &lt; <b>M: case M.</b>

Subgoal 2.1:

Variables: A L2 I L1
IH : forall A B K KRest, select A KRest K * -&gt; mem B K -&gt; B = A \/ mem B KRest
S : select A L1 L2 *
============================
 I = A \/ mem I (I::L1)
</pre>
<pre class="code extensibella"id="1387">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: A B L2 I L1
IH : forall A B K KRest, select A KRest K * -&gt; mem B K -&gt; B = A \/ mem B KRest
S : select A L1 L2 *
M : mem B L2
============================
 B = A \/ mem B (I::L1)
</pre>
<pre class="code extensibella"id="1388">
 &lt; <b>Or: apply IH to S M.</b>

Subgoal 2.2:

Variables: A B L2 I L1
IH : forall A B K KRest, select A KRest K * -&gt; mem B K -&gt; B = A \/ mem B KRest
S : select A L1 L2 *
M : mem B L2
Or : B = A \/ mem B L1
============================
 B = A \/ mem B (I::L1)
</pre>
<pre class="code extensibella"id="1389">
 &lt; <b>case Or.</b>

Subgoal 2.2.1:

Variables: A L2 I L1
IH : forall A B K KRest, select A KRest K * -&gt; mem B K -&gt; B = A \/ mem B KRest
S : select A L1 L2 *
M : mem A L2
============================
 A = A \/ mem A (I::L1)
</pre>
<pre class="code extensibella"id="1390">
 &lt; <b>search.</b>

Subgoal 2.2.2:

Variables: A B L2 I L1
IH : forall A B K KRest, select A KRest K * -&gt; mem B K -&gt; B = A \/ mem B KRest
S : select A L1 L2 *
M : mem B L2
H1 : mem B L1
============================
 B = A \/ mem B (I::L1)
</pre>
<pre class="code extensibella"id="1391">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="1392">
 &lt; <b>Theorem remove_all_exists :
     forall K ID,
       is_list (is_pair is_integer is_clause) K -&gt; is_integer ID -&gt; exists KR,
         remove_all K ID KR.</b>

============================
 forall K ID,
   is_list (is_pair is_integer is_clause) K -&gt; is_integer ID -&gt; exists KR,
     remove_all K ID KR
</pre>
<pre class="code extensibella"id="1393">
 &lt; <b>induction on 1.</b>

IH : forall K ID,
       is_list (is_pair is_integer is_clause) K * -&gt; is_integer ID -&gt; exists KR,
         remove_all K ID KR
============================
 forall K ID,
   is_list (is_pair is_integer is_clause) K @ -&gt; is_integer ID -&gt; exists KR,
     remove_all K ID KR
</pre>
<pre class="code extensibella"id="1394">
 &lt; <b>intros IsK IsID.</b>

Variables: K ID
IH : forall K ID,
       is_list (is_pair is_integer is_clause) K * -&gt; is_integer ID -&gt; exists KR,
         remove_all K ID KR
IsK : is_list (is_pair is_integer is_clause) K @
IsID : is_integer ID
============================
 exists KR, remove_all K ID KR
</pre>
<pre class="code extensibella"id="1395">
 &lt; <b>IsK: case IsK.</b>

Subgoal 1:

Variables: ID
IH : forall K ID,
       is_list (is_pair is_integer is_clause) K * -&gt; is_integer ID -&gt; exists KR,
         remove_all K ID KR
IsID : is_integer ID
============================
 exists KR, remove_all [] ID KR
</pre>
<pre class="code extensibella"id="1396">
 &lt; <b>search.</b>

Subgoal 2:

Variables: ID T H
IH : forall K ID,
       is_list (is_pair is_integer is_clause) K * -&gt; is_integer ID -&gt; exists KR,
         remove_all K ID KR
IsID : is_integer ID
IsK : is_pair is_integer is_clause H
IsK1 : is_list (is_pair is_integer is_clause) T *
============================
 exists KR, remove_all (H::T) ID KR
</pre>
<pre class="code extensibella"id="1397">
 &lt; <b>apply IH to IsK1 IsID.</b>

Subgoal 2:

Variables: ID T H KR
IH : forall K ID,
       is_list (is_pair is_integer is_clause) K * -&gt; is_integer ID -&gt; exists KR,
         remove_all K ID KR
IsID : is_integer ID
IsK : is_pair is_integer is_clause H
IsK1 : is_list (is_pair is_integer is_clause) T *
H1 : remove_all T ID KR
============================
 exists KR, remove_all (H::T) ID KR
</pre>
<pre class="code extensibella"id="1398">
 &lt; <b>IsP: case IsK.</b>

Subgoal 2:

Variables: ID T KR B A
IH : forall K ID,
       is_list (is_pair is_integer is_clause) K * -&gt; is_integer ID -&gt; exists KR,
         remove_all K ID KR
IsID : is_integer ID
IsK1 : is_list (is_pair is_integer is_clause) T *
H1 : remove_all T ID KR
IsP : is_integer A
IsP1 : is_clause B
============================
 exists KR, remove_all ((A, B)::T) ID KR
</pre>
<pre class="code extensibella"id="1399">
 &lt; <b>Or: apply is_integer_eq_or_not to IsP IsID.</b>

Subgoal 2:

Variables: ID T KR B A
IH : forall K ID,
       is_list (is_pair is_integer is_clause) K * -&gt; is_integer ID -&gt; exists KR,
         remove_all K ID KR
IsID : is_integer ID
IsK1 : is_list (is_pair is_integer is_clause) T *
H1 : remove_all T ID KR
IsP : is_integer A
IsP1 : is_clause B
Or : A = ID \/ (A = ID -&gt; false)
============================
 exists KR, remove_all ((A, B)::T) ID KR
</pre>
<pre class="code extensibella"id="1400">
 &lt; <b>case Or.</b>

Subgoal 2.1:

Variables: ID T KR B
IH : forall K ID,
       is_list (is_pair is_integer is_clause) K * -&gt; is_integer ID -&gt; exists KR,
         remove_all K ID KR
IsID : is_integer ID
IsK1 : is_list (is_pair is_integer is_clause) T *
H1 : remove_all T ID KR
IsP : is_integer ID
IsP1 : is_clause B
============================
 exists KR, remove_all ((ID, B)::T) ID KR
</pre>
<pre class="code extensibella"id="1401">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: ID T KR B A
IH : forall K ID,
       is_list (is_pair is_integer is_clause) K * -&gt; is_integer ID -&gt; exists KR,
         remove_all K ID KR
IsID : is_integer ID
IsK1 : is_list (is_pair is_integer is_clause) T *
H1 : remove_all T ID KR
IsP : is_integer A
IsP1 : is_clause B
H2 : A = ID -&gt; false
============================
 exists KR, remove_all ((A, B)::T) ID KR
</pre>
<pre class="code extensibella"id="1402">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="1403">
 &lt; <b>Theorem permutation_transitive_clauses :
     forall A B C,
       is_list (is_pair is_integer is_clause) A -&gt; is_list (is_pair is_integer is_clause) B -&gt;
       is_list (is_pair is_integer is_clause) C -&gt; permutation A B -&gt; permutation B C -&gt;
       permutation A C.</b>

============================
 forall A B C,
   is_list (is_pair is_integer is_clause) A -&gt; is_list (is_pair is_integer is_clause) B -&gt;
   is_list (is_pair is_integer is_clause) C -&gt; permutation A B -&gt; permutation B C -&gt;
   permutation A C
</pre>
<pre class="code extensibella"id="1404">
 &lt; <b>intros IsA IsB IsC PAB PBC.</b>

Variables: A B C
IsA : is_list (is_pair is_integer is_clause) A
IsB : is_list (is_pair is_integer is_clause) B
IsC : is_list (is_pair is_integer is_clause) C
PAB : permutation A B
PBC : permutation B C
============================
 permutation A C
</pre>
<pre class="code extensibella"id="1405">
 &lt; <b>assert forall I N1 N2,
     is_pair is_integer is_clause I -&gt; count I A N1 -&gt; count I C N2 -&gt; N1 = N2.</b>

Subgoal 1:

Variables: A B C
IsA : is_list (is_pair is_integer is_clause) A
IsB : is_list (is_pair is_integer is_clause) B
IsC : is_list (is_pair is_integer is_clause) C
PAB : permutation A B
PBC : permutation B C
============================
 forall I N1 N2,
   is_pair is_integer is_clause I -&gt; count I A N1 -&gt; count I C N2 -&gt; N1 = N2
</pre>
<pre class="code extensibella"id="1406">
 &lt; <b>intros IsI CA CC.</b>

Subgoal 1:

Variables: A B C I N1 N2
IsA : is_list (is_pair is_integer is_clause) A
IsB : is_list (is_pair is_integer is_clause) B
IsC : is_list (is_pair is_integer is_clause) C
PAB : permutation A B
PBC : permutation B C
IsI : is_pair is_integer is_clause I
CA : count I A N1
CC : count I C N2
============================
 N1 = N2
</pre>
<pre class="code extensibella"id="1407">
 &lt; <b>CB: apply is_count_exists to IsB IsI.</b>

Subgoal 1:

Variables: A B C I N1 N2 N
IsA : is_list (is_pair is_integer is_clause) A
IsB : is_list (is_pair is_integer is_clause) B
IsC : is_list (is_pair is_integer is_clause) C
PAB : permutation A B
PBC : permutation B C
IsI : is_pair is_integer is_clause I
CA : count I A N1
CC : count I C N2
CB : count I B N
============================
 N1 = N2
</pre>
<pre class="code extensibella"id="1408">
 &lt; <b>apply permutation_counts to PAB CA CB.</b>

Subgoal 1:

Variables: A B C I N2 N
IsA : is_list (is_pair is_integer is_clause) A
IsB : is_list (is_pair is_integer is_clause) B
IsC : is_list (is_pair is_integer is_clause) C
PAB : permutation A B
PBC : permutation B C
IsI : is_pair is_integer is_clause I
CA : count I A N
CC : count I C N2
CB : count I B N
============================
 N = N2
</pre>
<pre class="code extensibella"id="1409">
 &lt; <b>apply permutation_counts to PBC CB CC.</b>

Subgoal 1:

Variables: A B C I N2
IsA : is_list (is_pair is_integer is_clause) A
IsB : is_list (is_pair is_integer is_clause) B
IsC : is_list (is_pair is_integer is_clause) C
PAB : permutation A B
PBC : permutation B C
IsI : is_pair is_integer is_clause I
CA : count I A N2
CC : count I C N2
CB : count I B N2
============================
 N2 = N2
</pre>
<pre class="code extensibella"id="1410">
 &lt; <b>search.</b>

Variables: A B C
IsA : is_list (is_pair is_integer is_clause) A
IsB : is_list (is_pair is_integer is_clause) B
IsC : is_list (is_pair is_integer is_clause) C
PAB : permutation A B
PBC : permutation B C
H1 : forall I N1 N2,
       is_pair is_integer is_clause I -&gt; count I A N1 -&gt; count I C N2 -&gt; N1 = N2
============================
 permutation A C
</pre>
<pre class="code extensibella"id="1411">
 &lt; <b>apply counts_permutation to IsA IsC _.</b>

Variables: A B C
IsA : is_list (is_pair is_integer is_clause) A
IsB : is_list (is_pair is_integer is_clause) B
IsC : is_list (is_pair is_integer is_clause) C
PAB : permutation A B
PBC : permutation B C
H1 : forall I N1 N2,
       is_pair is_integer is_clause I -&gt; count I A N1 -&gt; count I C N2 -&gt; N1 = N2
H2 : permutation A C
============================
 permutation A C
</pre>
<pre class="code extensibella"id="1412">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="1413">
 &lt; <b>Extensible_Theorem
      checkFinalClauses_perm_help : forall A B FC,
         IsFC : is_finalClauses FC -&gt;
         IsA : is_list (is_pair is_integer is_clause) A -&gt;
         IsB : is_list (is_pair is_integer is_clause) B -&gt;
         CFCA : checkFinalClauses A FC -&gt;
         CFCB : checkFinalClauses B FC -&gt;
         exists L,
           permutation L A /\ permutation L B
      on CFCA.</b>

Subgoal 1:

Variables: A B KRest Rest C ID
IH : forall A B FC,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) A -&gt; is_list (is_pair is_integer is_clause) B -&gt;
       checkFinalClauses A FC * -&gt; checkFinalClauses B FC -&gt; exists L,
         permutation L A /\ permutation L B
IsFC : is_finalClauses (addFClause ID C Rest)
IsA : is_list (is_pair is_integer is_clause) A
IsB : is_list (is_pair is_integer is_clause) B
CFCA : checkFinalClauses A (addFClause ID C Rest) @
CFCB : checkFinalClauses B (addFClause ID C Rest)
CFCA1 : select (ID, C) KRest A
CFCA2 : checkFinalClauses KRest Rest *
============================
 exists L, permutation L A /\ permutation L B
</pre>
<pre class="code extensibella"id="1414">
 &lt; <b>case IsFC.</b>

Subgoal 1:

Variables: A B KRest Rest C ID
IH : forall A B FC,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) A -&gt; is_list (is_pair is_integer is_clause) B -&gt;
       checkFinalClauses A FC * -&gt; checkFinalClauses B FC -&gt; exists L,
         permutation L A /\ permutation L B
IsA : is_list (is_pair is_integer is_clause) A
IsB : is_list (is_pair is_integer is_clause) B
CFCA : checkFinalClauses A (addFClause ID C Rest) @
CFCB : checkFinalClauses B (addFClause ID C Rest)
CFCA1 : select (ID, C) KRest A
CFCA2 : checkFinalClauses KRest Rest *
H1 : is_integer ID
H2 : is_clause C
H3 : is_finalClauses Rest
============================
 exists L, permutation L A /\ permutation L B
</pre>
<pre class="code extensibella"id="1415">
 &lt; <b>CFCB: case CFCB.</b>

Subgoal 1:

Variables: A B KRest Rest C ID KRest1
IH : forall A B FC,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) A -&gt; is_list (is_pair is_integer is_clause) B -&gt;
       checkFinalClauses A FC * -&gt; checkFinalClauses B FC -&gt; exists L,
         permutation L A /\ permutation L B
IsA : is_list (is_pair is_integer is_clause) A
IsB : is_list (is_pair is_integer is_clause) B
CFCA : checkFinalClauses A (addFClause ID C Rest) @
CFCA1 : select (ID, C) KRest A
CFCA2 : checkFinalClauses KRest Rest *
H1 : is_integer ID
H2 : is_clause C
H3 : is_finalClauses Rest
CFCB : select (ID, C) KRest1 B
CFCB1 : checkFinalClauses KRest1 Rest
============================
 exists L, permutation L A /\ permutation L B
</pre>
<pre class="code extensibella"id="1416">
 &lt; <b>apply select_is to _ CFCA1.</b>

Subgoal 1:

Variables: A B KRest Rest C ID KRest1
IH : forall A B FC,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) A -&gt; is_list (is_pair is_integer is_clause) B -&gt;
       checkFinalClauses A FC * -&gt; checkFinalClauses B FC -&gt; exists L,
         permutation L A /\ permutation L B
IsA : is_list (is_pair is_integer is_clause) A
IsB : is_list (is_pair is_integer is_clause) B
CFCA : checkFinalClauses A (addFClause ID C Rest) @
CFCA1 : select (ID, C) KRest A
CFCA2 : checkFinalClauses KRest Rest *
H1 : is_integer ID
H2 : is_clause C
H3 : is_finalClauses Rest
CFCB : select (ID, C) KRest1 B
CFCB1 : checkFinalClauses KRest1 Rest
H4 : is_list (is_pair is_integer is_clause) KRest
============================
 exists L, permutation L A /\ permutation L B
</pre>
<pre class="code extensibella"id="1417">
 &lt; <b>apply select_is to _ CFCB.</b>

Subgoal 1:

Variables: A B KRest Rest C ID KRest1
IH : forall A B FC,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) A -&gt; is_list (is_pair is_integer is_clause) B -&gt;
       checkFinalClauses A FC * -&gt; checkFinalClauses B FC -&gt; exists L,
         permutation L A /\ permutation L B
IsA : is_list (is_pair is_integer is_clause) A
IsB : is_list (is_pair is_integer is_clause) B
CFCA : checkFinalClauses A (addFClause ID C Rest) @
CFCA1 : select (ID, C) KRest A
CFCA2 : checkFinalClauses KRest Rest *
H1 : is_integer ID
H2 : is_clause C
H3 : is_finalClauses Rest
CFCB : select (ID, C) KRest1 B
CFCB1 : checkFinalClauses KRest1 Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : is_list (is_pair is_integer is_clause) KRest1
============================
 exists L, permutation L A /\ permutation L B
</pre>
<pre class="code extensibella"id="1418">
 &lt; <b>apply IH to _ _ _ CFCA2 CFCB1.</b>

Subgoal 1:

Variables: A B KRest Rest C ID KRest1 L
IH : forall A B FC,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) A -&gt; is_list (is_pair is_integer is_clause) B -&gt;
       checkFinalClauses A FC * -&gt; checkFinalClauses B FC -&gt; exists L,
         permutation L A /\ permutation L B
IsA : is_list (is_pair is_integer is_clause) A
IsB : is_list (is_pair is_integer is_clause) B
CFCA : checkFinalClauses A (addFClause ID C Rest) @
CFCA1 : select (ID, C) KRest A
CFCA2 : checkFinalClauses KRest Rest *
H1 : is_integer ID
H2 : is_clause C
H3 : is_finalClauses Rest
CFCB : select (ID, C) KRest1 B
CFCB1 : checkFinalClauses KRest1 Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : is_list (is_pair is_integer is_clause) KRest1
H6 : permutation L KRest
H7 : permutation L KRest1
============================
 exists L, permutation L A /\ permutation L B
</pre>
<pre class="code extensibella"id="1419">
 &lt; <b>exists (ID, C)::L.</b>

Subgoal 1:

Variables: A B KRest Rest C ID KRest1 L
IH : forall A B FC,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) A -&gt; is_list (is_pair is_integer is_clause) B -&gt;
       checkFinalClauses A FC * -&gt; checkFinalClauses B FC -&gt; exists L,
         permutation L A /\ permutation L B
IsA : is_list (is_pair is_integer is_clause) A
IsB : is_list (is_pair is_integer is_clause) B
CFCA : checkFinalClauses A (addFClause ID C Rest) @
CFCA1 : select (ID, C) KRest A
CFCA2 : checkFinalClauses KRest Rest *
H1 : is_integer ID
H2 : is_clause C
H3 : is_finalClauses Rest
CFCB : select (ID, C) KRest1 B
CFCB1 : checkFinalClauses KRest1 Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : is_list (is_pair is_integer is_clause) KRest1
H6 : permutation L KRest
H7 : permutation L KRest1
============================
 permutation ((ID, C)::L) A /\ permutation ((ID, C)::L) B
</pre>
<pre class="code extensibella"id="1420">
 &lt; <b>search.</b>

Subgoal 2:

Variables: B
IH : forall A B FC,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) A -&gt; is_list (is_pair is_integer is_clause) B -&gt;
       checkFinalClauses A FC * -&gt; checkFinalClauses B FC -&gt; exists L,
         permutation L A /\ permutation L B
IsFC : is_finalClauses endFClause
IsA : is_list (is_pair is_integer is_clause) []
IsB : is_list (is_pair is_integer is_clause) B
CFCA : checkFinalClauses [] endFClause @
CFCB : checkFinalClauses B endFClause
============================
 exists L, permutation L [] /\ permutation L B
</pre>
<pre class="code extensibella"id="1421">
 &lt; <b>case CFCB.</b>

Subgoal 2:

IH : forall A B FC,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) A -&gt; is_list (is_pair is_integer is_clause) B -&gt;
       checkFinalClauses A FC * -&gt; checkFinalClauses B FC -&gt; exists L,
         permutation L A /\ permutation L B
IsFC : is_finalClauses endFClause
IsA : is_list (is_pair is_integer is_clause) []
IsB : is_list (is_pair is_integer is_clause) []
CFCA : checkFinalClauses [] endFClause @
============================
 exists L, permutation L [] /\ permutation L []
</pre>
<pre class="code extensibella"id="1422">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="1423">
 &lt; <b>Theorem checkFinalClauses_perm :
     forall A B FC,
       is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) A -&gt; is_list (is_pair is_integer is_clause) B -&gt;
       checkFinalClauses A FC -&gt; checkFinalClauses B FC -&gt; permutation A B.</b>

============================
 forall A B FC,
   is_finalClauses FC -&gt; is_list (is_pair is_integer is_clause) A -&gt; is_list (is_pair is_integer is_clause) B -&gt;
   checkFinalClauses A FC -&gt; checkFinalClauses B FC -&gt; permutation A B
</pre>
<pre class="code extensibella"id="1424">
 &lt; <b>intros IsFC IsA IsB CFCA CFCB.</b>

Variables: A B FC
IsFC : is_finalClauses FC
IsA : is_list (is_pair is_integer is_clause) A
IsB : is_list (is_pair is_integer is_clause) B
CFCA : checkFinalClauses A FC
CFCB : checkFinalClauses B FC
============================
 permutation A B
</pre>
<pre class="code extensibella"id="1425">
 &lt; <b>P: apply checkFinalClauses_perm_help to _ _ _ CFCA CFCB.</b>

Variables: A B FC L
IsFC : is_finalClauses FC
IsA : is_list (is_pair is_integer is_clause) A
IsB : is_list (is_pair is_integer is_clause) B
CFCA : checkFinalClauses A FC
CFCB : checkFinalClauses B FC
P : permutation L A
P1 : permutation L B
============================
 permutation A B
</pre>
<pre class="code extensibella"id="1426">
 &lt; <b>P': apply permutation_symmetric to P.</b>

Variables: A B FC L
IsFC : is_finalClauses FC
IsA : is_list (is_pair is_integer is_clause) A
IsB : is_list (is_pair is_integer is_clause) B
CFCA : checkFinalClauses A FC
CFCB : checkFinalClauses B FC
P : permutation L A
P1 : permutation L B
P' : permutation A L
============================
 permutation A B
</pre>
<pre class="code extensibella"id="1427">
 &lt; <b>apply permutation_is to _ P1.</b>

Variables: A B FC L
IsFC : is_finalClauses FC
IsA : is_list (is_pair is_integer is_clause) A
IsB : is_list (is_pair is_integer is_clause) B
CFCA : checkFinalClauses A FC
CFCB : checkFinalClauses B FC
P : permutation L A
P1 : permutation L B
P' : permutation A L
H1 : is_list (is_pair is_integer is_clause) L
============================
 permutation A B
</pre>
<pre class="code extensibella"id="1428">
 &lt; <b>apply permutation_transitive_clauses to _ _ _ P' P1.</b>

Variables: A B FC L
IsFC : is_finalClauses FC
IsA : is_list (is_pair is_integer is_clause) A
IsB : is_list (is_pair is_integer is_clause) B
CFCA : checkFinalClauses A FC
CFCB : checkFinalClauses B FC
P : permutation L A
P1 : permutation L B
P' : permutation A L
H1 : is_list (is_pair is_integer is_clause) L
H2 : permutation A B
============================
 permutation A B
</pre>
<pre class="code extensibella"id="1429">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="1430">
 &lt; <b>Define hasNeeded :
             (list (pair integer clause)) -&gt;
             (list (pair integer clauseUsedness)) -&gt;
             (list (pair integer clause)) -&gt;
             prop by
   hasNeeded K CU N :=
     (forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) N) /\
     (forall ID CN CK, mem (ID, CN) N -&gt; mem (ID, CK) K -&gt; CN = CK).</b>


</pre>
<pre class="code extensibella"id="1431">
 &lt; <b>Theorem hasNeeded_mem :
     forall K CU N ID,
       hasNeeded K CU N -&gt; mem (ID, needed) CU -&gt; exists C, mem (ID, C) N.</b>

============================
 forall K CU N ID,
   hasNeeded K CU N -&gt; mem (ID, needed) CU -&gt; exists C, mem (ID, C) N
</pre>
<pre class="code extensibella"id="1432">
 &lt; <b>intros HN M.</b>

Variables: K CU N ID
HN : hasNeeded K CU N
M : mem (ID, needed) CU
============================
 exists C, mem (ID, C) N
</pre>
<pre class="code extensibella"id="1433">
 &lt; <b>HN: case HN.</b>

Variables: K CU N ID
M : mem (ID, needed) CU
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) N
HN1 : forall ID CN CK, mem (ID, CN) N -&gt; mem (ID, CK) K -&gt; CN = CK
============================
 exists C, mem (ID, C) N
</pre>
<pre class="code extensibella"id="1434">
 &lt; <b>apply HN to M.</b>

Variables: K CU N ID C
M : mem (ID, needed) CU
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) N
HN1 : forall ID CN CK, mem (ID, CN) N -&gt; mem (ID, CK) K -&gt; CN = CK
H1 : mem (ID, C) N
============================
 exists C, mem (ID, C) N
</pre>
<pre class="code extensibella"id="1435">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="1436">
 &lt; <b>Theorem hasNeeded_lookup :
     forall K CU N ID C,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; is_list (is_pair is_integer is_clause) N -&gt;
       good_clause_list N -&gt; good_used_list CU -&gt; hasNeeded K CU N -&gt; lookup K ID C -&gt;
       mem (ID, needed) CU -&gt; lookup N ID C.</b>

============================
 forall K CU N ID C,
   is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; is_list (is_pair is_integer is_clause) N -&gt;
   good_clause_list N -&gt; good_used_list CU -&gt; hasNeeded K CU N -&gt; lookup K ID C -&gt;
   mem (ID, needed) CU -&gt; lookup N ID C
</pre>
<pre class="code extensibella"id="1437">
 &lt; <b>intros IsK GCLK IsN GCLN GUL HN Lkp Mem.</b>

Variables: K CU N ID C
IsK : is_list (is_pair is_integer is_clause) K
GCLK : good_clause_list K
IsN : is_list (is_pair is_integer is_clause) N
GCLN : good_clause_list N
GUL : good_used_list CU
HN : hasNeeded K CU N
Lkp : lookup K ID C
Mem : mem (ID, needed) CU
============================
 lookup N ID C
</pre>
<pre class="code extensibella"id="1438">
 &lt; <b>HN: case HN.</b>

Variables: K CU N ID C
IsK : is_list (is_pair is_integer is_clause) K
GCLK : good_clause_list K
IsN : is_list (is_pair is_integer is_clause) N
GCLN : good_clause_list N
GUL : good_used_list CU
Lkp : lookup K ID C
Mem : mem (ID, needed) CU
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) N
HN1 : forall ID CN CK, mem (ID, CN) N -&gt; mem (ID, CK) K -&gt; CN = CK
============================
 lookup N ID C
</pre>
<pre class="code extensibella"id="1439">
 &lt; <b>MN: apply HN to Mem.</b>

Variables: K CU N ID C C1
IsK : is_list (is_pair is_integer is_clause) K
GCLK : good_clause_list K
IsN : is_list (is_pair is_integer is_clause) N
GCLN : good_clause_list N
GUL : good_used_list CU
Lkp : lookup K ID C
Mem : mem (ID, needed) CU
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) N
HN1 : forall ID CN CK, mem (ID, CN) N -&gt; mem (ID, CK) K -&gt; CN = CK
MN : mem (ID, C1) N
============================
 lookup N ID C
</pre>
<pre class="code extensibella"id="1440">
 &lt; <b>LN: apply mem_lookup to _ MN.</b>

Variables: K CU N ID C C1 C'
IsK : is_list (is_pair is_integer is_clause) K
GCLK : good_clause_list K
IsN : is_list (is_pair is_integer is_clause) N
GCLN : good_clause_list N
GUL : good_used_list CU
Lkp : lookup K ID C
Mem : mem (ID, needed) CU
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) N
HN1 : forall ID CN CK, mem (ID, CN) N -&gt; mem (ID, CK) K -&gt; CN = CK
MN : mem (ID, C1) N
LN : lookup N ID C'
============================
 lookup N ID C
</pre>
<pre class="code extensibella"id="1441">
 &lt; <b>MK: apply lookup_mem to Lkp.</b>

Variables: K CU N ID C C1 C'
IsK : is_list (is_pair is_integer is_clause) K
GCLK : good_clause_list K
IsN : is_list (is_pair is_integer is_clause) N
GCLN : good_clause_list N
GUL : good_used_list CU
Lkp : lookup K ID C
Mem : mem (ID, needed) CU
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) N
HN1 : forall ID CN CK, mem (ID, CN) N -&gt; mem (ID, CK) K -&gt; CN = CK
MN : mem (ID, C1) N
LN : lookup N ID C'
MK : mem (ID, C) K
============================
 lookup N ID C
</pre>
<pre class="code extensibella"id="1442">
 &lt; <b>MN': apply lookup_mem to LN.</b>

Variables: K CU N ID C C1 C'
IsK : is_list (is_pair is_integer is_clause) K
GCLK : good_clause_list K
IsN : is_list (is_pair is_integer is_clause) N
GCLN : good_clause_list N
GUL : good_used_list CU
Lkp : lookup K ID C
Mem : mem (ID, needed) CU
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) N
HN1 : forall ID CN CK, mem (ID, CN) N -&gt; mem (ID, CK) K -&gt; CN = CK
MN : mem (ID, C1) N
LN : lookup N ID C'
MK : mem (ID, C) K
MN' : mem (ID, C') N
============================
 lookup N ID C
</pre>
<pre class="code extensibella"id="1443">
 &lt; <b>apply HN1 to MN' MK.</b>

Variables: K CU N ID C C1
IsK : is_list (is_pair is_integer is_clause) K
GCLK : good_clause_list K
IsN : is_list (is_pair is_integer is_clause) N
GCLN : good_clause_list N
GUL : good_used_list CU
Lkp : lookup K ID C
Mem : mem (ID, needed) CU
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) N
HN1 : forall ID CN CK, mem (ID, CN) N -&gt; mem (ID, CK) K -&gt; CN = CK
MN : mem (ID, C1) N
LN : lookup N ID C
MK : mem (ID, C) K
MN' : mem (ID, C) N
============================
 lookup N ID C
</pre>
<pre class="code extensibella"id="1444">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="1445">
 &lt; <b>Theorem hasNeeded_drop :
     forall K ID U CU N, hasNeeded K ((ID, U)::CU) N -&gt; hasNeeded K CU N.</b>

============================
 forall K ID U CU N, hasNeeded K ((ID, U)::CU) N -&gt; hasNeeded K CU N
</pre>
<pre class="code extensibella"id="1446">
 &lt; <b>intros HN.</b>

Variables: K ID U CU N
HN : hasNeeded K ((ID, U)::CU) N
============================
 hasNeeded K CU N
</pre>
<pre class="code extensibella"id="1447">
 &lt; <b>HN: case HN.</b>

Variables: K ID U CU N
HN : forall ID1, mem (ID1, needed) ((ID, U)::CU) -&gt; exists C, mem (ID1, C) N
HN1 : forall ID1 CN CK, mem (ID1, CN) N -&gt; mem (ID1, CK) K -&gt; CN = CK
============================
 hasNeeded K CU N
</pre>
<pre class="code extensibella"id="1448">
 &lt; <b>unfold .</b>

Subgoal 1:

Variables: K ID U CU N
HN : forall ID1, mem (ID1, needed) ((ID, U)::CU) -&gt; exists C, mem (ID1, C) N
HN1 : forall ID1 CN CK, mem (ID1, CN) N -&gt; mem (ID1, CK) K -&gt; CN = CK
============================
 forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) N
</pre>
<pre class="code extensibella"id="1449">
 &lt; <b>intros M.</b>

Subgoal 1:

Variables: K ID U CU N ID1
HN : forall ID1, mem (ID1, needed) ((ID, U)::CU) -&gt; exists C, mem (ID1, C) N
HN1 : forall ID1 CN CK, mem (ID1, CN) N -&gt; mem (ID1, CK) K -&gt; CN = CK
M : mem (ID1, needed) CU
============================
 exists C, mem (ID1, C) N
</pre>
<pre class="code extensibella"id="1450">
 &lt; <b>backchain HN.</b>

Subgoal 2:

Variables: K ID U CU N
HN : forall ID1, mem (ID1, needed) ((ID, U)::CU) -&gt; exists C, mem (ID1, C) N
HN1 : forall ID1 CN CK, mem (ID1, CN) N -&gt; mem (ID1, CK) K -&gt; CN = CK
============================
 forall ID CN CK, mem (ID, CN) N -&gt; mem (ID, CK) K -&gt; CN = CK
</pre>
<pre class="code extensibella"id="1451">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="1452">
 &lt; <b>Theorem rupProof_help_hasNeeded :
     forall K A Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf.</b>

============================
 forall K A Prf Needed Updated KN,
   is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
   is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf -&gt;
   makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
</pre>
<pre class="code extensibella"id="1453">
 &lt; <b>induction on 6.</b>

IH : forall K A Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf * -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
============================
 forall K A Prf Needed Updated KN,
   is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
   is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf @ -&gt;
   makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
</pre>
<pre class="code extensibella"id="1454">
 &lt; <b>intros IsK GCL GUL IsKN GCL_KN RUPPH MU HN.</b>

Variables: K A Prf Needed Updated KN
IH : forall K A Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf * -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
RUPPH : rupProof_help K A Prf @
MU : makeUsed Needed Prf Updated
HN : hasNeeded K Updated KN
============================
 rupProof_help KN A Prf
</pre>
<pre class="code extensibella"id="1455">
 &lt; <b>GUL': apply makeUsed_good_used_list to GUL MU.</b>

Variables: K A Prf Needed Updated KN
IH : forall K A Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf * -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
RUPPH : rupProof_help K A Prf @
MU : makeUsed Needed Prf Updated
HN : hasNeeded K Updated KN
GUL' : good_used_list Updated
============================
 rupProof_help KN A Prf
</pre>
<pre class="code extensibella"id="1456">
 &lt; <b>RUP: case RUPPH.</b>

Subgoal 1:

Variables: K A Needed Updated KN C ID
IH : forall K A Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf * -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
MU : makeUsed Needed [ID] Updated
HN : hasNeeded K Updated KN
GUL' : good_used_list Updated
RUP : lookup K ID C
RUP1 : unsat_clause A C
============================
 rupProof_help KN A [ID]
</pre>
<pre class="code extensibella"id="1457">
 &lt; <b>M: assert mem ID [ID].</b>

Subgoal 1:

Variables: K A Needed Updated KN C ID
IH : forall K A Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf * -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
MU : makeUsed Needed [ID] Updated
HN : hasNeeded K Updated KN
GUL' : good_used_list Updated
RUP : lookup K ID C
RUP1 : unsat_clause A C
M : mem ID [ID]
============================
 rupProof_help KN A [ID]
</pre>
<pre class="code extensibella"id="1458">
 &lt; <b>M': apply makeUsed_needed to MU M.</b>

Subgoal 1:

Variables: K A Needed Updated KN C ID
IH : forall K A Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf * -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
MU : makeUsed Needed [ID] Updated
HN : hasNeeded K Updated KN
GUL' : good_used_list Updated
RUP : lookup K ID C
RUP1 : unsat_clause A C
M : mem ID [ID]
M' : mem (ID, needed) Updated
============================
 rupProof_help KN A [ID]
</pre>
<pre class="code extensibella"id="1459">
 &lt; <b>apply hasNeeded_mem to HN M'.</b>

Subgoal 1:

Variables: K A Needed Updated KN C ID C1
IH : forall K A Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf * -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
MU : makeUsed Needed [ID] Updated
HN : hasNeeded K Updated KN
GUL' : good_used_list Updated
RUP : lookup K ID C
RUP1 : unsat_clause A C
M : mem ID [ID]
M' : mem (ID, needed) Updated
H1 : mem (ID, C1) KN
============================
 rupProof_help KN A [ID]
</pre>
<pre class="code extensibella"id="1460">
 &lt; <b>apply hasNeeded_lookup to _ _ _ _ _ HN RUP _.</b>

Subgoal 1:

Variables: K A Needed Updated KN C ID C1
IH : forall K A Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf * -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
MU : makeUsed Needed [ID] Updated
HN : hasNeeded K Updated KN
GUL' : good_used_list Updated
RUP : lookup K ID C
RUP1 : unsat_clause A C
M : mem ID [ID]
M' : mem (ID, needed) Updated
H1 : mem (ID, C1) KN
H2 : lookup KN ID C
============================
 rupProof_help KN A [ID]
</pre>
<pre class="code extensibella"id="1461">
 &lt; <b>search.</b>

Subgoal 2:

Variables: K A Needed Updated KN C L Prf1 ID
IH : forall K A Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf * -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
MU : makeUsed Needed (ID::Prf1) Updated
HN : hasNeeded K Updated KN
GUL' : good_used_list Updated
RUP : lookup K ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help K (L::A) Prf1 *
============================
 rupProof_help KN A (ID::Prf1)
</pre>
<pre class="code extensibella"id="1462">
 &lt; <b>M: assert mem ID (ID::Prf1).</b>

Subgoal 2:

Variables: K A Needed Updated KN C L Prf1 ID
IH : forall K A Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf * -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
MU : makeUsed Needed (ID::Prf1) Updated
HN : hasNeeded K Updated KN
GUL' : good_used_list Updated
RUP : lookup K ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help K (L::A) Prf1 *
M : mem ID (ID::Prf1)
============================
 rupProof_help KN A (ID::Prf1)
</pre>
<pre class="code extensibella"id="1463">
 &lt; <b>M': apply makeUsed_needed to MU M.</b>

Subgoal 2:

Variables: K A Needed Updated KN C L Prf1 ID
IH : forall K A Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf * -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
MU : makeUsed Needed (ID::Prf1) Updated
HN : hasNeeded K Updated KN
GUL' : good_used_list Updated
RUP : lookup K ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help K (L::A) Prf1 *
M : mem ID (ID::Prf1)
M' : mem (ID, needed) Updated
============================
 rupProof_help KN A (ID::Prf1)
</pre>
<pre class="code extensibella"id="1464">
 &lt; <b>apply hasNeeded_mem to HN M'.</b>

Subgoal 2:

Variables: K A Needed Updated KN C L Prf1 ID C1
IH : forall K A Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf * -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
MU : makeUsed Needed (ID::Prf1) Updated
HN : hasNeeded K Updated KN
GUL' : good_used_list Updated
RUP : lookup K ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help K (L::A) Prf1 *
M : mem ID (ID::Prf1)
M' : mem (ID, needed) Updated
H1 : mem (ID, C1) KN
============================
 rupProof_help KN A (ID::Prf1)
</pre>
<pre class="code extensibella"id="1465">
 &lt; <b>L: apply hasNeeded_lookup to _ _ _ _ _ HN RUP _.</b>

Subgoal 2:

Variables: K A Needed Updated KN C L Prf1 ID C1
IH : forall K A Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf * -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
MU : makeUsed Needed (ID::Prf1) Updated
HN : hasNeeded K Updated KN
GUL' : good_used_list Updated
RUP : lookup K ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help K (L::A) Prf1 *
M : mem ID (ID::Prf1)
M' : mem (ID, needed) Updated
H1 : mem (ID, C1) KN
L : lookup KN ID C
============================
 rupProof_help KN A (ID::Prf1)
</pre>
<pre class="code extensibella"id="1466">
 &lt; <b>MU': case MU (keep).</b>

Subgoal 2.1:

Variables: K A Needed KN C L Prf1 ID C1 KRest KOut
IH : forall K A Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf * -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
MU : makeUsed Needed (ID::Prf1) ((ID, needed)::KOut)
HN : hasNeeded K ((ID, needed)::KOut) KN
GUL' : good_used_list ((ID, needed)::KOut)
RUP : lookup K ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help K (L::A) Prf1 *
M : mem ID (ID::Prf1)
M' : mem (ID, needed) ((ID, needed)::KOut)
H1 : mem (ID, C1) KN
L : lookup KN ID C
MU' : select (ID, needed) KRest Needed
MU'1 : makeUsed KRest Prf1 KOut
============================
 rupProof_help KN A (ID::Prf1)
</pre>
<pre class="code extensibella"id="1467">
 &lt; <b>apply good_used_list_select to GUL MU'.</b>

Subgoal 2.1:

Variables: K A Needed KN C L Prf1 ID C1 KRest KOut
IH : forall K A Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf * -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
MU : makeUsed Needed (ID::Prf1) ((ID, needed)::KOut)
HN : hasNeeded K ((ID, needed)::KOut) KN
GUL' : good_used_list ((ID, needed)::KOut)
RUP : lookup K ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help K (L::A) Prf1 *
M : mem ID (ID::Prf1)
M' : mem (ID, needed) ((ID, needed)::KOut)
H1 : mem (ID, C1) KN
L : lookup KN ID C
MU' : select (ID, needed) KRest Needed
MU'1 : makeUsed KRest Prf1 KOut
H2 : good_used_list KRest
============================
 rupProof_help KN A (ID::Prf1)
</pre>
<pre class="code extensibella"id="1468">
 &lt; <b>HN': apply hasNeeded_drop to HN.</b>

Subgoal 2.1:

Variables: K A Needed KN C L Prf1 ID C1 KRest KOut
IH : forall K A Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf * -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
MU : makeUsed Needed (ID::Prf1) ((ID, needed)::KOut)
HN : hasNeeded K ((ID, needed)::KOut) KN
GUL' : good_used_list ((ID, needed)::KOut)
RUP : lookup K ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help K (L::A) Prf1 *
M : mem ID (ID::Prf1)
M' : mem (ID, needed) ((ID, needed)::KOut)
H1 : mem (ID, C1) KN
L : lookup KN ID C
MU' : select (ID, needed) KRest Needed
MU'1 : makeUsed KRest Prf1 KOut
H2 : good_used_list KRest
HN' : hasNeeded K KOut KN
============================
 rupProof_help KN A (ID::Prf1)
</pre>
<pre class="code extensibella"id="1469">
 &lt; <b>R: apply IH to _ _ _ _ _ RUP2 MU'1 HN'.</b>

Subgoal 2.1:

Variables: K A Needed KN C L Prf1 ID C1 KRest KOut
IH : forall K A Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf * -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
MU : makeUsed Needed (ID::Prf1) ((ID, needed)::KOut)
HN : hasNeeded K ((ID, needed)::KOut) KN
GUL' : good_used_list ((ID, needed)::KOut)
RUP : lookup K ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help K (L::A) Prf1 *
M : mem ID (ID::Prf1)
M' : mem (ID, needed) ((ID, needed)::KOut)
H1 : mem (ID, C1) KN
L : lookup KN ID C
MU' : select (ID, needed) KRest Needed
MU'1 : makeUsed KRest Prf1 KOut
H2 : good_used_list KRest
HN' : hasNeeded K KOut KN
R : rupProof_help KN (L::A) Prf1
============================
 rupProof_help KN A (ID::Prf1)
</pre>
<pre class="code extensibella"id="1470">
 &lt; <b>R': apply rupProof_help_orderless to _ _ GCL_KN R _.</b>

Subgoal 2.1:

Variables: K A Needed KN C L Prf1 ID C1 KRest KOut
IH : forall K A Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf * -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
MU : makeUsed Needed (ID::Prf1) ((ID, needed)::KOut)
HN : hasNeeded K ((ID, needed)::KOut) KN
GUL' : good_used_list ((ID, needed)::KOut)
RUP : lookup K ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help K (L::A) Prf1 *
M : mem ID (ID::Prf1)
M' : mem (ID, needed) ((ID, needed)::KOut)
H1 : mem (ID, C1) KN
L : lookup KN ID C
MU' : select (ID, needed) KRest Needed
MU'1 : makeUsed KRest Prf1 KOut
H2 : good_used_list KRest
HN' : hasNeeded K KOut KN
R : rupProof_help KN (L::A) Prf1
R' : rupProof_help KN (L::A) Prf1
============================
 rupProof_help KN A (ID::Prf1)
</pre>
<pre class="code extensibella"id="1471">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: K A Needed KN C L Prf1 ID C1 KRest KOut
IH : forall K A Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf * -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
MU : makeUsed Needed (ID::Prf1) ((ID, needed)::KOut)
HN : hasNeeded K ((ID, needed)::KOut) KN
GUL' : good_used_list ((ID, needed)::KOut)
RUP : lookup K ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help K (L::A) Prf1 *
M : mem ID (ID::Prf1)
M' : mem (ID, needed) ((ID, needed)::KOut)
H1 : mem (ID, C1) KN
L : lookup KN ID C
MU' : select (ID, unknown) KRest Needed
MU'1 : makeUsed KRest Prf1 KOut
============================
 rupProof_help KN A (ID::Prf1)
</pre>
<pre class="code extensibella"id="1472">
 &lt; <b>apply good_used_list_select to GUL MU'.</b>

Subgoal 2.2:

Variables: K A Needed KN C L Prf1 ID C1 KRest KOut
IH : forall K A Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf * -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
MU : makeUsed Needed (ID::Prf1) ((ID, needed)::KOut)
HN : hasNeeded K ((ID, needed)::KOut) KN
GUL' : good_used_list ((ID, needed)::KOut)
RUP : lookup K ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help K (L::A) Prf1 *
M : mem ID (ID::Prf1)
M' : mem (ID, needed) ((ID, needed)::KOut)
H1 : mem (ID, C1) KN
L : lookup KN ID C
MU' : select (ID, unknown) KRest Needed
MU'1 : makeUsed KRest Prf1 KOut
H2 : good_used_list KRest
============================
 rupProof_help KN A (ID::Prf1)
</pre>
<pre class="code extensibella"id="1473">
 &lt; <b>HN': apply hasNeeded_drop to HN.</b>

Subgoal 2.2:

Variables: K A Needed KN C L Prf1 ID C1 KRest KOut
IH : forall K A Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf * -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
MU : makeUsed Needed (ID::Prf1) ((ID, needed)::KOut)
HN : hasNeeded K ((ID, needed)::KOut) KN
GUL' : good_used_list ((ID, needed)::KOut)
RUP : lookup K ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help K (L::A) Prf1 *
M : mem ID (ID::Prf1)
M' : mem (ID, needed) ((ID, needed)::KOut)
H1 : mem (ID, C1) KN
L : lookup KN ID C
MU' : select (ID, unknown) KRest Needed
MU'1 : makeUsed KRest Prf1 KOut
H2 : good_used_list KRest
HN' : hasNeeded K KOut KN
============================
 rupProof_help KN A (ID::Prf1)
</pre>
<pre class="code extensibella"id="1474">
 &lt; <b>R: apply IH to _ _ _ _ _ RUP2 MU'1 HN'.</b>

Subgoal 2.2:

Variables: K A Needed KN C L Prf1 ID C1 KRest KOut
IH : forall K A Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf * -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
MU : makeUsed Needed (ID::Prf1) ((ID, needed)::KOut)
HN : hasNeeded K ((ID, needed)::KOut) KN
GUL' : good_used_list ((ID, needed)::KOut)
RUP : lookup K ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help K (L::A) Prf1 *
M : mem ID (ID::Prf1)
M' : mem (ID, needed) ((ID, needed)::KOut)
H1 : mem (ID, C1) KN
L : lookup KN ID C
MU' : select (ID, unknown) KRest Needed
MU'1 : makeUsed KRest Prf1 KOut
H2 : good_used_list KRest
HN' : hasNeeded K KOut KN
R : rupProof_help KN (L::A) Prf1
============================
 rupProof_help KN A (ID::Prf1)
</pre>
<pre class="code extensibella"id="1475">
 &lt; <b>R': apply rupProof_help_orderless to _ _ GCL_KN R _.</b>

Subgoal 2.2:

Variables: K A Needed KN C L Prf1 ID C1 KRest KOut
IH : forall K A Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof_help K A Prf * -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof_help KN A Prf
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
MU : makeUsed Needed (ID::Prf1) ((ID, needed)::KOut)
HN : hasNeeded K ((ID, needed)::KOut) KN
GUL' : good_used_list ((ID, needed)::KOut)
RUP : lookup K ID C
RUP1 : unit_clause A C L
RUP2 : rupProof_help K (L::A) Prf1 *
M : mem ID (ID::Prf1)
M' : mem (ID, needed) ((ID, needed)::KOut)
H1 : mem (ID, C1) KN
L : lookup KN ID C
MU' : select (ID, unknown) KRest Needed
MU'1 : makeUsed KRest Prf1 KOut
H2 : good_used_list KRest
HN' : hasNeeded K KOut KN
R : rupProof_help KN (L::A) Prf1
R' : rupProof_help KN (L::A) Prf1
============================
 rupProof_help KN A (ID::Prf1)
</pre>
<pre class="code extensibella"id="1476">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="1477">
 &lt; <b>Theorem rupProof_hasNeeded :
     forall K C Prf Needed Updated KN,
       is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
       is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof K C Prf -&gt;
       makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof KN C Prf.</b>

============================
 forall K C Prf Needed Updated KN,
   is_list (is_pair is_integer is_clause) K -&gt; good_clause_list K -&gt; good_used_list Needed -&gt;
   is_list (is_pair is_integer is_clause) KN -&gt; good_clause_list KN -&gt; rupProof K C Prf -&gt;
   makeUsed Needed Prf Updated -&gt; hasNeeded K Updated KN -&gt; rupProof KN C Prf
</pre>
<pre class="code extensibella"id="1478">
 &lt; <b>intros IsK GCL GUL IsKN GCL_KN RUP MU HN.</b>

Variables: K C Prf Needed Updated KN
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
RUP : rupProof K C Prf
MU : makeUsed Needed Prf Updated
HN : hasNeeded K Updated KN
============================
 rupProof KN C Prf
</pre>
<pre class="code extensibella"id="1479">
 &lt; <b>RUP: case RUP.</b>

Variables: K C Prf Needed Updated KN Lits A
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
MU : makeUsed Needed Prf Updated
HN : hasNeeded K Updated KN
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help K A Prf
============================
 rupProof KN C Prf
</pre>
<pre class="code extensibella"id="1480">
 &lt; <b>apply rupProof_help_hasNeeded to IsK GCL GUL IsKN GCL_KN RUP2 MU HN.</b>

Variables: K C Prf Needed Updated KN Lits A
IsK : is_list (is_pair is_integer is_clause) K
GCL : good_clause_list K
GUL : good_used_list Needed
IsKN : is_list (is_pair is_integer is_clause) KN
GCL_KN : good_clause_list KN
MU : makeUsed Needed Prf Updated
HN : hasNeeded K Updated KN
RUP : gatherLits C Lits
RUP1 : negateLitList Lits A
RUP2 : rupProof_help K A Prf
H1 : rupProof_help KN A Prf
============================
 rupProof KN C Prf
</pre>
<pre class="code extensibella"id="1481">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="1482">
 &lt; <b>Theorem hasNeeded_select_known :
     forall K CU N ID C KRest,
       hasNeeded K ((ID, unknown)::CU) N -&gt; select (ID, C) KRest K -&gt; good_used_list ((ID, unknown)::CU) -&gt;
       hasNeeded KRest CU N.</b>

============================
 forall K CU N ID C KRest,
   hasNeeded K ((ID, unknown)::CU) N -&gt; select (ID, C) KRest K -&gt; good_used_list ((ID, unknown)::CU) -&gt;
   hasNeeded KRest CU N
</pre>
<pre class="code extensibella"id="1483">
 &lt; <b>intros HN S GUL.</b>

Variables: K CU N ID C KRest
HN : hasNeeded K ((ID, unknown)::CU) N
S : select (ID, C) KRest K
GUL : good_used_list ((ID, unknown)::CU)
============================
 hasNeeded KRest CU N
</pre>
<pre class="code extensibella"id="1484">
 &lt; <b>HN': apply hasNeeded_drop to HN.</b>

Variables: K CU N ID C KRest
HN : hasNeeded K ((ID, unknown)::CU) N
S : select (ID, C) KRest K
GUL : good_used_list ((ID, unknown)::CU)
HN' : hasNeeded K CU N
============================
 hasNeeded KRest CU N
</pre>
<pre class="code extensibella"id="1485">
 &lt; <b>HN': case HN'.</b>

Variables: K CU N ID C KRest
HN : hasNeeded K ((ID, unknown)::CU) N
S : select (ID, C) KRest K
GUL : good_used_list ((ID, unknown)::CU)
HN' : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) N
HN'1 : forall ID CN CK, mem (ID, CN) N -&gt; mem (ID, CK) K -&gt; CN = CK
============================
 hasNeeded KRest CU N
</pre>
<pre class="code extensibella"id="1486">
 &lt; <b>unfold .</b>

Subgoal 1:

Variables: K CU N ID C KRest
HN : hasNeeded K ((ID, unknown)::CU) N
S : select (ID, C) KRest K
GUL : good_used_list ((ID, unknown)::CU)
HN' : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) N
HN'1 : forall ID CN CK, mem (ID, CN) N -&gt; mem (ID, CK) K -&gt; CN = CK
============================
 forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) N
</pre>
<pre class="code extensibella"id="1487">
 &lt; <b>search.</b>

Subgoal 2:

Variables: K CU N ID C KRest
HN : hasNeeded K ((ID, unknown)::CU) N
S : select (ID, C) KRest K
GUL : good_used_list ((ID, unknown)::CU)
HN' : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) N
HN'1 : forall ID CN CK, mem (ID, CN) N -&gt; mem (ID, CK) K -&gt; CN = CK
============================
 forall ID CN CK, mem (ID, CN) N -&gt; mem (ID, CK) KRest -&gt; CN = CK
</pre>
<pre class="code extensibella"id="1488">
 &lt; <b>intros MN MKR.</b>

Subgoal 2:

Variables: K CU N ID C KRest ID1 CN CK
HN : hasNeeded K ((ID, unknown)::CU) N
S : select (ID, C) KRest K
GUL : good_used_list ((ID, unknown)::CU)
HN' : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) N
HN'1 : forall ID CN CK, mem (ID, CN) N -&gt; mem (ID, CK) K -&gt; CN = CK
MN : mem (ID1, CN) N
MKR : mem (ID1, CK) KRest
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1489">
 &lt; <b>MK: apply mem_after_select_before to S MKR.</b>

Subgoal 2:

Variables: K CU N ID C KRest ID1 CN CK
HN : hasNeeded K ((ID, unknown)::CU) N
S : select (ID, C) KRest K
GUL : good_used_list ((ID, unknown)::CU)
HN' : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) N
HN'1 : forall ID CN CK, mem (ID, CN) N -&gt; mem (ID, CK) K -&gt; CN = CK
MN : mem (ID1, CN) N
MKR : mem (ID1, CK) KRest
MK : mem (ID1, CK) K
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1490">
 &lt; <b>apply HN'1 to MN MK.</b>

Subgoal 2:

Variables: K CU N ID C KRest ID1 CK
HN : hasNeeded K ((ID, unknown)::CU) N
S : select (ID, C) KRest K
GUL : good_used_list ((ID, unknown)::CU)
HN' : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) N
HN'1 : forall ID CN CK, mem (ID, CN) N -&gt; mem (ID, CK) K -&gt; CN = CK
MN : mem (ID1, CK) N
MKR : mem (ID1, CK) KRest
MK : mem (ID1, CK) K
============================
 CK = CK
</pre>
<pre class="code extensibella"id="1491">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="1492">
 &lt; <b>Theorem good_used_list_mems :
     forall L X UA UB,
       good_used_list L -&gt; mem (X, UA) L -&gt; mem (X, UB) L -&gt; UA = UB.</b>

============================
 forall L X UA UB, good_used_list L -&gt; mem (X, UA) L -&gt; mem (X, UB) L -&gt; UA = UB
</pre>
<pre class="code extensibella"id="1493">
 &lt; <b>induction on 2.</b>

IH : forall L X UA UB,
       good_used_list L -&gt; mem (X, UA) L * -&gt; mem (X, UB) L -&gt; UA = UB
============================
 forall L X UA UB,
   good_used_list L -&gt; mem (X, UA) L @ -&gt; mem (X, UB) L -&gt; UA = UB
</pre>
<pre class="code extensibella"id="1494">
 &lt; <b>intros GUL MA MB.</b>

Variables: L X UA UB
IH : forall L X UA UB,
       good_used_list L -&gt; mem (X, UA) L * -&gt; mem (X, UB) L -&gt; UA = UB
GUL : good_used_list L
MA : mem (X, UA) L @
MB : mem (X, UB) L
============================
 UA = UB
</pre>
<pre class="code extensibella"id="1495">
 &lt; <b>MA: case MA.</b>

Subgoal 1:

Variables: X UA UB Rest
IH : forall L X UA UB,
       good_used_list L -&gt; mem (X, UA) L * -&gt; mem (X, UB) L -&gt; UA = UB
GUL : good_used_list ((X, UA)::Rest)
MB : mem (X, UB) ((X, UA)::Rest)
============================
 UA = UB
</pre>
<pre class="code extensibella"id="1496">
 &lt; <b>MB: case MB.</b>

Subgoal 1.1:

Variables: X UA Rest
IH : forall L X UA UB,
       good_used_list L -&gt; mem (X, UA) L * -&gt; mem (X, UB) L -&gt; UA = UB
GUL : good_used_list ((X, UA)::Rest)
============================
 UA = UA
</pre>
<pre class="code extensibella"id="1497">
 &lt; <b>search.</b>

Subgoal 1.2:

Variables: X UA UB Rest
IH : forall L X UA UB,
       good_used_list L -&gt; mem (X, UA) L * -&gt; mem (X, UB) L -&gt; UA = UB
GUL : good_used_list ((X, UA)::Rest)
MB : mem (X, UB) Rest
============================
 UA = UB
</pre>
<pre class="code extensibella"id="1498">
 &lt; <b>GUL: case GUL.</b>

Subgoal 1.2:

Variables: X UA UB Rest
IH : forall L X UA UB,
       good_used_list L -&gt; mem (X, UA) L * -&gt; mem (X, UB) L -&gt; UA = UB
MB : mem (X, UB) Rest
GUL : forall ID U1 CURest U2,
        select (ID, U1) CURest ((X, UA)::Rest) -&gt; mem (ID, U2) CURest -&gt; false
============================
 UA = UB
</pre>
<pre class="code extensibella"id="1499">
 &lt; <b>apply GUL to _ MB.</b>

Subgoal 2:

Variables: X UA UB Rest I
IH : forall L X UA UB,
       good_used_list L -&gt; mem (X, UA) L * -&gt; mem (X, UB) L -&gt; UA = UB
GUL : good_used_list (I::Rest)
MB : mem (X, UB) (I::Rest)
MA : mem (X, UA) Rest *
============================
 UA = UB
</pre>
<pre class="code extensibella"id="1500">
 &lt; <b>MB: case MB.</b>

Subgoal 2.1:

Variables: X UA UB Rest
IH : forall L X UA UB,
       good_used_list L -&gt; mem (X, UA) L * -&gt; mem (X, UB) L -&gt; UA = UB
GUL : good_used_list ((X, UB)::Rest)
MA : mem (X, UA) Rest *
============================
 UA = UB
</pre>
<pre class="code extensibella"id="1501">
 &lt; <b>GUL: case GUL.</b>

Subgoal 2.1:

Variables: X UA UB Rest
IH : forall L X UA UB,
       good_used_list L -&gt; mem (X, UA) L * -&gt; mem (X, UB) L -&gt; UA = UB
MA : mem (X, UA) Rest *
GUL : forall ID U1 CURest U2,
        select (ID, U1) CURest ((X, UB)::Rest) -&gt; mem (ID, U2) CURest -&gt; false
============================
 UA = UB
</pre>
<pre class="code extensibella"id="1502">
 &lt; <b>apply GUL to _ MA.</b>

Subgoal 2.2:

Variables: X UA UB Rest I
IH : forall L X UA UB,
       good_used_list L -&gt; mem (X, UA) L * -&gt; mem (X, UB) L -&gt; UA = UB
GUL : good_used_list (I::Rest)
MA : mem (X, UA) Rest *
MB : mem (X, UB) Rest
============================
 UA = UB
</pre>
<pre class="code extensibella"id="1503">
 &lt; <b>GUL': apply good_used_list_drop to GUL.</b>

Subgoal 2.2:

Variables: X UA UB Rest I
IH : forall L X UA UB,
       good_used_list L -&gt; mem (X, UA) L * -&gt; mem (X, UB) L -&gt; UA = UB
GUL : good_used_list (I::Rest)
MA : mem (X, UA) Rest *
MB : mem (X, UB) Rest
GUL' : good_used_list Rest
============================
 UA = UB
</pre>
<pre class="code extensibella"id="1504">
 &lt; <b>apply IH to GUL' MA MB.</b>

Subgoal 2.2:

Variables: X UB Rest I
IH : forall L X UA UB,
       good_used_list L -&gt; mem (X, UA) L * -&gt; mem (X, UB) L -&gt; UA = UB
GUL : good_used_list (I::Rest)
MA : mem (X, UB) Rest *
MB : mem (X, UB) Rest
GUL' : good_used_list Rest
============================
 UB = UB
</pre>
<pre class="code extensibella"id="1505">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="1506">
 &lt; <b>Extensible_Theorem
      elaboration_check_add : forall KA KB KC P CU E,
         IsP : is_proof P -&gt;
         IsKA : is_list (is_pair is_integer is_clause) KA -&gt;
         IsKB : is_list (is_pair is_integer is_clause) KB -&gt;
         IsKC : is_list (is_pair is_integer is_clause) KC -&gt;
         GCLA : good_clause_list KA -&gt;
         GCLB : good_clause_list KB -&gt;
         GCLC : good_clause_list KC -&gt;
         Ela : elaborate KA P CU E -&gt;
         CP : checkProof KB E -&gt;
         Mems : (forall ID C,
           mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt;
         checkProof KC E
      on Ela.</b>

Subgoal 1:

Variables: KA KB KC CU Needed NRest Prf ID FC
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsP : is_proof (endFrat ID FC)
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (endFrat ID FC) CU (emptyLrat ID Prf) @
CP : checkProof KB (emptyLrat ID Prf)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID, needed) NRest Needed
Ela3 : rupProof KA emptyClause Prf
Ela4 : makeUsed NRest Prf CU
============================
 checkProof KC (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="1507">
 &lt; <b>CP: case CP (keep).</b>

Subgoal 1:

Variables: KA KB KC CU Needed NRest Prf ID FC
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsP : is_proof (endFrat ID FC)
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (endFrat ID FC) CU (emptyLrat ID Prf) @
CP : checkProof KB (emptyLrat ID Prf)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID, needed) NRest Needed
Ela3 : rupProof KA emptyClause Prf
Ela4 : makeUsed NRest Prf CU
CP1 : rupProof KB emptyClause Prf
============================
 checkProof KC (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="1508">
 &lt; <b>apply rupProof_orderless to _ _ _ CP1 _ with
     K2 = KC.</b>

Subgoal 1:

Variables: KA KB KC CU Needed NRest Prf ID FC
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsP : is_proof (endFrat ID FC)
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (endFrat ID FC) CU (emptyLrat ID Prf) @
CP : checkProof KB (emptyLrat ID Prf)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID, needed) NRest Needed
Ela3 : rupProof KA emptyClause Prf
Ela4 : makeUsed NRest Prf CU
CP1 : rupProof KB emptyClause Prf
H1 : rupProof KC emptyClause Prf
============================
 checkProof KC (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="1509">
 &lt; <b>search.</b>

Subgoal 2:

Variables: KA KB KC CU Needed NRest Prf ID FC
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsP : is_proof (endFratPrf ID Prf FC)
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (endFratPrf ID Prf FC) CU (emptyLrat ID Prf) @
CP : checkProof KB (emptyLrat ID Prf)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID, needed) NRest Needed
Ela3 : makeUsed NRest Prf CU
============================
 checkProof KC (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="1510">
 &lt; <b>CP: case CP (keep).</b>

Subgoal 2:

Variables: KA KB KC CU Needed NRest Prf ID FC
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsP : is_proof (endFratPrf ID Prf FC)
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (endFratPrf ID Prf FC) CU (emptyLrat ID Prf) @
CP : checkProof KB (emptyLrat ID Prf)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID, needed) NRest Needed
Ela3 : makeUsed NRest Prf CU
CP1 : rupProof KB emptyClause Prf
============================
 checkProof KC (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="1511">
 &lt; <b>apply rupProof_orderless to _ _ _ CP1 _ with
     K2 = KC.</b>

Subgoal 2:

Variables: KA KB KC CU Needed NRest Prf ID FC
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsP : is_proof (endFratPrf ID Prf FC)
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (endFratPrf ID Prf FC) CU (emptyLrat ID Prf) @
CP : checkProof KB (emptyLrat ID Prf)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : endKnownClauses FC Needed
Ela2 : select (ID, needed) NRest Needed
Ela3 : makeUsed NRest Prf CU
CP1 : rupProof KB emptyClause Prf
H1 : rupProof KC emptyClause Prf
============================
 checkProof KC (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="1512">
 &lt; <b>search.</b>

Subgoal 3:

Variables: KA KB KC E KRest Needed ID Rest C
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsP : is_proof (deleteFrat ID C Rest)
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (deleteFrat ID C Rest) ((ID, unknown)::Needed) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : select (ID, C) KRest KA
Ela2 : elaborate KRest Rest Needed E *
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1513">
 &lt; <b>Is: case IsP.</b>

Subgoal 3:

Variables: KA KB KC E KRest Needed ID Rest C
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (deleteFrat ID C Rest) ((ID, unknown)::Needed) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : select (ID, C) KRest KA
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1514">
 &lt; <b>apply good_clause_list_select to _ Ela1.</b>

Subgoal 3:

Variables: KA KB KC E KRest Needed ID Rest C
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (deleteFrat ID C Rest) ((ID, unknown)::Needed) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : select (ID, C) KRest KA
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : good_clause_list KRest
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1515">
 &lt; <b>apply select_is to _ Ela1.</b>

Subgoal 3:

Variables: KA KB KC E KRest Needed ID Rest C
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (deleteFrat ID C Rest) ((ID, unknown)::Needed) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : select (ID, C) KRest KA
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : good_clause_list KRest
H2 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1516">
 &lt; <b>apply IH to _ _ _ _ _ _ _ Ela2 CP _.</b>

Subgoal 3:

Variables: KA KB KC E KRest Needed ID Rest C
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (deleteFrat ID C Rest) ((ID, unknown)::Needed) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : select (ID, C) KRest KA
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : good_clause_list KRest
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : checkProof KC E
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1517">
 &lt; <b>search.</b>

Subgoal 4:

Variables: KA KB KC E C KRest Needed ID Rest
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsP : is_proof (deleteLratProof ID Rest)
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (deleteLratProof ID Rest) ((ID, unknown)::Needed) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : select (ID, C) KRest KA
Ela2 : elaborate KRest Rest Needed E *
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1518">
 &lt; <b>Is: case IsP.</b>

Subgoal 4:

Variables: KA KB KC E C KRest Needed ID Rest
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (deleteLratProof ID Rest) ((ID, unknown)::Needed) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : select (ID, C) KRest KA
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID
Is1 : is_proof Rest
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1519">
 &lt; <b>apply good_clause_list_select to _ Ela1.</b>

Subgoal 4:

Variables: KA KB KC E C KRest Needed ID Rest
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (deleteLratProof ID Rest) ((ID, unknown)::Needed) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : select (ID, C) KRest KA
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID
Is1 : is_proof Rest
H1 : good_clause_list KRest
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1520">
 &lt; <b>apply select_is to _ Ela1.</b>

Subgoal 4:

Variables: KA KB KC E C KRest Needed ID Rest
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (deleteLratProof ID Rest) ((ID, unknown)::Needed) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : select (ID, C) KRest KA
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID
Is1 : is_proof Rest
H1 : good_clause_list KRest
H2 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1521">
 &lt; <b>apply IH to _ _ _ _ _ _ _ Ela2 CP _.</b>

Subgoal 4:

Variables: KA KB KC E C KRest Needed ID Rest
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (deleteLratProof ID Rest) ((ID, unknown)::Needed) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : select (ID, C) KRest KA
Ela2 : elaborate KRest Rest Needed E *
Is : is_integer ID
Is1 : is_proof Rest
H1 : good_clause_list KRest
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : checkProof KC E
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1522">
 &lt; <b>search.</b>

Subgoal 5:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsP : is_proof (addLrupProof ID C Prf Rest)
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
============================
 checkProof KC (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1523">
 &lt; <b>Is: case IsP.</b>

Subgoal 5:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
============================
 checkProof KC (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1524">
 &lt; <b>CP: case CP (keep).</b>

Subgoal 5:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
============================
 checkProof KC (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1525">
 &lt; <b>apply good_clause_list_remove_all_add to _ Ela1 with
     C = C.</b>

Subgoal 5:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
============================
 checkProof KC (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1526">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 5:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof KC (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1527">
 &lt; <b>apply good_clause_list_remove_all_add to _ CP1 with
     C = C.</b>

Subgoal 5:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
============================
 checkProof KC (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1528">
 &lt; <b>apply remove_all_is to _ CP1.</b>

Subgoal 5:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
============================
 checkProof KC (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1529">
 &lt; <b>RAC: apply remove_all_exists to IsKC Is.</b>

Subgoal 5:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
============================
 checkProof KC (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1530">
 &lt; <b>GCLC': apply good_clause_list_remove_all_add to _ RAC with
            C = C.</b>

Subgoal 5:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
============================
 checkProof KC (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1531">
 &lt; <b>apply remove_all_is to _ RAC.</b>

Subgoal 5:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
============================
 checkProof KC (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1532">
 &lt; <b>apply IH to _ _ _ _ _ _ GCLC' Ela2 CP3 _.</b>

Subgoal 5.1:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
============================
 forall ID1 C1, mem (ID1, C1) ((ID, C)::KRest1) -&gt; mem (ID1, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1533">
 &lt; <b>intros MKR1+.</b>

Subgoal 5.1:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR ID1 C1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
MKR1+ : mem (ID1, C1) ((ID, C)::KRest1)
============================
 mem (ID1, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1534">
 &lt; <b>MKR1: case MKR1+.</b>

Subgoal 5.1.1:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
============================
 mem (ID, C) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1535">
 &lt; <b>search.</b>

Subgoal 5.1.2:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR ID1 C1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
MKR1 : mem (ID1, C1) KRest1
============================
 mem (ID1, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1536">
 &lt; <b>MB: apply remove_all_mem_after to CP1 MKR1.</b>

Subgoal 5.1.2:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR ID1 C1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
MKR1 : mem (ID1, C1) KRest1
MB : mem (ID1, C1) KB
============================
 mem (ID1, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1537">
 &lt; <b>MC: apply Mems to MB.</b>

Subgoal 5.1.2:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR ID1 C1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
MKR1 : mem (ID1, C1) KRest1
MB : mem (ID1, C1) KB
MC : mem (ID1, C1) KC
============================
 mem (ID1, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1538">
 &lt; <b>apply remove_all_still_mem to RAC MC _.</b>

Subgoal 5.1.2.1:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR ID1 C1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
MKR1 : mem (ID1, C1) KRest1
MB : mem (ID1, C1) KB
MC : mem (ID1, C1) KC
============================
 ID = ID1 -&gt; false
</pre>
<pre class="code extensibella"id="1539">
 &lt; <b>intros E.</b>

Subgoal 5.1.2.1:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR ID1 C1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
MKR1 : mem (ID1, C1) KRest1
MB : mem (ID1, C1) KB
MC : mem (ID1, C1) KC
E : ID = ID1
============================
 false
</pre>
<pre class="code extensibella"id="1540">
 &lt; <b>case E.</b>

Subgoal 5.1.2.1:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C Rest KRest1 KR ID1 C1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID1 C Prf Rest) CU (addLrupProof ID1 C Prf ERest) @
CP : checkProof KB (addLrupProof ID1 C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all KB ID1 KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID1, C)::KRest1) ERest
H1 : good_clause_list ((ID1, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID1, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID1 KR
GCLC' : good_clause_list ((ID1, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
MKR1 : mem (ID1, C1) KRest1
MB : mem (ID1, C1) KB
MC : mem (ID1, C1) KC
============================
 false
</pre>
<pre class="code extensibella"id="1541">
 &lt; <b>apply remove_all_no_mem to CP1 MKR1.</b>

Subgoal 5.1.2:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR ID1 C1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
MKR1 : mem (ID1, C1) KRest1
MB : mem (ID1, C1) KB
MC : mem (ID1, C1) KC
H6 : mem (ID1, C1) KR
============================
 mem (ID1, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1542">
 &lt; <b>search.</b>

Subgoal 5:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
H6 : checkProof ((ID, C)::KR) ERest
============================
 checkProof KC (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1543">
 &lt; <b>apply rupProof_orderless to _ _ _ CP2 Mems.</b>

Subgoal 5:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
H6 : checkProof ((ID, C)::KR) ERest
H7 : rupProof KC C Prf
============================
 checkProof KC (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1544">
 &lt; <b>search.</b>

Subgoal 6:

Variables: KA KB KC CU E KRest Needed Rest Prf C ID
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsP : is_proof (addLrupProof ID C Prf Rest)
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1545">
 &lt; <b>Is: case IsP.</b>

Subgoal 6:

Variables: KA KB KC CU E KRest Needed Rest Prf C ID
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1546">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 6:

Variables: KA KB KC CU E KRest Needed Rest Prf C ID
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1547">
 &lt; <b>apply good_clause_list_remove_all_add to _ Ela1 with
     C = C.</b>

Subgoal 6:

Variables: KA KB KC CU E KRest Needed Rest Prf C ID
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1548">
 &lt; <b>apply IH to _ _ _ _ _ _ GCLC Ela2 CP _.</b>

Subgoal 6:

Variables: KA KB KC CU E KRest Needed Rest Prf C ID
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addLrupProof ID C Prf Rest) CU E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : checkProof KC E
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1549">
 &lt; <b>search.</b>

Subgoal 7:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsP : is_proof (addProofless ID C Rest)
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof KA C Prf
Ela5 : makeUsed NRest Prf CU
============================
 checkProof KC (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1550">
 &lt; <b>Is: case IsP.</b>

Subgoal 7:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof KA C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
============================
 checkProof KC (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1551">
 &lt; <b>CP: case CP (keep).</b>

Subgoal 7:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof KA C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
============================
 checkProof KC (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1552">
 &lt; <b>apply good_clause_list_remove_all_add to _ Ela1 with
     C = C.</b>

Subgoal 7:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof KA C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
============================
 checkProof KC (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1553">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 7:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof KA C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof KC (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1554">
 &lt; <b>apply good_clause_list_remove_all_add to _ CP1 with
     C = C.</b>

Subgoal 7:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof KA C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
============================
 checkProof KC (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1555">
 &lt; <b>apply remove_all_is to _ CP1.</b>

Subgoal 7:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof KA C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
============================
 checkProof KC (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1556">
 &lt; <b>RAC: apply remove_all_exists to IsKC Is.</b>

Subgoal 7:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof KA C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
============================
 checkProof KC (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1557">
 &lt; <b>GCLC': apply good_clause_list_remove_all_add to _ RAC with
            C = C.</b>

Subgoal 7:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof KA C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
============================
 checkProof KC (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1558">
 &lt; <b>apply remove_all_is to _ RAC.</b>

Subgoal 7:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof KA C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
============================
 checkProof KC (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1559">
 &lt; <b>apply IH to _ _ _ _ _ _ GCLC' Ela2 CP3 _.</b>

Subgoal 7.1:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof KA C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
============================
 forall ID1 C1, mem (ID1, C1) ((ID, C)::KRest1) -&gt; mem (ID1, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1560">
 &lt; <b>intros MKR1+.</b>

Subgoal 7.1:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR ID1 C1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof KA C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
MKR1+ : mem (ID1, C1) ((ID, C)::KRest1)
============================
 mem (ID1, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1561">
 &lt; <b>MKR1: case MKR1+.</b>

Subgoal 7.1.1:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof KA C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
============================
 mem (ID, C) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1562">
 &lt; <b>search.</b>

Subgoal 7.1.2:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR ID1 C1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof KA C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
MKR1 : mem (ID1, C1) KRest1
============================
 mem (ID1, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1563">
 &lt; <b>MB: apply remove_all_mem_after to CP1 MKR1.</b>

Subgoal 7.1.2:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR ID1 C1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof KA C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
MKR1 : mem (ID1, C1) KRest1
MB : mem (ID1, C1) KB
============================
 mem (ID1, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1564">
 &lt; <b>MC: apply Mems to MB.</b>

Subgoal 7.1.2:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR ID1 C1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof KA C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
MKR1 : mem (ID1, C1) KRest1
MB : mem (ID1, C1) KB
MC : mem (ID1, C1) KC
============================
 mem (ID1, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1565">
 &lt; <b>apply remove_all_still_mem to RAC MC _.</b>

Subgoal 7.1.2.1:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR ID1 C1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof KA C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
MKR1 : mem (ID1, C1) KRest1
MB : mem (ID1, C1) KB
MC : mem (ID1, C1) KC
============================
 ID = ID1 -&gt; false
</pre>
<pre class="code extensibella"id="1566">
 &lt; <b>intros E.</b>

Subgoal 7.1.2.1:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR ID1 C1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof KA C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
MKR1 : mem (ID1, C1) KRest1
MB : mem (ID1, C1) KB
MC : mem (ID1, C1) KC
E : ID = ID1
============================
 false
</pre>
<pre class="code extensibella"id="1567">
 &lt; <b>case E.</b>

Subgoal 7.1.2.1:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C Rest KRest1 KR ID1 C1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID1 C Rest) CU (addLrupProof ID1 C Prf ERest) @
CP : checkProof KB (addLrupProof ID1 C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID1 KRest
Ela2 : elaborate ((ID1, C)::KRest) Rest Needed ERest *
Ela3 : select (ID1, needed) NRest Needed
Ela4 : rupProof KA C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all KB ID1 KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID1, C)::KRest1) ERest
H1 : good_clause_list ((ID1, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID1, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID1 KR
GCLC' : good_clause_list ((ID1, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
MKR1 : mem (ID1, C1) KRest1
MB : mem (ID1, C1) KB
MC : mem (ID1, C1) KC
============================
 false
</pre>
<pre class="code extensibella"id="1568">
 &lt; <b>apply remove_all_no_mem to CP1 MKR1.</b>

Subgoal 7.1.2:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR ID1 C1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof KA C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
MKR1 : mem (ID1, C1) KRest1
MB : mem (ID1, C1) KB
MC : mem (ID1, C1) KC
H6 : mem (ID1, C1) KR
============================
 mem (ID1, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1569">
 &lt; <b>search.</b>

Subgoal 7:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof KA C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
H6 : checkProof ((ID, C)::KR) ERest
============================
 checkProof KC (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1570">
 &lt; <b>apply rupProof_orderless to _ _ _ CP2 Mems.</b>

Subgoal 7:

Variables: KA KB KC CU KRest Needed NRest ERest Prf C ID Rest KRest1 KR
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
CP : checkProof KB (addLrupProof ID C Prf ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed ERest *
Ela3 : select (ID, needed) NRest Needed
Ela4 : rupProof KA C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all KB ID KRest1
CP2 : rupProof KB C Prf
CP3 : checkProof ((ID, C)::KRest1) ERest
H1 : good_clause_list ((ID, C)::KRest)
H2 : is_list (is_pair is_integer is_clause) KRest
H3 : good_clause_list ((ID, C)::KRest1)
H4 : is_list (is_pair is_integer is_clause) KRest1
RAC : remove_all KC ID KR
GCLC' : good_clause_list ((ID, C)::KR)
H5 : is_list (is_pair is_integer is_clause) KR
H6 : checkProof ((ID, C)::KR) ERest
H7 : rupProof KC C Prf
============================
 checkProof KC (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1571">
 &lt; <b>search.</b>

Subgoal 8:

Variables: KA KB KC CU E KRest Needed Rest C ID
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsP : is_proof (addProofless ID C Rest)
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1572">
 &lt; <b>Is: case IsP.</b>

Subgoal 8:

Variables: KA KB KC CU E KRest Needed Rest C ID
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1573">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 8:

Variables: KA KB KC CU E KRest Needed Rest C ID
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1574">
 &lt; <b>apply good_clause_list_remove_all_add to _ Ela1 with
     C = C.</b>

Subgoal 8:

Variables: KA KB KC CU E KRest Needed Rest C ID
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1575">
 &lt; <b>apply IH to _ _ _ _ _ _ GCLC Ela2 CP _.</b>

Subgoal 8:

Variables: KA KB KC CU E KRest Needed Rest C ID
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (addProofless ID C Rest) CU E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : checkProof KC E
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1576">
 &lt; <b>search.</b>

Subgoal 9:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsP : is_proof (relocateClause From To Rest)
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
============================
 checkProof KC (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1577">
 &lt; <b>Is: case IsP.</b>

Subgoal 9:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
============================
 checkProof KC (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1578">
 &lt; <b>CP: case CP (keep).</b>

Subgoal 9.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
============================
 checkProof KC (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1579">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 9.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof KC (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1580">
 &lt; <b>apply select_is to _ Ela2.</b>

Subgoal 9.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
============================
 checkProof KC (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1581">
 &lt; <b>assert good_clause_list ((To, C)::KRest2).</b>

Subgoal 9.1.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
============================
 good_clause_list ((To, C)::KRest2)
</pre>
<pre class="code extensibella"id="1582">
 &lt; <b>unfold .</b>

Subgoal 9.1.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
============================
 forall ID C1 KRest C2,
   select (ID, C1) KRest ((To, C)::KRest2) -&gt; mem (ID, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="1583">
 &lt; <b>intros S M.</b>

Subgoal 9.1.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 ID C2 KRest4 C3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
S : select (ID, C2) KRest4 ((To, C)::KRest2)
M : mem (ID, C3) KRest4
============================
 false
</pre>
<pre class="code extensibella"id="1584">
 &lt; <b>S: case S.</b>

Subgoal 9.1.1.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 C3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (To, C3) KRest2
============================
 false
</pre>
<pre class="code extensibella"id="1585">
 &lt; <b>M': apply mem_after_select_before to Ela2 M.</b>

Subgoal 9.1.1.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 C3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (To, C3) KRest2
M' : mem (To, C3) KRest
============================
 false
</pre>
<pre class="code extensibella"id="1586">
 &lt; <b>apply remove_all_no_mem to Ela1 M'.</b>

Subgoal 9.1.1.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 ID C2 C3 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (ID, C3) ((To, C)::L1)
S : select (ID, C2) L1 KRest2
============================
 false
</pre>
<pre class="code extensibella"id="1587">
 &lt; <b>M: case M.</b>

Subgoal 9.1.1.2.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 C2 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
S : select (To, C2) L1 KRest2
============================
 false
</pre>
<pre class="code extensibella"id="1588">
 &lt; <b>M: apply select_mem to S.</b>

Subgoal 9.1.1.2.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 C2 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
S : select (To, C2) L1 KRest2
M : mem (To, C2) KRest2
============================
 false
</pre>
<pre class="code extensibella"id="1589">
 &lt; <b>M': apply mem_after_select_before to Ela2 M.</b>

Subgoal 9.1.1.2.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 C2 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
S : select (To, C2) L1 KRest2
M : mem (To, C2) KRest2
M' : mem (To, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="1590">
 &lt; <b>M'': apply remove_all_no_mem to Ela1 M'.</b>

Subgoal 9.1.1.2.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 ID C2 C3 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
S : select (ID, C2) L1 KRest2
M : mem (ID, C3) L1
============================
 false
</pre>
<pre class="code extensibella"id="1591">
 &lt; <b>apply good_clause_list_remove_all to _ Ela1.</b>

Subgoal 9.1.1.2.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 ID C2 C3 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
S : select (ID, C2) L1 KRest2
M : mem (ID, C3) L1
H3 : good_clause_list KRest
============================
 false
</pre>
<pre class="code extensibella"id="1592">
 &lt; <b>GCL': apply good_clause_list_select to _ Ela2.</b>

Subgoal 9.1.1.2.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 ID C2 C3 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
S : select (ID, C2) L1 KRest2
M : mem (ID, C3) L1
H3 : good_clause_list KRest
GCL' : good_clause_list KRest2
============================
 false
</pre>
<pre class="code extensibella"id="1593">
 &lt; <b>GCL': case GCL'.</b>

Subgoal 9.1.1.2.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 ID C2 C3 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
S : select (ID, C2) L1 KRest2
M : mem (ID, C3) L1
H3 : good_clause_list KRest
GCL' : forall ID C1 KRest C2,
         select (ID, C1) KRest KRest2 -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="1594">
 &lt; <b>apply GCL' to S M.</b>

Subgoal 9.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
============================
 checkProof KC (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1595">
 &lt; <b>apply remove_all_is to _ CP2.</b>

Subgoal 9.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
============================
 checkProof KC (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1596">
 &lt; <b>apply select_is to _ CP3.</b>

Subgoal 9.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
============================
 checkProof KC (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1597">
 &lt; <b>assert good_clause_list ((To, C1)::KRest3).</b>

Subgoal 9.1.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
============================
 good_clause_list ((To, C1)::KRest3)
</pre>
<pre class="code extensibella"id="1598">
 &lt; <b>unfold .</b>

Subgoal 9.1.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
============================
 forall ID C2 KRest C3,
   select (ID, C2) KRest ((To, C1)::KRest3) -&gt; mem (ID, C3) KRest -&gt; false
</pre>
<pre class="code extensibella"id="1599">
 &lt; <b>intros S M.</b>

Subgoal 9.1.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 ID C2 KRest4 C3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
S : select (ID, C2) KRest4 ((To, C1)::KRest3)
M : mem (ID, C3) KRest4
============================
 false
</pre>
<pre class="code extensibella"id="1600">
 &lt; <b>S: case S.</b>

Subgoal 9.1.2.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 C3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
M : mem (To, C3) KRest3
============================
 false
</pre>
<pre class="code extensibella"id="1601">
 &lt; <b>M': apply mem_after_select_before to CP3 M.</b>

Subgoal 9.1.2.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 C3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
M : mem (To, C3) KRest3
M' : mem (To, C3) KRest1
============================
 false
</pre>
<pre class="code extensibella"id="1602">
 &lt; <b>apply remove_all_no_mem to CP2 M'.</b>

Subgoal 9.1.2.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 ID C2 C3 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
M : mem (ID, C3) ((To, C1)::L1)
S : select (ID, C2) L1 KRest3
============================
 false
</pre>
<pre class="code extensibella"id="1603">
 &lt; <b>M: case M.</b>

Subgoal 9.1.2.2.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 C2 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
S : select (To, C2) L1 KRest3
============================
 false
</pre>
<pre class="code extensibella"id="1604">
 &lt; <b>M: apply select_mem to S.</b>

Subgoal 9.1.2.2.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 C2 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
S : select (To, C2) L1 KRest3
M : mem (To, C2) KRest3
============================
 false
</pre>
<pre class="code extensibella"id="1605">
 &lt; <b>M': apply mem_after_select_before to CP3 M.</b>

Subgoal 9.1.2.2.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 C2 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
S : select (To, C2) L1 KRest3
M : mem (To, C2) KRest3
M' : mem (To, C2) KRest1
============================
 false
</pre>
<pre class="code extensibella"id="1606">
 &lt; <b>M'': apply remove_all_no_mem to CP2 M'.</b>

Subgoal 9.1.2.2.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 ID C2 C3 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
S : select (ID, C2) L1 KRest3
M : mem (ID, C3) L1
============================
 false
</pre>
<pre class="code extensibella"id="1607">
 &lt; <b>apply good_clause_list_remove_all to _ CP2.</b>

Subgoal 9.1.2.2.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 ID C2 C3 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
S : select (ID, C2) L1 KRest3
M : mem (ID, C3) L1
H6 : good_clause_list KRest1
============================
 false
</pre>
<pre class="code extensibella"id="1608">
 &lt; <b>GCL': apply good_clause_list_select to _ CP3.</b>

Subgoal 9.1.2.2.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 ID C2 C3 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
S : select (ID, C2) L1 KRest3
M : mem (ID, C3) L1
H6 : good_clause_list KRest1
GCL' : good_clause_list KRest3
============================
 false
</pre>
<pre class="code extensibella"id="1609">
 &lt; <b>GCL': case GCL'.</b>

Subgoal 9.1.2.2.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 ID C2 C3 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
S : select (ID, C2) L1 KRest3
M : mem (ID, C3) L1
H6 : good_clause_list KRest1
GCL' : forall ID C1 KRest C2,
         select (ID, C1) KRest KRest3 -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="1610">
 &lt; <b>apply GCL' to S M.</b>

Subgoal 9.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C1)::KRest3)
============================
 checkProof KC (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1611">
 &lt; <b>RAC: apply remove_all_exists to IsKC Is1.</b>

Subgoal 9.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 KR
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C1)::KRest3)
RAC : remove_all KC To KR
============================
 checkProof KC (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1612">
 &lt; <b>MKR1: apply select_mem to CP3.</b>

Subgoal 9.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 KR
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C1)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (From, C1) KRest1
============================
 checkProof KC (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1613">
 &lt; <b>MB: apply remove_all_mem_after to CP2 MKR1.</b>

Subgoal 9.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 KR
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C1)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (From, C1) KRest1
MB : mem (From, C1) KB
============================
 checkProof KC (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1614">
 &lt; <b>MC: apply Mems to MB.</b>

Subgoal 9.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 KR
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C1)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (From, C1) KRest1
MB : mem (From, C1) KB
MC : mem (From, C1) KC
============================
 checkProof KC (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1615">
 &lt; <b>MKR: apply remove_all_still_mem to RAC MC _.</b>

Subgoal 9.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 KR
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C1)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (From, C1) KRest1
MB : mem (From, C1) KB
MC : mem (From, C1) KC
MKR : mem (From, C1) KR
============================
 checkProof KC (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1616">
 &lt; <b>SC: apply mem_select to MKR.</b>

Subgoal 9.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 KR L'
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C1)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (From, C1) KRest1
MB : mem (From, C1) KB
MC : mem (From, C1) KC
MKR : mem (From, C1) KR
SC : select (From, C1) L' KR
============================
 checkProof KC (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1617">
 &lt; <b>apply remove_all_is to _ RAC.</b>

Subgoal 9.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 KR L'
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C1)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (From, C1) KRest1
MB : mem (From, C1) KB
MC : mem (From, C1) KC
MKR : mem (From, C1) KR
SC : select (From, C1) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
============================
 checkProof KC (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1618">
 &lt; <b>apply select_is to _ SC.</b>

Subgoal 9.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 KR L'
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C1)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (From, C1) KRest1
MB : mem (From, C1) KB
MC : mem (From, C1) KC
MKR : mem (From, C1) KR
SC : select (From, C1) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
============================
 checkProof KC (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1619">
 &lt; <b>GCLC': assert good_clause_list ((To, C1)::L').</b>

Subgoal 9.1.3:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 KR L'
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C1)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (From, C1) KRest1
MB : mem (From, C1) KB
MC : mem (From, C1) KC
MKR : mem (From, C1) KR
SC : select (From, C1) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
============================
 good_clause_list ((To, C1)::L')
</pre>
<pre class="code extensibella"id="1620">
 &lt; <b>unfold .</b>

Subgoal 9.1.3:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 KR L'
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C1)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (From, C1) KRest1
MB : mem (From, C1) KB
MC : mem (From, C1) KC
MKR : mem (From, C1) KR
SC : select (From, C1) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
============================
 forall ID C2 KRest C3,
   select (ID, C2) KRest ((To, C1)::L') -&gt; mem (ID, C3) KRest -&gt; false
</pre>
<pre class="code extensibella"id="1621">
 &lt; <b>intros S M.</b>

Subgoal 9.1.3:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 KR L' ID C2 KRest4 C3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C1)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (From, C1) KRest1
MB : mem (From, C1) KB
MC : mem (From, C1) KC
MKR : mem (From, C1) KR
SC : select (From, C1) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
S : select (ID, C2) KRest4 ((To, C1)::L')
M : mem (ID, C3) KRest4
============================
 false
</pre>
<pre class="code extensibella"id="1622">
 &lt; <b>S: case S.</b>

Subgoal 9.1.3.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 KR L' C3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C1)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (From, C1) KRest1
MB : mem (From, C1) KB
MC : mem (From, C1) KC
MKR : mem (From, C1) KR
SC : select (From, C1) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
M : mem (To, C3) L'
============================
 false
</pre>
<pre class="code extensibella"id="1623">
 &lt; <b>M': apply mem_after_select_before to SC M.</b>

Subgoal 9.1.3.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 KR L' C3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C1)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (From, C1) KRest1
MB : mem (From, C1) KB
MC : mem (From, C1) KC
MKR : mem (From, C1) KR
SC : select (From, C1) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
M : mem (To, C3) L'
M' : mem (To, C3) KR
============================
 false
</pre>
<pre class="code extensibella"id="1624">
 &lt; <b>apply remove_all_no_mem to RAC M'.</b>

Subgoal 9.1.3.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 KR L' ID C2 C3 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C1)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (From, C1) KRest1
MB : mem (From, C1) KB
MC : mem (From, C1) KC
MKR : mem (From, C1) KR
SC : select (From, C1) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
M : mem (ID, C3) ((To, C1)::L1)
S : select (ID, C2) L1 L'
============================
 false
</pre>
<pre class="code extensibella"id="1625">
 &lt; <b>M: case M.</b>

Subgoal 9.1.3.2.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 KR L' C2 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C1)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (From, C1) KRest1
MB : mem (From, C1) KB
MC : mem (From, C1) KC
MKR : mem (From, C1) KR
SC : select (From, C1) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
S : select (To, C2) L1 L'
============================
 false
</pre>
<pre class="code extensibella"id="1626">
 &lt; <b>M: apply select_mem to S.</b>

Subgoal 9.1.3.2.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 KR L' C2 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C1)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (From, C1) KRest1
MB : mem (From, C1) KB
MC : mem (From, C1) KC
MKR : mem (From, C1) KR
SC : select (From, C1) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
S : select (To, C2) L1 L'
M : mem (To, C2) L'
============================
 false
</pre>
<pre class="code extensibella"id="1627">
 &lt; <b>M': apply mem_after_select_before to SC M.</b>

Subgoal 9.1.3.2.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 KR L' C2 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C1)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (From, C1) KRest1
MB : mem (From, C1) KB
MC : mem (From, C1) KC
MKR : mem (From, C1) KR
SC : select (From, C1) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
S : select (To, C2) L1 L'
M : mem (To, C2) L'
M' : mem (To, C2) KR
============================
 false
</pre>
<pre class="code extensibella"id="1628">
 &lt; <b>M'': apply remove_all_no_mem to RAC M'.</b>

Subgoal 9.1.3.2.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 KR L' ID C2 C3 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C1)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (From, C1) KRest1
MB : mem (From, C1) KB
MC : mem (From, C1) KC
MKR : mem (From, C1) KR
SC : select (From, C1) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
S : select (ID, C2) L1 L'
M : mem (ID, C3) L1
============================
 false
</pre>
<pre class="code extensibella"id="1629">
 &lt; <b>apply good_clause_list_remove_all to _ RAC.</b>

Subgoal 9.1.3.2.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 KR L' ID C2 C3 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C1)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (From, C1) KRest1
MB : mem (From, C1) KB
MC : mem (From, C1) KC
MKR : mem (From, C1) KR
SC : select (From, C1) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
S : select (ID, C2) L1 L'
M : mem (ID, C3) L1
H9 : good_clause_list KR
============================
 false
</pre>
<pre class="code extensibella"id="1630">
 &lt; <b>GCL': apply good_clause_list_select to _ SC.</b>

Subgoal 9.1.3.2.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 KR L' ID C2 C3 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C1)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (From, C1) KRest1
MB : mem (From, C1) KB
MC : mem (From, C1) KC
MKR : mem (From, C1) KR
SC : select (From, C1) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
S : select (ID, C2) L1 L'
M : mem (ID, C3) L1
H9 : good_clause_list KR
GCL' : good_clause_list L'
============================
 false
</pre>
<pre class="code extensibella"id="1631">
 &lt; <b>GCL': case GCL'.</b>

Subgoal 9.1.3.2.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 KR L' ID C2 C3 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C1)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (From, C1) KRest1
MB : mem (From, C1) KB
MC : mem (From, C1) KC
MKR : mem (From, C1) KR
SC : select (From, C1) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
S : select (ID, C2) L1 L'
M : mem (ID, C3) L1
H9 : good_clause_list KR
GCL' : forall ID C1 KRest C2,
         select (ID, C1) KRest L' -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="1632">
 &lt; <b>apply GCL' to S M.</b>

Subgoal 9.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To From NRest Rest KRest1 C1 KRest3 KR L'
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
CP : checkProof KB (relocateClause From To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C1)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (From, C1) KRest1
MB : mem (From, C1) KB
MC : mem (From, C1) KC
MKR : mem (From, C1) KR
SC : select (From, C1) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C1)::L')
============================
 checkProof KC (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1633">
 &lt; <b>apply mem_is to _ MC.</b>

Subgoal 9.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' ID C2
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
CP : checkProof KB (relocateClause ID To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID, C2) KRest3 KRest1
CP4 : checkProof ((To, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C2)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (ID, C2) KRest1
MB : mem (ID, C2) KB
MC : mem (ID, C2) KC
MKR : mem (ID, C2) KR
SC : select (ID, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C2)::L')
H9 : is_integer ID
H10 : is_clause C2
============================
 checkProof KC (relocateClause ID To ERest)
</pre>
<pre class="code extensibella"id="1634">
 &lt; <b>Is': apply select_is_picked to _ Ela2.</b>

Subgoal 9.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' ID C2
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
CP : checkProof KB (relocateClause ID To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID, C2) KRest3 KRest1
CP4 : checkProof ((To, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C2)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (ID, C2) KRest1
MB : mem (ID, C2) KB
MC : mem (ID, C2) KC
MKR : mem (ID, C2) KR
SC : select (ID, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C2)::L')
H9 : is_integer ID
H10 : is_clause C2
Is' : is_pair is_integer is_clause (ID, C)
============================
 checkProof KC (relocateClause ID To ERest)
</pre>
<pre class="code extensibella"id="1635">
 &lt; <b>case Is'.</b>

Subgoal 9.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' ID C2
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
CP : checkProof KB (relocateClause ID To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID, C2) KRest3 KRest1
CP4 : checkProof ((To, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C2)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (ID, C2) KRest1
MB : mem (ID, C2) KB
MC : mem (ID, C2) KC
MKR : mem (ID, C2) KR
SC : select (ID, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C2)::L')
H9 : is_integer ID
H10 : is_clause C2
H11 : is_integer ID
H12 : is_clause C
============================
 checkProof KC (relocateClause ID To ERest)
</pre>
<pre class="code extensibella"id="1636">
 &lt; <b>apply IH to _ _ _ _ _ _ GCLC' Ela3 CP4 _.</b>

Subgoal 9.1.4:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' ID C2
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
CP : checkProof KB (relocateClause ID To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID, C2) KRest3 KRest1
CP4 : checkProof ((To, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C2)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (ID, C2) KRest1
MB : mem (ID, C2) KB
MC : mem (ID, C2) KC
MKR : mem (ID, C2) KR
SC : select (ID, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C2)::L')
H9 : is_integer ID
H10 : is_clause C2
H11 : is_integer ID
H12 : is_clause C
============================
 forall ID C, mem (ID, C) ((To, C2)::KRest3) -&gt; mem (ID, C) ((To, C2)::L')
</pre>
<pre class="code extensibella"id="1637">
 &lt; <b>intros M.</b>

Subgoal 9.1.4:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' ID C2 ID1 C3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
CP : checkProof KB (relocateClause ID To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID, C2) KRest3 KRest1
CP4 : checkProof ((To, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C2)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (ID, C2) KRest1
MB : mem (ID, C2) KB
MC : mem (ID, C2) KC
MKR : mem (ID, C2) KR
SC : select (ID, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C2)::L')
H9 : is_integer ID
H10 : is_clause C2
H11 : is_integer ID
H12 : is_clause C
M : mem (ID1, C3) ((To, C2)::KRest3)
============================
 mem (ID1, C3) ((To, C2)::L')
</pre>
<pre class="code extensibella"id="1638">
 &lt; <b>M: case M.</b>

Subgoal 9.1.4.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' ID C2
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
CP : checkProof KB (relocateClause ID To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID, C2) KRest3 KRest1
CP4 : checkProof ((To, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C2)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (ID, C2) KRest1
MB : mem (ID, C2) KB
MC : mem (ID, C2) KC
MKR : mem (ID, C2) KR
SC : select (ID, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C2)::L')
H9 : is_integer ID
H10 : is_clause C2
H11 : is_integer ID
H12 : is_clause C
============================
 mem (To, C2) ((To, C2)::L')
</pre>
<pre class="code extensibella"id="1639">
 &lt; <b>search.</b>

Subgoal 9.1.4.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' ID C2 ID1 C3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
CP : checkProof KB (relocateClause ID To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID, C2) KRest3 KRest1
CP4 : checkProof ((To, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C2)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (ID, C2) KRest1
MB : mem (ID, C2) KB
MC : mem (ID, C2) KC
MKR : mem (ID, C2) KR
SC : select (ID, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C2)::L')
H9 : is_integer ID
H10 : is_clause C2
H11 : is_integer ID
H12 : is_clause C
M : mem (ID1, C3) KRest3
============================
 mem (ID1, C3) ((To, C2)::L')
</pre>
<pre class="code extensibella"id="1640">
 &lt; <b>clear MKR1
   MB
   MC
   MKR.</b>

Subgoal 9.1.4.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' ID C2 ID1 C3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
CP : checkProof KB (relocateClause ID To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID, C2) KRest3 KRest1
CP4 : checkProof ((To, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C2)::KRest3)
RAC : remove_all KC To KR
SC : select (ID, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C2)::L')
H9 : is_integer ID
H10 : is_clause C2
H11 : is_integer ID
H12 : is_clause C
M : mem (ID1, C3) KRest3
============================
 mem (ID1, C3) ((To, C2)::L')
</pre>
<pre class="code extensibella"id="1641">
 &lt; <b>MKR1: apply mem_after_select_before to CP3 M.</b>

Subgoal 9.1.4.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' ID C2 ID1 C3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
CP : checkProof KB (relocateClause ID To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID, C2) KRest3 KRest1
CP4 : checkProof ((To, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C2)::KRest3)
RAC : remove_all KC To KR
SC : select (ID, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C2)::L')
H9 : is_integer ID
H10 : is_clause C2
H11 : is_integer ID
H12 : is_clause C
M : mem (ID1, C3) KRest3
MKR1 : mem (ID1, C3) KRest1
============================
 mem (ID1, C3) ((To, C2)::L')
</pre>
<pre class="code extensibella"id="1642">
 &lt; <b>MB: apply remove_all_mem_after to CP2 MKR1.</b>

Subgoal 9.1.4.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' ID C2 ID1 C3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
CP : checkProof KB (relocateClause ID To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID, C2) KRest3 KRest1
CP4 : checkProof ((To, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C2)::KRest3)
RAC : remove_all KC To KR
SC : select (ID, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C2)::L')
H9 : is_integer ID
H10 : is_clause C2
H11 : is_integer ID
H12 : is_clause C
M : mem (ID1, C3) KRest3
MKR1 : mem (ID1, C3) KRest1
MB : mem (ID1, C3) KB
============================
 mem (ID1, C3) ((To, C2)::L')
</pre>
<pre class="code extensibella"id="1643">
 &lt; <b>MC: apply Mems to MB.</b>

Subgoal 9.1.4.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' ID C2 ID1 C3
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
CP : checkProof KB (relocateClause ID To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID, C2) KRest3 KRest1
CP4 : checkProof ((To, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C2)::KRest3)
RAC : remove_all KC To KR
SC : select (ID, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C2)::L')
H9 : is_integer ID
H10 : is_clause C2
H11 : is_integer ID
H12 : is_clause C
M : mem (ID1, C3) KRest3
MKR1 : mem (ID1, C3) KRest1
MB : mem (ID1, C3) KB
MC : mem (ID1, C3) KC
============================
 mem (ID1, C3) ((To, C2)::L')
</pre>
<pre class="code extensibella"id="1644">
 &lt; <b>Is': apply mem_is to _ MB.</b>

Subgoal 9.1.4.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' ID C2 ID2 C4
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
CP : checkProof KB (relocateClause ID To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID, C2) KRest3 KRest1
CP4 : checkProof ((To, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C2)::KRest3)
RAC : remove_all KC To KR
SC : select (ID, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C2)::L')
H9 : is_integer ID
H10 : is_clause C2
H11 : is_integer ID
H12 : is_clause C
M : mem (ID2, C4) KRest3
MKR1 : mem (ID2, C4) KRest1
MB : mem (ID2, C4) KB
MC : mem (ID2, C4) KC
Is' : is_integer ID2
Is'1 : is_clause C4
============================
 mem (ID2, C4) ((To, C2)::L')
</pre>
<pre class="code extensibella"id="1645">
 &lt; <b>Or: apply is_integer_eq_or_not to Is1 Is'.</b>

Subgoal 9.1.4.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' ID C2 ID2 C4
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
CP : checkProof KB (relocateClause ID To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID, C2) KRest3 KRest1
CP4 : checkProof ((To, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C2)::KRest3)
RAC : remove_all KC To KR
SC : select (ID, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C2)::L')
H9 : is_integer ID
H10 : is_clause C2
H11 : is_integer ID
H12 : is_clause C
M : mem (ID2, C4) KRest3
MKR1 : mem (ID2, C4) KRest1
MB : mem (ID2, C4) KB
MC : mem (ID2, C4) KC
Is' : is_integer ID2
Is'1 : is_clause C4
Or : To = ID2 \/ (To = ID2 -&gt; false)
============================
 mem (ID2, C4) ((To, C2)::L')
</pre>
<pre class="code extensibella"id="1646">
 &lt; <b>N: case Or.</b>

Subgoal 9.1.4.2.1:

Variables: KA KB KC KRest C KRest2 Needed ERest NRest Rest KRest1 KRest3 KR L' ID C2 ID2 C4
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID ID2 Rest) ((ID, needed)::NRest) (relocateClause ID ID2 ERest) @
CP : checkProof KB (relocateClause ID ID2 ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA ID2 KRest
Ela2 : select (ID, C) KRest2 KRest
Ela3 : elaborate ((ID2, C)::KRest2) Rest Needed ERest *
Ela4 : select (ID2, needed) NRest Needed
Is : is_integer ID
Is1 : is_integer ID2
Is2 : is_proof Rest
CP1 : ID2 = ID -&gt; false
CP2 : remove_all KB ID2 KRest1
CP3 : select (ID, C2) KRest3 KRest1
CP4 : checkProof ((ID2, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((ID2, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((ID2, C2)::KRest3)
RAC : remove_all KC ID2 KR
SC : select (ID, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((ID2, C2)::L')
H9 : is_integer ID
H10 : is_clause C2
H11 : is_integer ID
H12 : is_clause C
M : mem (ID2, C4) KRest3
MKR1 : mem (ID2, C4) KRest1
MB : mem (ID2, C4) KB
MC : mem (ID2, C4) KC
Is' : is_integer ID2
Is'1 : is_clause C4
============================
 mem (ID2, C4) ((ID2, C2)::L')
</pre>
<pre class="code extensibella"id="1647">
 &lt; <b>apply remove_all_no_mem to CP2 _.</b>

Subgoal 9.1.4.2.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' ID C2 ID2 C4
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
CP : checkProof KB (relocateClause ID To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID, C2) KRest3 KRest1
CP4 : checkProof ((To, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C2)::KRest3)
RAC : remove_all KC To KR
SC : select (ID, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C2)::L')
H9 : is_integer ID
H10 : is_clause C2
H11 : is_integer ID
H12 : is_clause C
M : mem (ID2, C4) KRest3
MKR1 : mem (ID2, C4) KRest1
MB : mem (ID2, C4) KB
MC : mem (ID2, C4) KC
Is' : is_integer ID2
Is'1 : is_clause C4
N : To = ID2 -&gt; false
============================
 mem (ID2, C4) ((To, C2)::L')
</pre>
<pre class="code extensibella"id="1648">
 &lt; <b>MKR: apply remove_all_still_mem to RAC MC _.</b>

Subgoal 9.1.4.2.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' ID C2 ID2 C4
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
CP : checkProof KB (relocateClause ID To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID, C2) KRest3 KRest1
CP4 : checkProof ((To, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C2)::KRest3)
RAC : remove_all KC To KR
SC : select (ID, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C2)::L')
H9 : is_integer ID
H10 : is_clause C2
H11 : is_integer ID
H12 : is_clause C
M : mem (ID2, C4) KRest3
MKR1 : mem (ID2, C4) KRest1
MB : mem (ID2, C4) KB
MC : mem (ID2, C4) KC
Is' : is_integer ID2
Is'1 : is_clause C4
N : To = ID2 -&gt; false
MKR : mem (ID2, C4) KR
============================
 mem (ID2, C4) ((To, C2)::L')
</pre>
<pre class="code extensibella"id="1649">
 &lt; <b>Or: apply is_integer_eq_or_not to Is Is'.</b>

Subgoal 9.1.4.2.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' ID C2 ID2 C4
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
CP : checkProof KB (relocateClause ID To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID, C2) KRest3 KRest1
CP4 : checkProof ((To, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C2)::KRest3)
RAC : remove_all KC To KR
SC : select (ID, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C2)::L')
H9 : is_integer ID
H10 : is_clause C2
H11 : is_integer ID
H12 : is_clause C
M : mem (ID2, C4) KRest3
MKR1 : mem (ID2, C4) KRest1
MB : mem (ID2, C4) KB
MC : mem (ID2, C4) KC
Is' : is_integer ID2
Is'1 : is_clause C4
N : To = ID2 -&gt; false
MKR : mem (ID2, C4) KR
Or : ID = ID2 \/ (ID = ID2 -&gt; false)
============================
 mem (ID2, C4) ((To, C2)::L')
</pre>
<pre class="code extensibella"id="1650">
 &lt; <b>N': case Or.</b>

Subgoal 9.1.4.2.2.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' C2 ID2 C4
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID2 To Rest) ((ID2, needed)::NRest) (relocateClause ID2 To ERest) @
CP : checkProof KB (relocateClause ID2 To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID2, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID2
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID2 -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID2, C2) KRest3 KRest1
CP4 : checkProof ((To, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C2)::KRest3)
RAC : remove_all KC To KR
SC : select (ID2, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C2)::L')
H9 : is_integer ID2
H10 : is_clause C2
H11 : is_integer ID2
H12 : is_clause C
M : mem (ID2, C4) KRest3
MKR1 : mem (ID2, C4) KRest1
MB : mem (ID2, C4) KB
MC : mem (ID2, C4) KC
Is' : is_integer ID2
Is'1 : is_clause C4
N : To = ID2 -&gt; false
MKR : mem (ID2, C4) KR
============================
 mem (ID2, C4) ((To, C2)::L')
</pre>
<pre class="code extensibella"id="1651">
 &lt; <b>GCL: apply good_clause_list_remove_all to _ CP2.</b>

Subgoal 9.1.4.2.2.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' C2 ID2 C4
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID2 To Rest) ((ID2, needed)::NRest) (relocateClause ID2 To ERest) @
CP : checkProof KB (relocateClause ID2 To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID2, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID2
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID2 -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID2, C2) KRest3 KRest1
CP4 : checkProof ((To, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C2)::KRest3)
RAC : remove_all KC To KR
SC : select (ID2, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C2)::L')
H9 : is_integer ID2
H10 : is_clause C2
H11 : is_integer ID2
H12 : is_clause C
M : mem (ID2, C4) KRest3
MKR1 : mem (ID2, C4) KRest1
MB : mem (ID2, C4) KB
MC : mem (ID2, C4) KC
Is' : is_integer ID2
Is'1 : is_clause C4
N : To = ID2 -&gt; false
MKR : mem (ID2, C4) KR
GCL : good_clause_list KRest1
============================
 mem (ID2, C4) ((To, C2)::L')
</pre>
<pre class="code extensibella"id="1652">
 &lt; <b>GCL: case GCL.</b>

Subgoal 9.1.4.2.2.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' C2 ID2 C4
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID2 To Rest) ((ID2, needed)::NRest) (relocateClause ID2 To ERest) @
CP : checkProof KB (relocateClause ID2 To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID2, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID2
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID2 -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID2, C2) KRest3 KRest1
CP4 : checkProof ((To, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C2)::KRest3)
RAC : remove_all KC To KR
SC : select (ID2, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C2)::L')
H9 : is_integer ID2
H10 : is_clause C2
H11 : is_integer ID2
H12 : is_clause C
M : mem (ID2, C4) KRest3
MKR1 : mem (ID2, C4) KRest1
MB : mem (ID2, C4) KB
MC : mem (ID2, C4) KC
Is' : is_integer ID2
Is'1 : is_clause C4
N : To = ID2 -&gt; false
MKR : mem (ID2, C4) KR
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest KRest1 -&gt; mem (ID, C2) KRest -&gt; false
============================
 mem (ID2, C4) ((To, C2)::L')
</pre>
<pre class="code extensibella"id="1653">
 &lt; <b>apply GCL to CP3 _.</b>

Subgoal 9.1.4.2.2.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' ID C2 ID2 C4
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
CP : checkProof KB (relocateClause ID To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID, C2) KRest3 KRest1
CP4 : checkProof ((To, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C2)::KRest3)
RAC : remove_all KC To KR
SC : select (ID, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C2)::L')
H9 : is_integer ID
H10 : is_clause C2
H11 : is_integer ID
H12 : is_clause C
M : mem (ID2, C4) KRest3
MKR1 : mem (ID2, C4) KRest1
MB : mem (ID2, C4) KB
MC : mem (ID2, C4) KC
Is' : is_integer ID2
Is'1 : is_clause C4
N : To = ID2 -&gt; false
MKR : mem (ID2, C4) KR
N' : ID = ID2 -&gt; false
============================
 mem (ID2, C4) ((To, C2)::L')
</pre>
<pre class="code extensibella"id="1654">
 &lt; <b>apply mem_before_select_after to SC MKR _.</b>

Subgoal 9.1.4.2.2.2.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' ID C2 ID2 C4
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
CP : checkProof KB (relocateClause ID To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID, C2) KRest3 KRest1
CP4 : checkProof ((To, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C2)::KRest3)
RAC : remove_all KC To KR
SC : select (ID, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C2)::L')
H9 : is_integer ID
H10 : is_clause C2
H11 : is_integer ID
H12 : is_clause C
M : mem (ID2, C4) KRest3
MKR1 : mem (ID2, C4) KRest1
MB : mem (ID2, C4) KB
MC : mem (ID2, C4) KC
Is' : is_integer ID2
Is'1 : is_clause C4
N : To = ID2 -&gt; false
MKR : mem (ID2, C4) KR
N' : ID = ID2 -&gt; false
============================
 (ID, C2) = (ID2, C4) -&gt; false
</pre>
<pre class="code extensibella"id="1655">
 &lt; <b>intros E.</b>

Subgoal 9.1.4.2.2.2.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' ID C2 ID2 C4
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
CP : checkProof KB (relocateClause ID To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID, C2) KRest3 KRest1
CP4 : checkProof ((To, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C2)::KRest3)
RAC : remove_all KC To KR
SC : select (ID, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C2)::L')
H9 : is_integer ID
H10 : is_clause C2
H11 : is_integer ID
H12 : is_clause C
M : mem (ID2, C4) KRest3
MKR1 : mem (ID2, C4) KRest1
MB : mem (ID2, C4) KB
MC : mem (ID2, C4) KC
Is' : is_integer ID2
Is'1 : is_clause C4
N : To = ID2 -&gt; false
MKR : mem (ID2, C4) KR
N' : ID = ID2 -&gt; false
E : (ID, C2) = (ID2, C4)
============================
 false
</pre>
<pre class="code extensibella"id="1656">
 &lt; <b>case E.</b>

Subgoal 9.1.4.2.2.2.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' ID2 C4
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID2 To Rest) ((ID2, needed)::NRest) (relocateClause ID2 To ERest) @
CP : checkProof KB (relocateClause ID2 To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID2, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID2
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID2 -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID2, C4) KRest3 KRest1
CP4 : checkProof ((To, C4)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C4)::KRest3)
RAC : remove_all KC To KR
SC : select (ID2, C4) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C4)::L')
H9 : is_integer ID2
H10 : is_clause C4
H11 : is_integer ID2
H12 : is_clause C
M : mem (ID2, C4) KRest3
MKR1 : mem (ID2, C4) KRest1
MB : mem (ID2, C4) KB
MC : mem (ID2, C4) KC
Is' : is_integer ID2
Is'1 : is_clause C4
N : To = ID2 -&gt; false
MKR : mem (ID2, C4) KR
N' : ID2 = ID2 -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="1657">
 &lt; <b>backchain N'.</b>

Subgoal 9.1.4.2.2.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' ID C2 ID2 C4
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
CP : checkProof KB (relocateClause ID To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID, C2) KRest3 KRest1
CP4 : checkProof ((To, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C2)::KRest3)
RAC : remove_all KC To KR
SC : select (ID, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C2)::L')
H9 : is_integer ID
H10 : is_clause C2
H11 : is_integer ID
H12 : is_clause C
M : mem (ID2, C4) KRest3
MKR1 : mem (ID2, C4) KRest1
MB : mem (ID2, C4) KB
MC : mem (ID2, C4) KC
Is' : is_integer ID2
Is'1 : is_clause C4
N : To = ID2 -&gt; false
MKR : mem (ID2, C4) KR
N' : ID = ID2 -&gt; false
H13 : mem (ID2, C4) L'
============================
 mem (ID2, C4) ((To, C2)::L')
</pre>
<pre class="code extensibella"id="1658">
 &lt; <b>search.</b>

Subgoal 9.1:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest KRest1 KRest3 KR L' ID C2
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID To Rest) ((ID, needed)::NRest) (relocateClause ID To ERest) @
CP : checkProof KB (relocateClause ID To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (ID, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer ID
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = ID -&gt; false
CP2 : remove_all KB To KRest1
CP3 : select (ID, C2) KRest3 KRest1
CP4 : checkProof ((To, C2)::KRest3) ERest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_list (is_pair is_integer is_clause) KRest1
H5 : is_list (is_pair is_integer is_clause) KRest3
H6 : good_clause_list ((To, C2)::KRest3)
RAC : remove_all KC To KR
MKR1 : mem (ID, C2) KRest1
MB : mem (ID, C2) KB
MC : mem (ID, C2) KC
MKR : mem (ID, C2) KR
SC : select (ID, C2) L' KR
H7 : is_list (is_pair is_integer is_clause) KR
H8 : is_list (is_pair is_integer is_clause) L'
GCLC' : good_clause_list ((To, C2)::L')
H9 : is_integer ID
H10 : is_clause C2
H11 : is_integer ID
H12 : is_clause C
H13 : checkProof ((To, C2)::L') ERest
============================
 checkProof KC (relocateClause ID To ERest)
</pre>
<pre class="code extensibella"id="1659">
 &lt; <b>search.</b>

Subgoal 9.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest C1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause To To Rest) ((To, needed)::NRest) (relocateClause To To ERest) @
CP : checkProof KB (relocateClause To To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (To, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer To
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : mem (To, C1) KB
CP2 : checkProof KB ERest
============================
 checkProof KC (relocateClause To To ERest)
</pre>
<pre class="code extensibella"id="1660">
 &lt; <b>M: apply select_mem to Ela2.</b>

Subgoal 9.2:

Variables: KA KB KC KRest C KRest2 Needed ERest To NRest Rest C1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause To To Rest) ((To, needed)::NRest) (relocateClause To To ERest) @
CP : checkProof KB (relocateClause To To ERest)
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (To, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed ERest *
Ela4 : select (To, needed) NRest Needed
Is : is_integer To
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : mem (To, C1) KB
CP2 : checkProof KB ERest
M : mem (To, C) KRest
============================
 checkProof KC (relocateClause To To ERest)
</pre>
<pre class="code extensibella"id="1661">
 &lt; <b>apply remove_all_no_mem to Ela1 M.</b>

Subgoal 10:

Variables: KA KB KC CU E Rest ID
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsP : is_proof (relocateClause ID ID Rest)
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID ID Rest) CU E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : elaborate KA Rest CU E *
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1662">
 &lt; <b>Is: case IsP.</b>

Subgoal 10:

Variables: KA KB KC CU E Rest ID
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID ID Rest) CU E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : elaborate KA Rest CU E *
Is : is_integer ID
Is1 : is_integer ID
Is2 : is_proof Rest
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1663">
 &lt; <b>apply IH to _ _ _ _ _ _ GCLC Ela1 CP _.</b>

Subgoal 10:

Variables: KA KB KC CU E Rest ID
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause ID ID Rest) CU E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : elaborate KA Rest CU E *
Is : is_integer ID
Is1 : is_integer ID
Is2 : is_proof Rest
H1 : checkProof KC E
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1664">
 &lt; <b>search.</b>

Subgoal 11:

Variables: KA KB KC E KRest C KRest2 Needed NRest From Rest To
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsP : is_proof (relocateClause From To Rest)
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, unknown)::NRest) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1665">
 &lt; <b>Is: case IsP.</b>

Subgoal 11:

Variables: KA KB KC E KRest C KRest2 Needed NRest From Rest To
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, unknown)::NRest) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1666">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 11:

Variables: KA KB KC E KRest C KRest2 Needed NRest From Rest To
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, unknown)::NRest) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1667">
 &lt; <b>apply select_is to _ Ela2.</b>

Subgoal 11:

Variables: KA KB KC E KRest C KRest2 Needed NRest From Rest To
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, unknown)::NRest) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1668">
 &lt; <b>assert good_clause_list ((To, C)::KRest2).</b>

Subgoal 11.1:

Variables: KA KB KC E KRest C KRest2 Needed NRest From Rest To
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, unknown)::NRest) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
============================
 good_clause_list ((To, C)::KRest2)
</pre>
<pre class="code extensibella"id="1669">
 &lt; <b>unfold .</b>

Subgoal 11.1:

Variables: KA KB KC E KRest C KRest2 Needed NRest From Rest To
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, unknown)::NRest) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
============================
 forall ID C1 KRest C2,
   select (ID, C1) KRest ((To, C)::KRest2) -&gt; mem (ID, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="1670">
 &lt; <b>intros S M.</b>

Subgoal 11.1:

Variables: KA KB KC E KRest C KRest2 Needed NRest From Rest To ID C1 KRest1 C2
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, unknown)::NRest) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
S : select (ID, C1) KRest1 ((To, C)::KRest2)
M : mem (ID, C2) KRest1
============================
 false
</pre>
<pre class="code extensibella"id="1671">
 &lt; <b>S: case S.</b>

Subgoal 11.1.1:

Variables: KA KB KC E KRest C KRest2 Needed NRest From Rest To C2
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, unknown)::NRest) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (To, C2) KRest2
============================
 false
</pre>
<pre class="code extensibella"id="1672">
 &lt; <b>M': apply mem_after_select_before to Ela2 M.</b>

Subgoal 11.1.1:

Variables: KA KB KC E KRest C KRest2 Needed NRest From Rest To C2
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, unknown)::NRest) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (To, C2) KRest2
M' : mem (To, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="1673">
 &lt; <b>apply remove_all_no_mem to Ela1 M'.</b>

Subgoal 11.1.2:

Variables: KA KB KC E KRest C KRest2 Needed NRest From Rest To ID C1 C2 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, unknown)::NRest) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
M : mem (ID, C2) ((To, C)::L1)
S : select (ID, C1) L1 KRest2
============================
 false
</pre>
<pre class="code extensibella"id="1674">
 &lt; <b>M: case M.</b>

Subgoal 11.1.2.1:

Variables: KA KB KC E KRest C KRest2 Needed NRest From Rest To C1 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, unknown)::NRest) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
S : select (To, C1) L1 KRest2
============================
 false
</pre>
<pre class="code extensibella"id="1675">
 &lt; <b>M: apply select_mem to S.</b>

Subgoal 11.1.2.1:

Variables: KA KB KC E KRest C KRest2 Needed NRest From Rest To C1 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, unknown)::NRest) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
S : select (To, C1) L1 KRest2
M : mem (To, C1) KRest2
============================
 false
</pre>
<pre class="code extensibella"id="1676">
 &lt; <b>M': apply mem_after_select_before to Ela2 M.</b>

Subgoal 11.1.2.1:

Variables: KA KB KC E KRest C KRest2 Needed NRest From Rest To C1 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, unknown)::NRest) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
S : select (To, C1) L1 KRest2
M : mem (To, C1) KRest2
M' : mem (To, C1) KRest
============================
 false
</pre>
<pre class="code extensibella"id="1677">
 &lt; <b>M'': apply remove_all_no_mem to Ela1 M'.</b>

Subgoal 11.1.2.2:

Variables: KA KB KC E KRest C KRest2 Needed NRest From Rest To ID C1 C2 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, unknown)::NRest) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
S : select (ID, C1) L1 KRest2
M : mem (ID, C2) L1
============================
 false
</pre>
<pre class="code extensibella"id="1678">
 &lt; <b>apply good_clause_list_remove_all to _ Ela1.</b>

Subgoal 11.1.2.2:

Variables: KA KB KC E KRest C KRest2 Needed NRest From Rest To ID C1 C2 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, unknown)::NRest) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
S : select (ID, C1) L1 KRest2
M : mem (ID, C2) L1
H3 : good_clause_list KRest
============================
 false
</pre>
<pre class="code extensibella"id="1679">
 &lt; <b>GCL': apply good_clause_list_select to _ Ela2.</b>

Subgoal 11.1.2.2:

Variables: KA KB KC E KRest C KRest2 Needed NRest From Rest To ID C1 C2 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, unknown)::NRest) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
S : select (ID, C1) L1 KRest2
M : mem (ID, C2) L1
H3 : good_clause_list KRest
GCL' : good_clause_list KRest2
============================
 false
</pre>
<pre class="code extensibella"id="1680">
 &lt; <b>GCL': case GCL'.</b>

Subgoal 11.1.2.2:

Variables: KA KB KC E KRest C KRest2 Needed NRest From Rest To ID C1 C2 L1
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, unknown)::NRest) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
S : select (ID, C1) L1 KRest2
M : mem (ID, C2) L1
H3 : good_clause_list KRest
GCL' : forall ID C1 KRest C2,
         select (ID, C1) KRest KRest2 -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="1681">
 &lt; <b>apply GCL' to S M.</b>

Subgoal 11:

Variables: KA KB KC E KRest C KRest2 Needed NRest From Rest To
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, unknown)::NRest) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1682">
 &lt; <b>IsP: apply select_is_picked to _ Ela2.</b>

Subgoal 11:

Variables: KA KB KC E KRest C KRest2 Needed NRest From Rest To
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, unknown)::NRest) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
IsP : is_pair is_integer is_clause (From, C)
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1683">
 &lt; <b>case IsP.</b>

Subgoal 11:

Variables: KA KB KC E KRest C KRest2 Needed NRest From Rest To
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, unknown)::NRest) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_integer From
H5 : is_clause C
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1684">
 &lt; <b>apply IH to _ _ _ _ _ _ GCLC Ela3 CP _.</b>

Subgoal 11:

Variables: KA KB KC E KRest C KRest2 Needed NRest From Rest To
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (relocateClause From To Rest) ((From, unknown)::NRest) E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : remove_all KA To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed E *
Ela4 : select (To, unknown) NRest Needed
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : is_list (is_pair is_integer is_clause) KRest2
H3 : good_clause_list ((To, C)::KRest2)
H4 : is_integer From
H5 : is_clause C
H6 : checkProof KC E
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1685">
 &lt; <b>search.</b>

Subgoal 12:

Variables: KA KB KC CU E Rest Comment
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsP : is_proof (commentProof Comment Rest)
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (commentProof Comment Rest) CU E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : elaborate KA Rest CU E *
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1686">
 &lt; <b>case IsP.</b>

Subgoal 12:

Variables: KA KB KC CU E Rest Comment
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (commentProof Comment Rest) CU E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : elaborate KA Rest CU E *
H1 : is_string Comment
H2 : is_proof Rest
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1687">
 &lt; <b>apply IH to _ _ _ _ _ _ GCLC Ela1 CP _.</b>

Subgoal 12:

Variables: KA KB KC CU E Rest Comment
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA (commentProof Comment Rest) CU E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : elaborate KA Rest CU E *
H1 : is_string Comment
H2 : is_proof Rest
H3 : checkProof KC E
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1688">
 &lt; <b>search.</b>

Subgoal 13:

Variables: KA KB KC CU E PT
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsP : is_proof &lt;unknown I proof&gt;
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA &lt;unknown I proof&gt; CU E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : KA |{proof}- &lt;unknown I proof&gt; ~~&gt; PT
Ela2 : elaborate KA PT CU E *
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1689">
 &lt; <b>apply proj_proof_is to Ela1 _ _ _.</b>

Subgoal 13:

Variables: KA KB KC CU E PT
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsP : is_proof &lt;unknown I proof&gt;
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA &lt;unknown I proof&gt; CU E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : KA |{proof}- &lt;unknown I proof&gt; ~~&gt; PT
Ela2 : elaborate KA PT CU E *
H1 : is_proof PT
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1690">
 &lt; <b>apply IH to _ _ _ _ _ _ GCLC Ela2 CP _.</b>

Subgoal 13:

Variables: KA KB KC CU E PT
IH : forall KA KB KC P CU E,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) KA -&gt; is_list (is_pair is_integer is_clause) KB -&gt;
       is_list (is_pair is_integer is_clause) KC -&gt; good_clause_list KA -&gt; good_clause_list KB -&gt;
       good_clause_list KC -&gt; elaborate KA P CU E * -&gt; checkProof KB E -&gt; (forall ID C,
         mem (ID, C) KB -&gt; mem (ID, C) KC) -&gt; checkProof KC E
IsP : is_proof &lt;unknown I proof&gt;
IsKA : is_list (is_pair is_integer is_clause) KA
IsKB : is_list (is_pair is_integer is_clause) KB
IsKC : is_list (is_pair is_integer is_clause) KC
GCLA : good_clause_list KA
GCLB : good_clause_list KB
GCLC : good_clause_list KC
Ela : elaborate KA &lt;unknown I proof&gt; CU E @
CP : checkProof KB E
Mems : forall ID C, mem (ID, C) KB -&gt; mem (ID, C) KC
Ela1 : KA |{proof}- &lt;unknown I proof&gt; ~~&gt; PT
Ela2 : elaborate KA PT CU E *
H1 : is_proof PT
H2 : checkProof KC E
============================
 checkProof KC E
</pre>
<pre class="code extensibella"id="1691">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="1692">
 &lt; <b>Extensible_Theorem
      elaboration_valid : forall Known P CU E Needed,
         IsP : is_proof P -&gt;
         IsKnown : is_list (is_pair is_integer is_clause) Known -&gt;
         IsNeeded : is_list (is_pair is_integer is_clause) Needed -&gt;
         GCL : good_clause_list Known -&gt;
         GCL_N : good_clause_list Needed -&gt;
         CP : checkProof Known P -&gt;
         Ela : elaborate Known P CU E -&gt;
         HN : hasNeeded Known CU Needed -&gt;
         checkProof Needed E
      on Ela.</b>

Subgoal 1:

Variables: Known CU Needed Needed1 NRest Prf ID FC
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsP : is_proof (endFrat ID FC)
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (endFrat ID FC)
Ela : elaborate Known (endFrat ID FC) CU (emptyLrat ID Prf) @
HN : hasNeeded Known CU Needed
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
============================
 checkProof Needed (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="1693">
 &lt; <b>case IsP.</b>

Subgoal 1:

Variables: Known CU Needed Needed1 NRest Prf ID FC
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (endFrat ID FC)
Ela : elaborate Known (endFrat ID FC) CU (emptyLrat ID Prf) @
HN : hasNeeded Known CU Needed
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_finalClauses FC
============================
 checkProof Needed (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="1694">
 &lt; <b>CP: case CP (keep).</b>

Subgoal 1:

Variables: Known CU Needed Needed1 NRest Prf ID FC KRest Prf1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (endFrat ID FC)
Ela : elaborate Known (endFrat ID FC) CU (emptyLrat ID Prf) @
HN : hasNeeded Known CU Needed
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_finalClauses FC
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf1
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) FC
============================
 checkProof Needed (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="1695">
 &lt; <b>IsKR: apply remove_all_is to _ CP1.</b>

Subgoal 1:

Variables: Known CU Needed Needed1 NRest Prf ID FC KRest Prf1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (endFrat ID FC)
Ela : elaborate Known (endFrat ID FC) CU (emptyLrat ID Prf) @
HN : hasNeeded Known CU Needed
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_finalClauses FC
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf1
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) FC
IsKR : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof Needed (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="1696">
 &lt; <b>GCLKR: apply good_clause_list_remove_all_add to _ CP1 with
            C = emptyClause.</b>

Subgoal 1:

Variables: Known CU Needed Needed1 NRest Prf ID FC KRest Prf1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (endFrat ID FC)
Ela : elaborate Known (endFrat ID FC) CU (emptyLrat ID Prf) @
HN : hasNeeded Known CU Needed
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_finalClauses FC
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf1
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) FC
IsKR : is_list (is_pair is_integer is_clause) KRest
GCLKR : good_clause_list ((ID, emptyClause)::KRest)
============================
 checkProof Needed (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="1697">
 &lt; <b>GULN1: apply endKnownClauses_good_used_list to _ _ _ CP3 Ela1.</b>

Subgoal 1:

Variables: Known CU Needed Needed1 NRest Prf ID FC KRest Prf1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (endFrat ID FC)
Ela : elaborate Known (endFrat ID FC) CU (emptyLrat ID Prf) @
HN : hasNeeded Known CU Needed
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_finalClauses FC
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf1
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) FC
IsKR : is_list (is_pair is_integer is_clause) KRest
GCLKR : good_clause_list ((ID, emptyClause)::KRest)
GULN1 : good_used_list Needed1
============================
 checkProof Needed (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="1698">
 &lt; <b>apply good_used_list_select to _ Ela2.</b>

Subgoal 1:

Variables: Known CU Needed Needed1 NRest Prf ID FC KRest Prf1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (endFrat ID FC)
Ela : elaborate Known (endFrat ID FC) CU (emptyLrat ID Prf) @
HN : hasNeeded Known CU Needed
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_finalClauses FC
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf1
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) FC
IsKR : is_list (is_pair is_integer is_clause) KRest
GCLKR : good_clause_list ((ID, emptyClause)::KRest)
GULN1 : good_used_list Needed1
H3 : good_used_list NRest
============================
 checkProof Needed (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="1699">
 &lt; <b>apply rupProof_hasNeeded to _ _ _ _ _ Ela3 Ela4 HN.</b>

Subgoal 1:

Variables: Known CU Needed Needed1 NRest Prf ID FC KRest Prf1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (endFrat ID FC)
Ela : elaborate Known (endFrat ID FC) CU (emptyLrat ID Prf) @
HN : hasNeeded Known CU Needed
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : rupProof Known emptyClause Prf
Ela4 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_finalClauses FC
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf1
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) FC
IsKR : is_list (is_pair is_integer is_clause) KRest
GCLKR : good_clause_list ((ID, emptyClause)::KRest)
GULN1 : good_used_list Needed1
H3 : good_used_list NRest
H4 : rupProof Needed emptyClause Prf
============================
 checkProof Needed (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="1700">
 &lt; <b>search.</b>

Subgoal 2:

Variables: Known CU Needed Needed1 NRest Prf ID FC
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsP : is_proof (endFratPrf ID Prf FC)
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (endFratPrf ID Prf FC)
Ela : elaborate Known (endFratPrf ID Prf FC) CU (emptyLrat ID Prf) @
HN : hasNeeded Known CU Needed
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : makeUsed NRest Prf CU
============================
 checkProof Needed (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="1701">
 &lt; <b>case IsP.</b>

Subgoal 2:

Variables: Known CU Needed Needed1 NRest Prf ID FC
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (endFratPrf ID Prf FC)
Ela : elaborate Known (endFratPrf ID Prf FC) CU (emptyLrat ID Prf) @
HN : hasNeeded Known CU Needed
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_list is_integer Prf
H3 : is_finalClauses FC
============================
 checkProof Needed (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="1702">
 &lt; <b>CP: case CP (keep).</b>

Subgoal 2:

Variables: Known CU Needed Needed1 NRest Prf ID FC KRest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (endFratPrf ID Prf FC)
Ela : elaborate Known (endFratPrf ID Prf FC) CU (emptyLrat ID Prf) @
HN : hasNeeded Known CU Needed
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_list is_integer Prf
H3 : is_finalClauses FC
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) FC
============================
 checkProof Needed (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="1703">
 &lt; <b>IsKR: apply remove_all_is to _ CP1.</b>

Subgoal 2:

Variables: Known CU Needed Needed1 NRest Prf ID FC KRest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (endFratPrf ID Prf FC)
Ela : elaborate Known (endFratPrf ID Prf FC) CU (emptyLrat ID Prf) @
HN : hasNeeded Known CU Needed
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_list is_integer Prf
H3 : is_finalClauses FC
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) FC
IsKR : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof Needed (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="1704">
 &lt; <b>GCLKR: apply good_clause_list_remove_all_add to _ CP1 with
            C = emptyClause.</b>

Subgoal 2:

Variables: Known CU Needed Needed1 NRest Prf ID FC KRest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (endFratPrf ID Prf FC)
Ela : elaborate Known (endFratPrf ID Prf FC) CU (emptyLrat ID Prf) @
HN : hasNeeded Known CU Needed
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_list is_integer Prf
H3 : is_finalClauses FC
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) FC
IsKR : is_list (is_pair is_integer is_clause) KRest
GCLKR : good_clause_list ((ID, emptyClause)::KRest)
============================
 checkProof Needed (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="1705">
 &lt; <b>GULN1: apply endKnownClauses_good_used_list to _ _ _ CP3 Ela1.</b>

Subgoal 2:

Variables: Known CU Needed Needed1 NRest Prf ID FC KRest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (endFratPrf ID Prf FC)
Ela : elaborate Known (endFratPrf ID Prf FC) CU (emptyLrat ID Prf) @
HN : hasNeeded Known CU Needed
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_list is_integer Prf
H3 : is_finalClauses FC
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) FC
IsKR : is_list (is_pair is_integer is_clause) KRest
GCLKR : good_clause_list ((ID, emptyClause)::KRest)
GULN1 : good_used_list Needed1
============================
 checkProof Needed (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="1706">
 &lt; <b>apply good_used_list_select to _ Ela2.</b>

Subgoal 2:

Variables: Known CU Needed Needed1 NRest Prf ID FC KRest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (endFratPrf ID Prf FC)
Ela : elaborate Known (endFratPrf ID Prf FC) CU (emptyLrat ID Prf) @
HN : hasNeeded Known CU Needed
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_list is_integer Prf
H3 : is_finalClauses FC
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) FC
IsKR : is_list (is_pair is_integer is_clause) KRest
GCLKR : good_clause_list ((ID, emptyClause)::KRest)
GULN1 : good_used_list Needed1
H4 : good_used_list NRest
============================
 checkProof Needed (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="1707">
 &lt; <b>apply rupProof_hasNeeded to _ _ _ _ _ CP2 Ela3 HN.</b>

Subgoal 2:

Variables: Known CU Needed Needed1 NRest Prf ID FC KRest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (endFratPrf ID Prf FC)
Ela : elaborate Known (endFratPrf ID Prf FC) CU (emptyLrat ID Prf) @
HN : hasNeeded Known CU Needed
Ela1 : endKnownClauses FC Needed1
Ela2 : select (ID, needed) NRest Needed1
Ela3 : makeUsed NRest Prf CU
H1 : is_integer ID
H2 : is_list is_integer Prf
H3 : is_finalClauses FC
CP1 : remove_all Known ID KRest
CP2 : rupProof Known emptyClause Prf
CP3 : checkFinalClauses ((ID, emptyClause)::KRest) FC
IsKR : is_list (is_pair is_integer is_clause) KRest
GCLKR : good_clause_list ((ID, emptyClause)::KRest)
GULN1 : good_used_list Needed1
H4 : good_used_list NRest
H5 : rupProof Needed emptyClause Prf
============================
 checkProof Needed (emptyLrat ID Prf)
</pre>
<pre class="code extensibella"id="1708">
 &lt; <b>search.</b>

Subgoal 3:

Variables: Known E Needed KRest Needed1 ID Rest C
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsP : is_proof (deleteFrat ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (deleteFrat ID C Rest)
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed1) E @
HN : hasNeeded Known ((ID, unknown)::Needed1) Needed
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1709">
 &lt; <b>case IsP.</b>

Subgoal 3:

Variables: Known E Needed KRest Needed1 ID Rest C
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (deleteFrat ID C Rest)
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed1) E @
HN : hasNeeded Known ((ID, unknown)::Needed1) Needed
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1710">
 &lt; <b>CP: case CP (keep).</b>

Subgoal 3:

Variables: Known E Needed KRest Needed1 ID Rest C KRest1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (deleteFrat ID C Rest)
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed1) E @
HN : hasNeeded Known ((ID, unknown)::Needed1) Needed
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP1 : select (ID, C) KRest1 Known
CP2 : checkProof KRest1 Rest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1711">
 &lt; <b>apply select_is to _ CP1.</b>

Subgoal 3:

Variables: Known E Needed KRest Needed1 ID Rest C KRest1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (deleteFrat ID C Rest)
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed1) E @
HN : hasNeeded Known ((ID, unknown)::Needed1) Needed
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP1 : select (ID, C) KRest1 Known
CP2 : checkProof KRest1 Rest
H4 : is_list (is_pair is_integer is_clause) KRest1
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1712">
 &lt; <b>apply good_clause_list_selects to GCL CP1 Ela1.</b>

Subgoal 3:

Variables: Known E Needed KRest Needed1 ID Rest C
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (deleteFrat ID C Rest)
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed1) E @
HN : hasNeeded Known ((ID, unknown)::Needed1) Needed
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest
H4 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1713">
 &lt; <b>apply good_clause_list_select to _ Ela1.</b>

Subgoal 3:

Variables: Known E Needed KRest Needed1 ID Rest C
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (deleteFrat ID C Rest)
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed1) E @
HN : hasNeeded Known ((ID, unknown)::Needed1) Needed
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list KRest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1714">
 &lt; <b>apply select_is to _ Ela1.</b>

Subgoal 3:

Variables: Known E Needed KRest Needed1 ID Rest C
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (deleteFrat ID C Rest)
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed1) E @
HN : hasNeeded Known ((ID, unknown)::Needed1) Needed
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list KRest
H6 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1715">
 &lt; <b>GUL: apply elaboration_good_used_list to _ _ _ CP Ela.</b>

Subgoal 3:

Variables: Known E Needed KRest Needed1 ID Rest C
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (deleteFrat ID C Rest)
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed1) E @
HN : hasNeeded Known ((ID, unknown)::Needed1) Needed
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list KRest
H6 : is_list (is_pair is_integer is_clause) KRest
GUL : good_used_list ((ID, unknown)::Needed1)
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1716">
 &lt; <b>HN': apply hasNeeded_select_known to HN _ _.</b>

Subgoal 3:

Variables: Known E Needed KRest Needed1 ID Rest C
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (deleteFrat ID C Rest)
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed1) E @
HN : hasNeeded Known ((ID, unknown)::Needed1) Needed
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list KRest
H6 : is_list (is_pair is_integer is_clause) KRest
GUL : good_used_list ((ID, unknown)::Needed1)
HN' : hasNeeded KRest Needed1 Needed
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1717">
 &lt; <b>apply IH to _ _ _ _ _ CP2 Ela2 HN'.</b>

Subgoal 3:

Variables: Known E Needed KRest Needed1 ID Rest C
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (deleteFrat ID C Rest)
Ela : elaborate Known (deleteFrat ID C Rest) ((ID, unknown)::Needed1) E @
HN : hasNeeded Known ((ID, unknown)::Needed1) Needed
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
H1 : is_integer ID
H2 : is_clause C
H3 : is_proof Rest
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest
H4 : is_list (is_pair is_integer is_clause) KRest
H5 : good_clause_list KRest
H6 : is_list (is_pair is_integer is_clause) KRest
GUL : good_used_list ((ID, unknown)::Needed1)
HN' : hasNeeded KRest Needed1 Needed
H7 : checkProof Needed E
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1718">
 &lt; <b>search.</b>

Subgoal 4:

Variables: Known E Needed C KRest Needed1 ID Rest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsP : is_proof (deleteLratProof ID Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (deleteLratProof ID Rest)
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed1) E @
HN : hasNeeded Known ((ID, unknown)::Needed1) Needed
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1719">
 &lt; <b>case IsP.</b>

Subgoal 4:

Variables: Known E Needed C KRest Needed1 ID Rest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (deleteLratProof ID Rest)
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed1) E @
HN : hasNeeded Known ((ID, unknown)::Needed1) Needed
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
H1 : is_integer ID
H2 : is_proof Rest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1720">
 &lt; <b>CP: case CP (keep).</b>

Subgoal 4:

Variables: Known E Needed C KRest Needed1 ID Rest C1 KRest1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (deleteLratProof ID Rest)
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed1) E @
HN : hasNeeded Known ((ID, unknown)::Needed1) Needed
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
H1 : is_integer ID
H2 : is_proof Rest
CP1 : select (ID, C1) KRest1 Known
CP2 : checkProof KRest1 Rest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1721">
 &lt; <b>apply select_is to _ CP1.</b>

Subgoal 4:

Variables: Known E Needed C KRest Needed1 ID Rest C1 KRest1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (deleteLratProof ID Rest)
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed1) E @
HN : hasNeeded Known ((ID, unknown)::Needed1) Needed
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
H1 : is_integer ID
H2 : is_proof Rest
CP1 : select (ID, C1) KRest1 Known
CP2 : checkProof KRest1 Rest
H3 : is_list (is_pair is_integer is_clause) KRest1
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1722">
 &lt; <b>apply good_clause_list_selects to GCL CP1 Ela1.</b>

Subgoal 4:

Variables: Known E Needed C KRest Needed1 ID Rest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (deleteLratProof ID Rest)
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed1) E @
HN : hasNeeded Known ((ID, unknown)::Needed1) Needed
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
H1 : is_integer ID
H2 : is_proof Rest
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest
H3 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1723">
 &lt; <b>apply good_clause_list_select to _ Ela1.</b>

Subgoal 4:

Variables: Known E Needed C KRest Needed1 ID Rest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (deleteLratProof ID Rest)
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed1) E @
HN : hasNeeded Known ((ID, unknown)::Needed1) Needed
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
H1 : is_integer ID
H2 : is_proof Rest
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest
H3 : is_list (is_pair is_integer is_clause) KRest
H4 : good_clause_list KRest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1724">
 &lt; <b>apply select_is to _ Ela1.</b>

Subgoal 4:

Variables: Known E Needed C KRest Needed1 ID Rest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (deleteLratProof ID Rest)
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed1) E @
HN : hasNeeded Known ((ID, unknown)::Needed1) Needed
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
H1 : is_integer ID
H2 : is_proof Rest
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest
H3 : is_list (is_pair is_integer is_clause) KRest
H4 : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1725">
 &lt; <b>GUL: apply elaboration_good_used_list to _ _ _ CP Ela.</b>

Subgoal 4:

Variables: Known E Needed C KRest Needed1 ID Rest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (deleteLratProof ID Rest)
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed1) E @
HN : hasNeeded Known ((ID, unknown)::Needed1) Needed
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
H1 : is_integer ID
H2 : is_proof Rest
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest
H3 : is_list (is_pair is_integer is_clause) KRest
H4 : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest
GUL : good_used_list ((ID, unknown)::Needed1)
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1726">
 &lt; <b>HN': apply hasNeeded_select_known to HN _ _.</b>

Subgoal 4:

Variables: Known E Needed C KRest Needed1 ID Rest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (deleteLratProof ID Rest)
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed1) E @
HN : hasNeeded Known ((ID, unknown)::Needed1) Needed
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
H1 : is_integer ID
H2 : is_proof Rest
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest
H3 : is_list (is_pair is_integer is_clause) KRest
H4 : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest
GUL : good_used_list ((ID, unknown)::Needed1)
HN' : hasNeeded KRest Needed1 Needed
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1727">
 &lt; <b>apply IH to _ _ _ _ _ CP2 Ela2 HN'.</b>

Subgoal 4:

Variables: Known E Needed C KRest Needed1 ID Rest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (deleteLratProof ID Rest)
Ela : elaborate Known (deleteLratProof ID Rest) ((ID, unknown)::Needed1) E @
HN : hasNeeded Known ((ID, unknown)::Needed1) Needed
Ela1 : select (ID, C) KRest Known
Ela2 : elaborate KRest Rest Needed1 E *
H1 : is_integer ID
H2 : is_proof Rest
CP1 : select (ID, C) KRest Known
CP2 : checkProof KRest Rest
H3 : is_list (is_pair is_integer is_clause) KRest
H4 : good_clause_list KRest
H5 : is_list (is_pair is_integer is_clause) KRest
GUL : good_used_list ((ID, unknown)::Needed1)
HN' : hasNeeded KRest Needed1 Needed
H6 : checkProof Needed E
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1728">
 &lt; <b>search.</b>

Subgoal 5:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsP : is_proof (addLrupProof ID C Prf Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1729">
 &lt; <b>Is: case IsP.</b>

Subgoal 5:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1730">
 &lt; <b>CP: case CP (keep).</b>

Subgoal 5:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KRest1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest1
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest1) Rest
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1731">
 &lt; <b>apply remove_all_unique to CP1 Ela1.</b>

Subgoal 5:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1732">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 5:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1733">
 &lt; <b>apply good_clause_list_remove_all_add to _ Ela1 with
     C = C.</b>

Subgoal 5:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1734">
 &lt; <b>apply elaboration_is_needed to _ _ _ Ela2.</b>

Subgoal 5:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1735">
 &lt; <b>apply select_is_clauseUsedness to _ Ela3.</b>

Subgoal 5:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1736">
 &lt; <b>RA: apply remove_all_exists to IsNeeded Is.</b>

Subgoal 5:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1737">
 &lt; <b>apply remove_all_is to _ RA.</b>

Subgoal 5:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1738">
 &lt; <b>apply good_clause_list_remove_all_add to _ RA with
     C = C.</b>

Subgoal 5:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1739">
 &lt; <b>GUL: apply elaboration_good_used_list to _ _ _ CP3 Ela2.</b>

Subgoal 5:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1740">
 &lt; <b>apply good_used_list_select to GUL Ela3.</b>

Subgoal 5:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1741">
 &lt; <b>apply IH to _ _ _ _ _ CP3 Ela2 _ with
     Needed = (ID, C)::KR.</b>

Subgoal 5.1:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
============================
 hasNeeded ((ID, C)::KRest) Needed1 ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1742">
 &lt; <b>unfold .</b>

Subgoal 5.1.1:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
============================
 forall ID1, mem (ID1, needed) Needed1 -&gt; exists C1, mem (ID1, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1743">
 &lt; <b>intros MN1.</b>

Subgoal 5.1.1:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR ID1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID1, needed) Needed1
============================
 exists C1, mem (ID1, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1744">
 &lt; <b>apply mem_is_clauseUsedness to _ MN1.</b>

Subgoal 5.1.1:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
============================
 exists C1, mem (ID2, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1745">
 &lt; <b>Or: apply is_integer_eq_or_not to Is _ with
         I2 = ID2.</b>

Subgoal 5.1.1:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
Or : ID = ID2 \/ (ID = ID2 -&gt; false)
============================
 exists C1, mem (ID2, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1746">
 &lt; <b>N: case Or.</b>

Subgoal 5.1.1.1:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C Rest KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID2 C Prf Rest)
Ela : elaborate Known (addLrupProof ID2 C Prf Rest) CU (addLrupProof ID2 C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID2 KRest
Ela2 : elaborate ((ID2, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID2, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID2
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID2 KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID2, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID2, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID2 KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID2, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
============================
 exists C1, mem (ID2, C1) ((ID2, C)::KR)
</pre>
<pre class="code extensibella"id="1747">
 &lt; <b>search.</b>

Subgoal 5.1.1.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
============================
 exists C1, mem (ID2, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1748">
 &lt; <b>MNR: apply mem_before_select_after to Ela3 MN1 _.</b>

Subgoal 5.1.1.2.1:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
============================
 (ID, needed) = (ID2, needed) -&gt; false
</pre>
<pre class="code extensibella"id="1749">
 &lt; <b>intros E.</b>

Subgoal 5.1.1.2.1:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
E : (ID, needed) = (ID2, needed)
============================
 false
</pre>
<pre class="code extensibella"id="1750">
 &lt; <b>case E.</b>

Subgoal 5.1.1.2.1:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C Rest KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID2 C Prf Rest)
Ela : elaborate Known (addLrupProof ID2 C Prf Rest) CU (addLrupProof ID2 C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID2 KRest
Ela2 : elaborate ((ID2, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID2, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID2
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID2 KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID2, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID2, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID2 KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID2, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID2 = ID2 -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="1751">
 &lt; <b>backchain N.</b>

Subgoal 5.1.1.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
MNR : mem (ID2, needed) NRest
============================
 exists C1, mem (ID2, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1752">
 &lt; <b>MCU: apply makeUsed_subset to _ _ Ela4 MNR.</b>

Subgoal 5.1.1.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
MNR : mem (ID2, needed) NRest
MCU : mem (ID2, needed) CU
============================
 exists C1, mem (ID2, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1753">
 &lt; <b>HN: case HN.</b>

Subgoal 5.1.1.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
MNR : mem (ID2, needed) NRest
MCU : mem (ID2, needed) CU
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 exists C1, mem (ID2, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1754">
 &lt; <b>MN: apply HN to MCU.</b>

Subgoal 5.1.1.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR ID2 C2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
MNR : mem (ID2, needed) NRest
MCU : mem (ID2, needed) CU
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (ID2, C2) Needed
============================
 exists C1, mem (ID2, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1755">
 &lt; <b>apply remove_all_still_mem to RA MN _.</b>

Subgoal 5.1.1.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR ID2 C2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
MNR : mem (ID2, needed) NRest
MCU : mem (ID2, needed) CU
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (ID2, C2) Needed
H10 : mem (ID2, C2) KR
============================
 exists C1, mem (ID2, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1756">
 &lt; <b>search.</b>

Subgoal 5.1.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
============================
 forall ID1 CN CK,
   mem (ID1, CN) ((ID, C)::KR) -&gt; mem (ID1, CK) ((ID, C)::KRest) -&gt; CN = CK
</pre>
<pre class="code extensibella"id="1757">
 &lt; <b>intros MKR+ MKRest+.</b>

Subgoal 5.1.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR ID1 CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MKR+ : mem (ID1, CN) ((ID, C)::KR)
MKRest+ : mem (ID1, CK) ((ID, C)::KRest)
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1758">
 &lt; <b>MKR: case MKR+.</b>

Subgoal 5.1.2.1:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MKRest+ : mem (ID, CK) ((ID, C)::KRest)
============================
 C = CK
</pre>
<pre class="code extensibella"id="1759">
 &lt; <b>MKRest: case MKRest+.</b>

Subgoal 5.1.2.1.1:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
============================
 C = C
</pre>
<pre class="code extensibella"id="1760">
 &lt; <b>search.</b>

Subgoal 5.1.2.1.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MKRest : mem (ID, CK) KRest
============================
 C = CK
</pre>
<pre class="code extensibella"id="1761">
 &lt; <b>apply remove_all_no_mem to Ela1 MKRest.</b>

Subgoal 5.1.2.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR ID1 CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MKRest+ : mem (ID1, CK) ((ID, C)::KRest)
MKR : mem (ID1, CN) KR
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1762">
 &lt; <b>MKRest: case MKRest+.</b>

Subgoal 5.1.2.2.1:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR CN
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MKR : mem (ID, CN) KR
============================
 CN = C
</pre>
<pre class="code extensibella"id="1763">
 &lt; <b>apply remove_all_no_mem to RA MKR.</b>

Subgoal 5.1.2.2.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR ID1 CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MKR : mem (ID1, CN) KR
MKRest : mem (ID1, CK) KRest
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1764">
 &lt; <b>MN: apply remove_all_mem_after to RA MKR.</b>

Subgoal 5.1.2.2.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR ID1 CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MKR : mem (ID1, CN) KR
MKRest : mem (ID1, CK) KRest
MN : mem (ID1, CN) Needed
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1765">
 &lt; <b>MK: apply remove_all_mem_after to Ela1 MKRest.</b>

Subgoal 5.1.2.2.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR ID1 CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MKR : mem (ID1, CN) KR
MKRest : mem (ID1, CK) KRest
MN : mem (ID1, CN) Needed
MK : mem (ID1, CK) Known
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1766">
 &lt; <b>HN: case HN.</b>

Subgoal 5.1.2.2.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR ID1 CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MKR : mem (ID1, CN) KR
MKRest : mem (ID1, CK) KRest
MN : mem (ID1, CN) Needed
MK : mem (ID1, CK) Known
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1767">
 &lt; <b>apply HN1 to MN MK.</b>

Subgoal 5.1.2.2.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR ID1 CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MKR : mem (ID1, CK) KR
MKRest : mem (ID1, CK) KRest
MN : mem (ID1, CK) Needed
MK : mem (ID1, CK) Known
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 CK = CK
</pre>
<pre class="code extensibella"id="1768">
 &lt; <b>search.</b>

Subgoal 5:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
H8 : checkProof ((ID, C)::KR) ERest
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1769">
 &lt; <b>apply rupProof_hasNeeded to _ _ _ _ _ CP2 Ela4 HN.</b>

Subgoal 5:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
H8 : checkProof ((ID, C)::KR) ERest
H9 : rupProof Needed C Prf
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1770">
 &lt; <b>search.</b>

Subgoal 6:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsP : is_proof (addLrupProof ID C Prf Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1771">
 &lt; <b>Is: case IsP.</b>

Subgoal 6:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1772">
 &lt; <b>CP: case CP (keep).</b>

Subgoal 6:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KRest1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest1
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest1) Rest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1773">
 &lt; <b>apply remove_all_unique to CP1 Ela1.</b>

Subgoal 6:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1774">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 6:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1775">
 &lt; <b>apply good_clause_list_remove_all_add to _ Ela1 with
     C = C.</b>

Subgoal 6:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1776">
 &lt; <b>apply elaboration_is_needed to _ _ _ Ela2.</b>

Subgoal 6:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1777">
 &lt; <b>apply select_is_clauseUsedness to _ Ela3.</b>

Subgoal 6:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1778">
 &lt; <b>GUL: apply elaboration_good_used_list to _ _ _ CP3 Ela2.</b>

Subgoal 6:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1779">
 &lt; <b>apply good_used_list_select to GUL Ela3.</b>

Subgoal 6:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1780">
 &lt; <b>RA: apply remove_all_exists to IsNeeded Is.</b>

Subgoal 6:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1781">
 &lt; <b>apply good_clause_list_remove_all to _ RA.</b>

Subgoal 6:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1782">
 &lt; <b>apply remove_all_is to _ RA.</b>

Subgoal 6:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1783">
 &lt; <b>CP': apply IH to _ _ _ _ _ CP3 Ela2 _ with
          Needed = KR.</b>

Subgoal 6.1:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
============================
 hasNeeded ((ID, C)::KRest) Needed1 KR
</pre>
<pre class="code extensibella"id="1784">
 &lt; <b>unfold .</b>

Subgoal 6.1.1:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
============================
 forall ID1, mem (ID1, needed) Needed1 -&gt; exists C1, mem (ID1, C1) KR
</pre>
<pre class="code extensibella"id="1785">
 &lt; <b>intros MN1.</b>

Subgoal 6.1.1:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR ID1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
MN1 : mem (ID1, needed) Needed1
============================
 exists C1, mem (ID1, C1) KR
</pre>
<pre class="code extensibella"id="1786">
 &lt; <b>apply mem_is_clauseUsedness to _ MN1.</b>

Subgoal 6.1.1:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
============================
 exists C1, mem (ID2, C1) KR
</pre>
<pre class="code extensibella"id="1787">
 &lt; <b>Or: apply is_integer_eq_or_not to Is _ with
         I2 = ID2.</b>

Subgoal 6.1.1:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
Or : ID = ID2 \/ (ID = ID2 -&gt; false)
============================
 exists C1, mem (ID2, C1) KR
</pre>
<pre class="code extensibella"id="1788">
 &lt; <b>N: case Or.</b>

Subgoal 6.1.1.1:

Variables: Known CU E Needed KRest Needed1 Rest Prf C KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID2 C Prf Rest)
Ela : elaborate Known (addLrupProof ID2 C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID2 KRest
Ela2 : elaborate ((ID2, C)::KRest) Rest Needed1 E *
Ela3 : select (ID2, unknown) CU Needed1
Is : is_integer ID2
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID2 KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID2, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID2, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID2 KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
============================
 exists C1, mem (ID2, C1) KR
</pre>
<pre class="code extensibella"id="1789">
 &lt; <b>MN1': apply select_mem to Ela3.</b>

Subgoal 6.1.1.1:

Variables: Known CU E Needed KRest Needed1 Rest Prf C KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID2 C Prf Rest)
Ela : elaborate Known (addLrupProof ID2 C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID2 KRest
Ela2 : elaborate ((ID2, C)::KRest) Rest Needed1 E *
Ela3 : select (ID2, unknown) CU Needed1
Is : is_integer ID2
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID2 KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID2, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID2, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID2 KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
MN1' : mem (ID2, unknown) Needed1
============================
 exists C1, mem (ID2, C1) KR
</pre>
<pre class="code extensibella"id="1790">
 &lt; <b>apply good_used_list_mems to GUL MN1 MN1'.</b>

Subgoal 6.1.1.2:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
============================
 exists C1, mem (ID2, C1) KR
</pre>
<pre class="code extensibella"id="1791">
 &lt; <b>MCU: apply mem_before_select_after to Ela3 MN1 _.</b>

Subgoal 6.1.1.2:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
MCU : mem (ID2, needed) CU
============================
 exists C1, mem (ID2, C1) KR
</pre>
<pre class="code extensibella"id="1792">
 &lt; <b>HN: case HN.</b>

Subgoal 6.1.1.2:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
MCU : mem (ID2, needed) CU
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 exists C1, mem (ID2, C1) KR
</pre>
<pre class="code extensibella"id="1793">
 &lt; <b>MN: apply HN to MCU.</b>

Subgoal 6.1.1.2:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR ID2 C2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
MCU : mem (ID2, needed) CU
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (ID2, C2) Needed
============================
 exists C1, mem (ID2, C1) KR
</pre>
<pre class="code extensibella"id="1794">
 &lt; <b>apply remove_all_still_mem to RA MN _.</b>

Subgoal 6.1.1.2:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR ID2 C2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
MCU : mem (ID2, needed) CU
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (ID2, C2) Needed
H10 : mem (ID2, C2) KR
============================
 exists C1, mem (ID2, C1) KR
</pre>
<pre class="code extensibella"id="1795">
 &lt; <b>search.</b>

Subgoal 6.1.2:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
============================
 forall ID1 CN CK, mem (ID1, CN) KR -&gt; mem (ID1, CK) ((ID, C)::KRest) -&gt; CN = CK
</pre>
<pre class="code extensibella"id="1796">
 &lt; <b>intros ML' MKRest+.</b>

Subgoal 6.1.2:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR ID1 CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
ML' : mem (ID1, CN) KR
MKRest+ : mem (ID1, CK) ((ID, C)::KRest)
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1797">
 &lt; <b>MKRest: case MKRest+.</b>

Subgoal 6.1.2.1:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR CN
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
ML' : mem (ID, CN) KR
============================
 CN = C
</pre>
<pre class="code extensibella"id="1798">
 &lt; <b>apply remove_all_no_mem to RA ML'.</b>

Subgoal 6.1.2.2:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR ID1 CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
ML' : mem (ID1, CN) KR
MKRest : mem (ID1, CK) KRest
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1799">
 &lt; <b>MK: apply remove_all_mem_after to Ela1 MKRest.</b>

Subgoal 6.1.2.2:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR ID1 CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
ML' : mem (ID1, CN) KR
MKRest : mem (ID1, CK) KRest
MK : mem (ID1, CK) Known
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1800">
 &lt; <b>MN: apply remove_all_mem_after to RA ML'.</b>

Subgoal 6.1.2.2:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR ID1 CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
ML' : mem (ID1, CN) KR
MKRest : mem (ID1, CK) KRest
MK : mem (ID1, CK) Known
MN : mem (ID1, CN) Needed
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1801">
 &lt; <b>HN: case HN.</b>

Subgoal 6.1.2.2:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR ID1 CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
ML' : mem (ID1, CN) KR
MKRest : mem (ID1, CK) KRest
MK : mem (ID1, CK) Known
MN : mem (ID1, CN) Needed
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1802">
 &lt; <b>apply HN1 to MN MK.</b>

Subgoal 6.1.2.2:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR ID1 CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
ML' : mem (ID1, CK) KR
MKRest : mem (ID1, CK) KRest
MK : mem (ID1, CK) Known
MN : mem (ID1, CK) Needed
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 CK = CK
</pre>
<pre class="code extensibella"id="1803">
 &lt; <b>search.</b>

Subgoal 6:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
CP' : checkProof KR E
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1804">
 &lt; <b>apply elaboration_check_add to _ _ _ _ _ _ GCL_N Ela2 CP' _.</b>

Subgoal 6.2:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
CP' : checkProof KR E
============================
 forall ID C, mem (ID, C) KR -&gt; mem (ID, C) Needed
</pre>
<pre class="code extensibella"id="1805">
 &lt; <b>intros MKR.</b>

Subgoal 6.2:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR ID1 C1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
CP' : checkProof KR E
MKR : mem (ID1, C1) KR
============================
 mem (ID1, C1) Needed
</pre>
<pre class="code extensibella"id="1806">
 &lt; <b>apply remove_all_mem_after to RA MKR.</b>

Subgoal 6.2:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR ID1 C1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
CP' : checkProof KR E
MKR : mem (ID1, C1) KR
H8 : mem (ID1, C1) Needed
============================
 mem (ID1, C1) Needed
</pre>
<pre class="code extensibella"id="1807">
 &lt; <b>search.</b>

Subgoal 6:

Variables: Known CU E Needed KRest Needed1 Rest Prf C ID KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addLrupProof ID C Prf Rest)
Ela : elaborate Known (addLrupProof ID C Prf Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_list is_integer Prf
Is3 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
CP' : checkProof KR E
H8 : checkProof Needed E
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1808">
 &lt; <b>search.</b>

Subgoal 7:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsP : is_proof (addProofless ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1809">
 &lt; <b>Is: case IsP.</b>

Subgoal 7:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1810">
 &lt; <b>CP: case CP (keep).</b>

Subgoal 7:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest KRest1 Prf1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest1
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest1) Rest
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1811">
 &lt; <b>apply remove_all_unique to CP1 Ela1.</b>

Subgoal 7:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1812">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 7:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1813">
 &lt; <b>apply good_clause_list_remove_all_add to _ Ela1 with
     C = C.</b>

Subgoal 7:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1814">
 &lt; <b>apply elaboration_is_needed to _ _ _ Ela2.</b>

Subgoal 7:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1815">
 &lt; <b>apply select_is_clauseUsedness to _ Ela3.</b>

Subgoal 7:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1816">
 &lt; <b>RA: apply remove_all_exists to IsNeeded Is.</b>

Subgoal 7:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1817">
 &lt; <b>apply remove_all_is to _ RA.</b>

Subgoal 7:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1818">
 &lt; <b>apply good_clause_list_remove_all_add to _ RA with
     C = C.</b>

Subgoal 7:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1819">
 &lt; <b>GUL: apply elaboration_good_used_list to _ _ _ CP3 Ela2.</b>

Subgoal 7:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1820">
 &lt; <b>apply good_used_list_select to GUL Ela3.</b>

Subgoal 7:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1821">
 &lt; <b>apply IH to _ _ _ _ _ CP3 Ela2 _ with
     Needed = (ID, C)::KR.</b>

Subgoal 7.1:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
============================
 hasNeeded ((ID, C)::KRest) Needed1 ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1822">
 &lt; <b>unfold .</b>

Subgoal 7.1.1:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
============================
 forall ID1, mem (ID1, needed) Needed1 -&gt; exists C1, mem (ID1, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1823">
 &lt; <b>intros MN1.</b>

Subgoal 7.1.1:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR ID1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID1, needed) Needed1
============================
 exists C1, mem (ID1, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1824">
 &lt; <b>apply mem_is_clauseUsedness to _ MN1.</b>

Subgoal 7.1.1:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
============================
 exists C1, mem (ID2, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1825">
 &lt; <b>Or: apply is_integer_eq_or_not to Is _ with
         I2 = ID2.</b>

Subgoal 7.1.1:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
Or : ID = ID2 \/ (ID = ID2 -&gt; false)
============================
 exists C1, mem (ID2, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1826">
 &lt; <b>N: case Or.</b>

Subgoal 7.1.1.1:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C Rest Prf1 KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID2 C Rest)
Ela : elaborate Known (addProofless ID2 C Rest) CU (addLrupProof ID2 C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID2 KRest
Ela2 : elaborate ((ID2, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID2, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID2
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID2 KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID2, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID2, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID2 KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID2, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
============================
 exists C1, mem (ID2, C1) ((ID2, C)::KR)
</pre>
<pre class="code extensibella"id="1827">
 &lt; <b>search.</b>

Subgoal 7.1.1.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
============================
 exists C1, mem (ID2, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1828">
 &lt; <b>MNR: apply mem_before_select_after to Ela3 MN1 _.</b>

Subgoal 7.1.1.2.1:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
============================
 (ID, needed) = (ID2, needed) -&gt; false
</pre>
<pre class="code extensibella"id="1829">
 &lt; <b>intros E.</b>

Subgoal 7.1.1.2.1:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
E : (ID, needed) = (ID2, needed)
============================
 false
</pre>
<pre class="code extensibella"id="1830">
 &lt; <b>case E.</b>

Subgoal 7.1.1.2.1:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C Rest Prf1 KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID2 C Rest)
Ela : elaborate Known (addProofless ID2 C Rest) CU (addLrupProof ID2 C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID2 KRest
Ela2 : elaborate ((ID2, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID2, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID2
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID2 KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID2, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID2, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID2 KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID2, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID2 = ID2 -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="1831">
 &lt; <b>backchain N.</b>

Subgoal 7.1.1.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
MNR : mem (ID2, needed) NRest
============================
 exists C1, mem (ID2, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1832">
 &lt; <b>MCU: apply makeUsed_subset to _ _ Ela5 MNR.</b>

Subgoal 7.1.1.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
MNR : mem (ID2, needed) NRest
MCU : mem (ID2, needed) CU
============================
 exists C1, mem (ID2, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1833">
 &lt; <b>HN: case HN.</b>

Subgoal 7.1.1.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
MNR : mem (ID2, needed) NRest
MCU : mem (ID2, needed) CU
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 exists C1, mem (ID2, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1834">
 &lt; <b>MN: apply HN to MCU.</b>

Subgoal 7.1.1.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR ID2 C2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
MNR : mem (ID2, needed) NRest
MCU : mem (ID2, needed) CU
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (ID2, C2) Needed
============================
 exists C1, mem (ID2, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1835">
 &lt; <b>apply remove_all_still_mem to RA MN _.</b>

Subgoal 7.1.1.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR ID2 C2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
MNR : mem (ID2, needed) NRest
MCU : mem (ID2, needed) CU
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (ID2, C2) Needed
H10 : mem (ID2, C2) KR
============================
 exists C1, mem (ID2, C1) ((ID, C)::KR)
</pre>
<pre class="code extensibella"id="1836">
 &lt; <b>search.</b>

Subgoal 7.1.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
============================
 forall ID1 CN CK,
   mem (ID1, CN) ((ID, C)::KR) -&gt; mem (ID1, CK) ((ID, C)::KRest) -&gt; CN = CK
</pre>
<pre class="code extensibella"id="1837">
 &lt; <b>intros MKR+ MKRest+.</b>

Subgoal 7.1.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR ID1 CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MKR+ : mem (ID1, CN) ((ID, C)::KR)
MKRest+ : mem (ID1, CK) ((ID, C)::KRest)
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1838">
 &lt; <b>MKR: case MKR+.</b>

Subgoal 7.1.2.1:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MKRest+ : mem (ID, CK) ((ID, C)::KRest)
============================
 C = CK
</pre>
<pre class="code extensibella"id="1839">
 &lt; <b>MKRest: case MKRest+.</b>

Subgoal 7.1.2.1.1:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
============================
 C = C
</pre>
<pre class="code extensibella"id="1840">
 &lt; <b>search.</b>

Subgoal 7.1.2.1.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MKRest : mem (ID, CK) KRest
============================
 C = CK
</pre>
<pre class="code extensibella"id="1841">
 &lt; <b>apply remove_all_no_mem to Ela1 MKRest.</b>

Subgoal 7.1.2.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR ID1 CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MKRest+ : mem (ID1, CK) ((ID, C)::KRest)
MKR : mem (ID1, CN) KR
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1842">
 &lt; <b>MKRest: case MKRest+.</b>

Subgoal 7.1.2.2.1:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR CN
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MKR : mem (ID, CN) KR
============================
 CN = C
</pre>
<pre class="code extensibella"id="1843">
 &lt; <b>apply remove_all_no_mem to RA MKR.</b>

Subgoal 7.1.2.2.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR ID1 CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MKR : mem (ID1, CN) KR
MKRest : mem (ID1, CK) KRest
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1844">
 &lt; <b>MN: apply remove_all_mem_after to RA MKR.</b>

Subgoal 7.1.2.2.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR ID1 CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MKR : mem (ID1, CN) KR
MKRest : mem (ID1, CK) KRest
MN : mem (ID1, CN) Needed
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1845">
 &lt; <b>MK: apply remove_all_mem_after to Ela1 MKRest.</b>

Subgoal 7.1.2.2.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR ID1 CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MKR : mem (ID1, CN) KR
MKRest : mem (ID1, CK) KRest
MN : mem (ID1, CN) Needed
MK : mem (ID1, CK) Known
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1846">
 &lt; <b>HN: case HN.</b>

Subgoal 7.1.2.2.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR ID1 CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MKR : mem (ID1, CN) KR
MKRest : mem (ID1, CK) KRest
MN : mem (ID1, CN) Needed
MK : mem (ID1, CK) Known
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1847">
 &lt; <b>apply HN1 to MN MK.</b>

Subgoal 7.1.2.2.2:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR ID1 CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
MKR : mem (ID1, CK) KR
MKRest : mem (ID1, CK) KRest
MN : mem (ID1, CK) Needed
MK : mem (ID1, CK) Known
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 CK = CK
</pre>
<pre class="code extensibella"id="1848">
 &lt; <b>search.</b>

Subgoal 7:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
H8 : checkProof ((ID, C)::KR) ERest
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1849">
 &lt; <b>apply rupProof_hasNeeded to _ _ _ _ _ Ela4 Ela5 HN.</b>

Subgoal 7:

Variables: Known CU Needed KRest Needed1 NRest ERest Prf C ID Rest Prf1 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU (addLrupProof ID C Prf ERest) @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 ERest *
Ela3 : select (ID, needed) NRest Needed1
Ela4 : rupProof Known C Prf
Ela5 : makeUsed NRest Prf CU
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf1
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) NRest
RA : remove_all Needed ID KR
H5 : is_list (is_pair is_integer is_clause) KR
H6 : good_clause_list ((ID, C)::KR)
GUL : good_used_list Needed1
H7 : good_used_list NRest
H8 : checkProof ((ID, C)::KR) ERest
H9 : rupProof Needed C Prf
============================
 checkProof Needed (addLrupProof ID C Prf ERest)
</pre>
<pre class="code extensibella"id="1850">
 &lt; <b>search.</b>

Subgoal 8:

Variables: Known CU E Needed KRest Needed1 Rest C ID
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsP : is_proof (addProofless ID C Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1851">
 &lt; <b>Is: case IsP.</b>

Subgoal 8:

Variables: Known CU E Needed KRest Needed1 Rest C ID
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1852">
 &lt; <b>CP: case CP (keep).</b>

Subgoal 8:

Variables: Known CU E Needed KRest Needed1 Rest C ID KRest1 Prf
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest1
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest1) Rest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1853">
 &lt; <b>apply remove_all_unique to CP1 Ela1.</b>

Subgoal 8:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1854">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 8:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1855">
 &lt; <b>apply good_clause_list_remove_all_add to _ Ela1 with
     C = C.</b>

Subgoal 8:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1856">
 &lt; <b>apply elaboration_is_needed to _ _ _ Ela2.</b>

Subgoal 8:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1857">
 &lt; <b>apply select_is_clauseUsedness to _ Ela3.</b>

Subgoal 8:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1858">
 &lt; <b>GUL: apply elaboration_good_used_list to _ _ _ CP3 Ela2.</b>

Subgoal 8:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1859">
 &lt; <b>apply good_used_list_select to GUL Ela3.</b>

Subgoal 8:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1860">
 &lt; <b>RA: apply remove_all_exists to IsNeeded Is.</b>

Subgoal 8:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1861">
 &lt; <b>apply good_clause_list_remove_all to _ RA.</b>

Subgoal 8:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1862">
 &lt; <b>apply remove_all_is to _ RA.</b>

Subgoal 8:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1863">
 &lt; <b>CP': apply IH to _ _ _ _ _ CP3 Ela2 _ with
          Needed = KR.</b>

Subgoal 8.1:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
============================
 hasNeeded ((ID, C)::KRest) Needed1 KR
</pre>
<pre class="code extensibella"id="1864">
 &lt; <b>unfold .</b>

Subgoal 8.1.1:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
============================
 forall ID1, mem (ID1, needed) Needed1 -&gt; exists C1, mem (ID1, C1) KR
</pre>
<pre class="code extensibella"id="1865">
 &lt; <b>intros MN1.</b>

Subgoal 8.1.1:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR ID1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
MN1 : mem (ID1, needed) Needed1
============================
 exists C1, mem (ID1, C1) KR
</pre>
<pre class="code extensibella"id="1866">
 &lt; <b>apply mem_is_clauseUsedness to _ MN1.</b>

Subgoal 8.1.1:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
============================
 exists C1, mem (ID2, C1) KR
</pre>
<pre class="code extensibella"id="1867">
 &lt; <b>Or: apply is_integer_eq_or_not to Is _ with
         I2 = ID2.</b>

Subgoal 8.1.1:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
Or : ID = ID2 \/ (ID = ID2 -&gt; false)
============================
 exists C1, mem (ID2, C1) KR
</pre>
<pre class="code extensibella"id="1868">
 &lt; <b>N: case Or.</b>

Subgoal 8.1.1.1:

Variables: Known CU E Needed KRest Needed1 Rest C Prf KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID2 C Rest)
Ela : elaborate Known (addProofless ID2 C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID2 KRest
Ela2 : elaborate ((ID2, C)::KRest) Rest Needed1 E *
Ela3 : select (ID2, unknown) CU Needed1
Is : is_integer ID2
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID2 KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID2, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID2, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID2 KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
============================
 exists C1, mem (ID2, C1) KR
</pre>
<pre class="code extensibella"id="1869">
 &lt; <b>MN1': apply select_mem to Ela3.</b>

Subgoal 8.1.1.1:

Variables: Known CU E Needed KRest Needed1 Rest C Prf KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID2 C Rest)
Ela : elaborate Known (addProofless ID2 C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID2 KRest
Ela2 : elaborate ((ID2, C)::KRest) Rest Needed1 E *
Ela3 : select (ID2, unknown) CU Needed1
Is : is_integer ID2
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID2 KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID2, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID2, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID2 KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
MN1' : mem (ID2, unknown) Needed1
============================
 exists C1, mem (ID2, C1) KR
</pre>
<pre class="code extensibella"id="1870">
 &lt; <b>apply good_used_list_mems to GUL MN1 MN1'.</b>

Subgoal 8.1.1.2:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
============================
 exists C1, mem (ID2, C1) KR
</pre>
<pre class="code extensibella"id="1871">
 &lt; <b>MCU: apply mem_before_select_after to Ela3 MN1 _.</b>

Subgoal 8.1.1.2:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
MCU : mem (ID2, needed) CU
============================
 exists C1, mem (ID2, C1) KR
</pre>
<pre class="code extensibella"id="1872">
 &lt; <b>HN: case HN.</b>

Subgoal 8.1.1.2:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR ID2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
MCU : mem (ID2, needed) CU
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 exists C1, mem (ID2, C1) KR
</pre>
<pre class="code extensibella"id="1873">
 &lt; <b>MN: apply HN to MCU.</b>

Subgoal 8.1.1.2:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR ID2 C2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
MCU : mem (ID2, needed) CU
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (ID2, C2) Needed
============================
 exists C1, mem (ID2, C1) KR
</pre>
<pre class="code extensibella"id="1874">
 &lt; <b>apply remove_all_still_mem to RA MN _.</b>

Subgoal 8.1.1.2:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR ID2 C2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
MN1 : mem (ID2, needed) Needed1
H8 : is_integer ID2
H9 : is_clauseUsedness needed
N : ID = ID2 -&gt; false
MCU : mem (ID2, needed) CU
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (ID2, C2) Needed
H10 : mem (ID2, C2) KR
============================
 exists C1, mem (ID2, C1) KR
</pre>
<pre class="code extensibella"id="1875">
 &lt; <b>search.</b>

Subgoal 8.1.2:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
============================
 forall ID1 CN CK, mem (ID1, CN) KR -&gt; mem (ID1, CK) ((ID, C)::KRest) -&gt; CN = CK
</pre>
<pre class="code extensibella"id="1876">
 &lt; <b>intros ML' MKRest+.</b>

Subgoal 8.1.2:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR ID1 CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
ML' : mem (ID1, CN) KR
MKRest+ : mem (ID1, CK) ((ID, C)::KRest)
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1877">
 &lt; <b>MKRest: case MKRest+.</b>

Subgoal 8.1.2.1:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR CN
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
ML' : mem (ID, CN) KR
============================
 CN = C
</pre>
<pre class="code extensibella"id="1878">
 &lt; <b>apply remove_all_no_mem to RA ML'.</b>

Subgoal 8.1.2.2:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR ID1 CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
ML' : mem (ID1, CN) KR
MKRest : mem (ID1, CK) KRest
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1879">
 &lt; <b>MK: apply remove_all_mem_after to Ela1 MKRest.</b>

Subgoal 8.1.2.2:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR ID1 CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
ML' : mem (ID1, CN) KR
MKRest : mem (ID1, CK) KRest
MK : mem (ID1, CK) Known
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1880">
 &lt; <b>MN: apply remove_all_mem_after to RA ML'.</b>

Subgoal 8.1.2.2:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR ID1 CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
ML' : mem (ID1, CN) KR
MKRest : mem (ID1, CK) KRest
MK : mem (ID1, CK) Known
MN : mem (ID1, CN) Needed
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1881">
 &lt; <b>HN: case HN.</b>

Subgoal 8.1.2.2:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR ID1 CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
ML' : mem (ID1, CN) KR
MKRest : mem (ID1, CK) KRest
MK : mem (ID1, CK) Known
MN : mem (ID1, CN) Needed
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1882">
 &lt; <b>apply HN1 to MN MK.</b>

Subgoal 8.1.2.2:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR ID1 CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
ML' : mem (ID1, CK) KR
MKRest : mem (ID1, CK) KRest
MK : mem (ID1, CK) Known
MN : mem (ID1, CK) Needed
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 CK = CK
</pre>
<pre class="code extensibella"id="1883">
 &lt; <b>search.</b>

Subgoal 8:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
CP' : checkProof KR E
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1884">
 &lt; <b>apply elaboration_check_add to _ _ _ _ _ _ GCL_N Ela2 CP' _.</b>

Subgoal 8.2:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
CP' : checkProof KR E
============================
 forall ID C, mem (ID, C) KR -&gt; mem (ID, C) Needed
</pre>
<pre class="code extensibella"id="1885">
 &lt; <b>intros MKR.</b>

Subgoal 8.2:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR ID1 C1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
CP' : checkProof KR E
MKR : mem (ID1, C1) KR
============================
 mem (ID1, C1) Needed
</pre>
<pre class="code extensibella"id="1886">
 &lt; <b>apply remove_all_mem_after to RA MKR.</b>

Subgoal 8.2:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR ID1 C1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
CP' : checkProof KR E
MKR : mem (ID1, C1) KR
H8 : mem (ID1, C1) Needed
============================
 mem (ID1, C1) Needed
</pre>
<pre class="code extensibella"id="1887">
 &lt; <b>search.</b>

Subgoal 8:

Variables: Known CU E Needed KRest Needed1 Rest C ID Prf KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (addProofless ID C Rest)
Ela : elaborate Known (addProofless ID C Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : remove_all Known ID KRest
Ela2 : elaborate ((ID, C)::KRest) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_proof Rest
CP1 : remove_all Known ID KRest
CP2 : rupProof Known C Prf
CP3 : checkProof ((ID, C)::KRest) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list ((ID, C)::KRest)
H3 : is_list (is_pair is_integer is_clauseUsedness) Needed1
H4 : is_list (is_pair is_integer is_clauseUsedness) CU
GUL : good_used_list Needed1
H5 : good_used_list CU
RA : remove_all Needed ID KR
H6 : good_clause_list KR
H7 : is_list (is_pair is_integer is_clause) KR
CP' : checkProof KR E
H8 : checkProof Needed E
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1888">
 &lt; <b>search.</b>

Subgoal 9:

Variables: Known Needed KRest C KRest2 Needed1 ERest To From NRest Rest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsP : is_proof (relocateClause From To Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1889">
 &lt; <b>Is: case IsP.</b>

Subgoal 9:

Variables: Known Needed KRest C KRest2 Needed1 ERest To From NRest Rest
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1890">
 &lt; <b>CP: case CP (keep).</b>

Subgoal 9.1:

Variables: Known Needed KRest C KRest2 Needed1 ERest To From NRest Rest KRest1 C1 KRest3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) Rest
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1891">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 9.1:

Variables: Known Needed KRest C KRest2 Needed1 ERest To From NRest Rest KRest1 C1 KRest3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1892">
 &lt; <b>apply remove_all_unique to CP2 Ela1.</b>

Subgoal 9.1:

Variables: Known Needed KRest C KRest2 Needed1 ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1893">
 &lt; <b>apply good_clause_list_remove_all to _ CP2.</b>

Subgoal 9.1:

Variables: Known Needed KRest C KRest2 Needed1 ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1894">
 &lt; <b>apply good_clause_list_selects to _ Ela2 CP3.</b>

Subgoal 9.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1895">
 &lt; <b>apply select_is to _ Ela2.</b>

Subgoal 9.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1896">
 &lt; <b>IsP: apply select_is_picked to _ Ela2.</b>

Subgoal 9.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
IsP : is_pair is_integer is_clause (From, C1)
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1897">
 &lt; <b>Is': case IsP.</b>

Subgoal 9.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1898">
 &lt; <b>GCLKR+: assert good_clause_list ((To, C1)::KRest3).</b>

Subgoal 9.1.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
============================
 good_clause_list ((To, C1)::KRest3)
</pre>
<pre class="code extensibella"id="1899">
 &lt; <b>unfold .</b>

Subgoal 9.1.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
============================
 forall ID C2 KRest C3,
   select (ID, C2) KRest ((To, C1)::KRest3) -&gt; mem (ID, C3) KRest -&gt; false
</pre>
<pre class="code extensibella"id="1900">
 &lt; <b>intros S M.</b>

Subgoal 9.1.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 ID C2 KRest4 C3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
S : select (ID, C2) KRest4 ((To, C1)::KRest3)
M : mem (ID, C3) KRest4
============================
 false
</pre>
<pre class="code extensibella"id="1901">
 &lt; <b>S: case S.</b>

Subgoal 9.1.1.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 C3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
M : mem (To, C3) KRest3
============================
 false
</pre>
<pre class="code extensibella"id="1902">
 &lt; <b>M': apply mem_after_select_before to Ela2 M.</b>

Subgoal 9.1.1.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 C3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
M : mem (To, C3) KRest3
M' : mem (To, C3) KRest
============================
 false
</pre>
<pre class="code extensibella"id="1903">
 &lt; <b>apply remove_all_no_mem to Ela1 M'.</b>

Subgoal 9.1.1.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 ID C2 C3 L1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
M : mem (ID, C3) ((To, C1)::L1)
S : select (ID, C2) L1 KRest3
============================
 false
</pre>
<pre class="code extensibella"id="1904">
 &lt; <b>M: case M.</b>

Subgoal 9.1.1.2.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 C2 L1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
S : select (To, C2) L1 KRest3
============================
 false
</pre>
<pre class="code extensibella"id="1905">
 &lt; <b>M: apply select_mem to S.</b>

Subgoal 9.1.1.2.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 C2 L1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
S : select (To, C2) L1 KRest3
M : mem (To, C2) KRest3
============================
 false
</pre>
<pre class="code extensibella"id="1906">
 &lt; <b>M': apply mem_after_select_before to Ela2 M.</b>

Subgoal 9.1.1.2.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 C2 L1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
S : select (To, C2) L1 KRest3
M : mem (To, C2) KRest3
M' : mem (To, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="1907">
 &lt; <b>M'': apply remove_all_no_mem to Ela1 M'.</b>

Subgoal 9.1.1.2.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 ID C2 C3 L1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
S : select (ID, C2) L1 KRest3
M : mem (ID, C3) L1
============================
 false
</pre>
<pre class="code extensibella"id="1908">
 &lt; <b>apply good_clause_list_remove_all to _ Ela1.</b>

Subgoal 9.1.1.2.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 ID C2 C3 L1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
S : select (ID, C2) L1 KRest3
M : mem (ID, C3) L1
H4 : good_clause_list KRest
============================
 false
</pre>
<pre class="code extensibella"id="1909">
 &lt; <b>GCL': apply good_clause_list_select to _ Ela2.</b>

Subgoal 9.1.1.2.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 ID C2 C3 L1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
S : select (ID, C2) L1 KRest3
M : mem (ID, C3) L1
H4 : good_clause_list KRest
GCL' : good_clause_list KRest3
============================
 false
</pre>
<pre class="code extensibella"id="1910">
 &lt; <b>GCL': case GCL'.</b>

Subgoal 9.1.1.2.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 ID C2 C3 L1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
S : select (ID, C2) L1 KRest3
M : mem (ID, C3) L1
H4 : good_clause_list KRest
GCL' : forall ID C1 KRest C2,
         select (ID, C1) KRest KRest3 -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="1911">
 &lt; <b>apply GCL' to S M.</b>

Subgoal 9.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1912">
 &lt; <b>RA: apply remove_all_exists to IsNeeded Is1.</b>

Subgoal 9.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1913">
 &lt; <b>apply good_clause_list_remove_all to _ RA.</b>

Subgoal 9.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1914">
 &lt; <b>apply remove_all_is to _ RA.</b>

Subgoal 9.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1915">
 &lt; <b>MKRest: apply select_mem to Ela2.</b>

Subgoal 9.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
MKRest : mem (From, C1) KRest
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1916">
 &lt; <b>MK: apply remove_all_mem_after to Ela1 MKRest.</b>

Subgoal 9.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
MKRest : mem (From, C1) KRest
MK : mem (From, C1) Known
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1917">
 &lt; <b>HN': case HN (keep).</b>

Subgoal 9.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
MKRest : mem (From, C1) KRest
MK : mem (From, C1) Known
HN' : forall ID,
        mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN'1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1918">
 &lt; <b>MN: apply HN' to _ with
         ID = From.</b>

Subgoal 9.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR C2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
MKRest : mem (From, C1) KRest
MK : mem (From, C1) Known
HN' : forall ID,
        mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN'1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (From, C2) Needed
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1919">
 &lt; <b>apply HN'1 to MN MK.</b>

Subgoal 9.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
MKRest : mem (From, C1) KRest
MK : mem (From, C1) Known
HN' : forall ID,
        mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN'1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (From, C1) Needed
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1920">
 &lt; <b>MKR: apply remove_all_still_mem to RA MN _.</b>

Subgoal 9.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
MKRest : mem (From, C1) KRest
MK : mem (From, C1) Known
HN' : forall ID,
        mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN'1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (From, C1) Needed
MKR : mem (From, C1) KR
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1921">
 &lt; <b>SN: apply mem_select to MKR.</b>

Subgoal 9.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L'
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
MKRest : mem (From, C1) KRest
MK : mem (From, C1) Known
HN' : forall ID,
        mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN'1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (From, C1) Needed
MKR : mem (From, C1) KR
SN : select (From, C1) L' KR
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1922">
 &lt; <b>apply select_is to _ SN.</b>

Subgoal 9.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L'
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
MKRest : mem (From, C1) KRest
MK : mem (From, C1) Known
HN' : forall ID,
        mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN'1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (From, C1) Needed
MKR : mem (From, C1) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1923">
 &lt; <b>GCLL'+: assert good_clause_list ((To, C1)::L').</b>

Subgoal 9.1.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L'
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
MKRest : mem (From, C1) KRest
MK : mem (From, C1) Known
HN' : forall ID,
        mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN'1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (From, C1) Needed
MKR : mem (From, C1) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
============================
 good_clause_list ((To, C1)::L')
</pre>
<pre class="code extensibella"id="1924">
 &lt; <b>unfold .</b>

Subgoal 9.1.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L'
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
MKRest : mem (From, C1) KRest
MK : mem (From, C1) Known
HN' : forall ID,
        mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN'1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (From, C1) Needed
MKR : mem (From, C1) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
============================
 forall ID C2 KRest C3,
   select (ID, C2) KRest ((To, C1)::L') -&gt; mem (ID, C3) KRest -&gt; false
</pre>
<pre class="code extensibella"id="1925">
 &lt; <b>intros S M.</b>

Subgoal 9.1.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID C3 KRest4 C4
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
MKRest : mem (From, C1) KRest
MK : mem (From, C1) Known
HN' : forall ID,
        mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN'1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (From, C1) Needed
MKR : mem (From, C1) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
S : select (ID, C3) KRest4 ((To, C1)::L')
M : mem (ID, C4) KRest4
============================
 false
</pre>
<pre class="code extensibella"id="1926">
 &lt; <b>S: case S.</b>

Subgoal 9.1.2.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' C4
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
MKRest : mem (From, C1) KRest
MK : mem (From, C1) Known
HN' : forall ID,
        mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN'1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (From, C1) Needed
MKR : mem (From, C1) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
M : mem (To, C4) L'
============================
 false
</pre>
<pre class="code extensibella"id="1927">
 &lt; <b>M': apply mem_after_select_before to SN M.</b>

Subgoal 9.1.2.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' C4
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
MKRest : mem (From, C1) KRest
MK : mem (From, C1) Known
HN' : forall ID,
        mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN'1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (From, C1) Needed
MKR : mem (From, C1) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
M : mem (To, C4) L'
M' : mem (To, C4) KR
============================
 false
</pre>
<pre class="code extensibella"id="1928">
 &lt; <b>apply remove_all_no_mem to RA M'.</b>

Subgoal 9.1.2.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID C3 C4 L1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
MKRest : mem (From, C1) KRest
MK : mem (From, C1) Known
HN' : forall ID,
        mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN'1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (From, C1) Needed
MKR : mem (From, C1) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
M : mem (ID, C4) ((To, C1)::L1)
S : select (ID, C3) L1 L'
============================
 false
</pre>
<pre class="code extensibella"id="1929">
 &lt; <b>M: case M.</b>

Subgoal 9.1.2.2.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' C3 L1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
MKRest : mem (From, C1) KRest
MK : mem (From, C1) Known
HN' : forall ID,
        mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN'1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (From, C1) Needed
MKR : mem (From, C1) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
S : select (To, C3) L1 L'
============================
 false
</pre>
<pre class="code extensibella"id="1930">
 &lt; <b>M: apply select_mem to S.</b>

Subgoal 9.1.2.2.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' C3 L1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
MKRest : mem (From, C1) KRest
MK : mem (From, C1) Known
HN' : forall ID,
        mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN'1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (From, C1) Needed
MKR : mem (From, C1) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
S : select (To, C3) L1 L'
M : mem (To, C3) L'
============================
 false
</pre>
<pre class="code extensibella"id="1931">
 &lt; <b>M': apply mem_after_select_before to SN M.</b>

Subgoal 9.1.2.2.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' C3 L1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
MKRest : mem (From, C1) KRest
MK : mem (From, C1) Known
HN' : forall ID,
        mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN'1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (From, C1) Needed
MKR : mem (From, C1) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
S : select (To, C3) L1 L'
M : mem (To, C3) L'
M' : mem (To, C3) KR
============================
 false
</pre>
<pre class="code extensibella"id="1932">
 &lt; <b>M'': apply remove_all_no_mem to RA M'.</b>

Subgoal 9.1.2.2.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID C3 C4 L1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
MKRest : mem (From, C1) KRest
MK : mem (From, C1) Known
HN' : forall ID,
        mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN'1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (From, C1) Needed
MKR : mem (From, C1) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
S : select (ID, C3) L1 L'
M : mem (ID, C4) L1
============================
 false
</pre>
<pre class="code extensibella"id="1933">
 &lt; <b>apply good_clause_list_remove_all to _ RA.</b>

Subgoal 9.1.2.2.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID C3 C4 L1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
MKRest : mem (From, C1) KRest
MK : mem (From, C1) Known
HN' : forall ID,
        mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN'1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (From, C1) Needed
MKR : mem (From, C1) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
S : select (ID, C3) L1 L'
M : mem (ID, C4) L1
H7 : good_clause_list KR
============================
 false
</pre>
<pre class="code extensibella"id="1934">
 &lt; <b>GCL': apply good_clause_list_select to _ SN.</b>

Subgoal 9.1.2.2.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID C3 C4 L1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
MKRest : mem (From, C1) KRest
MK : mem (From, C1) Known
HN' : forall ID,
        mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN'1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (From, C1) Needed
MKR : mem (From, C1) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
S : select (ID, C3) L1 L'
M : mem (ID, C4) L1
H7 : good_clause_list KR
GCL' : good_clause_list L'
============================
 false
</pre>
<pre class="code extensibella"id="1935">
 &lt; <b>GCL': case GCL'.</b>

Subgoal 9.1.2.2.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID C3 C4 L1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
MKRest : mem (From, C1) KRest
MK : mem (From, C1) Known
HN' : forall ID,
        mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN'1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (From, C1) Needed
MKR : mem (From, C1) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
S : select (ID, C3) L1 L'
M : mem (ID, C4) L1
H7 : good_clause_list KR
GCL' : forall ID C1 KRest C2,
         select (ID, C1) KRest L' -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="1936">
 &lt; <b>apply GCL' to S M.</b>

Subgoal 9.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L'
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
MKRest : mem (From, C1) KRest
MK : mem (From, C1) Known
HN' : forall ID,
        mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN'1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MN : mem (From, C1) Needed
MKR : mem (From, C1) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1937">
 &lt; <b>clear MN
   MKR
   MK
   MKRest
   HN'
   HN'1.</b>

Subgoal 9.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L'
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1938">
 &lt; <b>GUL: apply elaboration_good_used_list to _ _ _ CP Ela.</b>

Subgoal 9.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L'
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1939">
 &lt; <b>assert hasNeeded ((To, C1)::KRest3) Needed1 ((To, C1)::L').</b>

Subgoal 9.1.3:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L'
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
============================
 hasNeeded ((To, C1)::KRest3) Needed1 ((To, C1)::L')
</pre>
<pre class="code extensibella"id="1940">
 &lt; <b>unfold .</b>

Subgoal 9.1.3.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L'
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
============================
 forall ID, mem (ID, needed) Needed1 -&gt; exists C, mem (ID, C) ((To, C1)::L')
</pre>
<pre class="code extensibella"id="1941">
 &lt; <b>intros MN.</b>

Subgoal 9.1.3.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
MN : mem (ID, needed) Needed1
============================
 exists C, mem (ID, C) ((To, C1)::L')
</pre>
<pre class="code extensibella"id="1942">
 &lt; <b>Or: apply select_mem_or to Ela4 MN.</b>

Subgoal 9.1.3.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
MN : mem (ID, needed) Needed1
Or : (ID, needed) = (To, needed) \/ mem (ID, needed) NRest
============================
 exists C, mem (ID, C) ((To, C1)::L')
</pre>
<pre class="code extensibella"id="1943">
 &lt; <b>MNR: case Or.</b>

Subgoal 9.1.3.1.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L'
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
MN : mem (To, needed) Needed1
============================
 exists C, mem (To, C) ((To, C1)::L')
</pre>
<pre class="code extensibella"id="1944">
 &lt; <b>search.</b>

Subgoal 9.1.3.1.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
MN : mem (ID, needed) Needed1
MNR : mem (ID, needed) NRest
============================
 exists C, mem (ID, C) ((To, C1)::L')
</pre>
<pre class="code extensibella"id="1945">
 &lt; <b>HN: case HN.</b>

Subgoal 9.1.3.1.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
MN : mem (ID, needed) Needed1
MNR : mem (ID, needed) NRest
HN : forall ID,
       mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 exists C, mem (ID, C) ((To, C1)::L')
</pre>
<pre class="code extensibella"id="1946">
 &lt; <b>MNeeded: apply HN to _ with
              ID = ID.</b>

Subgoal 9.1.3.1.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID C3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
MN : mem (ID, needed) Needed1
MNR : mem (ID, needed) NRest
HN : forall ID,
       mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MNeeded : mem (ID, C3) Needed
============================
 exists C, mem (ID, C) ((To, C1)::L')
</pre>
<pre class="code extensibella"id="1947">
 &lt; <b>Is'': apply mem_is to _ MNeeded.</b>

Subgoal 9.1.3.1.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID1 C4
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
MN : mem (ID1, needed) Needed1
MNR : mem (ID1, needed) NRest
HN : forall ID,
       mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MNeeded : mem (ID1, C4) Needed
Is'' : is_integer ID1
Is''1 : is_clause C4
============================
 exists C, mem (ID1, C) ((To, C1)::L')
</pre>
<pre class="code extensibella"id="1948">
 &lt; <b>Or: apply is_integer_eq_or_not to Is1 Is''.</b>

Subgoal 9.1.3.1.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID1 C4
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
MN : mem (ID1, needed) Needed1
MNR : mem (ID1, needed) NRest
HN : forall ID,
       mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MNeeded : mem (ID1, C4) Needed
Is'' : is_integer ID1
Is''1 : is_clause C4
Or : To = ID1 \/ (To = ID1 -&gt; false)
============================
 exists C, mem (ID1, C) ((To, C1)::L')
</pre>
<pre class="code extensibella"id="1949">
 &lt; <b>case Or.</b>

Subgoal 9.1.3.1.2.1:

Variables: Known Needed KRest Needed1 ERest From NRest Rest C1 KRest3 KR L' ID1 C4
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From ID1 Rest)
Ela : elaborate Known (relocateClause From ID1 Rest) ((From, needed)::NRest) (relocateClause From ID1 ERest) @
Ela1 : remove_all Known ID1 KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((ID1, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (ID1, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer ID1
Is2 : is_proof Rest
CP1 : ID1 = From -&gt; false
CP2 : remove_all Known ID1 KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((ID1, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((ID1, C1)::KRest3)
RA : remove_all Needed ID1 KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((ID1, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
MN : mem (ID1, needed) Needed1
MNR : mem (ID1, needed) NRest
HN : forall ID,
       mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MNeeded : mem (ID1, C4) Needed
Is'' : is_integer ID1
Is''1 : is_clause C4
============================
 exists C, mem (ID1, C) ((ID1, C1)::L')
</pre>
<pre class="code extensibella"id="1950">
 &lt; <b>search.</b>

Subgoal 9.1.3.1.2.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID1 C4
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
MN : mem (ID1, needed) Needed1
MNR : mem (ID1, needed) NRest
HN : forall ID,
       mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MNeeded : mem (ID1, C4) Needed
Is'' : is_integer ID1
Is''1 : is_clause C4
H7 : To = ID1 -&gt; false
============================
 exists C, mem (ID1, C) ((To, C1)::L')
</pre>
<pre class="code extensibella"id="1951">
 &lt; <b>MKR: apply remove_all_still_mem to RA MNeeded _.</b>

Subgoal 9.1.3.1.2.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID1 C4
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
MN : mem (ID1, needed) Needed1
MNR : mem (ID1, needed) NRest
HN : forall ID,
       mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MNeeded : mem (ID1, C4) Needed
Is'' : is_integer ID1
Is''1 : is_clause C4
H7 : To = ID1 -&gt; false
MKR : mem (ID1, C4) KR
============================
 exists C, mem (ID1, C) ((To, C1)::L')
</pre>
<pre class="code extensibella"id="1952">
 &lt; <b>Or: apply select_mem_or to SN MKR.</b>

Subgoal 9.1.3.1.2.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID1 C4
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
MN : mem (ID1, needed) Needed1
MNR : mem (ID1, needed) NRest
HN : forall ID,
       mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MNeeded : mem (ID1, C4) Needed
Is'' : is_integer ID1
Is''1 : is_clause C4
H7 : To = ID1 -&gt; false
MKR : mem (ID1, C4) KR
Or : (ID1, C4) = (From, C1) \/ mem (ID1, C4) L'
============================
 exists C, mem (ID1, C) ((To, C1)::L')
</pre>
<pre class="code extensibella"id="1953">
 &lt; <b>case Or.</b>

Subgoal 9.1.3.1.2.2.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L'
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
MN : mem (From, needed) Needed1
MNR : mem (From, needed) NRest
HN : forall ID,
       mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MNeeded : mem (From, C1) Needed
Is'' : is_integer From
Is''1 : is_clause C1
H7 : To = From -&gt; false
MKR : mem (From, C1) KR
============================
 exists C, mem (From, C) ((To, C1)::L')
</pre>
<pre class="code extensibella"id="1954">
 &lt; <b>GUL: case GUL.</b>

Subgoal 9.1.3.1.2.2.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L'
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
MN : mem (From, needed) Needed1
MNR : mem (From, needed) NRest
HN : forall ID,
       mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MNeeded : mem (From, C1) Needed
Is'' : is_integer From
Is''1 : is_clause C1
H7 : To = From -&gt; false
MKR : mem (From, C1) KR
GUL : forall ID U1 CURest U2,
        select (ID, U1) CURest ((From, needed)::NRest) -&gt; mem (ID, U2) CURest -&gt;
        false
============================
 exists C, mem (From, C) ((To, C1)::L')
</pre>
<pre class="code extensibella"id="1955">
 &lt; <b>apply GUL to _ MNR.</b>

Subgoal 9.1.3.1.2.2.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID1 C4
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
MN : mem (ID1, needed) Needed1
MNR : mem (ID1, needed) NRest
HN : forall ID,
       mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MNeeded : mem (ID1, C4) Needed
Is'' : is_integer ID1
Is''1 : is_clause C4
H7 : To = ID1 -&gt; false
MKR : mem (ID1, C4) KR
H8 : mem (ID1, C4) L'
============================
 exists C, mem (ID1, C) ((To, C1)::L')
</pre>
<pre class="code extensibella"id="1956">
 &lt; <b>search.</b>

Subgoal 9.1.3.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L'
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
============================
 forall ID CN CK,
   mem (ID, CN) ((To, C1)::L') -&gt; mem (ID, CK) ((To, C1)::KRest3) -&gt; CN = CK
</pre>
<pre class="code extensibella"id="1957">
 &lt; <b>intros ML'+ MKR3+.</b>

Subgoal 9.1.3.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
ML'+ : mem (ID, CN) ((To, C1)::L')
MKR3+ : mem (ID, CK) ((To, C1)::KRest3)
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1958">
 &lt; <b>ML': case ML'+.</b>

Subgoal 9.1.3.2.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
MKR3+ : mem (To, CK) ((To, C1)::KRest3)
============================
 C1 = CK
</pre>
<pre class="code extensibella"id="1959">
 &lt; <b>MKR3: case MKR3+.</b>

Subgoal 9.1.3.2.1.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L'
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
============================
 C1 = C1
</pre>
<pre class="code extensibella"id="1960">
 &lt; <b>search.</b>

Subgoal 9.1.3.2.1.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
MKR3 : mem (To, CK) KRest3
============================
 C1 = CK
</pre>
<pre class="code extensibella"id="1961">
 &lt; <b>GCL': case GCLKR+.</b>

Subgoal 9.1.3.2.1.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
MKR3 : mem (To, CK) KRest3
GCL' : forall ID C2 KRest C3,
         select (ID, C2) KRest ((To, C1)::KRest3) -&gt; mem (ID, C3) KRest -&gt; false
============================
 C1 = CK
</pre>
<pre class="code extensibella"id="1962">
 &lt; <b>apply GCL' to _ MKR3.</b>

Subgoal 9.1.3.2.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
MKR3+ : mem (ID, CK) ((To, C1)::KRest3)
ML' : mem (ID, CN) L'
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1963">
 &lt; <b>MKR3: case MKR3+.</b>

Subgoal 9.1.3.2.2.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' CN
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
ML' : mem (To, CN) L'
============================
 CN = C1
</pre>
<pre class="code extensibella"id="1964">
 &lt; <b>GCL': case GCLL'+.</b>

Subgoal 9.1.3.2.2.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' CN
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GUL : good_used_list ((From, needed)::NRest)
ML' : mem (To, CN) L'
GCL' : forall ID C2 KRest C3,
         select (ID, C2) KRest ((To, C1)::L') -&gt; mem (ID, C3) KRest -&gt; false
============================
 CN = C1
</pre>
<pre class="code extensibella"id="1965">
 &lt; <b>apply GCL' to _ ML'.</b>

Subgoal 9.1.3.2.2.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
ML' : mem (ID, CN) L'
MKR3 : mem (ID, CK) KRest3
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1966">
 &lt; <b>MKR: apply mem_after_select_before to SN ML'.</b>

Subgoal 9.1.3.2.2.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
ML' : mem (ID, CN) L'
MKR3 : mem (ID, CK) KRest3
MKR : mem (ID, CN) KR
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1967">
 &lt; <b>MN: apply remove_all_mem_after to RA MKR.</b>

Subgoal 9.1.3.2.2.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
ML' : mem (ID, CN) L'
MKR3 : mem (ID, CK) KRest3
MKR : mem (ID, CN) KR
MN : mem (ID, CN) Needed
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1968">
 &lt; <b>MKRest: apply mem_after_select_before to Ela2 MKR3.</b>

Subgoal 9.1.3.2.2.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
ML' : mem (ID, CN) L'
MKR3 : mem (ID, CK) KRest3
MKR : mem (ID, CN) KR
MN : mem (ID, CN) Needed
MKRest : mem (ID, CK) KRest
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1969">
 &lt; <b>MK: apply remove_all_mem_after to Ela1 MKRest.</b>

Subgoal 9.1.3.2.2.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
ML' : mem (ID, CN) L'
MKR3 : mem (ID, CK) KRest3
MKR : mem (ID, CN) KR
MN : mem (ID, CN) Needed
MKRest : mem (ID, CK) KRest
MK : mem (ID, CK) Known
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1970">
 &lt; <b>HN: case HN.</b>

Subgoal 9.1.3.2.2.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
ML' : mem (ID, CN) L'
MKR3 : mem (ID, CK) KRest3
MKR : mem (ID, CN) KR
MN : mem (ID, CN) Needed
MKRest : mem (ID, CK) KRest
MK : mem (ID, CK) Known
HN : forall ID,
       mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 CN = CK
</pre>
<pre class="code extensibella"id="1971">
 &lt; <b>apply HN1 to MN MK.</b>

Subgoal 9.1.3.2.2.2:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L' ID CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
ML' : mem (ID, CK) L'
MKR3 : mem (ID, CK) KRest3
MKR : mem (ID, CK) KR
MN : mem (ID, CK) Needed
MKRest : mem (ID, CK) KRest
MK : mem (ID, CK) Known
HN : forall ID,
       mem (ID, needed) ((From, needed)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 CK = CK
</pre>
<pre class="code extensibella"id="1972">
 &lt; <b>search.</b>

Subgoal 9.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L'
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
H7 : hasNeeded ((To, C1)::KRest3) Needed1 ((To, C1)::L')
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1973">
 &lt; <b>apply IH to _ _ _ _ _ CP4 Ela3 _ with
     Needed = (To, C1)::L'.</b>

Subgoal 9.1:

Variables: Known Needed KRest Needed1 ERest To From NRest Rest C1 KRest3 KR L'
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, needed)::NRest) (relocateClause From To ERest) @
HN : hasNeeded Known ((From, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
SN : select (From, C1) L' KR
H6 : is_list (is_pair is_integer is_clause) L'
GCLL'+ : good_clause_list ((To, C1)::L')
GUL : good_used_list ((From, needed)::NRest)
H7 : hasNeeded ((To, C1)::KRest3) Needed1 ((To, C1)::L')
H8 : checkProof ((To, C1)::L') ERest
============================
 checkProof Needed (relocateClause From To ERest)
</pre>
<pre class="code extensibella"id="1974">
 &lt; <b>search.</b>

Subgoal 9.2:

Variables: Known Needed KRest C KRest2 Needed1 ERest To NRest Rest C1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause To To Rest)
Ela : elaborate Known (relocateClause To To Rest) ((To, needed)::NRest) (relocateClause To To ERest) @
HN : hasNeeded Known ((To, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (To, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer To
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : mem (To, C1) Known
CP2 : checkProof Known Rest
============================
 checkProof Needed (relocateClause To To ERest)
</pre>
<pre class="code extensibella"id="1975">
 &lt; <b>M: apply select_mem to Ela2.</b>

Subgoal 9.2:

Variables: Known Needed KRest C KRest2 Needed1 ERest To NRest Rest C1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause To To Rest)
Ela : elaborate Known (relocateClause To To Rest) ((To, needed)::NRest) (relocateClause To To ERest) @
HN : hasNeeded Known ((To, needed)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (To, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 ERest *
Ela4 : select (To, needed) NRest Needed1
Is : is_integer To
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : mem (To, C1) Known
CP2 : checkProof Known Rest
M : mem (To, C) KRest
============================
 checkProof Needed (relocateClause To To ERest)
</pre>
<pre class="code extensibella"id="1976">
 &lt; <b>apply remove_all_no_mem to Ela1 M.</b>

Subgoal 10:

Variables: Known CU E Needed Rest ID
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsP : is_proof (relocateClause ID ID Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause ID ID Rest)
Ela : elaborate Known (relocateClause ID ID Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : elaborate Known Rest CU E *
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1977">
 &lt; <b>Is: case IsP.</b>

Subgoal 10:

Variables: Known CU E Needed Rest ID
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause ID ID Rest)
Ela : elaborate Known (relocateClause ID ID Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : elaborate Known Rest CU E *
Is : is_integer ID
Is1 : is_integer ID
Is2 : is_proof Rest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1978">
 &lt; <b>CP: case CP (keep).</b>

Subgoal 10.1:

Variables: Known CU E Needed Rest ID KRest C KRest2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause ID ID Rest)
Ela : elaborate Known (relocateClause ID ID Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : elaborate Known Rest CU E *
Is : is_integer ID
Is1 : is_integer ID
Is2 : is_proof Rest
CP1 : ID = ID -&gt; false
CP2 : remove_all Known ID KRest
CP3 : select (ID, C) KRest2 KRest
CP4 : checkProof ((ID, C)::KRest2) Rest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1979">
 &lt; <b>apply CP1 to _.</b>

Subgoal 10.2:

Variables: Known CU E Needed Rest ID C
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause ID ID Rest)
Ela : elaborate Known (relocateClause ID ID Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : elaborate Known Rest CU E *
Is : is_integer ID
Is1 : is_integer ID
Is2 : is_proof Rest
CP1 : mem (ID, C) Known
CP2 : checkProof Known Rest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1980">
 &lt; <b>apply IH to _ _ _ _ _ CP2 Ela1 HN.</b>

Subgoal 10.2:

Variables: Known CU E Needed Rest ID C
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause ID ID Rest)
Ela : elaborate Known (relocateClause ID ID Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : elaborate Known Rest CU E *
Is : is_integer ID
Is1 : is_integer ID
Is2 : is_proof Rest
CP1 : mem (ID, C) Known
CP2 : checkProof Known Rest
H1 : checkProof Needed E
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1981">
 &lt; <b>search.</b>

Subgoal 11:

Variables: Known E Needed KRest C KRest2 Needed1 NRest From Rest To
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsP : is_proof (relocateClause From To Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1982">
 &lt; <b>Is: case IsP.</b>

Subgoal 11:

Variables: Known E Needed KRest C KRest2 Needed1 NRest From Rest To
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1983">
 &lt; <b>CP: case CP (keep).</b>

Subgoal 11.1:

Variables: Known E Needed KRest C KRest2 Needed1 NRest From Rest To KRest1 C1 KRest3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) Rest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1984">
 &lt; <b>apply remove_all_is to _ Ela1.</b>

Subgoal 11.1:

Variables: Known E Needed KRest C KRest2 Needed1 NRest From Rest To KRest1 C1 KRest3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest1
CP3 : select (From, C1) KRest3 KRest1
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1985">
 &lt; <b>apply remove_all_unique to CP2 Ela1.</b>

Subgoal 11.1:

Variables: Known E Needed KRest C KRest2 Needed1 NRest From Rest To C1 KRest3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1986">
 &lt; <b>apply good_clause_list_remove_all to _ CP2.</b>

Subgoal 11.1:

Variables: Known E Needed KRest C KRest2 Needed1 NRest From Rest To C1 KRest3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1987">
 &lt; <b>apply good_clause_list_selects to _ Ela2 CP3.</b>

Subgoal 11.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1988">
 &lt; <b>apply select_is to _ Ela2.</b>

Subgoal 11.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1989">
 &lt; <b>IsP: apply select_is_picked to _ Ela2.</b>

Subgoal 11.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
IsP : is_pair is_integer is_clause (From, C1)
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1990">
 &lt; <b>Is': case IsP.</b>

Subgoal 11.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="1991">
 &lt; <b>GCLKR+: assert good_clause_list ((To, C1)::KRest3).</b>

Subgoal 11.1.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
============================
 good_clause_list ((To, C1)::KRest3)
</pre>
<pre class="code extensibella"id="1992">
 &lt; <b>unfold .</b>

Subgoal 11.1.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
============================
 forall ID C2 KRest C3,
   select (ID, C2) KRest ((To, C1)::KRest3) -&gt; mem (ID, C3) KRest -&gt; false
</pre>
<pre class="code extensibella"id="1993">
 &lt; <b>intros S M.</b>

Subgoal 11.1.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 ID C2 KRest4 C3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
S : select (ID, C2) KRest4 ((To, C1)::KRest3)
M : mem (ID, C3) KRest4
============================
 false
</pre>
<pre class="code extensibella"id="1994">
 &lt; <b>S: case S.</b>

Subgoal 11.1.1.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 C3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
M : mem (To, C3) KRest3
============================
 false
</pre>
<pre class="code extensibella"id="1995">
 &lt; <b>M': apply mem_after_select_before to Ela2 M.</b>

Subgoal 11.1.1.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 C3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
M : mem (To, C3) KRest3
M' : mem (To, C3) KRest
============================
 false
</pre>
<pre class="code extensibella"id="1996">
 &lt; <b>apply remove_all_no_mem to Ela1 M'.</b>

Subgoal 11.1.1.2:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 ID C2 C3 L1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
M : mem (ID, C3) ((To, C1)::L1)
S : select (ID, C2) L1 KRest3
============================
 false
</pre>
<pre class="code extensibella"id="1997">
 &lt; <b>M: case M.</b>

Subgoal 11.1.1.2.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 C2 L1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
S : select (To, C2) L1 KRest3
============================
 false
</pre>
<pre class="code extensibella"id="1998">
 &lt; <b>M: apply select_mem to S.</b>

Subgoal 11.1.1.2.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 C2 L1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
S : select (To, C2) L1 KRest3
M : mem (To, C2) KRest3
============================
 false
</pre>
<pre class="code extensibella"id="1999">
 &lt; <b>M': apply mem_after_select_before to Ela2 M.</b>

Subgoal 11.1.1.2.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 C2 L1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
S : select (To, C2) L1 KRest3
M : mem (To, C2) KRest3
M' : mem (To, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="2000">
 &lt; <b>M'': apply remove_all_no_mem to Ela1 M'.</b>

Subgoal 11.1.1.2.2:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 ID C2 C3 L1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
S : select (ID, C2) L1 KRest3
M : mem (ID, C3) L1
============================
 false
</pre>
<pre class="code extensibella"id="2001">
 &lt; <b>apply good_clause_list_remove_all to _ Ela1.</b>

Subgoal 11.1.1.2.2:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 ID C2 C3 L1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
S : select (ID, C2) L1 KRest3
M : mem (ID, C3) L1
H4 : good_clause_list KRest
============================
 false
</pre>
<pre class="code extensibella"id="2002">
 &lt; <b>GCL': apply good_clause_list_select to _ Ela2.</b>

Subgoal 11.1.1.2.2:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 ID C2 C3 L1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
S : select (ID, C2) L1 KRest3
M : mem (ID, C3) L1
H4 : good_clause_list KRest
GCL' : good_clause_list KRest3
============================
 false
</pre>
<pre class="code extensibella"id="2003">
 &lt; <b>GCL': case GCL'.</b>

Subgoal 11.1.1.2.2:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 ID C2 C3 L1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
S : select (ID, C2) L1 KRest3
M : mem (ID, C3) L1
H4 : good_clause_list KRest
GCL' : forall ID C1 KRest C2,
         select (ID, C1) KRest KRest3 -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="2004">
 &lt; <b>apply GCL' to S M.</b>

Subgoal 11.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="2005">
 &lt; <b>RA: apply remove_all_exists to IsNeeded Is1.</b>

Subgoal 11.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="2006">
 &lt; <b>apply good_clause_list_remove_all to _ RA.</b>

Subgoal 11.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="2007">
 &lt; <b>apply remove_all_is to _ RA.</b>

Subgoal 11.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="2008">
 &lt; <b>GUL: apply elaboration_good_used_list to _ _ _ CP4 Ela3.</b>

Subgoal 11.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="2009">
 &lt; <b>HN': assert hasNeeded ((To, C1)::KRest3) Needed1 KR.</b>

Subgoal 11.1.2:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
============================
 hasNeeded ((To, C1)::KRest3) Needed1 KR
</pre>
<pre class="code extensibella"id="2010">
 &lt; <b>unfold .</b>

Subgoal 11.1.2.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
============================
 forall ID, mem (ID, needed) Needed1 -&gt; exists C, mem (ID, C) KR
</pre>
<pre class="code extensibella"id="2011">
 &lt; <b>intros MN1.</b>

Subgoal 11.1.2.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR ID
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
MN1 : mem (ID, needed) Needed1
============================
 exists C, mem (ID, C) KR
</pre>
<pre class="code extensibella"id="2012">
 &lt; <b>HN: case HN.</b>

Subgoal 11.1.2.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR ID
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
MN1 : mem (ID, needed) Needed1
HN : forall ID,
       mem (ID, needed) ((From, unknown)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 exists C, mem (ID, C) KR
</pre>
<pre class="code extensibella"id="2013">
 &lt; <b>Or: apply select_mem_or to Ela4 MN1.</b>

Subgoal 11.1.2.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR ID
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
MN1 : mem (ID, needed) Needed1
HN : forall ID,
       mem (ID, needed) ((From, unknown)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
Or : (ID, needed) = (To, unknown) \/ mem (ID, needed) NRest
============================
 exists C, mem (ID, C) KR
</pre>
<pre class="code extensibella"id="2014">
 &lt; <b>MNR: case Or.</b>

Subgoal 11.1.2.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR ID
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
MN1 : mem (ID, needed) Needed1
HN : forall ID,
       mem (ID, needed) ((From, unknown)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MNR : mem (ID, needed) NRest
============================
 exists C, mem (ID, C) KR
</pre>
<pre class="code extensibella"id="2015">
 &lt; <b>MN: apply HN to _ with
         ID = ID.</b>

Subgoal 11.1.2.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR ID C2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
MN1 : mem (ID, needed) Needed1
HN : forall ID,
       mem (ID, needed) ((From, unknown)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MNR : mem (ID, needed) NRest
MN : mem (ID, C2) Needed
============================
 exists C, mem (ID, C) KR
</pre>
<pre class="code extensibella"id="2016">
 &lt; <b>apply remove_all_still_mem to RA MN _.</b>

Subgoal 11.1.2.1.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR ID C2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
MN1 : mem (ID, needed) Needed1
HN : forall ID,
       mem (ID, needed) ((From, unknown)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MNR : mem (ID, needed) NRest
MN : mem (ID, C2) Needed
============================
 To = ID -&gt; false
</pre>
<pre class="code extensibella"id="2017">
 &lt; <b>intros E.</b>

Subgoal 11.1.2.1.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR ID C2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
MN1 : mem (ID, needed) Needed1
HN : forall ID,
       mem (ID, needed) ((From, unknown)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MNR : mem (ID, needed) NRest
MN : mem (ID, C2) Needed
E : To = ID
============================
 false
</pre>
<pre class="code extensibella"id="2018">
 &lt; <b>case E.</b>

Subgoal 11.1.2.1.1:

Variables: Known E Needed KRest Needed1 NRest From Rest C1 KRest3 KR ID C2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From ID Rest)
Ela : elaborate Known (relocateClause From ID Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known ID KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((ID, C1)::KRest3) Rest Needed1 E *
Ela4 : select (ID, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer ID
Is2 : is_proof Rest
CP1 : ID = From -&gt; false
CP2 : remove_all Known ID KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((ID, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((ID, C1)::KRest3)
RA : remove_all Needed ID KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
MN1 : mem (ID, needed) Needed1
HN : forall ID,
       mem (ID, needed) ((From, unknown)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MNR : mem (ID, needed) NRest
MN : mem (ID, C2) Needed
============================
 false
</pre>
<pre class="code extensibella"id="2019">
 &lt; <b>MN': apply mem_after_select_before to Ela4 MNR.</b>

Subgoal 11.1.2.1.1:

Variables: Known E Needed KRest Needed1 NRest From Rest C1 KRest3 KR ID C2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From ID Rest)
Ela : elaborate Known (relocateClause From ID Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known ID KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((ID, C1)::KRest3) Rest Needed1 E *
Ela4 : select (ID, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer ID
Is2 : is_proof Rest
CP1 : ID = From -&gt; false
CP2 : remove_all Known ID KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((ID, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((ID, C1)::KRest3)
RA : remove_all Needed ID KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
MN1 : mem (ID, needed) Needed1
HN : forall ID,
       mem (ID, needed) ((From, unknown)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MNR : mem (ID, needed) NRest
MN : mem (ID, C2) Needed
MN' : mem (ID, needed) Needed1
============================
 false
</pre>
<pre class="code extensibella"id="2020">
 &lt; <b>MN'': apply select_mem to Ela4.</b>

Subgoal 11.1.2.1.1:

Variables: Known E Needed KRest Needed1 NRest From Rest C1 KRest3 KR ID C2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From ID Rest)
Ela : elaborate Known (relocateClause From ID Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known ID KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((ID, C1)::KRest3) Rest Needed1 E *
Ela4 : select (ID, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer ID
Is2 : is_proof Rest
CP1 : ID = From -&gt; false
CP2 : remove_all Known ID KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((ID, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((ID, C1)::KRest3)
RA : remove_all Needed ID KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
MN1 : mem (ID, needed) Needed1
HN : forall ID,
       mem (ID, needed) ((From, unknown)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MNR : mem (ID, needed) NRest
MN : mem (ID, C2) Needed
MN' : mem (ID, needed) Needed1
MN'' : mem (ID, unknown) Needed1
============================
 false
</pre>
<pre class="code extensibella"id="2021">
 &lt; <b>apply good_used_list_mems to _ MN' MN''.</b>

Subgoal 11.1.2.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR ID C2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
MN1 : mem (ID, needed) Needed1
HN : forall ID,
       mem (ID, needed) ((From, unknown)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
MNR : mem (ID, needed) NRest
MN : mem (ID, C2) Needed
H6 : mem (ID, C2) KR
============================
 exists C, mem (ID, C) KR
</pre>
<pre class="code extensibella"id="2022">
 &lt; <b>search.</b>

Subgoal 11.1.2.2:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
============================
 forall ID CN CK, mem (ID, CN) KR -&gt; mem (ID, CK) ((To, C1)::KRest3) -&gt; CN = CK
</pre>
<pre class="code extensibella"id="2023">
 &lt; <b>intros MKR MKR3+.</b>

Subgoal 11.1.2.2:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR ID CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
MKR : mem (ID, CN) KR
MKR3+ : mem (ID, CK) ((To, C1)::KRest3)
============================
 CN = CK
</pre>
<pre class="code extensibella"id="2024">
 &lt; <b>MKR3: case MKR3+.</b>

Subgoal 11.1.2.2.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR CN
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
MKR : mem (To, CN) KR
============================
 CN = C1
</pre>
<pre class="code extensibella"id="2025">
 &lt; <b>apply remove_all_no_mem to RA MKR.</b>

Subgoal 11.1.2.2.2:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR ID CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
MKR : mem (ID, CN) KR
MKR3 : mem (ID, CK) KRest3
============================
 CN = CK
</pre>
<pre class="code extensibella"id="2026">
 &lt; <b>MKRest: apply mem_after_select_before to Ela2 MKR3.</b>

Subgoal 11.1.2.2.2:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR ID CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
MKR : mem (ID, CN) KR
MKR3 : mem (ID, CK) KRest3
MKRest : mem (ID, CK) KRest
============================
 CN = CK
</pre>
<pre class="code extensibella"id="2027">
 &lt; <b>MK: apply remove_all_mem_after to Ela1 MKRest.</b>

Subgoal 11.1.2.2.2:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR ID CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
MKR : mem (ID, CN) KR
MKR3 : mem (ID, CK) KRest3
MKRest : mem (ID, CK) KRest
MK : mem (ID, CK) Known
============================
 CN = CK
</pre>
<pre class="code extensibella"id="2028">
 &lt; <b>MN: apply remove_all_mem_after to RA MKR.</b>

Subgoal 11.1.2.2.2:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR ID CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
MKR : mem (ID, CN) KR
MKR3 : mem (ID, CK) KRest3
MKRest : mem (ID, CK) KRest
MK : mem (ID, CK) Known
MN : mem (ID, CN) Needed
============================
 CN = CK
</pre>
<pre class="code extensibella"id="2029">
 &lt; <b>HN: case HN.</b>

Subgoal 11.1.2.2.2:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR ID CN CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
MKR : mem (ID, CN) KR
MKR3 : mem (ID, CK) KRest3
MKRest : mem (ID, CK) KRest
MK : mem (ID, CK) Known
MN : mem (ID, CN) Needed
HN : forall ID,
       mem (ID, needed) ((From, unknown)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 CN = CK
</pre>
<pre class="code extensibella"id="2030">
 &lt; <b>apply HN1 to MN MK.</b>

Subgoal 11.1.2.2.2:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR ID CK
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
MKR : mem (ID, CK) KR
MKR3 : mem (ID, CK) KRest3
MKRest : mem (ID, CK) KRest
MK : mem (ID, CK) Known
MN : mem (ID, CK) Needed
HN : forall ID,
       mem (ID, needed) ((From, unknown)::NRest) -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 CK = CK
</pre>
<pre class="code extensibella"id="2031">
 &lt; <b>search.</b>

Subgoal 11.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
HN' : hasNeeded ((To, C1)::KRest3) Needed1 KR
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="2032">
 &lt; <b>CP': apply IH to _ _ _ _ _ CP4 Ela3 HN'.</b>

Subgoal 11.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
HN' : hasNeeded ((To, C1)::KRest3) Needed1 KR
CP' : checkProof KR E
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="2033">
 &lt; <b>apply elaboration_check_add to _ _ _ _ _ _ GCL_N Ela3 CP' _.</b>

Subgoal 11.1.3:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
HN' : hasNeeded ((To, C1)::KRest3) Needed1 KR
CP' : checkProof KR E
============================
 forall ID C, mem (ID, C) KR -&gt; mem (ID, C) Needed
</pre>
<pre class="code extensibella"id="2034">
 &lt; <b>intros M.</b>

Subgoal 11.1.3:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR ID C2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
HN' : hasNeeded ((To, C1)::KRest3) Needed1 KR
CP' : checkProof KR E
M : mem (ID, C2) KR
============================
 mem (ID, C2) Needed
</pre>
<pre class="code extensibella"id="2035">
 &lt; <b>apply remove_all_mem_after to RA M.</b>

Subgoal 11.1.3:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR ID C2
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
HN' : hasNeeded ((To, C1)::KRest3) Needed1 KR
CP' : checkProof KR E
M : mem (ID, C2) KR
H6 : mem (ID, C2) Needed
============================
 mem (ID, C2) Needed
</pre>
<pre class="code extensibella"id="2036">
 &lt; <b>search.</b>

Subgoal 11.1:

Variables: Known E Needed KRest Needed1 NRest From Rest To C1 KRest3 KR
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause From To Rest)
Ela : elaborate Known (relocateClause From To Rest) ((From, unknown)::NRest) E @
HN : hasNeeded Known ((From, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (From, C1) KRest3 KRest
Ela3 : elaborate ((To, C1)::KRest3) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer From
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : To = From -&gt; false
CP2 : remove_all Known To KRest
CP3 : select (From, C1) KRest3 KRest
CP4 : checkProof ((To, C1)::KRest3) Rest
H1 : is_list (is_pair is_integer is_clause) KRest
H2 : good_clause_list KRest
H3 : is_list (is_pair is_integer is_clause) KRest3
Is' : is_integer From
Is'1 : is_clause C1
GCLKR+ : good_clause_list ((To, C1)::KRest3)
RA : remove_all Needed To KR
H4 : good_clause_list KR
H5 : is_list (is_pair is_integer is_clause) KR
GUL : good_used_list Needed1
HN' : hasNeeded ((To, C1)::KRest3) Needed1 KR
CP' : checkProof KR E
H6 : checkProof Needed E
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="2037">
 &lt; <b>search.</b>

Subgoal 11.2:

Variables: Known E Needed KRest C KRest2 Needed1 NRest Rest To C1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause To To Rest)
Ela : elaborate Known (relocateClause To To Rest) ((To, unknown)::NRest) E @
HN : hasNeeded Known ((To, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (To, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer To
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : mem (To, C1) Known
CP2 : checkProof Known Rest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="2038">
 &lt; <b>M: apply select_mem to Ela2.</b>

Subgoal 11.2:

Variables: Known E Needed KRest C KRest2 Needed1 NRest Rest To C1
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (relocateClause To To Rest)
Ela : elaborate Known (relocateClause To To Rest) ((To, unknown)::NRest) E @
HN : hasNeeded Known ((To, unknown)::NRest) Needed
Ela1 : remove_all Known To KRest
Ela2 : select (To, C) KRest2 KRest
Ela3 : elaborate ((To, C)::KRest2) Rest Needed1 E *
Ela4 : select (To, unknown) NRest Needed1
Is : is_integer To
Is1 : is_integer To
Is2 : is_proof Rest
CP1 : mem (To, C1) Known
CP2 : checkProof Known Rest
M : mem (To, C) KRest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="2039">
 &lt; <b>apply remove_all_no_mem to Ela1 M.</b>

Subgoal 12:

Variables: Known CU E Needed Rest Comment
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsP : is_proof (commentProof Comment Rest)
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (commentProof Comment Rest)
Ela : elaborate Known (commentProof Comment Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : elaborate Known Rest CU E *
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="2040">
 &lt; <b>case IsP.</b>

Subgoal 12:

Variables: Known CU E Needed Rest Comment
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known (commentProof Comment Rest)
Ela : elaborate Known (commentProof Comment Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : elaborate Known Rest CU E *
H1 : is_string Comment
H2 : is_proof Rest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="2041">
 &lt; <b>CP: case CP.</b>

Subgoal 12:

Variables: Known CU E Needed Rest Comment
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
Ela : elaborate Known (commentProof Comment Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : elaborate Known Rest CU E *
H1 : is_string Comment
H2 : is_proof Rest
CP : checkProof Known Rest
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="2042">
 &lt; <b>apply IH to _ _ _ _ _ CP Ela1 HN.</b>

Subgoal 12:

Variables: Known CU E Needed Rest Comment
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
Ela : elaborate Known (commentProof Comment Rest) CU E @
HN : hasNeeded Known CU Needed
Ela1 : elaborate Known Rest CU E *
H1 : is_string Comment
H2 : is_proof Rest
CP : checkProof Known Rest
H3 : checkProof Needed E
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="2043">
 &lt; <b>search.</b>

Subgoal 13:

Variables: Known CU E Needed PT
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsP : is_proof &lt;unknown I proof&gt;
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known &lt;unknown I proof&gt;
Ela : elaborate Known &lt;unknown I proof&gt; CU E @
HN : hasNeeded Known CU Needed
Ela1 : Known |{proof}- &lt;unknown I proof&gt; ~~&gt; PT
Ela2 : elaborate Known PT CU E *
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="2044">
 &lt; <b>apply proj_proof_is to Ela1 _ _ _.</b>

Subgoal 13:

Variables: Known CU E Needed PT
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsP : is_proof &lt;unknown I proof&gt;
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known &lt;unknown I proof&gt;
Ela : elaborate Known &lt;unknown I proof&gt; CU E @
HN : hasNeeded Known CU Needed
Ela1 : Known |{proof}- &lt;unknown I proof&gt; ~~&gt; PT
Ela2 : elaborate Known PT CU E *
H1 : is_proof PT
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="2045">
 &lt; <b>CP': apply proj_checkProof to Ela1 CP _ _.</b>

Subgoal 13:

Variables: Known CU E Needed PT
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsP : is_proof &lt;unknown I proof&gt;
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known &lt;unknown I proof&gt;
Ela : elaborate Known &lt;unknown I proof&gt; CU E @
HN : hasNeeded Known CU Needed
Ela1 : Known |{proof}- &lt;unknown I proof&gt; ~~&gt; PT
Ela2 : elaborate Known PT CU E *
H1 : is_proof PT
CP' : checkProof Known PT
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="2046">
 &lt; <b>apply IH to _ _ _ _ _ CP' Ela2 HN.</b>

Subgoal 13:

Variables: Known CU E Needed PT
IH : forall Known P CU E Needed,
       is_proof P -&gt; is_list (is_pair is_integer is_clause) Known -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Known -&gt; good_clause_list Needed -&gt; checkProof Known P -&gt;
       elaborate Known P CU E * -&gt; hasNeeded Known CU Needed -&gt; checkProof Needed E
IsP : is_proof &lt;unknown I proof&gt;
IsKnown : is_list (is_pair is_integer is_clause) Known
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_N : good_clause_list Needed
CP : checkProof Known &lt;unknown I proof&gt;
Ela : elaborate Known &lt;unknown I proof&gt; CU E @
HN : hasNeeded Known CU Needed
Ela1 : Known |{proof}- &lt;unknown I proof&gt; ~~&gt; PT
Ela2 : elaborate Known PT CU E *
H1 : is_proof PT
CP' : checkProof Known PT
H2 : checkProof Needed E
============================
 checkProof Needed E
</pre>
<pre class="code extensibella"id="2047">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="2048">
 &lt; <b>Theorem full_elaboration_valid :
     forall F P P',
       is_formula F -&gt; is_proof P -&gt; proveFormula F P -&gt; fullElaborate F P P' -&gt;
       proveFormula F P'.</b>

============================
 forall F P P',
   is_formula F -&gt; is_proof P -&gt; proveFormula F P -&gt; fullElaborate F P P' -&gt; proveFormula F P'
</pre>
<pre class="code extensibella"id="2049">
 &lt; <b>intros IsF IsP PF FE.</b>

Variables: F P P'
IsF : is_formula F
IsP : is_proof P
PF : proveFormula F P
FE : fullElaborate F P P'
============================
 proveFormula F P'
</pre>
<pre class="code extensibella"id="2050">
 &lt; <b>PF: case PF.</b>

Variables: F P P' KnownClauses
IsF : is_formula F
IsP : is_proof P
FE : fullElaborate F P P'
PF : formulaToKnown 1 F KnownClauses
PF1 : checkProof KnownClauses P
============================
 proveFormula F P'
</pre>
<pre class="code extensibella"id="2051">
 &lt; <b>FE: case FE.</b>

Variables: F P P' KnownClauses Known Needed
IsF : is_formula F
IsP : is_proof P
PF : formulaToKnown 1 F KnownClauses
PF1 : checkProof KnownClauses P
FE : formulaToKnown 1 F Known
FE1 : elaborate Known P Needed P'
============================
 proveFormula F P'
</pre>
<pre class="code extensibella"id="2052">
 &lt; <b>apply formulaToKnown_is to _ _ PF.</b>

Variables: F P P' KnownClauses Known Needed
IsF : is_formula F
IsP : is_proof P
PF : formulaToKnown 1 F KnownClauses
PF1 : checkProof KnownClauses P
FE : formulaToKnown 1 F Known
FE1 : elaborate Known P Needed P'
H1 : is_list (is_pair is_integer is_clause) KnownClauses
============================
 proveFormula F P'
</pre>
<pre class="code extensibella"id="2053">
 &lt; <b>GCL: assert good_clause_list KnownClauses.</b>

Subgoal 1:

Variables: F P P' KnownClauses Known Needed
IsF : is_formula F
IsP : is_proof P
PF : formulaToKnown 1 F KnownClauses
PF1 : checkProof KnownClauses P
FE : formulaToKnown 1 F Known
FE1 : elaborate Known P Needed P'
H1 : is_list (is_pair is_integer is_clause) KnownClauses
============================
 good_clause_list KnownClauses
</pre>
<pre class="code extensibella"id="2054">
 &lt; <b>unfold .</b>

Subgoal 1:

Variables: F P P' KnownClauses Known Needed
IsF : is_formula F
IsP : is_proof P
PF : formulaToKnown 1 F KnownClauses
PF1 : checkProof KnownClauses P
FE : formulaToKnown 1 F Known
FE1 : elaborate Known P Needed P'
H1 : is_list (is_pair is_integer is_clause) KnownClauses
============================
 forall ID C1 KRest C2,
   select (ID, C1) KRest KnownClauses -&gt; mem (ID, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="2055">
 &lt; <b>intros S M.</b>

Subgoal 1:

Variables: F P P' KnownClauses Known Needed ID C1 KRest C2
IsF : is_formula F
IsP : is_proof P
PF : formulaToKnown 1 F KnownClauses
PF1 : checkProof KnownClauses P
FE : formulaToKnown 1 F Known
FE1 : elaborate Known P Needed P'
H1 : is_list (is_pair is_integer is_clause) KnownClauses
S : select (ID, C1) KRest KnownClauses
M : mem (ID, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="2056">
 &lt; <b>backchain formulaToKnown_all_unique.</b>

Variables: F P P' KnownClauses Known Needed
IsF : is_formula F
IsP : is_proof P
PF : formulaToKnown 1 F KnownClauses
PF1 : checkProof KnownClauses P
FE : formulaToKnown 1 F Known
FE1 : elaborate Known P Needed P'
H1 : is_list (is_pair is_integer is_clause) KnownClauses
GCL : good_clause_list KnownClauses
============================
 proveFormula F P'
</pre>
<pre class="code extensibella"id="2057">
 &lt; <b>apply formulaToKnown_unique to _ _ PF FE.</b>

Variables: F P P' Known Needed
IsF : is_formula F
IsP : is_proof P
PF : formulaToKnown 1 F Known
PF1 : checkProof Known P
FE : formulaToKnown 1 F Known
FE1 : elaborate Known P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
============================
 proveFormula F P'
</pre>
<pre class="code extensibella"id="2058">
 &lt; <b>HN: assert hasNeeded Known Needed Known.</b>

Subgoal 2:

Variables: F P P' Known Needed
IsF : is_formula F
IsP : is_proof P
PF : formulaToKnown 1 F Known
PF1 : checkProof Known P
FE : formulaToKnown 1 F Known
FE1 : elaborate Known P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
============================
 hasNeeded Known Needed Known
</pre>
<pre class="code extensibella"id="2059">
 &lt; <b>unfold .</b>

Subgoal 2.1:

Variables: F P P' Known Needed
IsF : is_formula F
IsP : is_proof P
PF : formulaToKnown 1 F Known
PF1 : checkProof Known P
FE : formulaToKnown 1 F Known
FE1 : elaborate Known P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
============================
 forall ID, mem (ID, needed) Needed -&gt; exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2060">
 &lt; <b>intros M.</b>

Subgoal 2.1:

Variables: F P P' Known Needed ID
IsF : is_formula F
IsP : is_proof P
PF : formulaToKnown 1 F Known
PF1 : checkProof Known P
FE : formulaToKnown 1 F Known
FE1 : elaborate Known P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
M : mem (ID, needed) Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2061">
 &lt; <b>apply elaboration_all_mem to _ _ _ PF1 FE1 M.</b>

Subgoal 2.1:

Variables: F P P' Known Needed ID C
IsF : is_formula F
IsP : is_proof P
PF : formulaToKnown 1 F Known
PF1 : checkProof Known P
FE : formulaToKnown 1 F Known
FE1 : elaborate Known P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
M : mem (ID, needed) Needed
H2 : mem (ID, C) Known
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2062">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: F P P' Known Needed
IsF : is_formula F
IsP : is_proof P
PF : formulaToKnown 1 F Known
PF1 : checkProof Known P
FE : formulaToKnown 1 F Known
FE1 : elaborate Known P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
============================
 forall ID CN CK, mem (ID, CN) Known -&gt; mem (ID, CK) Known -&gt; CN = CK
</pre>
<pre class="code extensibella"id="2063">
 &lt; <b>intros M M'.</b>

Subgoal 2.2:

Variables: F P P' Known Needed ID CN CK
IsF : is_formula F
IsP : is_proof P
PF : formulaToKnown 1 F Known
PF1 : checkProof Known P
FE : formulaToKnown 1 F Known
FE1 : elaborate Known P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
M : mem (ID, CN) Known
M' : mem (ID, CK) Known
============================
 CN = CK
</pre>
<pre class="code extensibella"id="2064">
 &lt; <b>apply good_clause_list_mems to _ M M'.</b>

Subgoal 2.2:

Variables: F P P' Known Needed ID CK
IsF : is_formula F
IsP : is_proof P
PF : formulaToKnown 1 F Known
PF1 : checkProof Known P
FE : formulaToKnown 1 F Known
FE1 : elaborate Known P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
M : mem (ID, CK) Known
M' : mem (ID, CK) Known
============================
 CK = CK
</pre>
<pre class="code extensibella"id="2065">
 &lt; <b>search.</b>

Variables: F P P' Known Needed
IsF : is_formula F
IsP : is_proof P
PF : formulaToKnown 1 F Known
PF1 : checkProof Known P
FE : formulaToKnown 1 F Known
FE1 : elaborate Known P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
HN : hasNeeded Known Needed Known
============================
 proveFormula F P'
</pre>
<pre class="code extensibella"id="2066">
 &lt; <b>apply elaboration_valid to _ _ _ _ _ PF1 FE1 HN.</b>

Variables: F P P' Known Needed
IsF : is_formula F
IsP : is_proof P
PF : formulaToKnown 1 F Known
PF1 : checkProof Known P
FE : formulaToKnown 1 F Known
FE1 : elaborate Known P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
HN : hasNeeded Known Needed Known
H2 : checkProof Known P'
============================
 proveFormula F P'
</pre>
<pre class="code extensibella"id="2067">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="2068">
 &lt; <b>Extensible_Theorem
      elaborationFrat_all_mem : forall Clauses Known P CU E ID U,
         IsP : is_fratProof P -&gt;
         GCL : good_clause_list Known -&gt;
         IsKnown : is_list (is_pair is_integer is_clause) Known -&gt;
         GCLC : good_clause_list Clauses -&gt;
         IsClauses : is_list (is_pair is_integer is_clause) Clauses -&gt;
         CP : checkFratProof Clauses Known P -&gt;
         Ela : elaborateFratProof Clauses Known P CU E -&gt;
         NoMem : (forall ID CK CC,
           mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
         Mem : mem (ID, U) CU -&gt;
         exists C,
           mem (ID, C) Known
      on Ela,
      elaborationFrat_good_used_list : forall Clauses Known P CU E,
         IsP : is_fratProof P -&gt;
         GCL : good_clause_list Known -&gt;
         IsKnown : is_list (is_pair is_integer is_clause) Known -&gt;
         GCLC : good_clause_list Clauses -&gt;
         IsClauses : is_list (is_pair is_integer is_clause) Clauses -&gt;
         CP : checkFratProof Clauses Known P -&gt;
         Ela : elaborateFratProof Clauses Known P CU E -&gt;
         NoMem : (forall ID CK CC,
           mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
         good_used_list CU
      on Ela.</b>

Subgoal 1.1:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
IsP : is_fratProof (addOriginal ID1 C Rest)
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
CP : checkFratProof Clauses Known (addOriginal ID1 C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2069">
 &lt; <b>Is: case IsP.</b>

Subgoal 1.1:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
CP : checkFratProof Clauses Known (addOriginal ID1 C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2070">
 &lt; <b>CP: case CP.</b>

Subgoal 1.1:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest CRest1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest1 Clauses
CP1 : checkFratProof CRest1 ((ID1, C)::Known) Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2071">
 &lt; <b>apply select_is to _ Ela1.</b>

Subgoal 1.1:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest CRest1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest1 Clauses
CP1 : checkFratProof CRest1 ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2072">
 &lt; <b>Is': apply select_is_picked to _ Ela1.</b>

Subgoal 1.1:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest CRest1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest1 Clauses
CP1 : checkFratProof CRest1 ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
Is' : is_pair is_integer is_clause (ID1, C)
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2073">
 &lt; <b>case Is'.</b>

Subgoal 1.1:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest CRest1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest1 Clauses
CP1 : checkFratProof CRest1 ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2074">
 &lt; <b>apply good_clause_list_select to _ Ela1.</b>

Subgoal 1.1:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest CRest1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest1 Clauses
CP1 : checkFratProof CRest1 ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2075">
 &lt; <b>apply good_clause_list_selects to _ CP Ela1.</b>

Subgoal 1.1:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2076">
 &lt; <b>assert good_clause_list ((ID1, C)::Known).</b>

Subgoal 1.1.1:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
============================
 good_clause_list ((ID1, C)::Known)
</pre>
<pre class="code extensibella"id="2077">
 &lt; <b>unfold .</b>

Subgoal 1.1.1:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
============================
 forall ID C1 KRest C2,
   select (ID, C1) KRest ((ID1, C)::Known) -&gt; mem (ID, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="2078">
 &lt; <b>intros S M'.</b>

Subgoal 1.1.1:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest ID2 C1 KRest C2
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
S : select (ID2, C1) KRest ((ID1, C)::Known)
M' : mem (ID2, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="2079">
 &lt; <b>S: case S.</b>

Subgoal 1.1.1.1:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest C2
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
M' : mem (ID1, C2) Known
============================
 false
</pre>
<pre class="code extensibella"id="2080">
 &lt; <b>M'': apply select_mem to Ela1.</b>

Subgoal 1.1.1.1:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest C2
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
M' : mem (ID1, C2) Known
M'' : mem (ID1, C) Clauses
============================
 false
</pre>
<pre class="code extensibella"id="2081">
 &lt; <b>apply NoMem to M' M''.</b>

Subgoal 1.1.1.2:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest ID2 C1 C2 L1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
M' : mem (ID2, C2) ((ID1, C)::L1)
S : select (ID2, C1) L1 Known
============================
 false
</pre>
<pre class="code extensibella"id="2082">
 &lt; <b>M': case M'.</b>

Subgoal 1.1.1.2.1:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest C1 L1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
S : select (ID1, C1) L1 Known
============================
 false
</pre>
<pre class="code extensibella"id="2083">
 &lt; <b>MS: apply select_mem to S.</b>

Subgoal 1.1.1.2.1:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest C1 L1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
S : select (ID1, C1) L1 Known
MS : mem (ID1, C1) Known
============================
 false
</pre>
<pre class="code extensibella"id="2084">
 &lt; <b>M'': apply select_mem to Ela1.</b>

Subgoal 1.1.1.2.1:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest C1 L1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
S : select (ID1, C1) L1 Known
MS : mem (ID1, C1) Known
M'' : mem (ID1, C) Clauses
============================
 false
</pre>
<pre class="code extensibella"id="2085">
 &lt; <b>apply NoMem to MS M''.</b>

Subgoal 1.1.1.2.2:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest ID2 C1 C2 L1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
S : select (ID2, C1) L1 Known
M' : mem (ID2, C2) L1
============================
 false
</pre>
<pre class="code extensibella"id="2086">
 &lt; <b>GCL: case GCL.</b>

Subgoal 1.1.1.2.2:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest ID2 C1 C2 L1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
S : select (ID2, C1) L1 Known
M' : mem (ID2, C2) L1
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest Known -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="2087">
 &lt; <b>apply GCL to S M'.</b>

Subgoal 1.1:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2088">
 &lt; <b>assert forall ID CK CC,
     mem (ID, CK) ((ID1, C)::Known) -&gt; mem (ID, CC) CRest -&gt; false.</b>

Subgoal 1.1.2:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
============================
 forall ID CK CC, mem (ID, CK) ((ID1, C)::Known) -&gt; mem (ID, CC) CRest -&gt; false
</pre>
<pre class="code extensibella"id="2089">
 &lt; <b>intros MK+ MCR.</b>

Subgoal 1.1.2:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest ID2 CK CC
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
MK+ : mem (ID2, CK) ((ID1, C)::Known)
MCR : mem (ID2, CC) CRest
============================
 false
</pre>
<pre class="code extensibella"id="2090">
 &lt; <b>MK: case MK+.</b>

Subgoal 1.1.2.1:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest CC
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
MCR : mem (ID1, CC) CRest
============================
 false
</pre>
<pre class="code extensibella"id="2091">
 &lt; <b>GCLC: case GCLC.</b>

Subgoal 1.1.2.1:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest CC
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
MCR : mem (ID1, CC) CRest
GCLC : forall ID C1 KRest C2,
         select (ID, C1) KRest Clauses -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="2092">
 &lt; <b>apply GCLC to Ela1 MCR.</b>

Subgoal 1.1.2.2:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest ID2 CK CC
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
MCR : mem (ID2, CC) CRest
MK : mem (ID2, CK) Known
============================
 false
</pre>
<pre class="code extensibella"id="2093">
 &lt; <b>MC: apply mem_after_select_before to Ela1 MCR.</b>

Subgoal 1.1.2.2:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest ID2 CK CC
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
MCR : mem (ID2, CC) CRest
MK : mem (ID2, CK) Known
MC : mem (ID2, CC) Clauses
============================
 false
</pre>
<pre class="code extensibella"id="2094">
 &lt; <b>apply NoMem to MK MC.</b>

Subgoal 1.1:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
H6 : forall ID CK CC,
       mem (ID, CK) ((ID1, C)::Known) -&gt; mem (ID, CC) CRest -&gt; false
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2095">
 &lt; <b>GUL: apply IH1 to _ _ _ _ _ CP1 Ela2 _.</b>

Subgoal 1.1:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
H6 : forall ID CK CC,
       mem (ID, CK) ((ID1, C)::Known) -&gt; mem (ID, CC) CRest -&gt; false
GUL : good_used_list Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2096">
 &lt; <b>MN: apply mem_after_select_before to Ela3 Mem.</b>

Subgoal 1.1:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
H6 : forall ID CK CC,
       mem (ID, CK) ((ID1, C)::Known) -&gt; mem (ID, CC) CRest -&gt; false
GUL : good_used_list Needed
MN : mem (ID, U) Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2097">
 &lt; <b>MK+: apply IH to _ _ _ _ _ CP1 Ela2 _ MN.</b>

Subgoal 1.1:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest C1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
H6 : forall ID CK CC,
       mem (ID, CK) ((ID1, C)::Known) -&gt; mem (ID, CC) CRest -&gt; false
GUL : good_used_list Needed
MN : mem (ID, U) Needed
MK+ : mem (ID, C1) ((ID1, C)::Known)
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2098">
 &lt; <b>MK: case MK+.</b>

Subgoal 1.1.3:

Variables: Clauses Known CU U CRest Needed E1 C ID1 Rest
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID1, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
H6 : forall ID CK CC,
       mem (ID, CK) ((ID1, C)::Known) -&gt; mem (ID, CC) CRest -&gt; false
GUL : good_used_list Needed
MN : mem (ID1, U) Needed
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="2099">
 &lt; <b>GUL: case GUL.</b>

Subgoal 1.1.3:

Variables: Clauses Known CU U CRest Needed E1 C ID1 Rest
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID1, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
H6 : forall ID CK CC,
       mem (ID, CK) ((ID1, C)::Known) -&gt; mem (ID, CC) CRest -&gt; false
MN : mem (ID1, U) Needed
GUL : forall ID U1 CURest U2,
        select (ID, U1) CURest Needed -&gt; mem (ID, U2) CURest -&gt; false
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="2100">
 &lt; <b>apply GUL to Ela3 Mem.</b>

Subgoal 1.1.4:

Variables: Clauses Known CU ID U CRest Needed E1 C ID1 Rest C1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU (addOriginal ID1 C E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E1 *
Ela3 : select (ID1, needed) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
H6 : forall ID CK CC,
       mem (ID, CK) ((ID1, C)::Known) -&gt; mem (ID, CC) CRest -&gt; false
GUL : good_used_list Needed
MN : mem (ID, U) Needed
MK : mem (ID, C1) Known
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2101">
 &lt; <b>search.</b>

Subgoal 1.2:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
IsP : is_fratProof (addOriginal ID1 C Rest)
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
CP : checkFratProof Clauses Known (addOriginal ID1 C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2102">
 &lt; <b>Is: case IsP.</b>

Subgoal 1.2:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
CP : checkFratProof Clauses Known (addOriginal ID1 C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2103">
 &lt; <b>CP: case CP.</b>

Subgoal 1.2:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1 CRest1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest1 Clauses
CP1 : checkFratProof CRest1 ((ID1, C)::Known) Rest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2104">
 &lt; <b>apply select_is to _ Ela1.</b>

Subgoal 1.2:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1 CRest1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest1 Clauses
CP1 : checkFratProof CRest1 ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2105">
 &lt; <b>Is': apply select_is_picked to _ Ela1.</b>

Subgoal 1.2:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1 CRest1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest1 Clauses
CP1 : checkFratProof CRest1 ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
Is' : is_pair is_integer is_clause (ID1, C)
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2106">
 &lt; <b>case Is'.</b>

Subgoal 1.2:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1 CRest1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest1 Clauses
CP1 : checkFratProof CRest1 ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2107">
 &lt; <b>apply good_clause_list_select to _ Ela1.</b>

Subgoal 1.2:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1 CRest1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest1 Clauses
CP1 : checkFratProof CRest1 ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2108">
 &lt; <b>apply good_clause_list_selects to _ CP Ela1.</b>

Subgoal 1.2:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2109">
 &lt; <b>assert good_clause_list ((ID1, C)::Known).</b>

Subgoal 1.2.1:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
============================
 good_clause_list ((ID1, C)::Known)
</pre>
<pre class="code extensibella"id="2110">
 &lt; <b>unfold .</b>

Subgoal 1.2.1:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
============================
 forall ID C1 KRest C2,
   select (ID, C1) KRest ((ID1, C)::Known) -&gt; mem (ID, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="2111">
 &lt; <b>intros S M'.</b>

Subgoal 1.2.1:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1 ID2 C1 KRest C2
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
S : select (ID2, C1) KRest ((ID1, C)::Known)
M' : mem (ID2, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="2112">
 &lt; <b>S: case S.</b>

Subgoal 1.2.1.1:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1 C2
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
M' : mem (ID1, C2) Known
============================
 false
</pre>
<pre class="code extensibella"id="2113">
 &lt; <b>M'': apply select_mem to Ela1.</b>

Subgoal 1.2.1.1:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1 C2
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
M' : mem (ID1, C2) Known
M'' : mem (ID1, C) Clauses
============================
 false
</pre>
<pre class="code extensibella"id="2114">
 &lt; <b>apply NoMem to M' M''.</b>

Subgoal 1.2.1.2:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1 ID2 C1 C2 L1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
M' : mem (ID2, C2) ((ID1, C)::L1)
S : select (ID2, C1) L1 Known
============================
 false
</pre>
<pre class="code extensibella"id="2115">
 &lt; <b>M': case M'.</b>

Subgoal 1.2.1.2.1:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1 C1 L1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
S : select (ID1, C1) L1 Known
============================
 false
</pre>
<pre class="code extensibella"id="2116">
 &lt; <b>MS: apply select_mem to S.</b>

Subgoal 1.2.1.2.1:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1 C1 L1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
S : select (ID1, C1) L1 Known
MS : mem (ID1, C1) Known
============================
 false
</pre>
<pre class="code extensibella"id="2117">
 &lt; <b>M'': apply select_mem to Ela1.</b>

Subgoal 1.2.1.2.1:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1 C1 L1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
S : select (ID1, C1) L1 Known
MS : mem (ID1, C1) Known
M'' : mem (ID1, C) Clauses
============================
 false
</pre>
<pre class="code extensibella"id="2118">
 &lt; <b>apply NoMem to MS M''.</b>

Subgoal 1.2.1.2.2:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1 ID2 C1 C2 L1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
S : select (ID2, C1) L1 Known
M' : mem (ID2, C2) L1
============================
 false
</pre>
<pre class="code extensibella"id="2119">
 &lt; <b>GCL: case GCL.</b>

Subgoal 1.2.1.2.2:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1 ID2 C1 C2 L1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
S : select (ID2, C1) L1 Known
M' : mem (ID2, C2) L1
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest Known -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="2120">
 &lt; <b>apply GCL to S M'.</b>

Subgoal 1.2:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2121">
 &lt; <b>assert forall ID CK CC,
     mem (ID, CK) ((ID1, C)::Known) -&gt; mem (ID, CC) CRest -&gt; false.</b>

Subgoal 1.2.2:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
============================
 forall ID CK CC, mem (ID, CK) ((ID1, C)::Known) -&gt; mem (ID, CC) CRest -&gt; false
</pre>
<pre class="code extensibella"id="2122">
 &lt; <b>intros MK+ MCR.</b>

Subgoal 1.2.2:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1 ID2 CK CC
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
MK+ : mem (ID2, CK) ((ID1, C)::Known)
MCR : mem (ID2, CC) CRest
============================
 false
</pre>
<pre class="code extensibella"id="2123">
 &lt; <b>MK: case MK+.</b>

Subgoal 1.2.2.1:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1 CC
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
MCR : mem (ID1, CC) CRest
============================
 false
</pre>
<pre class="code extensibella"id="2124">
 &lt; <b>GCLC: case GCLC.</b>

Subgoal 1.2.2.1:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1 CC
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
MCR : mem (ID1, CC) CRest
GCLC : forall ID C1 KRest C2,
         select (ID, C1) KRest Clauses -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="2125">
 &lt; <b>apply GCLC to Ela1 MCR.</b>

Subgoal 1.2.2.2:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1 ID2 CK CC
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
MCR : mem (ID2, CC) CRest
MK : mem (ID2, CK) Known
============================
 false
</pre>
<pre class="code extensibella"id="2126">
 &lt; <b>MC: apply mem_after_select_before to Ela1 MCR.</b>

Subgoal 1.2.2.2:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1 ID2 CK CC
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
MCR : mem (ID2, CC) CRest
MK : mem (ID2, CK) Known
MC : mem (ID2, CC) Clauses
============================
 false
</pre>
<pre class="code extensibella"id="2127">
 &lt; <b>apply NoMem to MK MC.</b>

Subgoal 1.2:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
H6 : forall ID CK CC,
       mem (ID, CK) ((ID1, C)::Known) -&gt; mem (ID, CC) CRest -&gt; false
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2128">
 &lt; <b>GUL: apply IH1 to _ _ _ _ _ CP1 Ela2 _.</b>

Subgoal 1.2:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
H6 : forall ID CK CC,
       mem (ID, CK) ((ID1, C)::Known) -&gt; mem (ID, CC) CRest -&gt; false
GUL : good_used_list Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2129">
 &lt; <b>MN: apply mem_after_select_before to Ela3 Mem.</b>

Subgoal 1.2:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
H6 : forall ID CK CC,
       mem (ID, CK) ((ID1, C)::Known) -&gt; mem (ID, CC) CRest -&gt; false
GUL : good_used_list Needed
MN : mem (ID, U) Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2130">
 &lt; <b>MK+: apply IH to _ _ _ _ _ CP1 Ela2 _ MN.</b>

Subgoal 1.2:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1 C1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
H6 : forall ID CK CC,
       mem (ID, CK) ((ID1, C)::Known) -&gt; mem (ID, CC) CRest -&gt; false
GUL : good_used_list Needed
MN : mem (ID, U) Needed
MK+ : mem (ID, C1) ((ID1, C)::Known)
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2131">
 &lt; <b>MK: case MK+.</b>

Subgoal 1.2.3:

Variables: Clauses Known CU E U CRest Needed Rest C ID1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID1, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
H6 : forall ID CK CC,
       mem (ID, CK) ((ID1, C)::Known) -&gt; mem (ID, CC) CRest -&gt; false
GUL : good_used_list Needed
MN : mem (ID1, U) Needed
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="2132">
 &lt; <b>GUL: case GUL.</b>

Subgoal 1.2.3:

Variables: Clauses Known CU E U CRest Needed Rest C ID1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID1, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
H6 : forall ID CK CC,
       mem (ID, CK) ((ID1, C)::Known) -&gt; mem (ID, CC) CRest -&gt; false
MN : mem (ID1, U) Needed
GUL : forall ID U1 CURest U2,
        select (ID, U1) CURest Needed -&gt; mem (ID, U2) CURest -&gt; false
============================
 exists C, mem (ID1, C) Known
</pre>
<pre class="code extensibella"id="2133">
 &lt; <b>apply GUL to Ela3 Mem.</b>

Subgoal 1.2.4:

Variables: Clauses Known CU E ID U CRest Needed Rest C ID1 C1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID1 C Rest) CU E @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : select (ID1, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID1, C)::Known) Rest Needed E *
Ela3 : select (ID1, unknown) CU Needed
Is : is_integer ID1
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID1, C) CRest Clauses
CP1 : checkFratProof CRest ((ID1, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID1
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID1, C)::Known)
H6 : forall ID CK CC,
       mem (ID, CK) ((ID1, C)::Known) -&gt; mem (ID, CC) CRest -&gt; false
GUL : good_used_list Needed
MN : mem (ID, U) Needed
MK : mem (ID, C1) Known
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2134">
 &lt; <b>search.</b>

Subgoal 1.3:

Variables: Clauses Known CU ID U E1 P1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
IsP : is_fratProof (endOriginal P1)
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
CP : checkFratProof Clauses Known (endOriginal P1)
Ela : elaborateFratProof Clauses Known (endOriginal P1) CU (endOriginal E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : elaborate Known P1 CU E1
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2135">
 &lt; <b>Is: case IsP.</b>

Subgoal 1.3:

Variables: Clauses Known CU ID U E1 P1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
CP : checkFratProof Clauses Known (endOriginal P1)
Ela : elaborateFratProof Clauses Known (endOriginal P1) CU (endOriginal E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : elaborate Known P1 CU E1
Is : is_proof P1
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2136">
 &lt; <b>CP: case CP.</b>

Subgoal 1.3:

Variables: Clauses Known CU ID U E1 P1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (endOriginal P1) CU (endOriginal E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : elaborate Known P1 CU E1
Is : is_proof P1
CP : checkProof Known P1
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2137">
 &lt; <b>apply elaboration_all_mem to _ _ _ CP Ela1 Mem.</b>

Subgoal 1.3:

Variables: Clauses Known CU ID U E1 P1 C
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (endOriginal P1) CU (endOriginal E1) @
NoMem : forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false
Mem : mem (ID, U) CU
Ela1 : elaborate Known P1 CU E1
Is : is_proof P1
CP : checkProof Known P1
H1 : mem (ID, C) Known
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2138">
 &lt; <b>search.</b>

Subgoal 2.1:

Variables: Clauses Known CU CRest Needed E1 C ID Rest
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
IsP : is_fratProof (addOriginal ID C Rest)
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2139">
 &lt; <b>Is: case IsP.</b>

Subgoal 2.1:

Variables: Clauses Known CU CRest Needed E1 C ID Rest
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2140">
 &lt; <b>CP: case CP.</b>

Subgoal 2.1:

Variables: Clauses Known CU CRest Needed E1 C ID Rest CRest1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest1 Clauses
CP1 : checkFratProof CRest1 ((ID, C)::Known) Rest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2141">
 &lt; <b>apply select_is to _ Ela1.</b>

Subgoal 2.1:

Variables: Clauses Known CU CRest Needed E1 C ID Rest CRest1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest1 Clauses
CP1 : checkFratProof CRest1 ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2142">
 &lt; <b>Is': apply select_is_picked to _ Ela1.</b>

Subgoal 2.1:

Variables: Clauses Known CU CRest Needed E1 C ID Rest CRest1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest1 Clauses
CP1 : checkFratProof CRest1 ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
Is' : is_pair is_integer is_clause (ID, C)
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2143">
 &lt; <b>case Is'.</b>

Subgoal 2.1:

Variables: Clauses Known CU CRest Needed E1 C ID Rest CRest1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest1 Clauses
CP1 : checkFratProof CRest1 ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2144">
 &lt; <b>apply good_clause_list_select to _ Ela1.</b>

Subgoal 2.1:

Variables: Clauses Known CU CRest Needed E1 C ID Rest CRest1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest1 Clauses
CP1 : checkFratProof CRest1 ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2145">
 &lt; <b>apply good_clause_list_selects to _ CP Ela1.</b>

Subgoal 2.1:

Variables: Clauses Known CU CRest Needed E1 C ID Rest
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2146">
 &lt; <b>assert good_clause_list ((ID, C)::Known).</b>

Subgoal 2.1.1:

Variables: Clauses Known CU CRest Needed E1 C ID Rest
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
============================
 good_clause_list ((ID, C)::Known)
</pre>
<pre class="code extensibella"id="2147">
 &lt; <b>unfold .</b>

Subgoal 2.1.1:

Variables: Clauses Known CU CRest Needed E1 C ID Rest
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
============================
 forall ID1 C1 KRest C2,
   select (ID1, C1) KRest ((ID, C)::Known) -&gt; mem (ID1, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="2148">
 &lt; <b>intros S M.</b>

Subgoal 2.1.1:

Variables: Clauses Known CU CRest Needed E1 C ID Rest ID1 C1 KRest C2
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
S : select (ID1, C1) KRest ((ID, C)::Known)
M : mem (ID1, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="2149">
 &lt; <b>S: case S.</b>

Subgoal 2.1.1.1:

Variables: Clauses Known CU CRest Needed E1 C ID Rest C2
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
M : mem (ID, C2) Known
============================
 false
</pre>
<pre class="code extensibella"id="2150">
 &lt; <b>M': apply select_mem to Ela1.</b>

Subgoal 2.1.1.1:

Variables: Clauses Known CU CRest Needed E1 C ID Rest C2
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
M : mem (ID, C2) Known
M' : mem (ID, C) Clauses
============================
 false
</pre>
<pre class="code extensibella"id="2151">
 &lt; <b>apply NoMem to M M'.</b>

Subgoal 2.1.1.2:

Variables: Clauses Known CU CRest Needed E1 C ID Rest ID1 C1 C2 L1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
M : mem (ID1, C2) ((ID, C)::L1)
S : select (ID1, C1) L1 Known
============================
 false
</pre>
<pre class="code extensibella"id="2152">
 &lt; <b>M: case M.</b>

Subgoal 2.1.1.2.1:

Variables: Clauses Known CU CRest Needed E1 C ID Rest C1 L1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
S : select (ID, C1) L1 Known
============================
 false
</pre>
<pre class="code extensibella"id="2153">
 &lt; <b>MS: apply select_mem to S.</b>

Subgoal 2.1.1.2.1:

Variables: Clauses Known CU CRest Needed E1 C ID Rest C1 L1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
S : select (ID, C1) L1 Known
MS : mem (ID, C1) Known
============================
 false
</pre>
<pre class="code extensibella"id="2154">
 &lt; <b>M': apply select_mem to Ela1.</b>

Subgoal 2.1.1.2.1:

Variables: Clauses Known CU CRest Needed E1 C ID Rest C1 L1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
S : select (ID, C1) L1 Known
MS : mem (ID, C1) Known
M' : mem (ID, C) Clauses
============================
 false
</pre>
<pre class="code extensibella"id="2155">
 &lt; <b>apply NoMem to MS M'.</b>

Subgoal 2.1.1.2.2:

Variables: Clauses Known CU CRest Needed E1 C ID Rest ID1 C1 C2 L1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
S : select (ID1, C1) L1 Known
M : mem (ID1, C2) L1
============================
 false
</pre>
<pre class="code extensibella"id="2156">
 &lt; <b>GCL: case GCL.</b>

Subgoal 2.1.1.2.2:

Variables: Clauses Known CU CRest Needed E1 C ID Rest ID1 C1 C2 L1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
S : select (ID1, C1) L1 Known
M : mem (ID1, C2) L1
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest Known -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="2157">
 &lt; <b>apply GCL to S M.</b>

Subgoal 2.1:

Variables: Clauses Known CU CRest Needed E1 C ID Rest
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2158">
 &lt; <b>assert forall ID1 CK CC,
     mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false.</b>

Subgoal 2.1.2:

Variables: Clauses Known CU CRest Needed E1 C ID Rest
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
============================
 forall ID1 CK CC,
   mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
</pre>
<pre class="code extensibella"id="2159">
 &lt; <b>intros MK+ MCR.</b>

Subgoal 2.1.2:

Variables: Clauses Known CU CRest Needed E1 C ID Rest ID1 CK CC
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
MK+ : mem (ID1, CK) ((ID, C)::Known)
MCR : mem (ID1, CC) CRest
============================
 false
</pre>
<pre class="code extensibella"id="2160">
 &lt; <b>MK: case MK+.</b>

Subgoal 2.1.2.1:

Variables: Clauses Known CU CRest Needed E1 C ID Rest CC
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
MCR : mem (ID, CC) CRest
============================
 false
</pre>
<pre class="code extensibella"id="2161">
 &lt; <b>GCLC: case GCLC.</b>

Subgoal 2.1.2.1:

Variables: Clauses Known CU CRest Needed E1 C ID Rest CC
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
MCR : mem (ID, CC) CRest
GCLC : forall ID C1 KRest C2,
         select (ID, C1) KRest Clauses -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="2162">
 &lt; <b>apply GCLC to Ela1 MCR.</b>

Subgoal 2.1.2.2:

Variables: Clauses Known CU CRest Needed E1 C ID Rest ID1 CK CC
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
MCR : mem (ID1, CC) CRest
MK : mem (ID1, CK) Known
============================
 false
</pre>
<pre class="code extensibella"id="2163">
 &lt; <b>MC: apply mem_after_select_before to Ela1 MCR.</b>

Subgoal 2.1.2.2:

Variables: Clauses Known CU CRest Needed E1 C ID Rest ID1 CK CC
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
MCR : mem (ID1, CC) CRest
MK : mem (ID1, CK) Known
MC : mem (ID1, CC) Clauses
============================
 false
</pre>
<pre class="code extensibella"id="2164">
 &lt; <b>apply NoMem to MK MC.</b>

Subgoal 2.1:

Variables: Clauses Known CU CRest Needed E1 C ID Rest
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2165">
 &lt; <b>GUL: apply IH1 to _ _ _ _ _ CP1 Ela2 _.</b>

Subgoal 2.1:

Variables: Clauses Known CU CRest Needed E1 C ID Rest
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
GUL : good_used_list Needed
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2166">
 &lt; <b>apply good_used_list_select to GUL Ela3.</b>

Subgoal 2.1:

Variables: Clauses Known CU CRest Needed E1 C ID Rest
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E1 *
Ela3 : select (ID, needed) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
GUL : good_used_list Needed
H7 : good_used_list CU
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2167">
 &lt; <b>search.</b>

Subgoal 2.2:

Variables: Clauses Known CU E CRest Needed Rest C ID
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
IsP : is_fratProof (addOriginal ID C Rest)
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2168">
 &lt; <b>Is: case IsP.</b>

Subgoal 2.2:

Variables: Clauses Known CU E CRest Needed Rest C ID
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2169">
 &lt; <b>CP: case CP.</b>

Subgoal 2.2:

Variables: Clauses Known CU E CRest Needed Rest C ID CRest1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest1 Clauses
CP1 : checkFratProof CRest1 ((ID, C)::Known) Rest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2170">
 &lt; <b>apply select_is to _ Ela1.</b>

Subgoal 2.2:

Variables: Clauses Known CU E CRest Needed Rest C ID CRest1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest1 Clauses
CP1 : checkFratProof CRest1 ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2171">
 &lt; <b>Is': apply select_is_picked to _ Ela1.</b>

Subgoal 2.2:

Variables: Clauses Known CU E CRest Needed Rest C ID CRest1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest1 Clauses
CP1 : checkFratProof CRest1 ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
Is' : is_pair is_integer is_clause (ID, C)
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2172">
 &lt; <b>case Is'.</b>

Subgoal 2.2:

Variables: Clauses Known CU E CRest Needed Rest C ID CRest1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest1 Clauses
CP1 : checkFratProof CRest1 ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2173">
 &lt; <b>apply good_clause_list_select to _ Ela1.</b>

Subgoal 2.2:

Variables: Clauses Known CU E CRest Needed Rest C ID CRest1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest1 Clauses
CP1 : checkFratProof CRest1 ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2174">
 &lt; <b>apply good_clause_list_selects to _ CP Ela1.</b>

Subgoal 2.2:

Variables: Clauses Known CU E CRest Needed Rest C ID
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2175">
 &lt; <b>assert good_clause_list ((ID, C)::Known).</b>

Subgoal 2.2.1:

Variables: Clauses Known CU E CRest Needed Rest C ID
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
============================
 good_clause_list ((ID, C)::Known)
</pre>
<pre class="code extensibella"id="2176">
 &lt; <b>unfold .</b>

Subgoal 2.2.1:

Variables: Clauses Known CU E CRest Needed Rest C ID
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
============================
 forall ID1 C1 KRest C2,
   select (ID1, C1) KRest ((ID, C)::Known) -&gt; mem (ID1, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="2177">
 &lt; <b>intros S M.</b>

Subgoal 2.2.1:

Variables: Clauses Known CU E CRest Needed Rest C ID ID1 C1 KRest C2
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
S : select (ID1, C1) KRest ((ID, C)::Known)
M : mem (ID1, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="2178">
 &lt; <b>S: case S.</b>

Subgoal 2.2.1.1:

Variables: Clauses Known CU E CRest Needed Rest C ID C2
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
M : mem (ID, C2) Known
============================
 false
</pre>
<pre class="code extensibella"id="2179">
 &lt; <b>M': apply select_mem to Ela1.</b>

Subgoal 2.2.1.1:

Variables: Clauses Known CU E CRest Needed Rest C ID C2
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
M : mem (ID, C2) Known
M' : mem (ID, C) Clauses
============================
 false
</pre>
<pre class="code extensibella"id="2180">
 &lt; <b>apply NoMem to M M'.</b>

Subgoal 2.2.1.2:

Variables: Clauses Known CU E CRest Needed Rest C ID ID1 C1 C2 L1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
M : mem (ID1, C2) ((ID, C)::L1)
S : select (ID1, C1) L1 Known
============================
 false
</pre>
<pre class="code extensibella"id="2181">
 &lt; <b>M: case M.</b>

Subgoal 2.2.1.2.1:

Variables: Clauses Known CU E CRest Needed Rest C ID C1 L1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
S : select (ID, C1) L1 Known
============================
 false
</pre>
<pre class="code extensibella"id="2182">
 &lt; <b>MS: apply select_mem to S.</b>

Subgoal 2.2.1.2.1:

Variables: Clauses Known CU E CRest Needed Rest C ID C1 L1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
S : select (ID, C1) L1 Known
MS : mem (ID, C1) Known
============================
 false
</pre>
<pre class="code extensibella"id="2183">
 &lt; <b>M': apply select_mem to Ela1.</b>

Subgoal 2.2.1.2.1:

Variables: Clauses Known CU E CRest Needed Rest C ID C1 L1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
S : select (ID, C1) L1 Known
MS : mem (ID, C1) Known
M' : mem (ID, C) Clauses
============================
 false
</pre>
<pre class="code extensibella"id="2184">
 &lt; <b>apply NoMem to MS M'.</b>

Subgoal 2.2.1.2.2:

Variables: Clauses Known CU E CRest Needed Rest C ID ID1 C1 C2 L1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
S : select (ID1, C1) L1 Known
M : mem (ID1, C2) L1
============================
 false
</pre>
<pre class="code extensibella"id="2185">
 &lt; <b>GCL: case GCL.</b>

Subgoal 2.2.1.2.2:

Variables: Clauses Known CU E CRest Needed Rest C ID ID1 C1 C2 L1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
S : select (ID1, C1) L1 Known
M : mem (ID1, C2) L1
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest Known -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="2186">
 &lt; <b>apply GCL to S M.</b>

Subgoal 2.2:

Variables: Clauses Known CU E CRest Needed Rest C ID
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2187">
 &lt; <b>assert forall ID1 CK CC,
     mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false.</b>

Subgoal 2.2.2:

Variables: Clauses Known CU E CRest Needed Rest C ID
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
============================
 forall ID1 CK CC,
   mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
</pre>
<pre class="code extensibella"id="2188">
 &lt; <b>intros MK+ MCR.</b>

Subgoal 2.2.2:

Variables: Clauses Known CU E CRest Needed Rest C ID ID1 CK CC
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
MK+ : mem (ID1, CK) ((ID, C)::Known)
MCR : mem (ID1, CC) CRest
============================
 false
</pre>
<pre class="code extensibella"id="2189">
 &lt; <b>MK: case MK+.</b>

Subgoal 2.2.2.1:

Variables: Clauses Known CU E CRest Needed Rest C ID CC
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
MCR : mem (ID, CC) CRest
============================
 false
</pre>
<pre class="code extensibella"id="2190">
 &lt; <b>GCLC: case GCLC.</b>

Subgoal 2.2.2.1:

Variables: Clauses Known CU E CRest Needed Rest C ID CC
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
MCR : mem (ID, CC) CRest
GCLC : forall ID C1 KRest C2,
         select (ID, C1) KRest Clauses -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="2191">
 &lt; <b>apply GCLC to Ela1 MCR.</b>

Subgoal 2.2.2.2:

Variables: Clauses Known CU E CRest Needed Rest C ID ID1 CK CC
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
MCR : mem (ID1, CC) CRest
MK : mem (ID1, CK) Known
============================
 false
</pre>
<pre class="code extensibella"id="2192">
 &lt; <b>MC: apply mem_after_select_before to Ela1 MCR.</b>

Subgoal 2.2.2.2:

Variables: Clauses Known CU E CRest Needed Rest C ID ID1 CK CC
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
MCR : mem (ID1, CC) CRest
MK : mem (ID1, CK) Known
MC : mem (ID1, CC) Clauses
============================
 false
</pre>
<pre class="code extensibella"id="2193">
 &lt; <b>apply NoMem to MK MC.</b>

Subgoal 2.2:

Variables: Clauses Known CU E CRest Needed Rest C ID
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2194">
 &lt; <b>GUL: apply IH1 to _ _ _ _ _ CP1 Ela2 _.</b>

Subgoal 2.2:

Variables: Clauses Known CU E CRest Needed Rest C ID
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
GUL : good_used_list Needed
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2195">
 &lt; <b>apply good_used_list_select to GUL Ela3.</b>

Subgoal 2.2:

Variables: Clauses Known CU E CRest Needed Rest C ID
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed E *
Ela3 : select (ID, unknown) CU Needed
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP : select (ID, C) CRest Clauses
CP1 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list CRest
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
GUL : good_used_list Needed
H7 : good_used_list CU
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2196">
 &lt; <b>search.</b>

Subgoal 2.3:

Variables: Clauses Known CU E1 P1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
IsP : is_fratProof (endOriginal P1)
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
CP : checkFratProof Clauses Known (endOriginal P1)
Ela : elaborateFratProof Clauses Known (endOriginal P1) CU (endOriginal E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : elaborate Known P1 CU E1
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2197">
 &lt; <b>case IsP.</b>

Subgoal 2.3:

Variables: Clauses Known CU E1 P1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
CP : checkFratProof Clauses Known (endOriginal P1)
Ela : elaborateFratProof Clauses Known (endOriginal P1) CU (endOriginal E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : elaborate Known P1 CU E1
H1 : is_proof P1
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2198">
 &lt; <b>CP: case CP.</b>

Subgoal 2.3:

Variables: Clauses Known CU E1 P1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (endOriginal P1) CU (endOriginal E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : elaborate Known P1 CU E1
H1 : is_proof P1
CP : checkProof Known P1
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2199">
 &lt; <b>apply elaboration_good_used_list to _ _ _ CP Ela1.</b>

Subgoal 2.3:

Variables: Clauses Known CU E1 P1
IH : forall Clauses Known P CU E ID U,
       is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
       checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID1 CK CC, mem (ID1, CK) Known -&gt; mem (ID1, CC) Clauses -&gt; false) -&gt;
       mem (ID, U) CU -&gt; exists C, mem (ID, C) Known
IH1 : forall Clauses Known P CU E,
        is_fratProof P -&gt; good_clause_list Known -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
        good_clause_list Clauses -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt;
        checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
        (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
        good_used_list CU
GCL : good_clause_list Known
IsKnown : is_list (is_pair is_integer is_clause) Known
GCLC : good_clause_list Clauses
IsClauses : is_list (is_pair is_integer is_clause) Clauses
Ela : elaborateFratProof Clauses Known (endOriginal P1) CU (endOriginal E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
Ela1 : elaborate Known P1 CU E1
H1 : is_proof P1
CP : checkProof Known P1
H2 : good_used_list CU
============================
 good_used_list CU
</pre>
<pre class="code extensibella"id="2200">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="2201">
 &lt; <b>Extensible_Theorem
      elaborationFrat_valid : forall Clauses Known P CU E Needed Clauses',
         IsP : is_fratProof P -&gt;
         IsClauses : is_list (is_pair is_integer is_clause) Clauses -&gt;
         IsKnown : is_list (is_pair is_integer is_clause) Known -&gt;
         IsClauses' : is_list (is_pair is_integer is_clause) Clauses' -&gt;
         IsNeeded : is_list (is_pair is_integer is_clause) Needed -&gt;
         GCL_C : good_clause_list Clauses -&gt;
         GCL : good_clause_list Known -&gt;
         GCL_C' : good_clause_list Clauses' -&gt;
         GCL_N : good_clause_list Needed -&gt;
         CP : checkFratProof Clauses Known P -&gt;
         Ela : elaborateFratProof Clauses Known P CU E -&gt;
         NoMem : (forall ID CK CC,
           mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
         NoMemN : (forall ID CK CC,
           mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
         MemsC : (forall ID C,
           mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt;
         HN : hasNeeded Known CU Needed -&gt;
         checkFratProof Clauses' Needed E
      on Ela.</b>

Subgoal 1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsP : is_fratProof (addOriginal ID C Rest)
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
============================
 checkFratProof Clauses' Needed (addOriginal ID C E1)
</pre>
<pre class="code extensibella"id="2202">
 &lt; <b>Is: case IsP.</b>

Subgoal 1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
============================
 checkFratProof Clauses' Needed (addOriginal ID C E1)
</pre>
<pre class="code extensibella"id="2203">
 &lt; <b>CP: case CP (keep).</b>

Subgoal 1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest CRest1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest1 Clauses
CP2 : checkFratProof CRest1 ((ID, C)::Known) Rest
============================
 checkFratProof Clauses' Needed (addOriginal ID C E1)
</pre>
<pre class="code extensibella"id="2204">
 &lt; <b>apply select_is to _ CP1.</b>

Subgoal 1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest CRest1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest1 Clauses
CP2 : checkFratProof CRest1 ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest1
============================
 checkFratProof Clauses' Needed (addOriginal ID C E1)
</pre>
<pre class="code extensibella"id="2205">
 &lt; <b>apply good_clause_list_selects to _ CP1 Ela1.</b>

Subgoal 1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
============================
 checkFratProof Clauses' Needed (addOriginal ID C E1)
</pre>
<pre class="code extensibella"id="2206">
 &lt; <b>Is': apply select_is_picked to _ CP1.</b>

Subgoal 1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
Is' : is_pair is_integer is_clause (ID, C)
============================
 checkFratProof Clauses' Needed (addOriginal ID C E1)
</pre>
<pre class="code extensibella"id="2207">
 &lt; <b>case Is'.</b>

Subgoal 1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
============================
 checkFratProof Clauses' Needed (addOriginal ID C E1)
</pre>
<pre class="code extensibella"id="2208">
 &lt; <b>MC: apply select_mem to Ela1.</b>

Subgoal 1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
============================
 checkFratProof Clauses' Needed (addOriginal ID C E1)
</pre>
<pre class="code extensibella"id="2209">
 &lt; <b>MC': apply MemsC to MC.</b>

Subgoal 1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
============================
 checkFratProof Clauses' Needed (addOriginal ID C E1)
</pre>
<pre class="code extensibella"id="2210">
 &lt; <b>S: apply mem_select to MC'.</b>

Subgoal 1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
============================
 checkFratProof Clauses' Needed (addOriginal ID C E1)
</pre>
<pre class="code extensibella"id="2211">
 &lt; <b>apply select_is to _ S.</b>

Subgoal 1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
============================
 checkFratProof Clauses' Needed (addOriginal ID C E1)
</pre>
<pre class="code extensibella"id="2212">
 &lt; <b>assert good_clause_list ((ID, C)::Known).</b>

Subgoal 1.1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
============================
 good_clause_list ((ID, C)::Known)
</pre>
<pre class="code extensibella"id="2213">
 &lt; <b>unfold .</b>

Subgoal 1.1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
============================
 forall ID1 C1 KRest C2,
   select (ID1, C1) KRest ((ID, C)::Known) -&gt; mem (ID1, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="2214">
 &lt; <b>intros S' M.</b>

Subgoal 1.1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 C1 KRest C2
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
S' : select (ID1, C1) KRest ((ID, C)::Known)
M : mem (ID1, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="2215">
 &lt; <b>S': case S'.</b>

Subgoal 1.1.1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' C2
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
M : mem (ID, C2) Known
============================
 false
</pre>
<pre class="code extensibella"id="2216">
 &lt; <b>M': apply select_mem to Ela1.</b>

Subgoal 1.1.1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' C2
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
M : mem (ID, C2) Known
M' : mem (ID, C) Clauses
============================
 false
</pre>
<pre class="code extensibella"id="2217">
 &lt; <b>apply NoMem to M M'.</b>

Subgoal 1.1.2:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 C1 C2 L1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
M : mem (ID1, C2) ((ID, C)::L1)
S' : select (ID1, C1) L1 Known
============================
 false
</pre>
<pre class="code extensibella"id="2218">
 &lt; <b>M: case M.</b>

Subgoal 1.1.2.1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' C1 L1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
S' : select (ID, C1) L1 Known
============================
 false
</pre>
<pre class="code extensibella"id="2219">
 &lt; <b>MS: apply select_mem to S'.</b>

Subgoal 1.1.2.1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' C1 L1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
S' : select (ID, C1) L1 Known
MS : mem (ID, C1) Known
============================
 false
</pre>
<pre class="code extensibella"id="2220">
 &lt; <b>M': apply select_mem to Ela1.</b>

Subgoal 1.1.2.1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' C1 L1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
S' : select (ID, C1) L1 Known
MS : mem (ID, C1) Known
M' : mem (ID, C) Clauses
============================
 false
</pre>
<pre class="code extensibella"id="2221">
 &lt; <b>apply NoMem to MS M'.</b>

Subgoal 1.1.2.2:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 C1 C2 L1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
S' : select (ID1, C1) L1 Known
M : mem (ID1, C2) L1
============================
 false
</pre>
<pre class="code extensibella"id="2222">
 &lt; <b>GCL: case GCL.</b>

Subgoal 1.1.2.2:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 C1 C2 L1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
S' : select (ID1, C1) L1 Known
M : mem (ID1, C2) L1
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest Known -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="2223">
 &lt; <b>apply GCL to S' M.</b>

Subgoal 1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
============================
 checkFratProof Clauses' Needed (addOriginal ID C E1)
</pre>
<pre class="code extensibella"id="2224">
 &lt; <b>assert forall ID1 CK CC,
     mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false.</b>

Subgoal 1.2:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
============================
 forall ID1 CK CC,
   mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
</pre>
<pre class="code extensibella"id="2225">
 &lt; <b>intros MK+ MCR.</b>

Subgoal 1.2:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 CK CC
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
MK+ : mem (ID1, CK) ((ID, C)::Known)
MCR : mem (ID1, CC) CRest
============================
 false
</pre>
<pre class="code extensibella"id="2226">
 &lt; <b>MK: case MK+.</b>

Subgoal 1.2.1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' CC
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
MCR : mem (ID, CC) CRest
============================
 false
</pre>
<pre class="code extensibella"id="2227">
 &lt; <b>GCLC: case GCL_C.</b>

Subgoal 1.2.1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' CC
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
MCR : mem (ID, CC) CRest
GCLC : forall ID C1 KRest C2,
         select (ID, C1) KRest Clauses -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="2228">
 &lt; <b>apply GCLC to Ela1 MCR.</b>

Subgoal 1.2.2:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 CK CC
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
MCR : mem (ID1, CC) CRest
MK : mem (ID1, CK) Known
============================
 false
</pre>
<pre class="code extensibella"id="2229">
 &lt; <b>MC'': apply mem_after_select_before to Ela1 MCR.</b>

Subgoal 1.2.2:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 CK CC
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
MCR : mem (ID1, CC) CRest
MK : mem (ID1, CK) Known
MC'' : mem (ID1, CC) Clauses
============================
 false
</pre>
<pre class="code extensibella"id="2230">
 &lt; <b>apply NoMem to MK MC''.</b>

Subgoal 1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
============================
 checkFratProof Clauses' Needed (addOriginal ID C E1)
</pre>
<pre class="code extensibella"id="2231">
 &lt; <b>apply good_clause_list_select to _ Ela1.</b>

Subgoal 1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
============================
 checkFratProof Clauses' Needed (addOriginal ID C E1)
</pre>
<pre class="code extensibella"id="2232">
 &lt; <b>assert hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed).</b>

Subgoal 1.3:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
============================
 hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
</pre>
<pre class="code extensibella"id="2233">
 &lt; <b>unfold .</b>

Subgoal 1.3.1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
============================
 forall ID1,
   mem (ID1, needed) Needed1 -&gt; exists C1, mem (ID1, C1) ((ID, C)::Needed)
</pre>
<pre class="code extensibella"id="2234">
 &lt; <b>intros MN.</b>

Subgoal 1.3.1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
MN : mem (ID1, needed) Needed1
============================
 exists C1, mem (ID1, C1) ((ID, C)::Needed)
</pre>
<pre class="code extensibella"id="2235">
 &lt; <b>Or: apply select_mem_or to Ela3 MN.</b>

Subgoal 1.3.1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
MN : mem (ID1, needed) Needed1
Or : (ID1, needed) = (ID, needed) \/ mem (ID1, needed) CU
============================
 exists C1, mem (ID1, C1) ((ID, C)::Needed)
</pre>
<pre class="code extensibella"id="2236">
 &lt; <b>MCU: case Or.</b>

Subgoal 1.3.1.1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
MN : mem (ID, needed) Needed1
============================
 exists C1, mem (ID, C1) ((ID, C)::Needed)
</pre>
<pre class="code extensibella"id="2237">
 &lt; <b>search.</b>

Subgoal 1.3.1.2:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
MN : mem (ID1, needed) Needed1
MCU : mem (ID1, needed) CU
============================
 exists C1, mem (ID1, C1) ((ID, C)::Needed)
</pre>
<pre class="code extensibella"id="2238">
 &lt; <b>HN: case HN.</b>

Subgoal 1.3.1.2:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
MN : mem (ID1, needed) Needed1
MCU : mem (ID1, needed) CU
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 exists C1, mem (ID1, C1) ((ID, C)::Needed)
</pre>
<pre class="code extensibella"id="2239">
 &lt; <b>apply HN to MCU.</b>

Subgoal 1.3.1.2:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 C1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
MN : mem (ID1, needed) Needed1
MCU : mem (ID1, needed) CU
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
H8 : mem (ID1, C1) Needed
============================
 exists C1, mem (ID1, C1) ((ID, C)::Needed)
</pre>
<pre class="code extensibella"id="2240">
 &lt; <b>search.</b>

Subgoal 1.3.2:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
============================
 forall ID1 CN CK,
   mem (ID1, CN) ((ID, C)::Needed) -&gt; mem (ID1, CK) ((ID, C)::Known) -&gt; CN = CK
</pre>
<pre class="code extensibella"id="2241">
 &lt; <b>intros MN+ MK+.</b>

Subgoal 1.3.2:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 CN CK
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
MN+ : mem (ID1, CN) ((ID, C)::Needed)
MK+ : mem (ID1, CK) ((ID, C)::Known)
============================
 CN = CK
</pre>
<pre class="code extensibella"id="2242">
 &lt; <b>MN: case MN+.</b>

Subgoal 1.3.2.1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' CK
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
MK+ : mem (ID, CK) ((ID, C)::Known)
============================
 C = CK
</pre>
<pre class="code extensibella"id="2243">
 &lt; <b>MK: case MK+.</b>

Subgoal 1.3.2.1.1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
============================
 C = C
</pre>
<pre class="code extensibella"id="2244">
 &lt; <b>search.</b>

Subgoal 1.3.2.1.2:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' CK
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
MK : mem (ID, CK) Known
============================
 C = CK
</pre>
<pre class="code extensibella"id="2245">
 &lt; <b>apply NoMem to MK MC.</b>

Subgoal 1.3.2.2:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 CN CK
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
MK+ : mem (ID1, CK) ((ID, C)::Known)
MN : mem (ID1, CN) Needed
============================
 CN = CK
</pre>
<pre class="code extensibella"id="2246">
 &lt; <b>MK: case MK+.</b>

Subgoal 1.3.2.2.1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' CN
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
MN : mem (ID, CN) Needed
============================
 CN = C
</pre>
<pre class="code extensibella"id="2247">
 &lt; <b>apply NoMemN to MN MC.</b>

Subgoal 1.3.2.2.2:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 CN CK
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
MN : mem (ID1, CN) Needed
MK : mem (ID1, CK) Known
============================
 CN = CK
</pre>
<pre class="code extensibella"id="2248">
 &lt; <b>HN: case HN.</b>

Subgoal 1.3.2.2.2:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 CN CK
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
MN : mem (ID1, CN) Needed
MK : mem (ID1, CK) Known
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 CN = CK
</pre>
<pre class="code extensibella"id="2249">
 &lt; <b>apply HN1 to MN MK.</b>

Subgoal 1.3.2.2.2:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 CK
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
MN : mem (ID1, CK) Needed
MK : mem (ID1, CK) Known
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 CK = CK
</pre>
<pre class="code extensibella"id="2250">
 &lt; <b>search.</b>

Subgoal 1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
============================
 checkFratProof Clauses' Needed (addOriginal ID C E1)
</pre>
<pre class="code extensibella"id="2251">
 &lt; <b>assert forall ID1 C1,
     mem (ID1, C1) CRest -&gt; mem (ID1, C1) L'.</b>

Subgoal 1.4:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
============================
 forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) L'
</pre>
<pre class="code extensibella"id="2252">
 &lt; <b>intros MCR.</b>

Subgoal 1.4:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 C1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
MCR : mem (ID1, C1) CRest
============================
 mem (ID1, C1) L'
</pre>
<pre class="code extensibella"id="2253">
 &lt; <b>MCl: apply mem_after_select_before to _ MCR.</b>

Subgoal 1.4:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 C1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
MCR : mem (ID1, C1) CRest
MCl : mem (ID1, C1) Clauses
============================
 mem (ID1, C1) L'
</pre>
<pre class="code extensibella"id="2254">
 &lt; <b>MCl': apply MemsC to MCl.</b>

Subgoal 1.4:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 C1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
MCR : mem (ID1, C1) CRest
MCl : mem (ID1, C1) Clauses
MCl' : mem (ID1, C1) Clauses'
============================
 mem (ID1, C1) L'
</pre>
<pre class="code extensibella"id="2255">
 &lt; <b>Or: apply select_mem_or to S MCl'.</b>

Subgoal 1.4:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 C1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
MCR : mem (ID1, C1) CRest
MCl : mem (ID1, C1) Clauses
MCl' : mem (ID1, C1) Clauses'
Or : (ID1, C1) = (ID, C) \/ mem (ID1, C1) L'
============================
 mem (ID1, C1) L'
</pre>
<pre class="code extensibella"id="2256">
 &lt; <b>ML': case Or.</b>

Subgoal 1.4.1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
MCR : mem (ID, C) CRest
MCl : mem (ID, C) Clauses
MCl' : mem (ID, C) Clauses'
============================
 mem (ID, C) L'
</pre>
<pre class="code extensibella"id="2257">
 &lt; <b>GCL_C: case GCL_C.</b>

Subgoal 1.4.1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
MCR : mem (ID, C) CRest
MCl : mem (ID, C) Clauses
MCl' : mem (ID, C) Clauses'
GCL_C : forall ID C1 KRest C2,
          select (ID, C1) KRest Clauses -&gt; mem (ID, C2) KRest -&gt; false
============================
 mem (ID, C) L'
</pre>
<pre class="code extensibella"id="2258">
 &lt; <b>apply GCL_C to _ MCR.</b>

Subgoal 1.4.2:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 C1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
MCR : mem (ID1, C1) CRest
MCl : mem (ID1, C1) Clauses
MCl' : mem (ID1, C1) Clauses'
ML' : mem (ID1, C1) L'
============================
 mem (ID1, C1) L'
</pre>
<pre class="code extensibella"id="2259">
 &lt; <b>search.</b>

Subgoal 1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) L'
============================
 checkFratProof Clauses' Needed (addOriginal ID C E1)
</pre>
<pre class="code extensibella"id="2260">
 &lt; <b>assert forall ID1 CK CC,
     mem (ID1, CK) ((ID, C)::Needed) -&gt; mem (ID1, CC) CRest -&gt; false.</b>

Subgoal 1.5:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) L'
============================
 forall ID1 CK CC,
   mem (ID1, CK) ((ID, C)::Needed) -&gt; mem (ID1, CC) CRest -&gt; false
</pre>
<pre class="code extensibella"id="2261">
 &lt; <b>intros MN+ MCR.</b>

Subgoal 1.5:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 CK CC
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) L'
MN+ : mem (ID1, CK) ((ID, C)::Needed)
MCR : mem (ID1, CC) CRest
============================
 false
</pre>
<pre class="code extensibella"id="2262">
 &lt; <b>MN: case MN+.</b>

Subgoal 1.5.1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' CC
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) L'
MCR : mem (ID, CC) CRest
============================
 false
</pre>
<pre class="code extensibella"id="2263">
 &lt; <b>GCL_C: case GCL_C.</b>

Subgoal 1.5.1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' CC
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) L'
MCR : mem (ID, CC) CRest
GCL_C : forall ID C1 KRest C2,
          select (ID, C1) KRest Clauses -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="2264">
 &lt; <b>apply GCL_C to _ MCR.</b>

Subgoal 1.5.2:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 CK CC
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) L'
MCR : mem (ID1, CC) CRest
MN : mem (ID1, CK) Needed
============================
 false
</pre>
<pre class="code extensibella"id="2265">
 &lt; <b>MCl: apply mem_after_select_before to _ MCR.</b>

Subgoal 1.5.2:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 CK CC
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) L'
MCR : mem (ID1, CC) CRest
MN : mem (ID1, CK) Needed
MCl : mem (ID1, CC) Clauses
============================
 false
</pre>
<pre class="code extensibella"id="2266">
 &lt; <b>apply NoMemN to MN MCl.</b>

Subgoal 1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) L'
H10 : forall ID1 CK CC,
        mem (ID1, CK) ((ID, C)::Needed) -&gt; mem (ID1, CC) CRest -&gt; false
============================
 checkFratProof Clauses' Needed (addOriginal ID C E1)
</pre>
<pre class="code extensibella"id="2267">
 &lt; <b>assert good_clause_list ((ID, C)::Needed).</b>

Subgoal 1.6:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) L'
H10 : forall ID1 CK CC,
        mem (ID1, CK) ((ID, C)::Needed) -&gt; mem (ID1, CC) CRest -&gt; false
============================
 good_clause_list ((ID, C)::Needed)
</pre>
<pre class="code extensibella"id="2268">
 &lt; <b>unfold .</b>

Subgoal 1.6:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) L'
H10 : forall ID1 CK CC,
        mem (ID1, CK) ((ID, C)::Needed) -&gt; mem (ID1, CC) CRest -&gt; false
============================
 forall ID1 C1 KRest C2,
   select (ID1, C1) KRest ((ID, C)::Needed) -&gt; mem (ID1, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="2269">
 &lt; <b>intros SN+ MKR.</b>

Subgoal 1.6:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 C1 KRest C2
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) L'
H10 : forall ID1 CK CC,
        mem (ID1, CK) ((ID, C)::Needed) -&gt; mem (ID1, CC) CRest -&gt; false
SN+ : select (ID1, C1) KRest ((ID, C)::Needed)
MKR : mem (ID1, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="2270">
 &lt; <b>SN: case SN+.</b>

Subgoal 1.6.1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' C2
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) L'
H10 : forall ID1 CK CC,
        mem (ID1, CK) ((ID, C)::Needed) -&gt; mem (ID1, CC) CRest -&gt; false
MKR : mem (ID, C2) Needed
============================
 false
</pre>
<pre class="code extensibella"id="2271">
 &lt; <b>apply NoMemN to MKR _.</b>

Subgoal 1.6.2:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 C1 C2 L1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) L'
H10 : forall ID1 CK CC,
        mem (ID1, CK) ((ID, C)::Needed) -&gt; mem (ID1, CC) CRest -&gt; false
MKR : mem (ID1, C2) ((ID, C)::L1)
SN : select (ID1, C1) L1 Needed
============================
 false
</pre>
<pre class="code extensibella"id="2272">
 &lt; <b>MKR: case MKR.</b>

Subgoal 1.6.2.1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' C1 L1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) L'
H10 : forall ID1 CK CC,
        mem (ID1, CK) ((ID, C)::Needed) -&gt; mem (ID1, CC) CRest -&gt; false
SN : select (ID, C1) L1 Needed
============================
 false
</pre>
<pre class="code extensibella"id="2273">
 &lt; <b>MN: apply select_mem to SN.</b>

Subgoal 1.6.2.1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' C1 L1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) L'
H10 : forall ID1 CK CC,
        mem (ID1, CK) ((ID, C)::Needed) -&gt; mem (ID1, CC) CRest -&gt; false
SN : select (ID, C1) L1 Needed
MN : mem (ID, C1) Needed
============================
 false
</pre>
<pre class="code extensibella"id="2274">
 &lt; <b>apply NoMemN to MN _.</b>

Subgoal 1.6.2.2:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 C1 C2 L1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) L'
H10 : forall ID1 CK CC,
        mem (ID1, CK) ((ID, C)::Needed) -&gt; mem (ID1, CC) CRest -&gt; false
SN : select (ID1, C1) L1 Needed
MKR : mem (ID1, C2) L1
============================
 false
</pre>
<pre class="code extensibella"id="2275">
 &lt; <b>GCL_N: case GCL_N.</b>

Subgoal 1.6.2.2:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L' ID1 C1 C2 L1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) L'
H10 : forall ID1 CK CC,
        mem (ID1, CK) ((ID, C)::Needed) -&gt; mem (ID1, CC) CRest -&gt; false
SN : select (ID1, C1) L1 Needed
MKR : mem (ID1, C2) L1
GCL_N : forall ID C1 KRest C2,
          select (ID, C1) KRest Needed -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="2276">
 &lt; <b>apply GCL_N to SN MKR.</b>

Subgoal 1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) L'
H10 : forall ID1 CK CC,
        mem (ID1, CK) ((ID, C)::Needed) -&gt; mem (ID1, CC) CRest -&gt; false
H11 : good_clause_list ((ID, C)::Needed)
============================
 checkFratProof Clauses' Needed (addOriginal ID C E1)
</pre>
<pre class="code extensibella"id="2277">
 &lt; <b>apply good_clause_list_select to _ S.</b>

Subgoal 1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) L'
H10 : forall ID1 CK CC,
        mem (ID1, CK) ((ID, C)::Needed) -&gt; mem (ID1, CC) CRest -&gt; false
H11 : good_clause_list ((ID, C)::Needed)
H12 : good_clause_list L'
============================
 checkFratProof Clauses' Needed (addOriginal ID C E1)
</pre>
<pre class="code extensibella"id="2278">
 &lt; <b>apply IH to _ _ _ _ _ _ _ _ _ CP2 Ela2 _ _ _ _ with
     Needed = (ID, C)::Needed Clauses' = L'.</b>

Subgoal 1:

Variables: Clauses Known CU Needed Clauses' CRest Needed1 E1 C ID Rest L'
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU (addOriginal ID C E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E1 *
Ela3 : select (ID, needed) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
MC : mem (ID, C) Clauses
MC' : mem (ID, C) Clauses'
S : select (ID, C) L' Clauses'
H4 : is_list (is_pair is_integer is_clause) L'
H5 : good_clause_list ((ID, C)::Known)
H6 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H7 : good_clause_list CRest
H8 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) L'
H10 : forall ID1 CK CC,
        mem (ID1, CK) ((ID, C)::Needed) -&gt; mem (ID1, CC) CRest -&gt; false
H11 : good_clause_list ((ID, C)::Needed)
H12 : good_clause_list L'
H13 : checkFratProof L' ((ID, C)::Needed) E1
============================
 checkFratProof Clauses' Needed (addOriginal ID C E1)
</pre>
<pre class="code extensibella"id="2279">
 &lt; <b>search.</b>

Subgoal 2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsP : is_fratProof (addOriginal ID C Rest)
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
============================
 checkFratProof Clauses' Needed E
</pre>
<pre class="code extensibella"id="2280">
 &lt; <b>Is: case IsP.</b>

Subgoal 2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
============================
 checkFratProof Clauses' Needed E
</pre>
<pre class="code extensibella"id="2281">
 &lt; <b>CP: case CP (keep).</b>

Subgoal 2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID CRest1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest1 Clauses
CP2 : checkFratProof CRest1 ((ID, C)::Known) Rest
============================
 checkFratProof Clauses' Needed E
</pre>
<pre class="code extensibella"id="2282">
 &lt; <b>apply select_is to _ CP1.</b>

Subgoal 2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID CRest1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest1 Clauses
CP2 : checkFratProof CRest1 ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest1
============================
 checkFratProof Clauses' Needed E
</pre>
<pre class="code extensibella"id="2283">
 &lt; <b>apply good_clause_list_selects to _ CP1 Ela1.</b>

Subgoal 2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
============================
 checkFratProof Clauses' Needed E
</pre>
<pre class="code extensibella"id="2284">
 &lt; <b>Is': apply select_is_picked to _ CP1.</b>

Subgoal 2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
Is' : is_pair is_integer is_clause (ID, C)
============================
 checkFratProof Clauses' Needed E
</pre>
<pre class="code extensibella"id="2285">
 &lt; <b>case Is'.</b>

Subgoal 2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
============================
 checkFratProof Clauses' Needed E
</pre>
<pre class="code extensibella"id="2286">
 &lt; <b>assert good_clause_list ((ID, C)::Known).</b>

Subgoal 2.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
============================
 good_clause_list ((ID, C)::Known)
</pre>
<pre class="code extensibella"id="2287">
 &lt; <b>unfold .</b>

Subgoal 2.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
============================
 forall ID1 C1 KRest C2,
   select (ID1, C1) KRest ((ID, C)::Known) -&gt; mem (ID1, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="2288">
 &lt; <b>intros S' M.</b>

Subgoal 2.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1 C1 KRest C2
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
S' : select (ID1, C1) KRest ((ID, C)::Known)
M : mem (ID1, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="2289">
 &lt; <b>S': case S'.</b>

Subgoal 2.1.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID C2
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
M : mem (ID, C2) Known
============================
 false
</pre>
<pre class="code extensibella"id="2290">
 &lt; <b>M': apply select_mem to Ela1.</b>

Subgoal 2.1.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID C2
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
M : mem (ID, C2) Known
M' : mem (ID, C) Clauses
============================
 false
</pre>
<pre class="code extensibella"id="2291">
 &lt; <b>apply NoMem to M M'.</b>

Subgoal 2.1.2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1 C1 C2 L1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
M : mem (ID1, C2) ((ID, C)::L1)
S' : select (ID1, C1) L1 Known
============================
 false
</pre>
<pre class="code extensibella"id="2292">
 &lt; <b>M: case M.</b>

Subgoal 2.1.2.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID C1 L1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
S' : select (ID, C1) L1 Known
============================
 false
</pre>
<pre class="code extensibella"id="2293">
 &lt; <b>MS: apply select_mem to S'.</b>

Subgoal 2.1.2.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID C1 L1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
S' : select (ID, C1) L1 Known
MS : mem (ID, C1) Known
============================
 false
</pre>
<pre class="code extensibella"id="2294">
 &lt; <b>M': apply select_mem to Ela1.</b>

Subgoal 2.1.2.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID C1 L1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
S' : select (ID, C1) L1 Known
MS : mem (ID, C1) Known
M' : mem (ID, C) Clauses
============================
 false
</pre>
<pre class="code extensibella"id="2295">
 &lt; <b>apply NoMem to MS M'.</b>

Subgoal 2.1.2.2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1 C1 C2 L1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
S' : select (ID1, C1) L1 Known
M : mem (ID1, C2) L1
============================
 false
</pre>
<pre class="code extensibella"id="2296">
 &lt; <b>GCL: case GCL.</b>

Subgoal 2.1.2.2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1 C1 C2 L1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
S' : select (ID1, C1) L1 Known
M : mem (ID1, C2) L1
GCL : forall ID C1 KRest C2,
        select (ID, C1) KRest Known -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="2297">
 &lt; <b>apply GCL to S' M.</b>

Subgoal 2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
============================
 checkFratProof Clauses' Needed E
</pre>
<pre class="code extensibella"id="2298">
 &lt; <b>assert forall ID1 CK CC,
     mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false.</b>

Subgoal 2.2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
============================
 forall ID1 CK CC,
   mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
</pre>
<pre class="code extensibella"id="2299">
 &lt; <b>intros MK+ MCR.</b>

Subgoal 2.2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1 CK CC
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
MK+ : mem (ID1, CK) ((ID, C)::Known)
MCR : mem (ID1, CC) CRest
============================
 false
</pre>
<pre class="code extensibella"id="2300">
 &lt; <b>MK: case MK+.</b>

Subgoal 2.2.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID CC
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
MCR : mem (ID, CC) CRest
============================
 false
</pre>
<pre class="code extensibella"id="2301">
 &lt; <b>GCLC: case GCL_C.</b>

Subgoal 2.2.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID CC
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
MCR : mem (ID, CC) CRest
GCLC : forall ID C1 KRest C2,
         select (ID, C1) KRest Clauses -&gt; mem (ID, C2) KRest -&gt; false
============================
 false
</pre>
<pre class="code extensibella"id="2302">
 &lt; <b>apply GCLC to Ela1 MCR.</b>

Subgoal 2.2.2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1 CK CC
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
MCR : mem (ID1, CC) CRest
MK : mem (ID1, CK) Known
============================
 false
</pre>
<pre class="code extensibella"id="2303">
 &lt; <b>MC'': apply mem_after_select_before to Ela1 MCR.</b>

Subgoal 2.2.2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1 CK CC
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
MCR : mem (ID1, CC) CRest
MK : mem (ID1, CK) Known
MC'' : mem (ID1, CC) Clauses
============================
 false
</pre>
<pre class="code extensibella"id="2304">
 &lt; <b>apply NoMem to MK MC''.</b>

Subgoal 2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
============================
 checkFratProof Clauses' Needed E
</pre>
<pre class="code extensibella"id="2305">
 &lt; <b>apply good_clause_list_select to _ Ela1.</b>

Subgoal 2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
============================
 checkFratProof Clauses' Needed E
</pre>
<pre class="code extensibella"id="2306">
 &lt; <b>assert hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed).</b>

Subgoal 2.3:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
============================
 hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
</pre>
<pre class="code extensibella"id="2307">
 &lt; <b>unfold .</b>

Subgoal 2.3.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
============================
 forall ID1,
   mem (ID1, needed) Needed1 -&gt; exists C1, mem (ID1, C1) ((ID, C)::Needed)
</pre>
<pre class="code extensibella"id="2308">
 &lt; <b>intros MN.</b>

Subgoal 2.3.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
MN : mem (ID1, needed) Needed1
============================
 exists C1, mem (ID1, C1) ((ID, C)::Needed)
</pre>
<pre class="code extensibella"id="2309">
 &lt; <b>Or: apply select_mem_or to Ela3 MN.</b>

Subgoal 2.3.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
MN : mem (ID1, needed) Needed1
Or : (ID1, needed) = (ID, unknown) \/ mem (ID1, needed) CU
============================
 exists C1, mem (ID1, C1) ((ID, C)::Needed)
</pre>
<pre class="code extensibella"id="2310">
 &lt; <b>MCU: case Or.</b>

Subgoal 2.3.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
MN : mem (ID1, needed) Needed1
MCU : mem (ID1, needed) CU
============================
 exists C1, mem (ID1, C1) ((ID, C)::Needed)
</pre>
<pre class="code extensibella"id="2311">
 &lt; <b>HN: case HN.</b>

Subgoal 2.3.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
MN : mem (ID1, needed) Needed1
MCU : mem (ID1, needed) CU
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 exists C1, mem (ID1, C1) ((ID, C)::Needed)
</pre>
<pre class="code extensibella"id="2312">
 &lt; <b>apply HN to MCU.</b>

Subgoal 2.3.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1 C1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
MN : mem (ID1, needed) Needed1
MCU : mem (ID1, needed) CU
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
H7 : mem (ID1, C1) Needed
============================
 exists C1, mem (ID1, C1) ((ID, C)::Needed)
</pre>
<pre class="code extensibella"id="2313">
 &lt; <b>search.</b>

Subgoal 2.3.2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
============================
 forall ID1 CN CK,
   mem (ID1, CN) ((ID, C)::Needed) -&gt; mem (ID1, CK) ((ID, C)::Known) -&gt; CN = CK
</pre>
<pre class="code extensibella"id="2314">
 &lt; <b>intros MN+ MK+.</b>

Subgoal 2.3.2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1 CN CK
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
MN+ : mem (ID1, CN) ((ID, C)::Needed)
MK+ : mem (ID1, CK) ((ID, C)::Known)
============================
 CN = CK
</pre>
<pre class="code extensibella"id="2315">
 &lt; <b>MN: case MN+.</b>

Subgoal 2.3.2.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID CK
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
MK+ : mem (ID, CK) ((ID, C)::Known)
============================
 C = CK
</pre>
<pre class="code extensibella"id="2316">
 &lt; <b>MK: case MK+.</b>

Subgoal 2.3.2.1.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
============================
 C = C
</pre>
<pre class="code extensibella"id="2317">
 &lt; <b>search.</b>

Subgoal 2.3.2.1.2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID CK
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
MK : mem (ID, CK) Known
============================
 C = CK
</pre>
<pre class="code extensibella"id="2318">
 &lt; <b>MC: apply select_mem to Ela1.</b>

Subgoal 2.3.2.1.2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID CK
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
MK : mem (ID, CK) Known
MC : mem (ID, C) Clauses
============================
 C = CK
</pre>
<pre class="code extensibella"id="2319">
 &lt; <b>apply NoMem to MK MC.</b>

Subgoal 2.3.2.2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1 CN CK
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
MK+ : mem (ID1, CK) ((ID, C)::Known)
MN : mem (ID1, CN) Needed
============================
 CN = CK
</pre>
<pre class="code extensibella"id="2320">
 &lt; <b>MK: case MK+.</b>

Subgoal 2.3.2.2.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID CN
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
MN : mem (ID, CN) Needed
============================
 CN = C
</pre>
<pre class="code extensibella"id="2321">
 &lt; <b>MC: apply select_mem to Ela1.</b>

Subgoal 2.3.2.2.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID CN
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
MN : mem (ID, CN) Needed
MC : mem (ID, C) Clauses
============================
 CN = C
</pre>
<pre class="code extensibella"id="2322">
 &lt; <b>apply NoMemN to MN MC.</b>

Subgoal 2.3.2.2.2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1 CN CK
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
MN : mem (ID1, CN) Needed
MK : mem (ID1, CK) Known
============================
 CN = CK
</pre>
<pre class="code extensibella"id="2323">
 &lt; <b>HN: case HN.</b>

Subgoal 2.3.2.2.2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1 CN CK
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
MN : mem (ID1, CN) Needed
MK : mem (ID1, CK) Known
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 CN = CK
</pre>
<pre class="code extensibella"id="2324">
 &lt; <b>apply HN1 to MN MK.</b>

Subgoal 2.3.2.2.2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1 CK
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
MN : mem (ID1, CK) Needed
MK : mem (ID1, CK) Known
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 CK = CK
</pre>
<pre class="code extensibella"id="2325">
 &lt; <b>search.</b>

Subgoal 2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
============================
 checkFratProof Clauses' Needed E
</pre>
<pre class="code extensibella"id="2326">
 &lt; <b>assert hasNeeded ((ID, C)::Known) Needed1 Needed.</b>

Subgoal 2.4:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
============================
 hasNeeded ((ID, C)::Known) Needed1 Needed
</pre>
<pre class="code extensibella"id="2327">
 &lt; <b>unfold .</b>

Subgoal 2.4.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
============================
 forall ID1, mem (ID1, needed) Needed1 -&gt; exists C1, mem (ID1, C1) Needed
</pre>
<pre class="code extensibella"id="2328">
 &lt; <b>intros M.</b>

Subgoal 2.4.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
M : mem (ID1, needed) Needed1
============================
 exists C1, mem (ID1, C1) Needed
</pre>
<pre class="code extensibella"id="2329">
 &lt; <b>HN: case HN.</b>

Subgoal 2.4.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
M : mem (ID1, needed) Needed1
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 exists C1, mem (ID1, C1) Needed
</pre>
<pre class="code extensibella"id="2330">
 &lt; <b>Or: apply select_mem_or to Ela3 M.</b>

Subgoal 2.4.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
M : mem (ID1, needed) Needed1
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
Or : (ID1, needed) = (ID, unknown) \/ mem (ID1, needed) CU
============================
 exists C1, mem (ID1, C1) Needed
</pre>
<pre class="code extensibella"id="2331">
 &lt; <b>M': case Or.</b>

Subgoal 2.4.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
M : mem (ID1, needed) Needed1
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
M' : mem (ID1, needed) CU
============================
 exists C1, mem (ID1, C1) Needed
</pre>
<pre class="code extensibella"id="2332">
 &lt; <b>apply HN to M'.</b>

Subgoal 2.4.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1 C1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
M : mem (ID1, needed) Needed1
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
M' : mem (ID1, needed) CU
H8 : mem (ID1, C1) Needed
============================
 exists C1, mem (ID1, C1) Needed
</pre>
<pre class="code extensibella"id="2333">
 &lt; <b>search.</b>

Subgoal 2.4.2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
============================
 forall ID1 CN CK,
   mem (ID1, CN) Needed -&gt; mem (ID1, CK) ((ID, C)::Known) -&gt; CN = CK
</pre>
<pre class="code extensibella"id="2334">
 &lt; <b>intros MN MK+.</b>

Subgoal 2.4.2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1 CN CK
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
MN : mem (ID1, CN) Needed
MK+ : mem (ID1, CK) ((ID, C)::Known)
============================
 CN = CK
</pre>
<pre class="code extensibella"id="2335">
 &lt; <b>MK: case MK+.</b>

Subgoal 2.4.2.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID CN
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
MN : mem (ID, CN) Needed
============================
 CN = C
</pre>
<pre class="code extensibella"id="2336">
 &lt; <b>MC: apply select_mem to CP1.</b>

Subgoal 2.4.2.1:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID CN
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
MN : mem (ID, CN) Needed
MC : mem (ID, C) Clauses
============================
 CN = C
</pre>
<pre class="code extensibella"id="2337">
 &lt; <b>apply NoMemN to MN MC.</b>

Subgoal 2.4.2.2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1 CN CK
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
MN : mem (ID1, CN) Needed
MK : mem (ID1, CK) Known
============================
 CN = CK
</pre>
<pre class="code extensibella"id="2338">
 &lt; <b>HN: case HN.</b>

Subgoal 2.4.2.2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1 CN CK
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
MN : mem (ID1, CN) Needed
MK : mem (ID1, CK) Known
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 CN = CK
</pre>
<pre class="code extensibella"id="2339">
 &lt; <b>apply HN1 to MN MK.</b>

Subgoal 2.4.2.2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1 CK
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
MN : mem (ID1, CK) Needed
MK : mem (ID1, CK) Known
HN : forall ID, mem (ID, needed) CU -&gt; exists C, mem (ID, C) Needed
HN1 : forall ID CN CK, mem (ID, CN) Needed -&gt; mem (ID, CK) Known -&gt; CN = CK
============================
 CK = CK
</pre>
<pre class="code extensibella"id="2340">
 &lt; <b>search.</b>

Subgoal 2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H8 : hasNeeded ((ID, C)::Known) Needed1 Needed
============================
 checkFratProof Clauses' Needed E
</pre>
<pre class="code extensibella"id="2341">
 &lt; <b>assert forall ID C,
     mem (ID, C) CRest -&gt; mem (ID, C) Clauses'.</b>

Subgoal 2.5:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H8 : hasNeeded ((ID, C)::Known) Needed1 Needed
============================
 forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) Clauses'
</pre>
<pre class="code extensibella"id="2342">
 &lt; <b>intros MCR.</b>

Subgoal 2.5:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1 C1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H8 : hasNeeded ((ID, C)::Known) Needed1 Needed
MCR : mem (ID1, C1) CRest
============================
 mem (ID1, C1) Clauses'
</pre>
<pre class="code extensibella"id="2343">
 &lt; <b>apply mem_after_select_before to _ MCR.</b>

Subgoal 2.5:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1 C1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H8 : hasNeeded ((ID, C)::Known) Needed1 Needed
MCR : mem (ID1, C1) CRest
H9 : mem (ID1, C1) Clauses
============================
 mem (ID1, C1) Clauses'
</pre>
<pre class="code extensibella"id="2344">
 &lt; <b>backchain MemsC.</b>

Subgoal 2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H8 : hasNeeded ((ID, C)::Known) Needed1 Needed
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) Clauses'
============================
 checkFratProof Clauses' Needed E
</pre>
<pre class="code extensibella"id="2345">
 &lt; <b>assert forall ID CK CC,
     mem (ID, CK) Needed -&gt; mem (ID, CC) CRest -&gt; false.</b>

Subgoal 2.6:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H8 : hasNeeded ((ID, C)::Known) Needed1 Needed
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) Clauses'
============================
 forall ID1 CK CC, mem (ID1, CK) Needed -&gt; mem (ID1, CC) CRest -&gt; false
</pre>
<pre class="code extensibella"id="2346">
 &lt; <b>intros MN MCR.</b>

Subgoal 2.6:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1 CK CC
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H8 : hasNeeded ((ID, C)::Known) Needed1 Needed
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) Clauses'
MN : mem (ID1, CK) Needed
MCR : mem (ID1, CC) CRest
============================
 false
</pre>
<pre class="code extensibella"id="2347">
 &lt; <b>MC: apply mem_after_select_before to _ MCR.</b>

Subgoal 2.6:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID ID1 CK CC
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H8 : hasNeeded ((ID, C)::Known) Needed1 Needed
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) Clauses'
MN : mem (ID1, CK) Needed
MCR : mem (ID1, CC) CRest
MC : mem (ID1, CC) Clauses
============================
 false
</pre>
<pre class="code extensibella"id="2348">
 &lt; <b>apply NoMemN to MN MC.</b>

Subgoal 2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H8 : hasNeeded ((ID, C)::Known) Needed1 Needed
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) Clauses'
H10 : forall ID1 CK CC, mem (ID1, CK) Needed -&gt; mem (ID1, CC) CRest -&gt; false
============================
 checkFratProof Clauses' Needed E
</pre>
<pre class="code extensibella"id="2349">
 &lt; <b>apply IH to _ _ _ _ _ _ _ _ _ CP2 Ela2 _ _ _ _ with
     Needed = Needed Clauses' = Clauses'.</b>

Subgoal 2:

Variables: Clauses Known CU E Needed Clauses' CRest Needed1 Rest C ID
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (addOriginal ID C Rest)
Ela : elaborateFratProof Clauses Known (addOriginal ID C Rest) CU E @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : select (ID, C) CRest Clauses
Ela2 : elaborateFratProof CRest ((ID, C)::Known) Rest Needed1 E *
Ela3 : select (ID, unknown) CU Needed1
Is : is_integer ID
Is1 : is_clause C
Is2 : is_fratProof Rest
CP1 : select (ID, C) CRest Clauses
CP2 : checkFratProof CRest ((ID, C)::Known) Rest
H1 : is_list (is_pair is_integer is_clause) CRest
H2 : is_integer ID
H3 : is_clause C
H4 : good_clause_list ((ID, C)::Known)
H5 : forall ID1 CK CC,
       mem (ID1, CK) ((ID, C)::Known) -&gt; mem (ID1, CC) CRest -&gt; false
H6 : good_clause_list CRest
H7 : hasNeeded ((ID, C)::Known) Needed1 ((ID, C)::Needed)
H8 : hasNeeded ((ID, C)::Known) Needed1 Needed
H9 : forall ID1 C1, mem (ID1, C1) CRest -&gt; mem (ID1, C1) Clauses'
H10 : forall ID1 CK CC, mem (ID1, CK) Needed -&gt; mem (ID1, CC) CRest -&gt; false
H11 : checkFratProof Clauses' Needed E
============================
 checkFratProof Clauses' Needed E
</pre>
<pre class="code extensibella"id="2350">
 &lt; <b>search.</b>

Subgoal 3:

Variables: Clauses Known CU Needed Clauses' E1 P1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsP : is_fratProof (endOriginal P1)
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (endOriginal P1)
Ela : elaborateFratProof Clauses Known (endOriginal P1) CU (endOriginal E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : elaborate Known P1 CU E1
============================
 checkFratProof Clauses' Needed (endOriginal E1)
</pre>
<pre class="code extensibella"id="2351">
 &lt; <b>case IsP.</b>

Subgoal 3:

Variables: Clauses Known CU Needed Clauses' E1 P1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
CP : checkFratProof Clauses Known (endOriginal P1)
Ela : elaborateFratProof Clauses Known (endOriginal P1) CU (endOriginal E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : elaborate Known P1 CU E1
H1 : is_proof P1
============================
 checkFratProof Clauses' Needed (endOriginal E1)
</pre>
<pre class="code extensibella"id="2352">
 &lt; <b>CP: case CP.</b>

Subgoal 3:

Variables: Clauses Known CU Needed Clauses' E1 P1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
Ela : elaborateFratProof Clauses Known (endOriginal P1) CU (endOriginal E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : elaborate Known P1 CU E1
H1 : is_proof P1
CP : checkProof Known P1
============================
 checkFratProof Clauses' Needed (endOriginal E1)
</pre>
<pre class="code extensibella"id="2353">
 &lt; <b>apply elaboration_valid to _ _ _ _ _ CP Ela1 HN.</b>

Subgoal 3:

Variables: Clauses Known CU Needed Clauses' E1 P1
IH : forall Clauses Known P CU E Needed Clauses',
       is_fratProof P -&gt; is_list (is_pair is_integer is_clause) Clauses -&gt; is_list (is_pair is_integer is_clause) Known -&gt;
       is_list (is_pair is_integer is_clause) Clauses' -&gt; is_list (is_pair is_integer is_clause) Needed -&gt;
       good_clause_list Clauses -&gt; good_clause_list Known -&gt; good_clause_list Clauses' -&gt;
       good_clause_list Needed -&gt; checkFratProof Clauses Known P -&gt; elaborateFratProof Clauses Known P CU E * -&gt;
       (forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false) -&gt;
       (forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses') -&gt; hasNeeded Known CU Needed -&gt;
       checkFratProof Clauses' Needed E
IsClauses : is_list (is_pair is_integer is_clause) Clauses
IsKnown : is_list (is_pair is_integer is_clause) Known
IsClauses' : is_list (is_pair is_integer is_clause) Clauses'
IsNeeded : is_list (is_pair is_integer is_clause) Needed
GCL_C : good_clause_list Clauses
GCL : good_clause_list Known
GCL_C' : good_clause_list Clauses'
GCL_N : good_clause_list Needed
Ela : elaborateFratProof Clauses Known (endOriginal P1) CU (endOriginal E1) @
NoMem : forall ID CK CC, mem (ID, CK) Known -&gt; mem (ID, CC) Clauses -&gt; false
NoMemN : forall ID CK CC, mem (ID, CK) Needed -&gt; mem (ID, CC) Clauses -&gt; false
MemsC : forall ID C, mem (ID, C) Clauses -&gt; mem (ID, C) Clauses'
HN : hasNeeded Known CU Needed
Ela1 : elaborate Known P1 CU E1
H1 : is_proof P1
CP : checkProof Known P1
H2 : checkProof Needed E1
============================
 checkFratProof Clauses' Needed (endOriginal E1)
</pre>
<pre class="code extensibella"id="2354">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="2355">
 &lt; <b>Theorem full_elaborationFrat_valid :
     forall F P P',
       is_formula F -&gt; is_fratProof P -&gt; fratProveFormula F P -&gt; fullElaborateFrat F P P' -&gt;
       fratProveFormula F P'.</b>

============================
 forall F P P',
   is_formula F -&gt; is_fratProof P -&gt; fratProveFormula F P -&gt; fullElaborateFrat F P P' -&gt;
   fratProveFormula F P'
</pre>
<pre class="code extensibella"id="2356">
 &lt; <b>intros IsF IsP PF FE.</b>

Variables: F P P'
IsF : is_formula F
IsP : is_fratProof P
PF : fratProveFormula F P
FE : fullElaborateFrat F P P'
============================
 fratProveFormula F P'
</pre>
<pre class="code extensibella"id="2357">
 &lt; <b>PF: case PF.</b>

Variables: F P P' KnownClauses
IsF : is_formula F
IsP : is_fratProof P
FE : fullElaborateFrat F P P'
PF : formulaToKnown 1 F KnownClauses
PF1 : checkFratProof KnownClauses [] P
============================
 fratProveFormula F P'
</pre>
<pre class="code extensibella"id="2358">
 &lt; <b>FE: case FE.</b>

Variables: F P P' KnownClauses Known Needed
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F KnownClauses
PF1 : checkFratProof KnownClauses [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
============================
 fratProveFormula F P'
</pre>
<pre class="code extensibella"id="2359">
 &lt; <b>apply formulaToKnown_is to _ _ PF.</b>

Variables: F P P' KnownClauses Known Needed
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F KnownClauses
PF1 : checkFratProof KnownClauses [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) KnownClauses
============================
 fratProveFormula F P'
</pre>
<pre class="code extensibella"id="2360">
 &lt; <b>GCL: assert good_clause_list KnownClauses.</b>

Subgoal 1:

Variables: F P P' KnownClauses Known Needed
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F KnownClauses
PF1 : checkFratProof KnownClauses [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) KnownClauses
============================
 good_clause_list KnownClauses
</pre>
<pre class="code extensibella"id="2361">
 &lt; <b>unfold .</b>

Subgoal 1:

Variables: F P P' KnownClauses Known Needed
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F KnownClauses
PF1 : checkFratProof KnownClauses [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) KnownClauses
============================
 forall ID C1 KRest C2,
   select (ID, C1) KRest KnownClauses -&gt; mem (ID, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="2362">
 &lt; <b>intros S M.</b>

Subgoal 1:

Variables: F P P' KnownClauses Known Needed ID C1 KRest C2
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F KnownClauses
PF1 : checkFratProof KnownClauses [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) KnownClauses
S : select (ID, C1) KRest KnownClauses
M : mem (ID, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="2363">
 &lt; <b>backchain formulaToKnown_all_unique.</b>

Variables: F P P' KnownClauses Known Needed
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F KnownClauses
PF1 : checkFratProof KnownClauses [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) KnownClauses
GCL : good_clause_list KnownClauses
============================
 fratProveFormula F P'
</pre>
<pre class="code extensibella"id="2364">
 &lt; <b>apply formulaToKnown_unique to _ _ PF FE.</b>

Variables: F P P' Known Needed
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
============================
 fratProveFormula F P'
</pre>
<pre class="code extensibella"id="2365">
 &lt; <b>HN: assert hasNeeded Known Needed Known.</b>

Subgoal 2:

Variables: F P P' Known Needed
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
============================
 hasNeeded Known Needed Known
</pre>
<pre class="code extensibella"id="2366">
 &lt; <b>unfold .</b>

Subgoal 2.1:

Variables: F P P' Known Needed
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
============================
 forall ID, mem (ID, needed) Needed -&gt; exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2367">
 &lt; <b>intros M.</b>

Subgoal 2.1:

Variables: F P P' Known Needed ID
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
M : mem (ID, needed) Needed
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2368">
 &lt; <b>M': apply elaborationFrat_all_mem to _ _ _ _ _ PF1 FE1 _ M.</b>

Subgoal 2.1.1:

Variables: F P P' Known Needed ID
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
M : mem (ID, needed) Needed
============================
 forall ID1 CK CC, mem (ID1, CK) [] -&gt; mem (ID1, CC) Known -&gt; false
</pre>
<pre class="code extensibella"id="2369">
 &lt; <b>intros M'.</b>

Subgoal 2.1.1:

Variables: F P P' Known Needed ID ID1 CK CC
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
M : mem (ID, needed) Needed
M' : mem (ID1, CK) []
H2 : mem (ID1, CC) Known
============================
 false
</pre>
<pre class="code extensibella"id="2370">
 &lt; <b>case M'.</b>

Subgoal 2.1.2:

Variables: F P P' Known Needed ID
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
M : mem (ID, needed) Needed
============================
 good_clause_list []
</pre>
<pre class="code extensibella"id="2371">
 &lt; <b>unfold .</b>

Subgoal 2.1.2:

Variables: F P P' Known Needed ID
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
M : mem (ID, needed) Needed
============================
 forall ID C1 KRest C2, select (ID, C1) KRest [] -&gt; mem (ID, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="2372">
 &lt; <b>intros S M'.</b>

Subgoal 2.1.2:

Variables: F P P' Known Needed ID ID1 C1 KRest C2
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
M : mem (ID, needed) Needed
S : select (ID1, C1) KRest []
M' : mem (ID1, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="2373">
 &lt; <b>S: case S.</b>

Subgoal 2.1:

Variables: F P P' Known Needed ID C
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
M : mem (ID, needed) Needed
M' : mem (ID, C) []
============================
 exists C, mem (ID, C) Known
</pre>
<pre class="code extensibella"id="2374">
 &lt; <b>case M'.</b>

Subgoal 2.2:

Variables: F P P' Known Needed
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
============================
 forall ID CN CK, mem (ID, CN) Known -&gt; mem (ID, CK) Known -&gt; CN = CK
</pre>
<pre class="code extensibella"id="2375">
 &lt; <b>intros M M'.</b>

Subgoal 2.2:

Variables: F P P' Known Needed ID CN CK
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
M : mem (ID, CN) Known
M' : mem (ID, CK) Known
============================
 CN = CK
</pre>
<pre class="code extensibella"id="2376">
 &lt; <b>apply good_clause_list_mems to _ M M'.</b>

Subgoal 2.2:

Variables: F P P' Known Needed ID CK
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
M : mem (ID, CK) Known
M' : mem (ID, CK) Known
============================
 CK = CK
</pre>
<pre class="code extensibella"id="2377">
 &lt; <b>search.</b>

Variables: F P P' Known Needed
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
HN : hasNeeded Known Needed Known
============================
 fratProveFormula F P'
</pre>
<pre class="code extensibella"id="2378">
 &lt; <b>assert good_clause_list [].</b>

Subgoal 3:

Variables: F P P' Known Needed
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
HN : hasNeeded Known Needed Known
============================
 good_clause_list []
</pre>
<pre class="code extensibella"id="2379">
 &lt; <b>unfold .</b>

Subgoal 3:

Variables: F P P' Known Needed
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
HN : hasNeeded Known Needed Known
============================
 forall ID C1 KRest C2, select (ID, C1) KRest [] -&gt; mem (ID, C2) KRest -&gt; false
</pre>
<pre class="code extensibella"id="2380">
 &lt; <b>intros S.</b>

Subgoal 3:

Variables: F P P' Known Needed ID C1 KRest C2
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
HN : hasNeeded Known Needed Known
S : select (ID, C1) KRest []
H2 : mem (ID, C2) KRest
============================
 false
</pre>
<pre class="code extensibella"id="2381">
 &lt; <b>case S.</b>

Variables: F P P' Known Needed
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
HN : hasNeeded Known Needed Known
H2 : good_clause_list []
============================
 fratProveFormula F P'
</pre>
<pre class="code extensibella"id="2382">
 &lt; <b>apply elaborationFrat_valid to _ _ _ _ _ _ _ _ _ PF1 FE1 _ _ _ _ with
     Needed = [].</b>

Subgoal 4:

Variables: F P P' Known Needed
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
HN : hasNeeded Known Needed Known
H2 : good_clause_list []
============================
 hasNeeded [] Needed []
</pre>
<pre class="code extensibella"id="2383">
 &lt; <b>unfold .</b>

Subgoal 4.1:

Variables: F P P' Known Needed
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
HN : hasNeeded Known Needed Known
H2 : good_clause_list []
============================
 forall ID, mem (ID, needed) Needed -&gt; exists C, mem (ID, C) []
</pre>
<pre class="code extensibella"id="2384">
 &lt; <b>intros M.</b>

Subgoal 4.1:

Variables: F P P' Known Needed ID
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
HN : hasNeeded Known Needed Known
H2 : good_clause_list []
M : mem (ID, needed) Needed
============================
 exists C, mem (ID, C) []
</pre>
<pre class="code extensibella"id="2385">
 &lt; <b>M'': apply elaborationFrat_all_mem to _ _ _ _ _ PF1 FE1 _ M.</b>

Subgoal 4.1.1:

Variables: F P P' Known Needed ID
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
HN : hasNeeded Known Needed Known
H2 : good_clause_list []
M : mem (ID, needed) Needed
============================
 forall ID1 CK CC, mem (ID1, CK) [] -&gt; mem (ID1, CC) Known -&gt; false
</pre>
<pre class="code extensibella"id="2386">
 &lt; <b>intros M'.</b>

Subgoal 4.1.1:

Variables: F P P' Known Needed ID ID1 CK CC
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
HN : hasNeeded Known Needed Known
H2 : good_clause_list []
M : mem (ID, needed) Needed
M' : mem (ID1, CK) []
H3 : mem (ID1, CC) Known
============================
 false
</pre>
<pre class="code extensibella"id="2387">
 &lt; <b>case M'.</b>

Subgoal 4.1:

Variables: F P P' Known Needed ID C
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
HN : hasNeeded Known Needed Known
H2 : good_clause_list []
M : mem (ID, needed) Needed
M'' : mem (ID, C) []
============================
 exists C, mem (ID, C) []
</pre>
<pre class="code extensibella"id="2388">
 &lt; <b>case M''.</b>

Subgoal 4.2:

Variables: F P P' Known Needed
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
HN : hasNeeded Known Needed Known
H2 : good_clause_list []
============================
 forall ID CN CK, mem (ID, CN) [] -&gt; mem (ID, CK) [] -&gt; CN = CK
</pre>
<pre class="code extensibella"id="2389">
 &lt; <b>intros MK MK'.</b>

Subgoal 4.2:

Variables: F P P' Known Needed ID CN CK
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
HN : hasNeeded Known Needed Known
H2 : good_clause_list []
MK : mem (ID, CN) []
MK' : mem (ID, CK) []
============================
 CN = CK
</pre>
<pre class="code extensibella"id="2390">
 &lt; <b>apply good_clause_list_mems to _ MK MK'.</b>

Subgoal 4.2:

Variables: F P P' Known Needed ID CK
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
HN : hasNeeded Known Needed Known
H2 : good_clause_list []
MK : mem (ID, CK) []
MK' : mem (ID, CK) []
============================
 CK = CK
</pre>
<pre class="code extensibella"id="2391">
 &lt; <b>search.</b>

Subgoal 5:

Variables: F P P' Known Needed
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
HN : hasNeeded Known Needed Known
H2 : good_clause_list []
============================
 forall ID CK CC, mem (ID, CK) [] -&gt; mem (ID, CC) Known -&gt; false
</pre>
<pre class="code extensibella"id="2392">
 &lt; <b>intros M.</b>

Subgoal 5:

Variables: F P P' Known Needed ID CK CC
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
HN : hasNeeded Known Needed Known
H2 : good_clause_list []
M : mem (ID, CK) []
H3 : mem (ID, CC) Known
============================
 false
</pre>
<pre class="code extensibella"id="2393">
 &lt; <b>case M.</b>

Subgoal 6:

Variables: F P P' Known Needed
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
HN : hasNeeded Known Needed Known
H2 : good_clause_list []
============================
 forall ID CK CC, mem (ID, CK) [] -&gt; mem (ID, CC) Known -&gt; false
</pre>
<pre class="code extensibella"id="2394">
 &lt; <b>intros M.</b>

Subgoal 6:

Variables: F P P' Known Needed ID CK CC
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
HN : hasNeeded Known Needed Known
H2 : good_clause_list []
M : mem (ID, CK) []
H3 : mem (ID, CC) Known
============================
 false
</pre>
<pre class="code extensibella"id="2395">
 &lt; <b>case M.</b>

Variables: F P P' Known Needed
IsF : is_formula F
IsP : is_fratProof P
PF : formulaToKnown 1 F Known
PF1 : checkFratProof Known [] P
FE : formulaToKnown 1 F Known
FE1 : elaborateFratProof Known [] P Needed P'
H1 : is_list (is_pair is_integer is_clause) Known
GCL : good_clause_list Known
HN : hasNeeded Known Needed Known
H2 : good_clause_list []
H3 : checkFratProof Known [] P'
============================
 fratProveFormula F P'
</pre>
<pre class="code extensibella"id="2396">
 &lt; <b>search.</b>

Proof completed.
</pre>
</div>
<div class="section">
<a class="navlink" href="../description.html">Back to example home</a>
</div>
</body>
</html>
