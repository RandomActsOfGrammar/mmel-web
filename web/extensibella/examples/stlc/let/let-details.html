<html>
<head>
<title>Extensibella:  Extensibella Example:  stlc:let - Details</title>
<link href="../../../../style.css" rel="stylesheet" type="text/css">
<script src="../../../../actions.js"></script>
<link rel="icon" href="../../../images/favicon.png" type="image/x-icon">
</head>
<body class="extensibella">
<div id="header-logo">
<a href="../../../index.html">
<img class="header-logo" src="../../../images/Extensibella.png" alt="Extensibella logo">
</a>
</div>
<h2>Reasoning Details</h2>
<div class="section">
<pre class="code extensibella">
 < <b>Module stlc:let.</b>
</pre>
<pre class="code extensibella"id="1">
 &lt; <b>Prove_Constraint stlc:host:proj_ty_is.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="2">
 &lt; <b>Prove stlc:host:type_is.</b>

Subgoal 6:

Variables: Ctx Ty Ty1 T2 T1 X
IH : forall Ctx T Ty,
       is_list (is_pair is_string is_ty) Ctx -&gt; is_tm T -&gt; typeOf Ctx T Ty * -&gt; is_ty Ty
IsCtx : is_list (is_pair is_string is_ty) Ctx
IsT : is_tm (let X T1 T2)
Ty : typeOf Ctx (let X T1 T2) Ty @
Ty1 : typeOf Ctx T1 Ty1 *
Ty2 : typeOf ((X, Ty1)::Ctx) T2 Ty *
============================
 is_ty Ty
</pre>
<pre class="code extensibella"id="3">
 &lt; <b>Is: case IsT.</b>

Subgoal 6:

Variables: Ctx Ty Ty1 T2 T1 X
IH : forall Ctx T Ty,
       is_list (is_pair is_string is_ty) Ctx -&gt; is_tm T -&gt; typeOf Ctx T Ty * -&gt; is_ty Ty
IsCtx : is_list (is_pair is_string is_ty) Ctx
Ty : typeOf Ctx (let X T1 T2) Ty @
Ty1 : typeOf Ctx T1 Ty1 *
Ty2 : typeOf ((X, Ty1)::Ctx) T2 Ty *
Is : is_string X
Is1 : is_tm T1
Is2 : is_tm T2
============================
 is_ty Ty
</pre>
<pre class="code extensibella"id="4">
 &lt; <b>apply IH to _ Is1 Ty1.</b>

Subgoal 6:

Variables: Ctx Ty Ty1 T2 T1 X
IH : forall Ctx T Ty,
       is_list (is_pair is_string is_ty) Ctx -&gt; is_tm T -&gt; typeOf Ctx T Ty * -&gt; is_ty Ty
IsCtx : is_list (is_pair is_string is_ty) Ctx
Ty : typeOf Ctx (let X T1 T2) Ty @
Ty1 : typeOf Ctx T1 Ty1 *
Ty2 : typeOf ((X, Ty1)::Ctx) T2 Ty *
Is : is_string X
Is1 : is_tm T1
Is2 : is_tm T2
H1 : is_ty Ty1
============================
 is_ty Ty
</pre>
<pre class="code extensibella"id="5">
 &lt; <b>apply IH to _ Is2 Ty2.</b>

Subgoal 6:

Variables: Ctx Ty Ty1 T2 T1 X
IH : forall Ctx T Ty,
       is_list (is_pair is_string is_ty) Ctx -&gt; is_tm T -&gt; typeOf Ctx T Ty * -&gt; is_ty Ty
IsCtx : is_list (is_pair is_string is_ty) Ctx
Ty : typeOf Ctx (let X T1 T2) Ty @
Ty1 : typeOf Ctx T1 Ty1 *
Ty2 : typeOf ((X, Ty1)::Ctx) T2 Ty *
Is : is_string X
Is1 : is_tm T1
Is2 : is_tm T2
H1 : is_ty Ty1
H2 : is_ty Ty
============================
 is_ty Ty
</pre>
<pre class="code extensibella"id="6">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="7">
 &lt; <b>Prove_Constraint stlc:host:proj_is.</b>

Variables: Ctx T1 T2 Ty X
Proj : Ctx |{tm}- let X T1 T2 ~~&gt; app (abs X Ty T2) T1
IsCtx : is_list (is_pair is_string is_ty) Ctx
IsT : is_tm (let X T1 T2)
Proj1 : typeOf Ctx T1 Ty
============================
 is_tm (app (abs X Ty T2) T1)
</pre>
<pre class="code extensibella"id="8">
 &lt; <b>case IsT.</b>

Variables: Ctx T1 T2 Ty X
Proj : Ctx |{tm}- let X T1 T2 ~~&gt; app (abs X Ty T2) T1
IsCtx : is_list (is_pair is_string is_ty) Ctx
Proj1 : typeOf Ctx T1 Ty
H1 : is_string X
H2 : is_tm T1
H3 : is_tm T2
============================
 is_tm (app (abs X Ty T2) T1)
</pre>
<pre class="code extensibella"id="9">
 &lt; <b>apply type_is to _ _ Proj1.</b>

Variables: Ctx T1 T2 Ty X
Proj : Ctx |{tm}- let X T1 T2 ~~&gt; app (abs X Ty T2) T1
IsCtx : is_list (is_pair is_string is_ty) Ctx
Proj1 : typeOf Ctx T1 Ty
H1 : is_string X
H2 : is_tm T1
H3 : is_tm T2
H4 : is_ty Ty
============================
 is_tm (app (abs X Ty T2) T1)
</pre>
<pre class="code extensibella"id="10">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="11">
 &lt; <b>Prove stlc:host:type_unique.</b>

Subgoal 6:

Variables: Ctx TyA TyB Ty1 T2 T1 X
IH : forall Ctx T TyA TyB,
       is_list (is_pair is_string is_ty) Ctx -&gt; is_tm T -&gt; typeOf Ctx T TyA * -&gt;
       typeOf Ctx T TyB -&gt; TyA = TyB
IsCtx : is_list (is_pair is_string is_ty) Ctx
IsT : is_tm (let X T1 T2)
TyA : typeOf Ctx (let X T1 T2) TyA @
TyB : typeOf Ctx (let X T1 T2) TyB
TyA1 : typeOf Ctx T1 Ty1 *
TyA2 : typeOf ((X, Ty1)::Ctx) T2 TyA *
============================
 TyA = TyB
</pre>
<pre class="code extensibella"id="12">
 &lt; <b>TyB: case TyB.</b>

Subgoal 6:

Variables: Ctx TyA TyB Ty1 T2 T1 X Ty2
IH : forall Ctx T TyA TyB,
       is_list (is_pair is_string is_ty) Ctx -&gt; is_tm T -&gt; typeOf Ctx T TyA * -&gt;
       typeOf Ctx T TyB -&gt; TyA = TyB
IsCtx : is_list (is_pair is_string is_ty) Ctx
IsT : is_tm (let X T1 T2)
TyA : typeOf Ctx (let X T1 T2) TyA @
TyA1 : typeOf Ctx T1 Ty1 *
TyA2 : typeOf ((X, Ty1)::Ctx) T2 TyA *
TyB : typeOf Ctx T1 Ty2
TyB1 : typeOf ((X, Ty2)::Ctx) T2 TyB
============================
 TyA = TyB
</pre>
<pre class="code extensibella"id="13">
 &lt; <b>case IsT.</b>

Subgoal 6:

Variables: Ctx TyA TyB Ty1 T2 T1 X Ty2
IH : forall Ctx T TyA TyB,
       is_list (is_pair is_string is_ty) Ctx -&gt; is_tm T -&gt; typeOf Ctx T TyA * -&gt;
       typeOf Ctx T TyB -&gt; TyA = TyB
IsCtx : is_list (is_pair is_string is_ty) Ctx
TyA : typeOf Ctx (let X T1 T2) TyA @
TyA1 : typeOf Ctx T1 Ty1 *
TyA2 : typeOf ((X, Ty1)::Ctx) T2 TyA *
TyB : typeOf Ctx T1 Ty2
TyB1 : typeOf ((X, Ty2)::Ctx) T2 TyB
H1 : is_string X
H2 : is_tm T1
H3 : is_tm T2
============================
 TyA = TyB
</pre>
<pre class="code extensibella"id="14">
 &lt; <b>apply IH to _ _ TyA1 TyB.</b>

Subgoal 6:

Variables: Ctx TyA TyB T2 T1 X Ty2
IH : forall Ctx T TyA TyB,
       is_list (is_pair is_string is_ty) Ctx -&gt; is_tm T -&gt; typeOf Ctx T TyA * -&gt;
       typeOf Ctx T TyB -&gt; TyA = TyB
IsCtx : is_list (is_pair is_string is_ty) Ctx
TyA : typeOf Ctx (let X T1 T2) TyA @
TyA1 : typeOf Ctx T1 Ty2 *
TyA2 : typeOf ((X, Ty2)::Ctx) T2 TyA *
TyB : typeOf Ctx T1 Ty2
TyB1 : typeOf ((X, Ty2)::Ctx) T2 TyB
H1 : is_string X
H2 : is_tm T1
H3 : is_tm T2
============================
 TyA = TyB
</pre>
<pre class="code extensibella"id="15">
 &lt; <b>apply type_is to _ _ TyA1.</b>

Subgoal 6:

Variables: Ctx TyA TyB T2 T1 X Ty2
IH : forall Ctx T TyA TyB,
       is_list (is_pair is_string is_ty) Ctx -&gt; is_tm T -&gt; typeOf Ctx T TyA * -&gt;
       typeOf Ctx T TyB -&gt; TyA = TyB
IsCtx : is_list (is_pair is_string is_ty) Ctx
TyA : typeOf Ctx (let X T1 T2) TyA @
TyA1 : typeOf Ctx T1 Ty2 *
TyA2 : typeOf ((X, Ty2)::Ctx) T2 TyA *
TyB : typeOf Ctx T1 Ty2
TyB1 : typeOf ((X, Ty2)::Ctx) T2 TyB
H1 : is_string X
H2 : is_tm T1
H3 : is_tm T2
H4 : is_ty Ty2
============================
 TyA = TyB
</pre>
<pre class="code extensibella"id="16">
 &lt; <b>apply IH to _ _ TyA2 TyB1.</b>

Subgoal 6:

Variables: Ctx TyB T2 T1 X Ty2
IH : forall Ctx T TyA TyB,
       is_list (is_pair is_string is_ty) Ctx -&gt; is_tm T -&gt; typeOf Ctx T TyA * -&gt;
       typeOf Ctx T TyB -&gt; TyA = TyB
IsCtx : is_list (is_pair is_string is_ty) Ctx
TyA : typeOf Ctx (let X T1 T2) TyB @
TyA1 : typeOf Ctx T1 Ty2 *
TyA2 : typeOf ((X, Ty2)::Ctx) T2 TyB *
TyB : typeOf Ctx T1 Ty2
TyB1 : typeOf ((X, Ty2)::Ctx) T2 TyB
H1 : is_string X
H2 : is_tm T1
H3 : is_tm T2
H4 : is_ty Ty2
============================
 TyB = TyB
</pre>
<pre class="code extensibella"id="17">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="18">
 &lt; <b>Prove_Constraint stlc:host:proj_ty_unique.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="19">
 &lt; <b>Prove_Constraint stlc:host:proj_tm_unique.</b>

Variables: Ctx TB T1 T2 Ty X
Hyp : Ctx |{tm}- let X T1 T2 ~~&gt; app (abs X Ty T2) T1
Hyp1 : Ctx |{tm}- let X T1 T2 ~~&gt; TB
Hyp2 : is_tm (let X T1 T2)
Hyp3 : is_list (is_pair is_string is_ty) Ctx
Hyp4 : typeOf Ctx T1 Ty
============================
 app (abs X Ty T2) T1 = TB
</pre>
<pre class="code extensibella"id="20">
 &lt; <b>case Hyp1.</b>

Variables: Ctx T1 T2 Ty X Ty1
Hyp : Ctx |{tm}- let X T1 T2 ~~&gt; app (abs X Ty T2) T1
Hyp2 : is_tm (let X T1 T2)
Hyp3 : is_list (is_pair is_string is_ty) Ctx
Hyp4 : typeOf Ctx T1 Ty
H1 : typeOf Ctx T1 Ty1
============================
 app (abs X Ty T2) T1 = app (abs X Ty1 T2) T1
</pre>
<pre class="code extensibella"id="21">
 &lt; <b>case Hyp2.</b>

Variables: Ctx T1 T2 Ty X Ty1
Hyp : Ctx |{tm}- let X T1 T2 ~~&gt; app (abs X Ty T2) T1
Hyp3 : is_list (is_pair is_string is_ty) Ctx
Hyp4 : typeOf Ctx T1 Ty
H1 : typeOf Ctx T1 Ty1
H2 : is_string X
H3 : is_tm T1
H4 : is_tm T2
============================
 app (abs X Ty T2) T1 = app (abs X Ty1 T2) T1
</pre>
<pre class="code extensibella"id="22">
 &lt; <b>apply type_unique to _ _ Hyp4 H1.</b>

Variables: Ctx T1 T2 X Ty1
Hyp : Ctx |{tm}- let X T1 T2 ~~&gt; app (abs X Ty1 T2) T1
Hyp3 : is_list (is_pair is_string is_ty) Ctx
Hyp4 : typeOf Ctx T1 Ty1
H1 : typeOf Ctx T1 Ty1
H2 : is_string X
H3 : is_tm T1
H4 : is_tm T2
============================
 app (abs X Ty1 T2) T1 = app (abs X Ty1 T2) T1
</pre>
<pre class="code extensibella"id="23">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="24">
 &lt; <b>Prove stlc:host:subst_is.</b>

Subgoal 8:

Variables: X R S2 S1 Y T2 T1
IH : forall X R T S,
       is_tm T -&gt; is_string X -&gt; is_tm R -&gt; subst X R T S * -&gt; is_tm S
IsT : is_tm (let Y T1 T2)
IsX : is_string X
IsR : is_tm R
S : subst X R (let Y T1 T2) (let Y S1 S2) @
S1 : X = Y -&gt; false
S2 : subst X R T1 S1 *
S3 : subst X R T2 S2 *
============================
 is_tm (let Y S1 S2)
</pre>
<pre class="code extensibella"id="25">
 &lt; <b>Is: case IsT.</b>

Subgoal 8:

Variables: X R S2 S1 Y T2 T1
IH : forall X R T S,
       is_tm T -&gt; is_string X -&gt; is_tm R -&gt; subst X R T S * -&gt; is_tm S
IsX : is_string X
IsR : is_tm R
S : subst X R (let Y T1 T2) (let Y S1 S2) @
S1 : X = Y -&gt; false
S2 : subst X R T1 S1 *
S3 : subst X R T2 S2 *
Is : is_string Y
Is1 : is_tm T1
Is2 : is_tm T2
============================
 is_tm (let Y S1 S2)
</pre>
<pre class="code extensibella"id="26">
 &lt; <b>apply IH to _ _ _ S2.</b>

Subgoal 8:

Variables: X R S2 S1 Y T2 T1
IH : forall X R T S,
       is_tm T -&gt; is_string X -&gt; is_tm R -&gt; subst X R T S * -&gt; is_tm S
IsX : is_string X
IsR : is_tm R
S : subst X R (let Y T1 T2) (let Y S1 S2) @
S1 : X = Y -&gt; false
S2 : subst X R T1 S1 *
S3 : subst X R T2 S2 *
Is : is_string Y
Is1 : is_tm T1
Is2 : is_tm T2
H1 : is_tm S1
============================
 is_tm (let Y S1 S2)
</pre>
<pre class="code extensibella"id="27">
 &lt; <b>apply IH to _ _ _ S3.</b>

Subgoal 8:

Variables: X R S2 S1 Y T2 T1
IH : forall X R T S,
       is_tm T -&gt; is_string X -&gt; is_tm R -&gt; subst X R T S * -&gt; is_tm S
IsX : is_string X
IsR : is_tm R
S : subst X R (let Y T1 T2) (let Y S1 S2) @
S1 : X = Y -&gt; false
S2 : subst X R T1 S1 *
S3 : subst X R T2 S2 *
Is : is_string Y
Is1 : is_tm T1
Is2 : is_tm T2
H1 : is_tm S1
H2 : is_tm S2
============================
 is_tm (let Y S1 S2)
</pre>
<pre class="code extensibella"id="28">
 &lt; <b>search.</b>

Subgoal 9:

Variables: X R T2 S1 T1
IH : forall X R T S,
       is_tm T -&gt; is_string X -&gt; is_tm R -&gt; subst X R T S * -&gt; is_tm S
IsT : is_tm (let X T1 T2)
IsX : is_string X
IsR : is_tm R
S : subst X R (let X T1 T2) (let X S1 T2) @
S1 : subst X R T1 S1 *
============================
 is_tm (let X S1 T2)
</pre>
<pre class="code extensibella"id="29">
 &lt; <b>Is: case IsT.</b>

Subgoal 9:

Variables: X R T2 S1 T1
IH : forall X R T S,
       is_tm T -&gt; is_string X -&gt; is_tm R -&gt; subst X R T S * -&gt; is_tm S
IsX : is_string X
IsR : is_tm R
S : subst X R (let X T1 T2) (let X S1 T2) @
S1 : subst X R T1 S1 *
Is : is_string X
Is1 : is_tm T1
Is2 : is_tm T2
============================
 is_tm (let X S1 T2)
</pre>
<pre class="code extensibella"id="30">
 &lt; <b>apply IH to _ _ _ S1.</b>

Subgoal 9:

Variables: X R T2 S1 T1
IH : forall X R T S,
       is_tm T -&gt; is_string X -&gt; is_tm R -&gt; subst X R T S * -&gt; is_tm S
IsX : is_string X
IsR : is_tm R
S : subst X R (let X T1 T2) (let X S1 T2) @
S1 : subst X R T1 S1 *
Is : is_string X
Is1 : is_tm T1
Is2 : is_tm T2
H1 : is_tm S1
============================
 is_tm (let X S1 T2)
</pre>
<pre class="code extensibella"id="31">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="32">
 &lt; <b>Prove stlc:host:eval_is.</b>

Subgoal 7:

Variables: T2 T11 X T1
IH : forall T T', is_tm T -&gt; eval T T' * -&gt; is_tm T'
IsT : is_tm (let X T1 T2)
Ev : eval (let X T1 T2) (let X T11 T2) @
Ev1 : eval T1 T11 *
============================
 is_tm (let X T11 T2)
</pre>
<pre class="code extensibella"id="33">
 &lt; <b>Is: case IsT.</b>

Subgoal 7:

Variables: T2 T11 X T1
IH : forall T T', is_tm T -&gt; eval T T' * -&gt; is_tm T'
Ev : eval (let X T1 T2) (let X T11 T2) @
Ev1 : eval T1 T11 *
Is : is_string X
Is1 : is_tm T1
Is2 : is_tm T2
============================
 is_tm (let X T11 T2)
</pre>
<pre class="code extensibella"id="34">
 &lt; <b>apply IH to _ Ev1.</b>

Subgoal 7:

Variables: T2 T11 X T1
IH : forall T T', is_tm T -&gt; eval T T' * -&gt; is_tm T'
Ev : eval (let X T1 T2) (let X T11 T2) @
Ev1 : eval T1 T11 *
Is : is_string X
Is1 : is_tm T1
Is2 : is_tm T2
H1 : is_tm T11
============================
 is_tm (let X T11 T2)
</pre>
<pre class="code extensibella"id="35">
 &lt; <b>search.</b>

Subgoal 8:

Variables: T' T2 T1 X
IH : forall T T', is_tm T -&gt; eval T T' * -&gt; is_tm T'
IsT : is_tm (let X T1 T2)
Ev : eval (let X T1 T2) T' @
Ev1 : value T1
Ev2 : subst X T1 T2 T'
============================
 is_tm T'
</pre>
<pre class="code extensibella"id="36">
 &lt; <b>Is: case IsT.</b>

Subgoal 8:

Variables: T' T2 T1 X
IH : forall T T', is_tm T -&gt; eval T T' * -&gt; is_tm T'
Ev : eval (let X T1 T2) T' @
Ev1 : value T1
Ev2 : subst X T1 T2 T'
Is : is_string X
Is1 : is_tm T1
Is2 : is_tm T2
============================
 is_tm T'
</pre>
<pre class="code extensibella"id="37">
 &lt; <b>apply subst_is to _ _ _ Ev2.</b>

Subgoal 8:

Variables: T' T2 T1 X
IH : forall T T', is_tm T -&gt; eval T T' * -&gt; is_tm T'
Ev : eval (let X T1 T2) T' @
Ev1 : value T1
Ev2 : subst X T1 T2 T'
Is : is_string X
Is1 : is_tm T1
Is2 : is_tm T2
H1 : is_tm T'
============================
 is_tm T'
</pre>
<pre class="code extensibella"id="38">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="39">
 &lt; <b>Prove stlc:host:subst_unique.</b>

Subgoal 8:

Variables: X R VB S2 S1 Y T2 T1
IH : forall X R T VA VB, subst X R T VA * -&gt; subst X R T VB -&gt; VA = VB
SA : subst X R (let Y T1 T2) (let Y S1 S2) @
SB : subst X R (let Y T1 T2) VB
SA1 : X = Y -&gt; false
SA2 : subst X R T1 S1 *
SA3 : subst X R T2 S2 *
============================
 let Y S1 S2 = VB
</pre>
<pre class="code extensibella"id="40">
 &lt; <b>SB: case SB.</b>

Subgoal 8.1:

Variables: X R S2 S1 Y T2 T1 S4 S3
IH : forall X R T VA VB, subst X R T VA * -&gt; subst X R T VB -&gt; VA = VB
SA : subst X R (let Y T1 T2) (let Y S1 S2) @
SA1 : X = Y -&gt; false
SA2 : subst X R T1 S1 *
SA3 : subst X R T2 S2 *
SB : X = Y -&gt; false
SB1 : subst X R T1 S3
SB2 : subst X R T2 S4
============================
 let Y S1 S2 = let Y S3 S4
</pre>
<pre class="code extensibella"id="41">
 &lt; <b>apply IH to SA2 SB1.</b>

Subgoal 8.1:

Variables: X R S2 Y T2 T1 S4 S3
IH : forall X R T VA VB, subst X R T VA * -&gt; subst X R T VB -&gt; VA = VB
SA : subst X R (let Y T1 T2) (let Y S3 S2) @
SA1 : X = Y -&gt; false
SA2 : subst X R T1 S3 *
SA3 : subst X R T2 S2 *
SB : X = Y -&gt; false
SB1 : subst X R T1 S3
SB2 : subst X R T2 S4
============================
 let Y S3 S2 = let Y S3 S4
</pre>
<pre class="code extensibella"id="42">
 &lt; <b>apply IH to SA3 SB2.</b>

Subgoal 8.1:

Variables: X R Y T2 T1 S4 S3
IH : forall X R T VA VB, subst X R T VA * -&gt; subst X R T VB -&gt; VA = VB
SA : subst X R (let Y T1 T2) (let Y S3 S4) @
SA1 : X = Y -&gt; false
SA2 : subst X R T1 S3 *
SA3 : subst X R T2 S4 *
SB : X = Y -&gt; false
SB1 : subst X R T1 S3
SB2 : subst X R T2 S4
============================
 let Y S3 S4 = let Y S3 S4
</pre>
<pre class="code extensibella"id="43">
 &lt; <b>search.</b>

Subgoal 8.2:

Variables: R S2 S1 Y T2 T1 S3
IH : forall X R T VA VB, subst X R T VA * -&gt; subst X R T VB -&gt; VA = VB
SA : subst Y R (let Y T1 T2) (let Y S1 S2) @
SA1 : Y = Y -&gt; false
SA2 : subst Y R T1 S1 *
SA3 : subst Y R T2 S2 *
SB : subst Y R T1 S3
============================
 let Y S1 S2 = let Y S3 T2
</pre>
<pre class="code extensibella"id="44">
 &lt; <b>apply SA1 to _.</b>

Subgoal 9:

Variables: X R VB T2 S1 T1
IH : forall X R T VA VB, subst X R T VA * -&gt; subst X R T VB -&gt; VA = VB
SA : subst X R (let X T1 T2) (let X S1 T2) @
SB : subst X R (let X T1 T2) VB
SA1 : subst X R T1 S1 *
============================
 let X S1 T2 = VB
</pre>
<pre class="code extensibella"id="45">
 &lt; <b>SB: case SB.</b>

Subgoal 9.1:

Variables: X R T2 S1 T1 S3 S2
IH : forall X R T VA VB, subst X R T VA * -&gt; subst X R T VB -&gt; VA = VB
SA : subst X R (let X T1 T2) (let X S1 T2) @
SA1 : subst X R T1 S1 *
SB : X = X -&gt; false
SB1 : subst X R T1 S2
SB2 : subst X R T2 S3
============================
 let X S1 T2 = let X S2 S3
</pre>
<pre class="code extensibella"id="46">
 &lt; <b>apply SB to _.</b>

Subgoal 9.2:

Variables: X R T2 S1 T1 S2
IH : forall X R T VA VB, subst X R T VA * -&gt; subst X R T VB -&gt; VA = VB
SA : subst X R (let X T1 T2) (let X S1 T2) @
SA1 : subst X R T1 S1 *
SB : subst X R T1 S2
============================
 let X S1 T2 = let X S2 T2
</pre>
<pre class="code extensibella"id="47">
 &lt; <b>apply IH to SA1 SB.</b>

Subgoal 9.2:

Variables: X R T2 T1 S2
IH : forall X R T VA VB, subst X R T VA * -&gt; subst X R T VB -&gt; VA = VB
SA : subst X R (let X T1 T2) (let X S2 T2) @
SA1 : subst X R T1 S2 *
SB : subst X R T1 S2
============================
 let X S2 T2 = let X S2 T2
</pre>
<pre class="code extensibella"id="48">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="49">
 &lt; <b>Prove stlc:host:value_eval_false.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="50">
 &lt; <b>Prove stlc:host:eval_unique.</b>

Subgoal 7:

Variables: VB T2 T11 X T1
IH : forall T VA VB, eval T VA * -&gt; eval T VB -&gt; VA = VB
EvA : eval (let X T1 T2) (let X T11 T2) @
EvB : eval (let X T1 T2) VB
EvA1 : eval T1 T11 *
============================
 let X T11 T2 = VB
</pre>
<pre class="code extensibella"id="51">
 &lt; <b>EvB: case EvB.</b>

Subgoal 7.1:

Variables: T2 T11 X T1 T5
IH : forall T VA VB, eval T VA * -&gt; eval T VB -&gt; VA = VB
EvA : eval (let X T1 T2) (let X T11 T2) @
EvA1 : eval T1 T11 *
EvB : eval T1 T5
============================
 let X T11 T2 = let X T5 T2
</pre>
<pre class="code extensibella"id="52">
 &lt; <b>apply IH to EvA1 EvB.</b>

Subgoal 7.1:

Variables: T2 X T1 T5
IH : forall T VA VB, eval T VA * -&gt; eval T VB -&gt; VA = VB
EvA : eval (let X T1 T2) (let X T5 T2) @
EvA1 : eval T1 T5 *
EvB : eval T1 T5
============================
 let X T5 T2 = let X T5 T2
</pre>
<pre class="code extensibella"id="53">
 &lt; <b>search.</b>

Subgoal 7.2:

Variables: VB T2 T11 X T1
IH : forall T VA VB, eval T VA * -&gt; eval T VB -&gt; VA = VB
EvA : eval (let X T1 T2) (let X T11 T2) @
EvA1 : eval T1 T11 *
EvB : value T1
EvB1 : subst X T1 T2 VB
============================
 let X T11 T2 = VB
</pre>
<pre class="code extensibella"id="54">
 &lt; <b>apply value_eval_false to EvB EvA1.</b>

Subgoal 8:

Variables: VA VB T2 T1 X
IH : forall T VA VB, eval T VA * -&gt; eval T VB -&gt; VA = VB
EvA : eval (let X T1 T2) VA @
EvB : eval (let X T1 T2) VB
EvA1 : value T1
EvA2 : subst X T1 T2 VA
============================
 VA = VB
</pre>
<pre class="code extensibella"id="55">
 &lt; <b>EvB: case EvB.</b>

Subgoal 8.1:

Variables: VA T2 T1 X T11
IH : forall T VA VB, eval T VA * -&gt; eval T VB -&gt; VA = VB
EvA : eval (let X T1 T2) VA @
EvA1 : value T1
EvA2 : subst X T1 T2 VA
EvB : eval T1 T11
============================
 VA = let X T11 T2
</pre>
<pre class="code extensibella"id="56">
 &lt; <b>apply value_eval_false to EvA1 EvB.</b>

Subgoal 8.2:

Variables: VA VB T2 T1 X
IH : forall T VA VB, eval T VA * -&gt; eval T VB -&gt; VA = VB
EvA : eval (let X T1 T2) VA @
EvA1 : value T1
EvA2 : subst X T1 T2 VA
EvB : value T1
EvB1 : subst X T1 T2 VB
============================
 VA = VB
</pre>
<pre class="code extensibella"id="57">
 &lt; <b>apply subst_unique to EvA2 EvB1.</b>

Subgoal 8.2:

Variables: VB T2 T1 X
IH : forall T VA VB, eval T VA * -&gt; eval T VB -&gt; VA = VB
EvA : eval (let X T1 T2) VB @
EvA1 : value T1
EvA2 : subst X T1 T2 VB
EvB : value T1
EvB1 : subst X T1 T2 VB
============================
 VB = VB
</pre>
<pre class="code extensibella"id="58">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="59">
 &lt; <b>Prove stlc:host:ty_lookup.</b>

Subgoal 6:

Variables: Ctx1 Ctx2 Ty Ty1 T2 T1 X
IH : forall Ctx1 Ctx2 T Ty,
       typeOf Ctx1 T Ty * -&gt; (forall X XTy,
         lookup Ctx1 X XTy -&gt; lookup Ctx2 X XTy) -&gt; typeOf Ctx2 T Ty
Ty : typeOf Ctx1 (let X T1 T2) Ty @
L : forall X XTy, lookup Ctx1 X XTy -&gt; lookup Ctx2 X XTy
Ty1 : typeOf Ctx1 T1 Ty1 *
Ty2 : typeOf ((X, Ty1)::Ctx1) T2 Ty *
============================
 typeOf Ctx2 (let X T1 T2) Ty
</pre>
<pre class="code extensibella"id="60">
 &lt; <b>apply IH to Ty1 L.</b>

Subgoal 6:

Variables: Ctx1 Ctx2 Ty Ty1 T2 T1 X
IH : forall Ctx1 Ctx2 T Ty,
       typeOf Ctx1 T Ty * -&gt; (forall X XTy,
         lookup Ctx1 X XTy -&gt; lookup Ctx2 X XTy) -&gt; typeOf Ctx2 T Ty
Ty : typeOf Ctx1 (let X T1 T2) Ty @
L : forall X XTy, lookup Ctx1 X XTy -&gt; lookup Ctx2 X XTy
Ty1 : typeOf Ctx1 T1 Ty1 *
Ty2 : typeOf ((X, Ty1)::Ctx1) T2 Ty *
H1 : typeOf Ctx2 T1 Ty1
============================
 typeOf Ctx2 (let X T1 T2) Ty
</pre>
<pre class="code extensibella"id="61">
 &lt; <b>apply IH to Ty2 _ with
     Ctx2 = (X, Ty1)::Ctx2.</b>

Subgoal 6.1:

Variables: Ctx1 Ctx2 Ty Ty1 T2 T1 X
IH : forall Ctx1 Ctx2 T Ty,
       typeOf Ctx1 T Ty * -&gt; (forall X XTy,
         lookup Ctx1 X XTy -&gt; lookup Ctx2 X XTy) -&gt; typeOf Ctx2 T Ty
Ty : typeOf Ctx1 (let X T1 T2) Ty @
L : forall X XTy, lookup Ctx1 X XTy -&gt; lookup Ctx2 X XTy
Ty1 : typeOf Ctx1 T1 Ty1 *
Ty2 : typeOf ((X, Ty1)::Ctx1) T2 Ty *
H1 : typeOf Ctx2 T1 Ty1
============================
 forall X1 XTy, lookup ((X, Ty1)::Ctx1) X1 XTy -&gt; lookup ((X, Ty1)::Ctx2) X1 XTy
</pre>
<pre class="code extensibella"id="62">
 &lt; <b>intros Lkp.</b>

Subgoal 6.1:

Variables: Ctx1 Ctx2 Ty Ty1 T2 T1 X X1 XTy
IH : forall Ctx1 Ctx2 T Ty,
       typeOf Ctx1 T Ty * -&gt; (forall X XTy,
         lookup Ctx1 X XTy -&gt; lookup Ctx2 X XTy) -&gt; typeOf Ctx2 T Ty
Ty : typeOf Ctx1 (let X T1 T2) Ty @
L : forall X XTy, lookup Ctx1 X XTy -&gt; lookup Ctx2 X XTy
Ty1 : typeOf Ctx1 T1 Ty1 *
Ty2 : typeOf ((X, Ty1)::Ctx1) T2 Ty *
H1 : typeOf Ctx2 T1 Ty1
Lkp : lookup ((X, Ty1)::Ctx1) X1 XTy
============================
 lookup ((X, Ty1)::Ctx2) X1 XTy
</pre>
<pre class="code extensibella"id="63">
 &lt; <b>Lkp: case Lkp.</b>

Subgoal 6.1.1:

Variables: Ctx1 Ctx2 Ty T2 T1 X1 XTy
IH : forall Ctx1 Ctx2 T Ty,
       typeOf Ctx1 T Ty * -&gt; (forall X XTy,
         lookup Ctx1 X XTy -&gt; lookup Ctx2 X XTy) -&gt; typeOf Ctx2 T Ty
Ty : typeOf Ctx1 (let X1 T1 T2) Ty @
L : forall X XTy, lookup Ctx1 X XTy -&gt; lookup Ctx2 X XTy
Ty1 : typeOf Ctx1 T1 XTy *
Ty2 : typeOf ((X1, XTy)::Ctx1) T2 Ty *
H1 : typeOf Ctx2 T1 XTy
============================
 lookup ((X1, XTy)::Ctx2) X1 XTy
</pre>
<pre class="code extensibella"id="64">
 &lt; <b>search.</b>

Subgoal 6.1.2:

Variables: Ctx1 Ctx2 Ty Ty1 T2 T1 X X1 XTy
IH : forall Ctx1 Ctx2 T Ty,
       typeOf Ctx1 T Ty * -&gt; (forall X XTy,
         lookup Ctx1 X XTy -&gt; lookup Ctx2 X XTy) -&gt; typeOf Ctx2 T Ty
Ty : typeOf Ctx1 (let X T1 T2) Ty @
L : forall X XTy, lookup Ctx1 X XTy -&gt; lookup Ctx2 X XTy
Ty1 : typeOf Ctx1 T1 Ty1 *
Ty2 : typeOf ((X, Ty1)::Ctx1) T2 Ty *
H1 : typeOf Ctx2 T1 Ty1
Lkp : X = X1 -&gt; false
Lkp1 : lookup Ctx1 X1 XTy
============================
 lookup ((X, Ty1)::Ctx2) X1 XTy
</pre>
<pre class="code extensibella"id="65">
 &lt; <b>apply L to Lkp1.</b>

Subgoal 6.1.2:

Variables: Ctx1 Ctx2 Ty Ty1 T2 T1 X X1 XTy
IH : forall Ctx1 Ctx2 T Ty,
       typeOf Ctx1 T Ty * -&gt; (forall X XTy,
         lookup Ctx1 X XTy -&gt; lookup Ctx2 X XTy) -&gt; typeOf Ctx2 T Ty
Ty : typeOf Ctx1 (let X T1 T2) Ty @
L : forall X XTy, lookup Ctx1 X XTy -&gt; lookup Ctx2 X XTy
Ty1 : typeOf Ctx1 T1 Ty1 *
Ty2 : typeOf ((X, Ty1)::Ctx1) T2 Ty *
H1 : typeOf Ctx2 T1 Ty1
Lkp : X = X1 -&gt; false
Lkp1 : lookup Ctx1 X1 XTy
H2 : lookup Ctx2 X1 XTy
============================
 lookup ((X, Ty1)::Ctx2) X1 XTy
</pre>
<pre class="code extensibella"id="66">
 &lt; <b>search.</b>

Subgoal 6:

Variables: Ctx1 Ctx2 Ty Ty1 T2 T1 X
IH : forall Ctx1 Ctx2 T Ty,
       typeOf Ctx1 T Ty * -&gt; (forall X XTy,
         lookup Ctx1 X XTy -&gt; lookup Ctx2 X XTy) -&gt; typeOf Ctx2 T Ty
Ty : typeOf Ctx1 (let X T1 T2) Ty @
L : forall X XTy, lookup Ctx1 X XTy -&gt; lookup Ctx2 X XTy
Ty1 : typeOf Ctx1 T1 Ty1 *
Ty2 : typeOf ((X, Ty1)::Ctx1) T2 Ty *
H1 : typeOf Ctx2 T1 Ty1
H2 : typeOf ((X, Ty1)::Ctx2) T2 Ty
============================
 typeOf Ctx2 (let X T1 T2) Ty
</pre>
<pre class="code extensibella"id="67">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="68">
 &lt; <b>Prove stlc:host:subst_type_preservation.</b>

Subgoal 8:

Variables: Ctx X XTy Ty R S2 S1 Y T2 T1
IH : forall T Ctx X XTy Ty R S,
       typeOf ((X, XTy)::Ctx) T Ty -&gt; subst X R T S * -&gt; typeOf [] R XTy -&gt; typeOf Ctx S Ty
TTy : typeOf ((X, XTy)::Ctx) (let Y T1 T2) Ty
S : subst X R (let Y T1 T2) (let Y S1 S2) @
RTy : typeOf [] R XTy
S1 : X = Y -&gt; false
S2 : subst X R T1 S1 *
S3 : subst X R T2 S2 *
============================
 typeOf Ctx (let Y S1 S2) Ty
</pre>
<pre class="code extensibella"id="69">
 &lt; <b>Ty: case TTy.</b>

Subgoal 8:

Variables: Ctx X XTy Ty R S2 S1 Y T2 T1 Ty1
IH : forall T Ctx X XTy Ty R S,
       typeOf ((X, XTy)::Ctx) T Ty -&gt; subst X R T S * -&gt; typeOf [] R XTy -&gt; typeOf Ctx S Ty
S : subst X R (let Y T1 T2) (let Y S1 S2) @
RTy : typeOf [] R XTy
S1 : X = Y -&gt; false
S2 : subst X R T1 S1 *
S3 : subst X R T2 S2 *
Ty : typeOf ((X, XTy)::Ctx) T1 Ty1
Ty1 : typeOf ((Y, Ty1)::((X, XTy)::Ctx)) T2 Ty
============================
 typeOf Ctx (let Y S1 S2) Ty
</pre>
<pre class="code extensibella"id="70">
 &lt; <b>apply IH to Ty S2 RTy.</b>

Subgoal 8:

Variables: Ctx X XTy Ty R S2 S1 Y T2 T1 Ty1
IH : forall T Ctx X XTy Ty R S,
       typeOf ((X, XTy)::Ctx) T Ty -&gt; subst X R T S * -&gt; typeOf [] R XTy -&gt; typeOf Ctx S Ty
S : subst X R (let Y T1 T2) (let Y S1 S2) @
RTy : typeOf [] R XTy
S1 : X = Y -&gt; false
S2 : subst X R T1 S1 *
S3 : subst X R T2 S2 *
Ty : typeOf ((X, XTy)::Ctx) T1 Ty1
Ty1 : typeOf ((Y, Ty1)::((X, XTy)::Ctx)) T2 Ty
H1 : typeOf Ctx S1 Ty1
============================
 typeOf Ctx (let Y S1 S2) Ty
</pre>
<pre class="code extensibella"id="71">
 &lt; <b>Ty': apply ty_lookup to Ty1 _ with
          Ctx2 = (X, XTy)::((Y, Ty1)::Ctx).</b>

Subgoal 8.1:

Variables: Ctx X XTy Ty R S2 S1 Y T2 T1 Ty1
IH : forall T Ctx X XTy Ty R S,
       typeOf ((X, XTy)::Ctx) T Ty -&gt; subst X R T S * -&gt; typeOf [] R XTy -&gt; typeOf Ctx S Ty
S : subst X R (let Y T1 T2) (let Y S1 S2) @
RTy : typeOf [] R XTy
S1 : X = Y -&gt; false
S2 : subst X R T1 S1 *
S3 : subst X R T2 S2 *
Ty : typeOf ((X, XTy)::Ctx) T1 Ty1
Ty1 : typeOf ((Y, Ty1)::((X, XTy)::Ctx)) T2 Ty
H1 : typeOf Ctx S1 Ty1
============================
 forall X1 XTy1,
   lookup ((Y, Ty1)::((X, XTy)::Ctx)) X1 XTy1 -&gt; lookup ((X, XTy)::((Y, Ty1)::Ctx)) X1 XTy1
</pre>
<pre class="code extensibella"id="72">
 &lt; <b>intros L.</b>

Subgoal 8.1:

Variables: Ctx X XTy Ty R S2 S1 Y T2 T1 Ty1 X1 XTy1
IH : forall T Ctx X XTy Ty R S,
       typeOf ((X, XTy)::Ctx) T Ty -&gt; subst X R T S * -&gt; typeOf [] R XTy -&gt; typeOf Ctx S Ty
S : subst X R (let Y T1 T2) (let Y S1 S2) @
RTy : typeOf [] R XTy
S1 : X = Y -&gt; false
S2 : subst X R T1 S1 *
S3 : subst X R T2 S2 *
Ty : typeOf ((X, XTy)::Ctx) T1 Ty1
Ty1 : typeOf ((Y, Ty1)::((X, XTy)::Ctx)) T2 Ty
H1 : typeOf Ctx S1 Ty1
L : lookup ((Y, Ty1)::((X, XTy)::Ctx)) X1 XTy1
============================
 lookup ((X, XTy)::((Y, Ty1)::Ctx)) X1 XTy1
</pre>
<pre class="code extensibella"id="73">
 &lt; <b>L: case L.</b>

Subgoal 8.1.1:

Variables: Ctx X XTy Ty R S2 S1 T2 T1 X1 XTy1
IH : forall T Ctx X XTy Ty R S,
       typeOf ((X, XTy)::Ctx) T Ty -&gt; subst X R T S * -&gt; typeOf [] R XTy -&gt; typeOf Ctx S Ty
S : subst X R (let X1 T1 T2) (let X1 S1 S2) @
RTy : typeOf [] R XTy
S1 : X = X1 -&gt; false
S2 : subst X R T1 S1 *
S3 : subst X R T2 S2 *
Ty : typeOf ((X, XTy)::Ctx) T1 XTy1
Ty1 : typeOf ((X1, XTy1)::((X, XTy)::Ctx)) T2 Ty
H1 : typeOf Ctx S1 XTy1
============================
 lookup ((X, XTy)::((X1, XTy1)::Ctx)) X1 XTy1
</pre>
<pre class="code extensibella"id="74">
 &lt; <b>search.</b>

Subgoal 8.1.2:

Variables: Ctx X XTy Ty R S2 S1 Y T2 T1 Ty1 X1 XTy1
IH : forall T Ctx X XTy Ty R S,
       typeOf ((X, XTy)::Ctx) T Ty -&gt; subst X R T S * -&gt; typeOf [] R XTy -&gt; typeOf Ctx S Ty
S : subst X R (let Y T1 T2) (let Y S1 S2) @
RTy : typeOf [] R XTy
S1 : X = Y -&gt; false
S2 : subst X R T1 S1 *
S3 : subst X R T2 S2 *
Ty : typeOf ((X, XTy)::Ctx) T1 Ty1
Ty1 : typeOf ((Y, Ty1)::((X, XTy)::Ctx)) T2 Ty
H1 : typeOf Ctx S1 Ty1
L : Y = X1 -&gt; false
L1 : lookup ((X, XTy)::Ctx) X1 XTy1
============================
 lookup ((X, XTy)::((Y, Ty1)::Ctx)) X1 XTy1
</pre>
<pre class="code extensibella"id="75">
 &lt; <b>L: case L1.</b>

Subgoal 8.1.2.1:

Variables: Ctx Ty R S2 S1 Y T2 T1 Ty1 X1 XTy1
IH : forall T Ctx X XTy Ty R S,
       typeOf ((X, XTy)::Ctx) T Ty -&gt; subst X R T S * -&gt; typeOf [] R XTy -&gt; typeOf Ctx S Ty
S : subst X1 R (let Y T1 T2) (let Y S1 S2) @
RTy : typeOf [] R XTy1
S1 : X1 = Y -&gt; false
S2 : subst X1 R T1 S1 *
S3 : subst X1 R T2 S2 *
Ty : typeOf ((X1, XTy1)::Ctx) T1 Ty1
Ty1 : typeOf ((Y, Ty1)::((X1, XTy1)::Ctx)) T2 Ty
H1 : typeOf Ctx S1 Ty1
L : Y = X1 -&gt; false
============================
 lookup ((X1, XTy1)::((Y, Ty1)::Ctx)) X1 XTy1
</pre>
<pre class="code extensibella"id="76">
 &lt; <b>search.</b>

Subgoal 8.1.2.2:

Variables: Ctx X XTy Ty R S2 S1 Y T2 T1 Ty1 X1 XTy1
IH : forall T Ctx X XTy Ty R S,
       typeOf ((X, XTy)::Ctx) T Ty -&gt; subst X R T S * -&gt; typeOf [] R XTy -&gt; typeOf Ctx S Ty
S : subst X R (let Y T1 T2) (let Y S1 S2) @
RTy : typeOf [] R XTy
S1 : X = Y -&gt; false
S2 : subst X R T1 S1 *
S3 : subst X R T2 S2 *
Ty : typeOf ((X, XTy)::Ctx) T1 Ty1
Ty1 : typeOf ((Y, Ty1)::((X, XTy)::Ctx)) T2 Ty
H1 : typeOf Ctx S1 Ty1
L : Y = X1 -&gt; false
L1 : X = X1 -&gt; false
L2 : lookup Ctx X1 XTy1
============================
 lookup ((X, XTy)::((Y, Ty1)::Ctx)) X1 XTy1
</pre>
<pre class="code extensibella"id="77">
 &lt; <b>search.</b>

Subgoal 8:

Variables: Ctx X XTy Ty R S2 S1 Y T2 T1 Ty1
IH : forall T Ctx X XTy Ty R S,
       typeOf ((X, XTy)::Ctx) T Ty -&gt; subst X R T S * -&gt; typeOf [] R XTy -&gt; typeOf Ctx S Ty
S : subst X R (let Y T1 T2) (let Y S1 S2) @
RTy : typeOf [] R XTy
S1 : X = Y -&gt; false
S2 : subst X R T1 S1 *
S3 : subst X R T2 S2 *
Ty : typeOf ((X, XTy)::Ctx) T1 Ty1
Ty1 : typeOf ((Y, Ty1)::((X, XTy)::Ctx)) T2 Ty
H1 : typeOf Ctx S1 Ty1
Ty' : typeOf ((X, XTy)::((Y, Ty1)::Ctx)) T2 Ty
============================
 typeOf Ctx (let Y S1 S2) Ty
</pre>
<pre class="code extensibella"id="78">
 &lt; <b>apply IH to Ty' S3 RTy.</b>

Subgoal 8:

Variables: Ctx X XTy Ty R S2 S1 Y T2 T1 Ty1
IH : forall T Ctx X XTy Ty R S,
       typeOf ((X, XTy)::Ctx) T Ty -&gt; subst X R T S * -&gt; typeOf [] R XTy -&gt; typeOf Ctx S Ty
S : subst X R (let Y T1 T2) (let Y S1 S2) @
RTy : typeOf [] R XTy
S1 : X = Y -&gt; false
S2 : subst X R T1 S1 *
S3 : subst X R T2 S2 *
Ty : typeOf ((X, XTy)::Ctx) T1 Ty1
Ty1 : typeOf ((Y, Ty1)::((X, XTy)::Ctx)) T2 Ty
H1 : typeOf Ctx S1 Ty1
Ty' : typeOf ((X, XTy)::((Y, Ty1)::Ctx)) T2 Ty
H2 : typeOf ((Y, Ty1)::Ctx) S2 Ty
============================
 typeOf Ctx (let Y S1 S2) Ty
</pre>
<pre class="code extensibella"id="79">
 &lt; <b>search.</b>

Subgoal 9:

Variables: Ctx X XTy Ty R T2 S1 T1
IH : forall T Ctx X XTy Ty R S,
       typeOf ((X, XTy)::Ctx) T Ty -&gt; subst X R T S * -&gt; typeOf [] R XTy -&gt; typeOf Ctx S Ty
TTy : typeOf ((X, XTy)::Ctx) (let X T1 T2) Ty
S : subst X R (let X T1 T2) (let X S1 T2) @
RTy : typeOf [] R XTy
S1 : subst X R T1 S1 *
============================
 typeOf Ctx (let X S1 T2) Ty
</pre>
<pre class="code extensibella"id="80">
 &lt; <b>Ty: case TTy.</b>

Subgoal 9:

Variables: Ctx X XTy Ty R T2 S1 T1 Ty1
IH : forall T Ctx X XTy Ty R S,
       typeOf ((X, XTy)::Ctx) T Ty -&gt; subst X R T S * -&gt; typeOf [] R XTy -&gt; typeOf Ctx S Ty
S : subst X R (let X T1 T2) (let X S1 T2) @
RTy : typeOf [] R XTy
S1 : subst X R T1 S1 *
Ty : typeOf ((X, XTy)::Ctx) T1 Ty1
Ty1 : typeOf ((X, Ty1)::((X, XTy)::Ctx)) T2 Ty
============================
 typeOf Ctx (let X S1 T2) Ty
</pre>
<pre class="code extensibella"id="81">
 &lt; <b>apply IH to Ty S1 RTy.</b>

Subgoal 9:

Variables: Ctx X XTy Ty R T2 S1 T1 Ty1
IH : forall T Ctx X XTy Ty R S,
       typeOf ((X, XTy)::Ctx) T Ty -&gt; subst X R T S * -&gt; typeOf [] R XTy -&gt; typeOf Ctx S Ty
S : subst X R (let X T1 T2) (let X S1 T2) @
RTy : typeOf [] R XTy
S1 : subst X R T1 S1 *
Ty : typeOf ((X, XTy)::Ctx) T1 Ty1
Ty1 : typeOf ((X, Ty1)::((X, XTy)::Ctx)) T2 Ty
H1 : typeOf Ctx S1 Ty1
============================
 typeOf Ctx (let X S1 T2) Ty
</pre>
<pre class="code extensibella"id="82">
 &lt; <b>apply ty_lookup to Ty1 _ with
     Ctx2 = (X, Ty1)::Ctx.</b>

Subgoal 9.1:

Variables: Ctx X XTy Ty R T2 S1 T1 Ty1
IH : forall T Ctx X XTy Ty R S,
       typeOf ((X, XTy)::Ctx) T Ty -&gt; subst X R T S * -&gt; typeOf [] R XTy -&gt; typeOf Ctx S Ty
S : subst X R (let X T1 T2) (let X S1 T2) @
RTy : typeOf [] R XTy
S1 : subst X R T1 S1 *
Ty : typeOf ((X, XTy)::Ctx) T1 Ty1
Ty1 : typeOf ((X, Ty1)::((X, XTy)::Ctx)) T2 Ty
H1 : typeOf Ctx S1 Ty1
============================
 forall X1 XTy1,
   lookup ((X, Ty1)::((X, XTy)::Ctx)) X1 XTy1 -&gt; lookup ((X, Ty1)::Ctx) X1 XTy1
</pre>
<pre class="code extensibella"id="83">
 &lt; <b>intros L.</b>

Subgoal 9.1:

Variables: Ctx X XTy Ty R T2 S1 T1 Ty1 X1 XTy1
IH : forall T Ctx X XTy Ty R S,
       typeOf ((X, XTy)::Ctx) T Ty -&gt; subst X R T S * -&gt; typeOf [] R XTy -&gt; typeOf Ctx S Ty
S : subst X R (let X T1 T2) (let X S1 T2) @
RTy : typeOf [] R XTy
S1 : subst X R T1 S1 *
Ty : typeOf ((X, XTy)::Ctx) T1 Ty1
Ty1 : typeOf ((X, Ty1)::((X, XTy)::Ctx)) T2 Ty
H1 : typeOf Ctx S1 Ty1
L : lookup ((X, Ty1)::((X, XTy)::Ctx)) X1 XTy1
============================
 lookup ((X, Ty1)::Ctx) X1 XTy1
</pre>
<pre class="code extensibella"id="84">
 &lt; <b>L: case L.</b>

Subgoal 9.1.1:

Variables: Ctx XTy Ty R T2 S1 T1 X1 XTy1
IH : forall T Ctx X XTy Ty R S,
       typeOf ((X, XTy)::Ctx) T Ty -&gt; subst X R T S * -&gt; typeOf [] R XTy -&gt; typeOf Ctx S Ty
S : subst X1 R (let X1 T1 T2) (let X1 S1 T2) @
RTy : typeOf [] R XTy
S1 : subst X1 R T1 S1 *
Ty : typeOf ((X1, XTy)::Ctx) T1 XTy1
Ty1 : typeOf ((X1, XTy1)::((X1, XTy)::Ctx)) T2 Ty
H1 : typeOf Ctx S1 XTy1
============================
 lookup ((X1, XTy1)::Ctx) X1 XTy1
</pre>
<pre class="code extensibella"id="85">
 &lt; <b>search.</b>

Subgoal 9.1.2:

Variables: Ctx X XTy Ty R T2 S1 T1 Ty1 X1 XTy1
IH : forall T Ctx X XTy Ty R S,
       typeOf ((X, XTy)::Ctx) T Ty -&gt; subst X R T S * -&gt; typeOf [] R XTy -&gt; typeOf Ctx S Ty
S : subst X R (let X T1 T2) (let X S1 T2) @
RTy : typeOf [] R XTy
S1 : subst X R T1 S1 *
Ty : typeOf ((X, XTy)::Ctx) T1 Ty1
Ty1 : typeOf ((X, Ty1)::((X, XTy)::Ctx)) T2 Ty
H1 : typeOf Ctx S1 Ty1
L : X = X1 -&gt; false
L1 : lookup ((X, XTy)::Ctx) X1 XTy1
============================
 lookup ((X, Ty1)::Ctx) X1 XTy1
</pre>
<pre class="code extensibella"id="86">
 &lt; <b>L: case L1.</b>

Subgoal 9.1.2.1:

Variables: Ctx Ty R T2 S1 T1 Ty1 X1 XTy1
IH : forall T Ctx X XTy Ty R S,
       typeOf ((X, XTy)::Ctx) T Ty -&gt; subst X R T S * -&gt; typeOf [] R XTy -&gt; typeOf Ctx S Ty
S : subst X1 R (let X1 T1 T2) (let X1 S1 T2) @
RTy : typeOf [] R XTy1
S1 : subst X1 R T1 S1 *
Ty : typeOf ((X1, XTy1)::Ctx) T1 Ty1
Ty1 : typeOf ((X1, Ty1)::((X1, XTy1)::Ctx)) T2 Ty
H1 : typeOf Ctx S1 Ty1
L : X1 = X1 -&gt; false
============================
 lookup ((X1, Ty1)::Ctx) X1 XTy1
</pre>
<pre class="code extensibella"id="87">
 &lt; <b>apply L to _.</b>

Subgoal 9.1.2.2:

Variables: Ctx X XTy Ty R T2 S1 T1 Ty1 X1 XTy1
IH : forall T Ctx X XTy Ty R S,
       typeOf ((X, XTy)::Ctx) T Ty -&gt; subst X R T S * -&gt; typeOf [] R XTy -&gt; typeOf Ctx S Ty
S : subst X R (let X T1 T2) (let X S1 T2) @
RTy : typeOf [] R XTy
S1 : subst X R T1 S1 *
Ty : typeOf ((X, XTy)::Ctx) T1 Ty1
Ty1 : typeOf ((X, Ty1)::((X, XTy)::Ctx)) T2 Ty
H1 : typeOf Ctx S1 Ty1
L : X = X1 -&gt; false
L1 : X = X1 -&gt; false
L2 : lookup Ctx X1 XTy1
============================
 lookup ((X, Ty1)::Ctx) X1 XTy1
</pre>
<pre class="code extensibella"id="88">
 &lt; <b>search.</b>

Subgoal 9:

Variables: Ctx X XTy Ty R T2 S1 T1 Ty1
IH : forall T Ctx X XTy Ty R S,
       typeOf ((X, XTy)::Ctx) T Ty -&gt; subst X R T S * -&gt; typeOf [] R XTy -&gt; typeOf Ctx S Ty
S : subst X R (let X T1 T2) (let X S1 T2) @
RTy : typeOf [] R XTy
S1 : subst X R T1 S1 *
Ty : typeOf ((X, XTy)::Ctx) T1 Ty1
Ty1 : typeOf ((X, Ty1)::((X, XTy)::Ctx)) T2 Ty
H1 : typeOf Ctx S1 Ty1
H2 : typeOf ((X, Ty1)::Ctx) T2 Ty
============================
 typeOf Ctx (let X S1 T2) Ty
</pre>
<pre class="code extensibella"id="89">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="90">
 &lt; <b>Prove stlc:host:type_preservation.</b>

Subgoal 7:

Variables: Ty T2 T11 X T1
IH : forall T Ty T', typeOf [] T Ty -&gt; eval T T' * -&gt; typeOf [] T' Ty
Ty : typeOf [] (let X T1 T2) Ty
Ev : eval (let X T1 T2) (let X T11 T2) @
Ev1 : eval T1 T11 *
============================
 typeOf [] (let X T11 T2) Ty
</pre>
<pre class="code extensibella"id="91">
 &lt; <b>Ty: case Ty.</b>

Subgoal 7:

Variables: Ty T2 T11 X T1 Ty1
IH : forall T Ty T', typeOf [] T Ty -&gt; eval T T' * -&gt; typeOf [] T' Ty
Ev : eval (let X T1 T2) (let X T11 T2) @
Ev1 : eval T1 T11 *
Ty : typeOf [] T1 Ty1
Ty1 : typeOf [(X, Ty1)] T2 Ty
============================
 typeOf [] (let X T11 T2) Ty
</pre>
<pre class="code extensibella"id="92">
 &lt; <b>apply IH to Ty Ev1.</b>

Subgoal 7:

Variables: Ty T2 T11 X T1 Ty1
IH : forall T Ty T', typeOf [] T Ty -&gt; eval T T' * -&gt; typeOf [] T' Ty
Ev : eval (let X T1 T2) (let X T11 T2) @
Ev1 : eval T1 T11 *
Ty : typeOf [] T1 Ty1
Ty1 : typeOf [(X, Ty1)] T2 Ty
H1 : typeOf [] T11 Ty1
============================
 typeOf [] (let X T11 T2) Ty
</pre>
<pre class="code extensibella"id="93">
 &lt; <b>search.</b>

Subgoal 8:

Variables: Ty T' T2 T1 X
IH : forall T Ty T', typeOf [] T Ty -&gt; eval T T' * -&gt; typeOf [] T' Ty
Ty : typeOf [] (let X T1 T2) Ty
Ev : eval (let X T1 T2) T' @
Ev1 : value T1
Ev2 : subst X T1 T2 T'
============================
 typeOf [] T' Ty
</pre>
<pre class="code extensibella"id="94">
 &lt; <b>Ty: case Ty.</b>

Subgoal 8:

Variables: Ty T' T2 T1 X Ty1
IH : forall T Ty T', typeOf [] T Ty -&gt; eval T T' * -&gt; typeOf [] T' Ty
Ev : eval (let X T1 T2) T' @
Ev1 : value T1
Ev2 : subst X T1 T2 T'
Ty : typeOf [] T1 Ty1
Ty1 : typeOf [(X, Ty1)] T2 Ty
============================
 typeOf [] T' Ty
</pre>
<pre class="code extensibella"id="95">
 &lt; <b>apply subst_type_preservation to Ty1 Ev2 Ty.</b>

Subgoal 8:

Variables: Ty T' T2 T1 X Ty1
IH : forall T Ty T', typeOf [] T Ty -&gt; eval T T' * -&gt; typeOf [] T' Ty
Ev : eval (let X T1 T2) T' @
Ev1 : value T1
Ev2 : subst X T1 T2 T'
Ty : typeOf [] T1 Ty1
Ty1 : typeOf [(X, Ty1)] T2 Ty
H1 : typeOf [] T' Ty
============================
 typeOf [] T' Ty
</pre>
<pre class="code extensibella"id="96">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="97">
 &lt; <b>Prove stlc:host:subst_total.</b>

Subgoal 6:

Variables: X R Tm Tm1 S
IH : forall X R T, is_tm T * -&gt; is_string X -&gt; exists S, subst X R T S
IsT : is_tm (let S Tm1 Tm) @
IsX : is_string X
IsT1 : is_string S
IsT2 : is_tm Tm1 *
IsT3 : is_tm Tm *
============================
 exists S1, subst X R (let S Tm1 Tm) S1
</pre>
<pre class="code extensibella"id="98">
 &lt; <b>Or: apply is_string_eq_or_not to IsX IsT1.</b>

Subgoal 6:

Variables: X R Tm Tm1 S
IH : forall X R T, is_tm T * -&gt; is_string X -&gt; exists S, subst X R T S
IsT : is_tm (let S Tm1 Tm) @
IsX : is_string X
IsT1 : is_string S
IsT2 : is_tm Tm1 *
IsT3 : is_tm Tm *
Or : X = S \/ (X = S -&gt; false)
============================
 exists S1, subst X R (let S Tm1 Tm) S1
</pre>
<pre class="code extensibella"id="99">
 &lt; <b>E: case Or.</b>

Subgoal 6.1:

Variables: R Tm Tm1 S
IH : forall X R T, is_tm T * -&gt; is_string X -&gt; exists S, subst X R T S
IsT : is_tm (let S Tm1 Tm) @
IsX : is_string S
IsT1 : is_string S
IsT2 : is_tm Tm1 *
IsT3 : is_tm Tm *
============================
 exists S1, subst S R (let S Tm1 Tm) S1
</pre>
<pre class="code extensibella"id="100">
 &lt; <b>apply IH to IsT2 IsX with
     R = R.</b>

Subgoal 6.1:

Variables: R Tm Tm1 S S1
IH : forall X R T, is_tm T * -&gt; is_string X -&gt; exists S, subst X R T S
IsT : is_tm (let S Tm1 Tm) @
IsX : is_string S
IsT1 : is_string S
IsT2 : is_tm Tm1 *
IsT3 : is_tm Tm *
H1 : subst S R Tm1 S1
============================
 exists S1, subst S R (let S Tm1 Tm) S1
</pre>
<pre class="code extensibella"id="101">
 &lt; <b>search.</b>

Subgoal 6.2:

Variables: X R Tm Tm1 S
IH : forall X R T, is_tm T * -&gt; is_string X -&gt; exists S, subst X R T S
IsT : is_tm (let S Tm1 Tm) @
IsX : is_string X
IsT1 : is_string S
IsT2 : is_tm Tm1 *
IsT3 : is_tm Tm *
E : X = S -&gt; false
============================
 exists S1, subst X R (let S Tm1 Tm) S1
</pre>
<pre class="code extensibella"id="102">
 &lt; <b>apply IH to IsT2 IsX with
     R = R.</b>

Subgoal 6.2:

Variables: X R Tm Tm1 S S1
IH : forall X R T, is_tm T * -&gt; is_string X -&gt; exists S, subst X R T S
IsT : is_tm (let S Tm1 Tm) @
IsX : is_string X
IsT1 : is_string S
IsT2 : is_tm Tm1 *
IsT3 : is_tm Tm *
E : X = S -&gt; false
H1 : subst X R Tm1 S1
============================
 exists S1, subst X R (let S Tm1 Tm) S1
</pre>
<pre class="code extensibella"id="103">
 &lt; <b>apply IH to IsT3 IsX with
     R = R.</b>

Subgoal 6.2:

Variables: X R Tm Tm1 S S1 S2
IH : forall X R T, is_tm T * -&gt; is_string X -&gt; exists S, subst X R T S
IsT : is_tm (let S Tm1 Tm) @
IsX : is_string X
IsT1 : is_string S
IsT2 : is_tm Tm1 *
IsT3 : is_tm Tm *
E : X = S -&gt; false
H1 : subst X R Tm1 S1
H2 : subst X R Tm S2
============================
 exists S1, subst X R (let S Tm1 Tm) S1
</pre>
<pre class="code extensibella"id="104">
 &lt; <b>search.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="105">
 &lt; <b>Prove stlc:host:canonical_forms.</b>

Proof completed.
</pre>
<pre class="code extensibella"id="106">
 &lt; <b>Prove stlc:host:progress.</b>

Subgoal 6:

Variables: Ty Ty1 T2 T1 X
IH : forall T Ty,
       is_tm T -&gt; typeOf [] T Ty * -&gt; (exists T', eval T T') \/ value T
IsT : is_tm (let X T1 T2)
Ty : typeOf [] (let X T1 T2) Ty @
Ty1 : typeOf [] T1 Ty1 *
Ty2 : typeOf [(X, Ty1)] T2 Ty *
============================
 (exists T', eval (let X T1 T2) T') \/ value (let X T1 T2)
</pre>
<pre class="code extensibella"id="107">
 &lt; <b>Is: case IsT.</b>

Subgoal 6:

Variables: Ty Ty1 T2 T1 X
IH : forall T Ty,
       is_tm T -&gt; typeOf [] T Ty * -&gt; (exists T', eval T T') \/ value T
Ty : typeOf [] (let X T1 T2) Ty @
Ty1 : typeOf [] T1 Ty1 *
Ty2 : typeOf [(X, Ty1)] T2 Ty *
Is : is_string X
Is1 : is_tm T1
Is2 : is_tm T2
============================
 (exists T', eval (let X T1 T2) T') \/ value (let X T1 T2)
</pre>
<pre class="code extensibella"id="108">
 &lt; <b>Or: apply IH to _ Ty1.</b>

Subgoal 6:

Variables: Ty Ty1 T2 T1 X
IH : forall T Ty,
       is_tm T -&gt; typeOf [] T Ty * -&gt; (exists T', eval T T') \/ value T
Ty : typeOf [] (let X T1 T2) Ty @
Ty1 : typeOf [] T1 Ty1 *
Ty2 : typeOf [(X, Ty1)] T2 Ty *
Is : is_string X
Is1 : is_tm T1
Is2 : is_tm T2
Or : (exists T', eval T1 T') \/ value T1
============================
 (exists T', eval (let X T1 T2) T') \/ value (let X T1 T2)
</pre>
<pre class="code extensibella"id="109">
 &lt; <b>EV: case Or.</b>

Subgoal 6.1:

Variables: Ty Ty1 T2 T1 X T'
IH : forall T Ty,
       is_tm T -&gt; typeOf [] T Ty * -&gt; (exists T', eval T T') \/ value T
Ty : typeOf [] (let X T1 T2) Ty @
Ty1 : typeOf [] T1 Ty1 *
Ty2 : typeOf [(X, Ty1)] T2 Ty *
Is : is_string X
Is1 : is_tm T1
Is2 : is_tm T2
EV : eval T1 T'
============================
 (exists T', eval (let X T1 T2) T') \/ value (let X T1 T2)
</pre>
<pre class="code extensibella"id="110">
 &lt; <b>search.</b>

Subgoal 6.2:

Variables: Ty Ty1 T2 T1 X
IH : forall T Ty,
       is_tm T -&gt; typeOf [] T Ty * -&gt; (exists T', eval T T') \/ value T
Ty : typeOf [] (let X T1 T2) Ty @
Ty1 : typeOf [] T1 Ty1 *
Ty2 : typeOf [(X, Ty1)] T2 Ty *
Is : is_string X
Is1 : is_tm T1
Is2 : is_tm T2
EV : value T1
============================
 (exists T', eval (let X T1 T2) T') \/ value (let X T1 T2)
</pre>
<pre class="code extensibella"id="111">
 &lt; <b>apply subst_total to Is2 Is with
     R = T1.</b>

Subgoal 6.2:

Variables: Ty Ty1 T2 T1 X S
IH : forall T Ty,
       is_tm T -&gt; typeOf [] T Ty * -&gt; (exists T', eval T T') \/ value T
Ty : typeOf [] (let X T1 T2) Ty @
Ty1 : typeOf [] T1 Ty1 *
Ty2 : typeOf [(X, Ty1)] T2 Ty *
Is : is_string X
Is1 : is_tm T1
Is2 : is_tm T2
EV : value T1
H1 : subst X T1 T2 S
============================
 (exists T', eval (let X T1 T2) T') \/ value (let X T1 T2)
</pre>
<pre class="code extensibella"id="112">
 &lt; <b>search.</b>

Proof completed.
</pre>
</div>
<div class="section">
<a class="navlink" href="../description.html">Back to example home</a>
</div>
</body>
</html>
