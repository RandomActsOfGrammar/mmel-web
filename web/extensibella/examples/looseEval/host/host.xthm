Module looseEval:host.

%can use fresh_name to generate new names for stmt projection
Theorem fresh_name_unique : forall Base Names FA FB,
  fresh_name Base Names FA -> fresh_name Base Names FB -> FA = FB.
induction on 1. intros FA FB. FA: case FA.
  %FN-Final
   FB: case FB.
     %FN-Final
      search.
     %FN-Step
      apply not_mem to FA FB.
  %FN-Step
   FB: case FB.
     %FN-Final
      apply not_mem to FB FA.
     %FN-Step
      apply append_unique to FA1 FB1. apply IH to FA2 FB2. search.


Theorem fresh_name_unique_mems : forall Base NamesA NamesB FA FB,
  fresh_name Base NamesA FA -> fresh_name Base NamesB FB ->
  (forall X, mem X NamesA -> mem X NamesB) ->
  (forall X, mem X NamesB -> mem X NamesA) ->
  FA = FB.
induction on 1. intros FA FB MAB MBA. FA: case FA.
  %FN-Final
   FB: case FB.
     %FN-Final
      search.
     %FN-Step
      MA: apply MBA to FB. apply not_mem to FA MA.
  %FN-Step
   FB: case FB.
     %FN-Final
      MB: apply MAB to FA. apply not_mem to FB MB.
     %FN-Step
      apply append_unique to FA1 FB1. apply IH to FA2 FB2 _ _. search.


Theorem fresh_name_is : forall Base Names F,
  is_string Base -> fresh_name Base Names F -> is_string F.
induction on 2. intros Is FN. FN: case FN.
  %FN-Final
   search.
  %FN-Step
   apply append_string_is to _ _ FN1. apply IH to _ FN2. search.


/*
  The rest of this is proving fresh_name_exists:
*/
Theorem mem_string_list_or_not : forall S L,
  is_string S -> is_list is_string L -> mem S L \/ (mem S L -> false).
induction on 2. intros IsS IsL. IsL: case IsL.
  %nil
   right. intros M. case M.
  %cons
   Or: apply is_string_eq_or_not to IsS IsL. E: case Or.
     %S = H
      search.
     %S != H
      Or: apply IH to IsS IsL1. M: case Or.
        %mem S T
         search.
        %mem S T -> false
         right. intros X. case X.
           %S = H
            backchain E.
           %mem S T
            backchain M.


Theorem mem_is_string : forall L X,
  is_list is_string L -> mem X L -> is_string X.
induction on 2. intros Is M. M: case M.
  %Mem-Here
   case Is. search.
  %Mem-Later
   case Is. apply IH to _ M. search.


Theorem select_string_list_is : forall S L L',
  is_list is_string L -> select S L' L -> is_list is_string L'.
induction on 2. intros Is S. S: case S.
  %Slct-First
   case Is. search.
  %Slct-Later
   case Is. apply IH to _ S. search.


Theorem select_length[A] : forall (X : A) L L' N N',
  select X L' L -> length L N -> 1 + N' = N -> length L' N'.
induction on 1. intros S L P. S: case S.
  %Slct-First
   L: case L (keep). IsN: apply length_is to L.
   Is: apply plus_integer_is_integer_result to IsN P. clear Is.
   Is: apply plus_integer_is_integer_result to IsN L2. clear Is.
   apply plus_integer_unique_addend to _ _ _ P L2. search.
  %Slct-Later
   L: case L (keep). IsN: apply length_is to L.
   Is: apply plus_integer_is_integer_result to IsN P. clear Is.
   Is: apply plus_integer_is_integer_result to IsN L2. clear Is.
   apply plus_integer_unique_addend to _ _ _ P L2. clear Is2.
   M: apply minus_integer_total to Is1 _ with N2 = 1.
   P': apply minus_plus_same_integer to _ _ M.
   apply minus_integer_is_integer to _ _ M.
   P'': apply plus_integer_comm to _ _ P'.
   apply IH to S L1 P''. search.


Theorem length_exists_string : forall L,
  is_list is_string L -> exists N, length L N.
induction on 1. intros Is. Is: case Is.
  %nil
   search.
  %cons
   Len: apply IH to Is1. IsN: apply length_is to Len.
   apply plus_integer_total to _ IsN with N1 = 1. search.


Theorem not_mem_not_mem : forall X L,
  is_list is_string L -> (mem X L -> false) -> not_mem X L.
induction on 1. intros IsL NM. Is: case IsL.
  %nil
   search.
  %cons
   unfold.
     %H = X -> false
      intros E. case E. backchain NM.
     %not_mem X T
      apply IH to Is1 _ with X = X. intros M. backchain NM. search.


Define adds_ : string -> string -> prop by
adds_ S S;
adds_ S U := exists S', S ++ "_" = S' /\ adds_ S' U.


Theorem fresh_name_remove : forall Base Names F S Names',
  fresh_name Base Names F -> (adds_ Base S -> false) ->
  select S Names' Names -> fresh_name Base Names' F.
induction on 1. intros F NA S. F: case F.
  %FN-Final
   apply not_mem_before_select_after to S F. search.
  %FN-Step
   apply IH to F2 _ S. intros A. backchain NA.
   apply mem_before_select_after to S F _.
     intros E. case E. backchain NA.
   search.


Theorem fresh_name_add : forall Base Names F S Names',
  fresh_name Base Names F -> (adds_ Base S -> false) ->
  select S Names Names' -> fresh_name Base Names' F.
induction on 1. intros F NA S. F: case F.
  %FN-Final
   apply not_mem_after_select_before to S F _.
     intros E. case E. backchain NA.
   search.
  %FN-Step
   apply IH to F2 _ S. intros A. backchain NA.
   apply mem_after_select_before to S F. search.

Theorem length_adds_ : forall A B NA NB,
  adds_ A B -> length A NA -> length B NB -> NA <= NB.
induction on 1. intros Add LA LB. Add: case Add.
  %same
   apply length_unique to LA LB. IsN: apply length_is to LA.
   apply is_integer_lesseq to IsN. search.
  %step
   IsNA: apply length_is to LA.
   P: apply plus_integer_total to IsNA _ with N2 = 1.
   LenS': apply append_length to Add LA _ P.
   LEq: apply IH to Add1 LenS' LB. P': apply plus_integer_comm to _ _ P.
   L: apply lt_plus_one to P' _. LEq': apply less_integer_lesseq to L.
   apply lesseq_integer_transitive to LEq' LEq. search.


Theorem not_adds_ : forall Base S,
  is_string Base -> adds_ S Base -> Base ++ "_" = S -> false.
intros IsBase Add App. LenBase: apply string_length_total to IsBase.
IsN: apply length_is to LenBase.
P: apply plus_integer_total to IsN _ with N2 = 1.
LenS: apply append_length to App LenBase _ P.
P': apply plus_integer_comm to _ _ P. L: apply lt_plus_one to P' _.
LEq: apply length_adds_ to Add LenS LenBase.
apply less_lesseq_flip_false to L LEq.


Theorem fresh_name_exists_acc : forall Base Names Len,
  is_string Base -> is_list is_string Names -> length Names Len ->
  acc Len -> exists F, fresh_name Base Names F.
induction on 4. intros IsBase IsNames Len Acc.
Or: apply mem_string_list_or_not to IsBase IsNames. M: case Or.
  %mem Base Names
   S: apply mem_select to M. IsLen: apply length_is to Len.
   Minus: apply minus_integer_total to IsLen _ with N2 = 1.
   P: apply minus_plus_same_integer to _ _ Minus.
   IsN3: apply minus_integer_is_integer to _ _ Minus.
   P': apply plus_integer_comm to _ _ P.
   Len': apply select_length to S Len P'.
   L: apply lt_plus_one to P' _. Acc: case Acc.
   G: apply length_geq_0 to Len'. Pos: case G. A: apply Acc to _ L.
   IsL': apply select_string_list_is to _ S.
   App: apply append_string_total to IsBase _ with S2 = "_".
   IsS: apply append_string_is to _ _ App.
   F: apply IH to IsS IsL' Len' A. exists F.
   apply fresh_name_add to F _ S.
     intros Add. apply not_adds_ to _ Add App.
   search.
  %mem Base Names -> false
   apply not_mem_not_mem to _ M. search.


Theorem fresh_name_exists : forall Base Names,
  is_string Base -> is_list is_string Names ->
  exists F, fresh_name Base Names F.
intros IsBase IsNames. Len: apply length_exists_string to IsNames.
IsN: apply length_is to Len. Pos: apply length_geq_0 to Len.
L: case Pos. Acc: apply all_acc to IsN L.
apply fresh_name_exists_acc to IsBase IsNames Len Acc. search.


Theorem fresh_name_not_mem : forall Base Names F,
  fresh_name Base Names F -> mem F Names -> false.
induction on 1. intros F M. F: case F.
  %FN-Final
   apply not_mem to F M.
  %FN-Step
   apply IH to F2 M.


Theorem fresh_name_start : forall Base Names F,
  is_string Base -> fresh_name Base Names F ->
  exists S, Base ++ S = F.
induction on 2. intros IsBase F. F: case F.
  %FN-Final
   exists "". A: apply append_string_total to IsBase _ with S2 = "".
   apply append_nil_right to A. search.
  %FN-Step
   apply append_string_is to _ _ F1. A: apply IH to _ F2.
   apply append_associative to F1 A. search.





/********************************************************************
  ____            _
 | __ )  __ _ ___(_) ___
 |  _ \ / _` / __| |/ __|
 | |_) | (_| \__ \ | (__
 |____/ \__,_|___/_|\___|
  ____            _           _   _
 |  _ \ _ __ ___ (_) ___  ___| |_(_) ___  _ __
 | |_) | '__/ _ \| |/ _ \/ __| __| |/ _ \| '_ \
 |  __/| | | (_) | |  __/ (__| |_| | (_) | | | |
 |_|   |_|  \___// |\___|\___|\__|_|\___/|_| |_|
   ____         |_/    _             _       _
  / ___|___  _ __  ___| |_ _ __ __ _(_)_ __ | |_ ___ 
 | |   / _ \| '_ \/ __| __| '__/ _` | | '_ \| __/ __|
 | |__| (_) | | | \__ \ |_| | | (_| | | | | | |_\__ \
 \____\___/|_| |_|___/\__|_|  \__,_|_|_| |_|\__|___/

 Basic Projection Constraints
 ********************************************************************/
Projection_Constraint proj_expr_unique : forall E E1 E2,
  PrA : |{expr}- E ~~> E1 ->
  PrB : |{expr}- E ~~> E2 ->
  IsE : is_expr E ->
  E1 = E2.
Projection_Constraint proj_expr_is : forall E E',
  Pr : |{expr}- E ~~> E' ->
  IsE : is_expr E ->
  is_expr E'.

Projection_Constraint proj_stmt_unique : forall L1 L2 S S1 S2,
  PrA : L1 |{stmt}- S ~~> S1 ->
  PrB : L2 |{stmt}- S ~~> S2 ->
  IsS : is_stmt S ->
  IsL1 : is_list is_string L1 ->
  IsL2 : is_list is_string L2 ->
  Rel12 : (forall X, mem X L1 -> mem X L2) ->
  Rel21 : (forall X, mem X L2 -> mem X L1) ->
  S1 = S2.
Projection_Constraint proj_stmt_is : forall L S S',
  Pr : L |{stmt}- S ~~> S' ->
  IsS : is_stmt S ->
  IsL : is_list is_string L ->
  is_stmt S'.
Projection_Constraint proj_stmt_other : forall L S S' L',
  Pr : L |{stmt}- S ~~> S' ->
  IsS : is_stmt S ->
  IsL : is_list is_string L ->
  IsL' : is_list is_string L' ->
  exists S'', L' |{stmt}- S ~~> S''.

Projection_Constraint proj_fun_unique : forall F F1 F2,
  PrA : |{fun}- F ~~> F1 ->
  PrB : |{fun}- F ~~> F2 ->
  IsF : is_fun F ->
  F1 = F2.
Projection_Constraint proj_fun_is : forall F F',
  Pr : |{fun}- F ~~> F' ->
  IsF : is_fun F ->
  is_fun F'.

Projection_Constraint proj_param_unique : forall P P1 P2,
  PrA : |{param}- P ~~> P1 ->
  PrB : |{param}- P ~~> P2 ->
  IsP : is_param P ->
  P1 = P2.
Projection_Constraint proj_param_is : forall P P',
  Pr : |{param}- P ~~> P' ->
  IsP : is_param P ->
  is_param P'.

Projection_Constraint proj_program_unique : forall P P1 P2,
  PrA : |{program}- P ~~> P1 ->
  PrB : |{program}- P ~~> P2 ->
  IsP : is_program P ->
  P1 = P2.
Projection_Constraint proj_program_is : forall P P',
  Pr : |{program}- P ~~> P' ->
  IsP : is_program P ->
  is_program P'.

Projection_Constraint proj_typ_unique : forall T T1 T2,
  PrA : |{typ}- T ~~> T1 ->
  PrB : |{typ}- T ~~> T2 ->
  IsT : is_typ T ->
  T1 = T2.
Projection_Constraint proj_typ_is : forall T T',
  Pr : |{typ}- T ~~> T' ->
  IsT : is_typ T ->
  is_typ T'.

Projection_Constraint proj_value_unique : forall V V1 V2,
  PrA : |{value}- V ~~> V1 ->
  PrB : |{value}- V ~~> V2 ->
  IsV : is_value V ->
  V1 = V2.
Projection_Constraint proj_value_is : forall V V',
  Pr : |{value}- V ~~> V' ->
  IsV : is_value V ->
  is_value V'.





/********************************************************************
  ____            _     _       _     _
 |  _ \  ___  ___(_) __| | __ _| |__ | | ___
 | | | |/ _ \/ __| |/ _` |/ _` | '_ \| |/ _ \
 | |_| |  __/ (__| | (_| | (_| | |_) | |  __/
 |____/ \___|\___|_|\__,_|\__,_|_.__/|_|\___|
  _____                  _ _ _
 | ____|__ _ _   _  __ _| (_) |_ _   _
 |  _| / _` | | | |/ _` | | | __| | | |
 | |__| (_| | |_| | (_| | | | |_| |_| |
 |_____\__, |\__,_|\__,_|_|_|\__|\__, |
          |_|                    |___/
 Decidable Equality
 ********************************************************************/
Theorem is_list_is_string_eq_or_not : forall L1 L2,
  is_list is_string L1 -> is_list is_string L2 ->
  L1 = L2 \/ (L1 = L2 -> false).
induction on 1. intros IsLA IsLB. IsLA: case IsLA.
  %nil
   case IsLB.
     %nil
      search.
     %cons
      search.
  %cons
   IsLB: case IsLB.
     %nil
      search.
     %cons
      Or1: apply is_string_eq_or_not to IsLA IsLB.
      Or2: apply IH to IsLA1 IsLB1. N: case Or1.
        %H = H1
         N: case Or2.
           %T = T1
            search.
           %T != T1
            right. intros E. case E. backchain N.
        %H != H1
         right. intros E. case E. backchain N.



Proj_Rel is_expr E, is_args A, is_recFieldExprs RF.
Ext_Ind forall E, is_expr E; forall A, is_args A;
        forall RF, is_recFieldExprs RF.
%is_expr
 %num
  search.
 %plus
  apply IH to R1. apply IH to R2. search.
 %minus
  apply IH to R1. apply IH to R2. search.
 %mult
  apply IH to R1. apply IH to R2. search.
 %div
  apply IH to R1. apply IH to R2. search.
 %true
  search.
 %false
  search.
 %and
  apply IH to R1. apply IH to R2. search.
 %or
  apply IH to R1. apply IH to R2. search.
 %not
  apply IH to R1. search.
 %greater
  apply IH to R1. apply IH to R2. search.
 %eq
  apply IH to R1. apply IH to R2. search.
 %stringLit
  search.
 %appString
  apply IH to R1. apply IH to R2. search.
 %name
  search.
 %call
  apply IH1 to R2. search.
 %recBuild
  apply IH2 to R1. search.
 %recFieldAccess
  apply IH to R1. search.
 %errorExpr
  apply IH to R1. search.
%is_args
 %nilArgs
  search.
 %consArgs
  apply IH to R1. apply IH1 to R2. search.
%is_recFieldExprs
 %nilRecFieldExprs
  search.
 %consRecFieldExprs
  apply IH to R2. apply IH2 to R3. search.

Proj_Rel is_stmt S.
Ext_Ind forall S, is_stmt S.
%is_stmt
 %noop
  search.
 %seq
  apply IH to R1. apply IH to R2. search.
 %declare
  search.
 %assign
  search.
 %recUpdate
  search.
 %ifThenElse
  apply IH to R2. apply IH to R3. search.
 %while
  apply IH to R2. search.
 %scopeStmt
  apply IH to R1. search.
 %printVal
  search.


/*
  With these properties, we make the args and recFieldExprs types
  nonextensible.
*/
Extensible_Theorem
  is_args_nilArgs_or_consArgs : forall A,
    Is : is_args A ->
    A = nilArgs \/ (exists E A', A = consArgs E A')
  on Is.
%nilArgs
 search.
%consArgs
 search.
Extensible_Theorem
  is_recFieldExprs_nilRecFieldExprs_or_consRecFieldExprs : forall RF,
    Is : is_recFieldExprs RF ->
    RF = nilRecFieldExprs \/
    (exists F E RF', RF = consRecFieldExprs F E RF')
  on Is.
%nilRecFieldExprs
 search.
%consRecFieldExprs
 search.


Proj_Rel is_value V, is_recFieldVals RFVs.
Ext_Ind forall V, is_value V; forall RFVs, is_recFieldVals RFVs.
%is_value
 %intVal
  search.
 %trueVal
  search.
 %falseVal
  search.
 %stringVal
  search.
 %recVal
  apply IH1 to R1. search.
%is_recFieldVals
 %nilRecFieldVals
  search.
 %consRecFieldVals
  apply IH to R2. apply IH1 to R3. search.


Extensible_Theorem
  is_value_intVal_or_not : forall V,
    IsV : is_value V ->
    (exists I, intVal I = V) \/ ((exists I, intVal I = V) -> false)
  on IsV.
search. search. search. search. search.
Extensible_Theorem
  is_value_trueVal_or_not : forall V,
    IsV : is_value V ->
    trueVal = V \/ (trueVal = V -> false)
  on IsV.
search. search. search. search. search.
Extensible_Theorem
  is_value_falseVal_or_not : forall V,
    IsV : is_value V ->
    falseVal = V \/ (falseVal = V -> false)
  on IsV.
search. search. search. search. search.
Extensible_Theorem
  is_value_stringVal_or_not : forall V,
    IsV : is_value V ->
    (exists S, stringVal S = V) \/
    ((exists S, stringVal S = V) -> false)
  on IsV.
search. search. search. search. search.
Extensible_Theorem
  is_value_recVal_or_not : forall V,
    IsV : is_value V ->
    (exists Fs, recVal Fs = V) \/
    ((exists Fs, recVal Fs = V) -> false)
  on IsV.
search. search. search. search. search.

Extensible_Theorem
  is_recFieldVals_nil_or_cons : forall RFVs,
    IsRFVs : is_recFieldVals RFVs ->
    RFVs = nilRecFieldVals \/
    exists F V R, RFVs = consRecFieldVals F V R
  on IsRFVs.
search. search.

Extensible_Theorem
  is_value_eq_or_not : forall V1 V2,
    Is1 : is_value V1 ->
    Is2 : is_value V2 ->
    V1 = V2 \/ (V1 = V2 -> false)
  on Is1,
  is_recFieldVals_eq_or_not : forall RFVs1 RFVs2,
    Is1 : is_recFieldVals RFVs1 ->
    Is2 : is_recFieldVals RFVs2 ->
    RFVs1 = RFVs2 \/ (RFVs1 = RFVs2 -> false)
  on Is1.
%is_value_eq_or_not
 %intVal
  Or: apply is_value_intVal_or_not to Is2. N: case Or.
    %intVal
     Is': case Is2. Or: apply is_integer_eq_or_not to Is3 Is'.
     N: case Or.
       %I = I1
        search.
       %I != I1
        right. intros E. case E. backchain N.
    %not
     right. intros E. case E. backchain N.
 %trueVal
  Or: apply is_value_trueVal_or_not to Is2. N: case Or.
    %trueVal
     search.
    %not
     right. intros E. case E. backchain N.
 %falseVal
  Or: apply is_value_falseVal_or_not to Is2. N: case Or.
    %falseVal
     search.
    %not
     right. intros E. case E. backchain N.
 %stringVal
  Or: apply is_value_stringVal_or_not to Is2. N: case Or.
    %stringVal
     Is': case Is2. Or: apply is_string_eq_or_not to Is3 Is'.
     N: case Or.
       %S = S1
        search.
       %S != S1
        right. intros E. case E. backchain N.
    %not
     right. intros E. case E. backchain N.
 %recVal
  Or: apply is_value_recVal_or_not to Is2. N: case Or.
    %recVal
     Is': case Is2. Or: apply IH1 to Is3 Is'. N: case Or.
       %RecFieldVals = Fs
        search.
       %RecFieldVals != Fs
        right. intros E. case E. backchain N.
    %not recVal
     right. intros E. case E. backchain N.
%is_recFieldVals_eq_or_not
 %nilRecFieldVals
  Or: apply is_recFieldVals_nil_or_cons to Is2. case Or.
    %nilRecFieldVals
     search.
    %consRecFieldVals
     right. intros E. case E.
 %consRecFieldVals
  Or: apply is_recFieldVals_nil_or_cons to Is2. case Or.
    %nilRecFieldVals
     right. intros E. case E.
    %consRecFieldVals
     Is': case Is2. Or: apply is_string_eq_or_not to Is3 Is'.
     N: case Or.
       %S = F
        Or: apply IH to Is4 Is'1. N: case Or.
          %Value = V
           Or: apply IH1 to Is5 Is'2. N: case Or.
             %RecFieldVals = R
              search.
             %RecFieldVals != R
              right. intros E. case E. backchain N.
          %Value != V
           right. intros E. case E. backchain N.
       %S != F
        right. intros E. case E. backchain N.





/********************************************************************
  ____                            
 / ___|  ___ ___  _ __   ___  ___ 
 \___ \ / __/ _ \| '_ \ / _ \/ __|
  ___) | (_| (_) | |_) |  __/\__ \
 |____/ \___\___/| .__/ \___||___/
                 |_|
 Scopes
 ********************************************************************/
Theorem lookupScopes_unique[Key, Item] :
  forall L (K : Key) (I1 I2 : Item),
    lookupScopes K L I1 -> lookupScopes K L I2 -> I1 = I2.
induction on 1. intros LkpA LkpB. LkpA: case LkpA.
  %1:  LS-FirstScope
   LkpB: case LkpB.
     %1.1:  LS-FirstScope
      apply lookup_unique to LkpA LkpB. search.
     %1.2:  LS-Later
      apply no_lookup to LkpB LkpA.
  %2:  LS-Later
   LkpB: case LkpB.
     %2.1:  LS-FirstScope
      apply no_lookup to LkpA LkpB.
     %2.2:  LS-Later
      apply IH to LkpA1 LkpB1. search.


Theorem lookupScopes_names [K, V] : forall Ctx (X : K) (V : V) Names,
  lookupScopes X Ctx V -> names Ctx Names -> mem X Names.
induction on 1. intros L N. L: case L.
  %LS-FirstScope
   N: case N. M: apply lookup_mem to L. M': apply domain_mem to M N.
   apply mem_append_left to M' N2. search.
  %LS-Later
   N: case N. M: apply IH to L1 N1. apply mem_append_right to M N2.
   search.


Theorem lookup_after_dual_select[Key, Item] :
  forall (K X : Key) (V1 V2 I1 I2 : Item) L R1 R2,
    select (K, V1) R1 L ->  select (K, V2) R2 L -> (K = X -> false) ->
    lookup R1 X I1 -> lookup R2 X I2 -> I1 = I2.
intros SlctA SlctB NEq LkpA LkpB.
assert X = K -> false. intros E. case E. backchain NEq.
LkpLA: apply lookup_after_select_before to LkpA SlctA _.
LkpLB: apply lookup_after_select_before to LkpB SlctB _.
apply lookup_unique to LkpLA LkpLB. search.


Theorem remove_all_unique[Key, Item] :
  forall (L : list (pair Key Item)) X A B,
    remove_all L X A -> remove_all L X B -> A = B.
induction on 1. intros RA RB. RA: case RA.
  %RA-Nil
   case RB. search.
  %RA-Remove
   RB: case RB.
     %RA-Remove
      apply IH to RA RB. search.
     %RA-keep
      apply RB to _.
  %RA-Keep
   RB: case RB.
     %RA-Remove
      apply RA to _.
     %RA-keep
      apply IH to RA1 RB1. search.


Theorem replaceScopes_unique[Key, Item] :
  forall X V (L : list (list (pair Key Item))) RA RB,
    replaceScopes X V L RA -> replaceScopes X V L RB -> RA = RB.
induction on 1. intros RA RB. RA: case RA.
  %RS-FirstScope
   RB: case RB.
     %RS-FirstScope
      apply remove_all_unique to RA1 RB1. search.
     %RS-Later
      apply no_lookup_mem to RB RA.
  %RS-Later
   RB: case RB.
     %RS-FirstScope
      apply no_lookup_mem to RA RB.
     %RS-Later
      apply IH to RA1 RB1. search.


Theorem replaceScopes_names [K, V] :
  forall Ctx (X : K) (V : V) Names R,
    replaceScopes X V Ctx R -> names Ctx Names -> mem X Names.
induction on 1. intros R N. R: case R.
  %RS-FirstScope
   N: case N. M: apply domain_mem to R N.
   apply mem_append_left to M N2. search.
  %LS-Later
   N: case N. M: apply IH to R1 N1. apply mem_append_right to M N2.
   search.


Theorem remove_all_names [K, V] :
  forall (X : K) (L R : list (pair K V)) NL NR Z,
    remove_all L X R -> domain L NL -> domain R NR -> mem Z NL ->
    (X = Z -> false) -> mem Z NR.
induction on 1. intros RA LD RD M NEq. RA: case RA.
  %RA-Nil
   case LD. case M.
  %RA-Remove
   LD: case LD. M: case M.
     %Mem-Here
      apply NEq to _.
     %Mem-Later
      apply IH to RA LD RD _ NEq. search.
  %RA-Keep
   LD: case LD. RD: case RD. M: case M.
     %Mem-Here
      search.
     %Mem-Later
      apply IH to RA1 LD RD M NEq. search.


Theorem mem_after_remove_all_before [K, V] :
  forall L R X (Z : pair K V),
    remove_all L X R -> mem Z R -> mem Z L.
induction on 1. intros R M. R: case R.
  %RA-Nil
   case M.
  %RA-Remove
   apply IH to R M. search.
  %RA-Keep
   M: case M.
     %Mem-Here
      search.
     %Mem-Later
      apply IH to R1 M. search.


Theorem mem_before_remove_all_after [K, V] :
  forall L R X (K : K) (V : V),
    remove_all L X R -> mem (K, V) L -> (K = X -> false) ->
    mem (K, V) R.
induction on 1. intros R M NEq. R: case R.
  %RA-Nil
   case M.
  %RA-Remove
   M: case M.
     %Mem-Here:  K = X
      apply NEq to _.
     %Mem-Later
      apply IH to R M NEq. search.
  %RA-Keep
   M: case M.
     %Mem-Here:  K = K1
      search.
     %Mem-Later
      apply IH to R1 M _. search.


Theorem names_unique [K, V] :
  forall (L : list (list (pair K V))) NA NB,
    names L NA -> names L NB -> NA = NB.
induction on 1. intros NA NB. NA: case NA.
  %Names-Nil
   case NB. search.
  %Names-Cons
   NB: case NB. apply IH to NA1 NB1. apply domain_unique to NA NB.
   apply append_unique to NA2 NB2. search.


%two sets of scopes where the names in the first are associated with
%the same items in the second one
Define lookup_all_scopes :
list (list (pair string Item)) ->
list (list (pair string Item)) -> prop by
  lookup_all_scopes [] [];
  lookup_all_scopes (A::ARest) (B::BRest) :=
    (forall X V, lookup A X V -> lookup B X V) /\
    %We will need is_string for proving things with remove_all later
    (forall X, is_string X -> no_lookup A X -> no_lookup B X) /\
    lookup_all_scopes ARest BRest.


Theorem lookup_all_scopes_lookupScopes[Item] :
  forall A B X (V : Item),
    is_string X -> lookup_all_scopes A B -> lookupScopes X A V ->
    lookupScopes X B V.
induction on 2. intros IsX LAS LS. LAS: case LAS.
  %nil
   case LS.
  %cons
   LS: case LS.
     %LS-FirstScope
      apply LAS to LS. search.
     %LS-Later
      apply IH to _ LAS2 LS1. apply LAS1 to _ LS. search.


Theorem lookup_all_scopes_add[Item] :
  forall A B AS BS X (V : Item),
    lookup_all_scopes (AS::A) (BS::B) ->
    lookup_all_scopes (((X, V)::AS)::A) (((X, V)::BS)::B).
intros LAS. L: case LAS. unfold.
  %lookup
   intros Lkp. Lkp: case Lkp.
     %Lkp-Here
      search.
     %Lkp-Later
      apply L to Lkp1. search.
  %no_lookup
   intros X N. N: case N. apply L1 to _ N1. search.
  %rest
   search.


%all scopes contain the same values for the same names
%order within scope does not matter
Define scopes_same : list (list (pair string value)) ->
                     list (list (pair string value)) -> prop by
scopes_same [] [];
scopes_same (A::ARest) (B::BRest) :=
  (forall X V, lookup A X V -> lookup B X V) /\
  (forall X V, lookup B X V -> lookup A X V) /\
  scopes_same ARest BRest.


Theorem scopes_same_reflexive : forall L,
  is_list (is_list (is_pair is_string is_value)) L -> scopes_same L L.
induction on 1. intros IsL. IsL: case IsL.
  %nil
   search.
  %cons
   unfold.
     %lookup ->
      intros L. search.
     %lookup <-
      intros L. search.
     %rest
      apply IH to IsL1. search.


Theorem scopes_same_trans : forall A B C,
  scopes_same A B -> scopes_same B C -> scopes_same A C.
induction on 1. intros AB BC. AB: case AB.
  %last
   case BC. search.
  %end
   BC: case BC. unfold.
     %lookup A -> lookp C
      intros L. LB: apply AB to L. apply BC to LB. search.
     %lookup C -> lookup A
      intros L. LB: apply BC1 to L. apply AB1 to LB. search.
     %rest
      apply IH to AB2 BC2. search.


Theorem scopes_same_symm : forall A B,
  scopes_same A B -> scopes_same B A.
induction on 1. intros SS. SS: case SS.
  %last
   search.
  %step
   apply IH to SS2. unfold. search. search. search.





/********************************************************************
 __     __         _       _     _           
 \ \   / /_ _ _ __(_) __ _| |__ | | ___  ___ 
  \ \ / / _` | '__| |/ _` | '_ \| |/ _ \/ __|
   \ V / (_| | |  | | (_| | |_) | |  __/\__ \
    \_/ \__,_|_|  |_|\__,_|_.__/|_|\___||___/

 Variables
 ********************************************************************/

/********************************************************************
 Variables are unique
 ********************************************************************/
Extensible_Theorem
  vars_unique : forall E V1 V2,
    IsE : is_expr E ->
    VarsA : vars E V1 ->
    VarsB : vars E V2 ->
    V1 = V2
  on VarsA
also
  varsArgs_unique : forall A V1 V2,
    IsA : is_args A ->
    VarsA : varsArgs A V1 ->
    VarsB : varsArgs A V2 ->
    V1 = V2
  on VarsA,
  varsRecFields_unique : forall RF V1 V2,
    IsRF : is_recFieldExprs RF ->
    VarsA : varsRecFields RF V1 ->
    VarsB : varsRecFields RF V2 ->
    V1 = V2
  on VarsA.
%vars_unique
  %V-Num
   case VarsB. search.
  %V-Plus
   case IsE. VarsB: case VarsB (keep). apply IH to _ VarsA1 VarsB1.
   apply IH to _ VarsA2 VarsB2. apply append_unique to VarsA3 VarsB3.
   search.
  %V-Minus
   case IsE. VarsB: case VarsB (keep). apply IH to _ VarsA1 VarsB1.
   apply IH to _ VarsA2 VarsB2. apply append_unique to VarsA3 VarsB3.
   search.
  %V-Mult
   case IsE. VarsB: case VarsB (keep). apply IH to _ VarsA1 VarsB1.
   apply IH to _ VarsA2 VarsB2. apply append_unique to VarsA3 VarsB3.
   search.
  %V-Div
   case IsE. VarsB: case VarsB (keep). apply IH to _ VarsA1 VarsB1.
   apply IH to _ VarsA2 VarsB2. apply append_unique to VarsA3 VarsB3.
   search.
  %V-True
   case VarsB. search.
  %V-False
   case VarsB. search.
  %V-And
   case IsE. VarsB: case VarsB (keep). apply IH to _ VarsA1 VarsB1.
   apply IH to _ VarsA2 VarsB2. apply append_unique to VarsA3 VarsB3.
   search.
  %V-Or
   case IsE. VarsB: case VarsB (keep). apply IH to _ VarsA1 VarsB1.
   apply IH to _ VarsA2 VarsB2. apply append_unique to VarsA3 VarsB3.
   search.
  %V-Not
   case IsE. VarsB: case VarsB (keep). apply IH to _ VarsA1 VarsB1.
   search.
  %V-Greater
   case IsE. VarsB: case VarsB (keep). apply IH to _ VarsA1 VarsB1.
   apply IH to _ VarsA2 VarsB2. apply append_unique to VarsA3 VarsB3.
   search.
  %V-Eq
   case IsE. VarsB: case VarsB (keep). apply IH to _ VarsA1 VarsB1.
   apply IH to _ VarsA2 VarsB2. apply append_unique to VarsA3 VarsB3.
   search.
  %V-String
   case VarsB. search.
  %V-AppString
   case IsE. VarsB: case VarsB (keep). apply IH to _ VarsA1 VarsB1.
   apply IH to _ VarsA2 VarsB2. apply append_unique to VarsA3 VarsB3.
   search.
  %V-Name
   case VarsB. search.
  %V-Call
   case IsE. VarsB: case VarsB (keep). apply IH1 to _ VarsA1 VarsB1.
   apply IH1 to _ VarsA1 VarsB1. search.
  %V-RecBuild
   case IsE. VarsB: case VarsB (keep). apply IH2 to _ VarsA1 VarsB1.
   search.
  %V-RecAccess
   case IsE. VarsB: case VarsB (keep). apply IH to _ VarsA1 VarsB1.
   search.
  %V-Error
   case IsE. VarsB: case VarsB. apply IH to _ VarsA1 VarsB. search.
%varsArgs_unique
 VarsA: case VarsA.
   %VA-Nil
    case VarsB. search.
   %VA-Cons
    case IsA. VarsB: case VarsB. apply IH to _ VarsA VarsB.
    apply IH1 to _ VarsA1 VarsB1.
    apply append_unique to VarsA2 VarsB2. search.
%varsRecFields_unique
 VarsA: case VarsA.
   %VRF-Nil
    case VarsB. search.
   %VRF-Cons
    case IsRF. VarsB: case VarsB. apply IH to _ VarsA VarsB.
    apply IH2 to _ VarsA1 VarsB1.
    apply append_unique to VarsA2 VarsB2. search.




/********************************************************************
 Variables is_list is_string
 ********************************************************************/
Theorem append_list_string_is : forall L1 L2 L3,
  is_list is_string L1 -> is_list is_string L2 -> L1 ++ L2 = L3 ->
  is_list is_string L3.
induction on 3. intros IsA IsB App. App: case App.
  %nil
   search.
  %cons
   case IsA. apply IH to _ _ App. search.


Extensible_Theorem
  vars_is : forall E V,
    IsE : is_expr E ->
    V : vars E V ->
    is_list is_string V
  on V
also
  varsArgs_is : forall A V,
    IsA : is_args A ->
    V : varsArgs A V ->
    is_list is_string V
  on V,
  varsRecFields_is : forall RF V,
    IsRF : is_recFieldExprs RF ->
    V : varsRecFields RF V ->
    is_list is_string V
  on V.
%vars_is
 %V-Num
  search.
 %V-Plus
  case IsE. IsV2: apply IH to _ V1. IsV3: apply IH to _ V2.
  apply append_list_string_is to _ _ V3. search.
 %V-Minus
  case IsE. IsV2: apply IH to _ V1. IsV3: apply IH to _ V2.
  apply append_list_string_is to _ _ V3. search.
 %V-Mult
  case IsE. IsV2: apply IH to _ V1. IsV3: apply IH to _ V2.
  apply append_list_string_is to _ _ V3. search.
 %V-Div
  case IsE. IsV2: apply IH to _ V1. IsV3: apply IH to _ V2.
  apply append_list_string_is to _ _ V3. search.
 %V-True
  search.
 %V-False
  search.
 %V-And
  case IsE. IsV2: apply IH to _ V1. IsV3: apply IH to _ V2.
  apply append_list_string_is to _ _ V3. search.
 %V-Or
  case IsE. IsV2: apply IH to _ V1. IsV3: apply IH to _ V2.
  apply append_list_string_is to _ _ V3. search.
 %V-Not
  case IsE. Is: apply IH to _ V1. search.
 %V-Greater
  case IsE. IsV2: apply IH to _ V1. IsV3: apply IH to _ V2.
  apply append_list_string_is to _ _ V3. search.
 %V-Eq
  case IsE. IsV2: apply IH to _ V1. IsV3: apply IH to _ V2.
  apply append_list_string_is to _ _ V3. search.
 %V-String
  search.
 %V-AppString
  case IsE. IsV2: apply IH to _ V1. IsV3: apply IH to _ V2.
  apply append_list_string_is to _ _ V3. search.
 %V-Name
  case IsE. search.
 %V-Call
  case IsE. apply IH1 to _ V1. search.
 %V-RecBuild
  case IsE. apply IH2 to _ V1. search.
 %V-RecAccess
  case IsE. apply IH to _ V1. search.
 %V-Error
  case IsE. apply IH to _ V1. search.
%varsArgs_is
 V: case V.
   %VA-Nil
    search.
   %VA-Cons
    case IsA. Is1: apply IH to _ V. Is2: apply IH1 to _ V1.
    apply append_list_string_is to _ _ V2. search.
%varsRecfields_is
 V: case V.
   %VRF-Nil
    search.
   %VRF-Cons
    Is: case IsRF. IsA: apply IH to _ V. IsB: apply IH2 to _ V1.
    apply append_list_string_is to _ _ V2. search.




/********************************************************************
 Variables exist for anything
 ********************************************************************/
Theorem append_list_string_total : forall L1 L2,
  is_list is_string L1 -> is_list is_string L2 ->
  exists L3, L1 ++ L2 = L3.
induction on 1. intros IsA IsB. IsA: case IsA.
  %nil
   search.
  %cons
   apply IH to IsA1 IsB. search.


Extensible_Theorem
  vars_exist : forall E,
    IsE : is_expr E ->
    exists V, vars E V
  on IsE,
  varsArgs_exist : forall A,
    IsA : is_args A ->
    exists V, varsArgs A V
  on IsA,
  varsRecFields_exist : forall RF,
    IsRF : is_recFieldExprs RF ->
    exists V, varsRecFields RF V
  on IsRF.
%vars_exist
 %V-Num
  search.
 %V-Plus
  V1: apply IH to IsE1. V2: apply IH to IsE2.
  Is1: apply vars_is to _ V1. Is2: apply vars_is to _ V2.
  apply append_list_string_total to Is1 Is2. search.
 %V-Minus
  V1: apply IH to IsE1. V2: apply IH to IsE2.
  Is1: apply vars_is to _ V1. Is2: apply vars_is to _ V2.
  apply append_list_string_total to Is1 Is2. search.
 %V-Mult
  V1: apply IH to IsE1. V2: apply IH to IsE2.
  Is1: apply vars_is to _ V1. Is2: apply vars_is to _ V2.
  apply append_list_string_total to Is1 Is2. search.
 %V-Div
  V1: apply IH to IsE1. V2: apply IH to IsE2.
  Is1: apply vars_is to _ V1. Is2: apply vars_is to _ V2.
  apply append_list_string_total to Is1 Is2. search.
 %V-True
  search.
 %V-False
  search.
 %V-And
  V1: apply IH to IsE1. V2: apply IH to IsE2.
  Is1: apply vars_is to _ V1. Is2: apply vars_is to _ V2.
  apply append_list_string_total to Is1 Is2. search.
 %V-Or
  V1: apply IH to IsE1. V2: apply IH to IsE2.
  Is1: apply vars_is to _ V1. Is2: apply vars_is to _ V2.
  apply append_list_string_total to Is1 Is2. search.
 %V-Not
  apply IH to IsE1. search.
 %V-Greater
  V1: apply IH to IsE1. V2: apply IH to IsE2.
  Is1: apply vars_is to _ V1. Is2: apply vars_is to _ V2.
  apply append_list_string_total to Is1 Is2. search.
 %V-Eq
  V1: apply IH to IsE1. V2: apply IH to IsE2.
  Is1: apply vars_is to _ V1. Is2: apply vars_is to _ V2.
  apply append_list_string_total to Is1 Is2. search.
 %V-String
  search.
 %V-AppString
  V1: apply IH to IsE1. V2: apply IH to IsE2.
  Is1: apply vars_is to _ V1. Is2: apply vars_is to _ V2.
  apply append_list_string_total to Is1 Is2. search.
 %V-Name
  search.
 %V-Call
  apply IH1 to IsE2. search.
 %V-RecBuild
  apply IH2 to IsE1. search.
 %V-RecAccess
  apply IH to IsE1. search.
 %V-Error
  apply IH to IsE1. search.
%varsArgs_exist
 %VA-Nil
  search.
 %VA-Cons
  VE: apply IH to IsA1. VA: apply IH1 to IsA2.
  IsVE: apply vars_is to _ VE. IsVA: apply varsArgs_is to _ VA.
  apply append_list_string_total to IsVE IsVA. search.
%varsRecfields_exist
 %VRF-Nil
  search.
 %VRF-Cons
  VE: apply IH to IsRF2. VRF: apply IH2 to IsRF3.
  IsVE: apply vars_is to _ VE. IsVRF: apply varsRecFields_is to _ VRF.
  apply append_list_string_total to IsVE IsVRF. search.




/********************************************************************
 Projection Constraint for Variables
 ********************************************************************/
%projection maintains the set of variables
Projection_Constraint proj_vars : forall E E_P V V_P X,
  Pr : |{expr}- E ~~> E_P ->
  IsE : is_expr E ->
  V : vars E V ->
  V_P : vars E_P V_P ->
  Mem : mem X V ->
  mem X V_P.

%Note we don't have versions for args and recFieldExprs because we
%made those types nonextensible above





/********************************************************************
  _____            _             
 |_   _|   _ _ __ (_)_ __   __ _ 
   | || | | | '_ \| | '_ \ / _` |
   | || |_| | |_) | | | | | (_| |
   |_| \__, | .__/|_|_| |_|\__, |
       |___/|_|            |___/

 Typing
 ********************************************************************/

/********************************************************************
 Basic lemmas around types and typing
 ********************************************************************/

%--------------------------------------------
% Theorems about [(string, typ)]
%--------------------------------------------
Theorem is_list_mem_lookup_type : forall L ID E,
  is_list (is_pair is_string is_typ) L ->
  mem (ID, E) L -> is_string ID ->
  exists E', lookup L ID E'.
induction on 2. intros IsL Mem IsID. Mem: case Mem.
  %Mem-Here
   search.
  %Mem-Later
   Is: case IsL. Is: case Is.
   Or: apply is_string_eq_or_not to Is IsID. Eq: case Or.
     %A = ID
      search.
     %A = ID -> false
      apply IH to Is1 Mem IsID. search.


Theorem lookup_is_type : forall L ID E,
  is_list (is_pair is_string is_typ) L -> lookup L ID E ->
  is_typ E.
induction on 2. intros IsL Lkp. Lkp: case Lkp.
  %Lkp-Here
   Is: case IsL. case Is. search.
  %Lkp-Later
   Is: case IsL. apply IH to Is1 Lkp1. search.


Theorem lookup_is_key_type : forall L ID E,
  is_list (is_pair is_string is_typ) L -> lookup L ID E ->
  is_string ID.
induction on 2. intros IsL Lkp. Lkp: case Lkp.
  %Lkp-Here
   Is: case IsL. case Is. search.
  %Lkp-Later
   Is: case IsL. apply IH to Is1 Lkp1. search.


Theorem mem_is_type : forall L IDE,
  is_list (is_pair is_string is_typ) L -> mem IDE L ->
  is_pair is_string is_typ IDE.
induction on 2. intros Is M. M: case M.
  %Mem-Here
   case Is. search.
  %Mem-Later
   case Is. apply IH to _ M. search.


Theorem zip_is_type : forall A B L,
  is_list is_string A -> is_list is_typ B -> zip A B L ->
  is_list (is_pair is_string is_typ) L.
induction on 3. intros IsA IsB Z. Z: case Z.
  %Zip-Nil
   search.
  %Zip-Cons
   IsA: case IsA. IsB: case IsB. apply IH to _ _ Z. search.


Theorem length_exists_list_pair_string_ty : forall L,
  is_list (is_list (is_pair is_string is_typ)) L ->
  exists N, length L N.
induction on 1. intros IsL. IsL: case IsL.
  %nil
   search.
  %cons
   Len: apply IH to IsL1. Is: apply length_is to Len.
   apply plus_integer_total to _ Is with N1 = 1. search.


%--------------------------------------------
% Theorems about function contexts
% [(string, (type, [type]))]
%--------------------------------------------
Theorem is_list_mem_lookup_funTyCtx : forall L ID E,
  is_list (is_pair is_string
          (is_pair is_typ (is_list is_typ))) L ->
  mem (ID, E) L -> is_string ID ->
  exists E', lookup L ID E'.
induction on 2. intros IsL Mem IsID. Mem: case Mem.
  %Mem-Here
   search.
  %Mem-Later
   Is: case IsL. Is: case Is.
   Or: apply is_string_eq_or_not to Is IsID. Eq: case Or.
     %A = ID
      search.
     %A = ID -> false
      apply IH to Is1 Mem IsID. search.


Theorem mem_is_funTyCtx : forall L IDE,
  is_list (is_pair is_string
          (is_pair is_typ (is_list is_typ))) L -> mem IDE L ->
  is_pair is_string
  (is_pair is_typ (is_list is_typ)) IDE.
induction on 2. intros Is M. M: case M.
  %Mem-Here
   case Is. search.
  %Mem-Later
   case Is. apply IH to _ M. search.


Theorem lookup_is_value_funTyCtx : forall L ID E,
  is_list (is_pair is_string
          (is_pair is_typ (is_list is_typ))) L -> lookup L ID E ->
  is_pair is_typ (is_list is_typ) E.
intros Is L. M: apply lookup_mem to L.
Is: apply mem_is_funTyCtx to _ M. case Is1. search.


Theorem lookup_is_key_funTyCtx : forall L ID E,
  is_list (is_pair is_string
          (is_pair is_typ (is_list is_typ))) L ->
  lookup L ID E ->
  is_string ID.
intros Is L. M: apply lookup_mem to L.
Is: apply mem_is_funTyCtx to _ M. case Is1. search.


%-------------------------------------------------


Theorem lookupScopes_isTy : forall L X Ty,
  is_list (is_list (is_pair is_string is_typ)) L ->
  lookupScopes X L Ty -> is_typ Ty.
induction on 2. intros Is L. L: case L.
  %LS-FirstScope
   case Is. apply lookup_is_type to _ L. search.
  %LS-Later
   case Is. apply IH to _ L1. search.


Theorem zip_is_string_ty : forall A B Z,
  is_list is_string A -> is_list is_typ B -> zip A B Z ->
  is_list (is_pair is_string is_typ) Z.
induction on 3. intros IsA IsB Z. Z: case Z.
  %Zip-Nil
   search.
  %Zip-Cons
   case IsA. case IsB. apply IH to _ _ Z. search.


Theorem length_exists_ty : forall L,
  is_list is_typ L -> exists N, length L N.
induction on 1. intros IsL. IsL: case IsL.
  %nil
   search.
  %cons
   Len: apply IH to IsL1. Is: apply length_is to Len.
   apply plus_integer_total to _ Is with N1 = 1. search.


%-------------------------------------------------


Theorem lookupRecFieldTy_is : forall Fields F Ty,
  is_recFieldTys Fields -> lookupRecFieldTy Fields F Ty -> is_typ Ty.
induction on 2. intros IsF L. L: case L.
  %LFT-Here
   case IsF. search.
  %LFT-Later
   case IsF. apply IH to _ L1. search.


Theorem lookupRecFieldTy_unique : forall Fields F TyA TyB,
  lookupRecFieldTy Fields F TyA -> lookupRecFieldTy Fields F TyB ->
  TyA = TyB.
induction on 1. intros LA LB. LA: case LA.
  %LRF-Here
   LB: case LB.
     %LRF-Here
      search.
     %LRF-Later
      apply LB to _.
  %LRF-Later
   LB: case LB.
     %LRF-Here
      apply LA to _.
     %LRF-Later
      apply IH to LA1 LB1. search.




/********************************************************************
 Types/Contexts produced in typing have is relations
 ********************************************************************/
Extensible_Theorem
  typeOf_isTy : forall E FT ET Ty,
    IsE : is_expr E ->
    IsFT : is_list (is_pair is_string
                   (is_pair is_typ (is_list is_typ))) FT ->
    IsET : is_list (is_list (is_pair is_string is_typ)) ET ->
    Ty : typeOf FT ET E Ty ->
    is_typ Ty
  on Ty as IH_E
also
  typeOfArgs_isTy : forall A FT ET Tys,
    IsA : is_args A ->
    IsFT : is_list (is_pair is_string
                   (is_pair is_typ (is_list is_typ))) FT ->
    IsET : is_list (is_list (is_pair is_string is_typ)) ET ->
    Ty : typeOfArgs FT ET A Tys ->
    is_list is_typ Tys
  on Ty as IH_A,
  typeOfRecFields_isTy : forall RF FT ET Fields,
    IsRF : is_recFieldExprs RF ->
    IsFT : is_list (is_pair is_string
                   (is_pair is_typ (is_list is_typ))) FT ->
    IsET : is_list (is_list (is_pair is_string is_typ)) ET ->
    Ty : typeOfRecFields FT ET RF Fields ->
    is_recFieldTys Fields
  on Ty as IH_RF.
%typeOf_isTy
 %T-Num
  search.
 %T-Plus
  search.
 %T-Minus
  search.
 %T-Mult
  search.
 %T-Div
  search.
 %T-True
  search.
 %T-False
  search.
 %T-And
  search.
 %T-Or
  search.
 %T-Not
  search.
 %T-Greater
  search.
 %T-Eq-Int
  search.
 %T-Eq-Bool
  search.
 %T-Eq-String
  search.
 %T-String
  search.
 %T-AppString
  search.
 %T-Name
  apply lookupScopes_isTy to _ Ty1. search.
 %T-Call
  case IsE. IsFP: apply lookup_is_value_funTyCtx to _ Ty1. case IsFP.
  search.
 %T-RecBuild
  case IsE. apply IH_RF to _ _ _ Ty1. search.
 %T-RecAccess
  case IsE. Is: apply IH_E to _ _ _ Ty1. case Is.
  apply lookupRecFieldTy_is to _ Ty2. search.
 %T-Error
  case IsE. search.
%typeOfArgs_isTy
 Ty: case Ty.
   %TA-Nil
    search.
   %TA-Cons
    case IsA. apply IH_E to _ _ _ Ty. apply IH_A to _ _ _ Ty1. search.
%typeOfRecFields_isTy
 Ty: case Ty.
   %TRF-Nil
    search.
   %TRF-Cons
    case IsRF. apply IH_E to _ _ _ Ty. apply IH_RF to _ _ _ Ty1.
    search.


Extensible_Theorem
  stmtOK_isCtx : forall S FT ET ET',
    IsS : is_stmt S ->
    IsFT : is_list (is_pair is_string
                   (is_pair is_typ (is_list is_typ))) FT ->
    IsET : is_list (is_list (is_pair is_string is_typ)) ET ->
    Ty : stmtOK FT ET S ET' ->
    is_list (is_list (is_pair is_string is_typ)) ET'
  on Ty.
%T-Noop
 search.
%T-Seq
 case IsS. apply IH to _ _ _ Ty1. apply IH to _ _ _ Ty2. search.
%T-Declare
 case IsS. apply typeOf_isTy to _ _ _ Ty2. case IsET. search.
%T-Assign
 search.
%T-RecUpdate
 search.
%T-IfThenElse
 search.
%T-While
 search.
%T-ScopeStmt
 search.
%T-Print-Int
 search.
%T-Print-Bool
 search.
%T-Print-String
 search.




/********************************************************************
 Statements do not make unwanted modifications to contexts
 ********************************************************************/
Extensible_Theorem
  stmtOK_keep_scopes : forall FT ET S ET' N,
    IsS : is_stmt S ->
    IsFT : is_list (is_pair is_string
                   (is_pair is_typ (is_list is_typ))) FT ->
    IsET : is_list (is_list (is_pair is_string is_typ)) ET ->
    Ty : stmtOK FT ET S ET' ->
    L : length ET N ->
    length ET' N
  on Ty.
%T-Noop
 search.
%T-Seq
 case IsS. apply IH to _ _ _ Ty1 _. apply stmtOK_isCtx to _ _ _ Ty1.
 apply IH to _ _ _ Ty2 _. search.
%T-Declare
 L: case L. search.
%T-Assign
 search.
%T-RecUpdate
 search.
%T-IfThenElse
 search.
%T-While
 search.
%T-ScopeStmt
 search.
%T-Print-Int
 search.
%T-Print-Bool
 search.
%T-Print-String
 search.


Extensible_Theorem
  stmtOK_older_scopes_same : forall FT ET S ET' Scope,
    IsS : is_stmt S ->
    IsFT : is_list (is_pair is_string
                   (is_pair is_typ (is_list is_typ))) FT ->
    IsET : is_list (is_list (is_pair is_string is_typ)) (Scope::ET) ->
    Ty : stmtOK FT (Scope::ET) S ET' ->
    exists Scope', ET' = Scope'::ET
  on Ty.
%T-Noop
 search.
%T-Seq
 case IsS. apply IH to _ _ _ Ty1. apply stmtOK_isCtx to _ _ _ Ty1.
 apply IH to _ _ _ Ty2. search.
%T-Declare
 search.
%T-Assign
 search.
%T-RecUpdate
 search.
%T-IfThenElse
 search.
%T-While
 search.
%T-ScopeStmt
 search.
%T-Print-Int
 search.
%T-Print-Bool
 search.
%T-Print-String
 search.


%Don't overwrite existing names in current scope
%Can't say lookupScopes because can overwrite names from older scopes
%   in this scope
Extensible_Theorem
  stmtOK_first_scope_lookup_same : forall FT ET S Scope Scope' X Ty,
    IsS : is_stmt S ->
    IsFT : is_list (is_pair is_string
                   (is_pair is_typ (is_list is_typ))) FT ->
    IsET : is_list (is_list (is_pair is_string is_typ)) (Scope::ET) ->
    Ty : stmtOK FT (Scope::ET) S (Scope'::ET) ->
    L : lookup Scope X Ty ->
    lookup Scope' X Ty
  on Ty.
%T-Noop
 search.
%T-Seq
 case IsS. apply stmtOK_older_scopes_same to _ _ _ Ty1.
 L': apply IH to _ _ _ Ty1 L. apply stmtOK_isCtx to _ _ _ Ty1.
 apply stmtOK_older_scopes_same to _ _ _ Ty2.
 apply IH to _ _ _ Ty2 L'. search.
%T-Declare
 Is: case IsS. case IsET. Is': apply lookup_is_key_type to _ L.
 Or: apply is_string_eq_or_not to Is1 Is'. E: case Or.
   %X1 = X
    apply no_lookup to Ty1 L.
   %X1 != X
    search.
%T-Assign
 search.
%T-RecUpdate
 search.
%T-IfThenElse
 search.
%T-While
 search.
%T-ScopeStmt
 search.
%T-Print-Int
 search.
%T-Print-Bool
 search.
%T-Print-String
 search.




/********************************************************************
 Typing unique
 ********************************************************************/
Extensible_Theorem
  typeOf_unique : forall FT ET_A ET_B E TyA TyB,
    IsE : is_expr E ->
    IsFT : is_list (is_pair is_string
                   (is_pair is_typ (is_list is_typ))) FT ->
    IsA : is_list (is_list (is_pair is_string is_typ)) ET_A ->
    IsB : is_list (is_list (is_pair is_string is_typ)) ET_B ->
    TyA : typeOf FT ET_A E TyA ->
    TyB : typeOf FT ET_B E TyB ->
    Lkp : lookup_all_scopes ET_A ET_B ->
    TyA = TyB
  on TyA as IH_E
also
  typeOfArgs_unique : forall FT ET_A ET_B A TysA TysB,
    IsA : is_args A ->
    IsFT : is_list (is_pair is_string
                   (is_pair is_typ (is_list is_typ))) FT ->
    IsA : is_list (is_list (is_pair is_string is_typ)) ET_A ->
    IsB : is_list (is_list (is_pair is_string is_typ)) ET_B ->
    TyA : typeOfArgs FT ET_A A TysA ->
    TyB : typeOfArgs FT ET_B A TysB ->
    Lkp : lookup_all_scopes ET_A ET_B ->
    TysA = TysB
  on TyA as IH_A,
  typeOfRecFields_unique : forall FT ET_A ET_B RF FieldsA FieldsB,
    IsRF : is_recFieldExprs RF ->
    IsFT : is_list (is_pair is_string
                   (is_pair is_typ (is_list is_typ))) FT ->
    IsA : is_list (is_list (is_pair is_string is_typ)) ET_A ->
    IsB : is_list (is_list (is_pair is_string is_typ)) ET_B ->
    TyA : typeOfRecFields FT ET_A RF FieldsA ->
    TyB : typeOfRecFields FT ET_B RF FieldsB ->
    Lkp : lookup_all_scopes ET_A ET_B ->
    FieldsA = FieldsB
  on TyA as IH_RF.
%typeOf_unique
 %T-Num
  case TyB. search.
 %T-Plus
  case TyB. search.
 %T-Minus
  case TyB. search.
 %T-Mult
  case TyB. search.
 %T-Div
  case TyB. search.
 %T-True
  case TyB. search.
 %T-False
  case TyB. search.
 %T-And
  case TyB. search.
 %T-Or
  case TyB. search.
 %T-Not
  case TyB. search.
 %T-Greater
  case TyB. search.
 %T-Eq-Int
  case TyB. search. search. search.
 %T-Eq-Bool
  case TyB. search. search. search.
 %T-Eq-String
  case TyB. search. search. search.
 %T-String
  case TyB. search.
 %T-AppString
  case TyB. search.
 %T-Name
  TyB: case TyB. case IsE.
  L: apply lookup_all_scopes_lookupScopes to _ Lkp TyA1.
  apply lookupScopes_unique to L TyB. search.
 %T-Call
  TyB: case TyB. apply lookup_unique to TyA1 TyB. search.
 %T-RecBuild
  case IsE. TyB: case TyB. apply IH_RF to _ _ _ _ TyA1 TyB _. search.
 %T-RecAccess
  case IsE. TyB: case TyB. apply IH_E to _ _ _ _ TyA1 TyB _.
  apply lookupRecFieldTy_unique to TyA2 TyB1. search.
 %T-Error
  case TyB. search.
%typeOfArgs_unique
 TyA: case TyA.
   %TRF-Nil
    case TyB. search.
   %TRF-Cons
    case IsA. TyB: case TyB. apply IH_E to _ _ _ _ TyA TyB _.
    apply IH_A to _ _ _ _ TyA1 TyB1 _. search.
%typeOfRecFields_unique
 TyA: case TyA.
   %TRF-Nil
    case TyB. search.
   %TRF-Cons
    case IsRF. TyB: case TyB. apply IH_E to _ _ _ _ TyA TyB _.
    apply IH_RF to _ _ _ _ TyA1 TyB1 _. search.


Extensible_Theorem
  stmtOK_unique : forall FT ET_A ET_B S ET_A' ET_B',
    IsS : is_stmt S ->
    IsFT : is_list (is_pair is_string
                   (is_pair is_typ (is_list is_typ))) FT ->
    IsA : is_list (is_list (is_pair is_string is_typ)) ET_A ->
    IsB : is_list (is_list (is_pair is_string is_typ)) ET_B ->
    TyA : stmtOK FT ET_A S ET_A' ->
    TyB : stmtOK FT ET_B S ET_B' ->
    Lkp : lookup_all_scopes ET_A ET_B ->
    lookup_all_scopes ET_A' ET_B'
  on TyA as IH_S.
%T-Noop
 case TyB. search.
%T-Seq
 case IsS. TyB: case TyB. apply IH_S to _ _ _ _ TyA1 TyB _.
 apply stmtOK_isCtx to _ _ _ TyA1. apply stmtOK_isCtx to _ _ _ TyB.
 apply IH_S to _ _ _ _ TyA2 TyB1 _. search.
%T-Declare
 case IsS. TyB: case TyB. apply typeOf_unique to _ _ _ _ TyA2 TyB1 _.
 backchain lookup_all_scopes_add.
%T-Assign
 case TyB. search.
%T-RecUpdate
 case IsS. TyB: case TyB. search.
%T-IfThenElse
 TyB: case TyB. search.
%T-While
 TyB: case TyB. search.
%T-ScopeStmt
 TyB: case TyB. search.
%T-Print-Int
 TyB: case TyB.
   %T-Print-Int
    search.
   %T-Print-Bool
    search.
   %T-Print-String
    search.
%T-Print-Bool
 case TyB.
   %T-Print-Int
    search.
   %T-Print-Bool
    search.
   %T-Print-String
    search.
%T-Print-String
 case TyB.
   %T-Print-Int
    search.
   %T-Print-Bool
    search.
   %T-Print-String
    search.




/********************************************************************
 Gathered function typing information has is relations
 ********************************************************************/
Extensible_Theorem
  paramTy_is : forall P N T,
    IsP : is_param P ->
    PT : paramTy P N T ->
    is_string N /\ is_typ T
  on PT.
%PT-Param
 case IsP. search.


Theorem paramTys_is : forall Ps PTys,
  is_list is_param Ps -> paramTys Ps PTys ->
  is_list (is_pair is_string is_typ) PTys.
induction on 2. intros IsPs PT. PT: case PT.
  %PT-Nil
   search.
  %PT-Cons
   case IsPs. apply paramTy_is to _ PT. apply IH to _ PT1. search.


Theorem values_is_ty : forall L V,
  is_list (is_pair is_string is_typ) L -> values L V ->
  is_list is_typ V.
induction on 2. intros Is V. V: case V.
  %V-Nil
   search.
  %V-Cons
   Is: case Is. case Is. apply IH to _ V. search.


Extensible_Theorem
  getFunInfo_is : forall F N R P,
    IsF : is_fun F ->
    GFI : getFunInfo F N R P ->
    is_string N /\ is_typ R /\ is_list is_typ P
  on GFI.
%GFI-Fun
 case IsF. apply paramTys_is to _ GFI1. apply values_is_ty to _ GFI2.
 search.


Theorem gatherFunInfo_is : forall Fs Ctx,
  is_list is_fun Fs -> gatherFunInfo Fs Ctx ->
  is_list (is_pair is_string (is_pair is_typ (is_list is_typ))) Ctx.
induction on 2. intros IsFs GFI. GFI: case GFI.
  %GFI-Nil
   search.
  %GFI-Cons
   case IsFs. apply getFunInfo_is to _ GFI. apply IH to _ GFI1.
   search.




/********************************************************************
 Gathered function typing information always exists
 ********************************************************************/
Extensible_Theorem
  paramTy_exists : forall P,
    IsP : is_param P ->
    exists N T, paramTy P N T
  on IsP.
%param
 search.


Theorem paramTys_exists : forall Ps,
  is_list is_param Ps -> exists PTys, paramTys Ps PTys.
induction on 1. intros Is. Is: case Is.
  %nil
   search.
  %cons
   apply paramTy_exists to Is. apply IH to Is1. search.


Theorem values_exists_ty : forall L,
  is_list (is_pair is_string is_typ) L -> exists V, values L V.
induction on 1. intros Is. Is: case Is.
  %nil
   search.
  %cons
   case Is. apply IH to Is1. search.


Extensible_Theorem
  getFunInfo_exists : forall F,
    IsF : is_fun F ->
    exists N R P, getFunInfo F N R P
  on IsF.
%fun
 PT: apply paramTys_exists to IsF5. Is: apply paramTys_is to _ PT.
 apply values_exists_ty to Is. search.


Theorem gatherFunInfo_exists : forall Fs,
  is_list is_fun Fs -> exists Ctx, gatherFunInfo Fs Ctx.
induction on 1. intros Is. Is: case Is.
  %nil
   search.
  %cons
   apply getFunInfo_exists to Is. apply IH to Is1. search.





/********************************************************************
  _____            _             _   _             
 | ____|_   ____ _| |_   _  __ _| |_(_) ___  _ __  
 |  _| \ \ / / _` | | | | |/ _` | __| |/ _ \| '_ \ 
 | |___ \ V / (_| | | |_| | (_| | |_| | (_) | | | |
 |_____| \_/ \__,_|_|\__,_|\__,_|\__|_|\___/|_| |_|

 Evaluation
 ********************************************************************/

/********************************************************************
 Basic lemmas around values and evaluation
 ********************************************************************/

%--------------------------------------------
% Theorems about [(string, value)]
%--------------------------------------------
Theorem is_list_mem_lookup : forall L ID E,
  is_list (is_pair is_string is_value) L ->
  mem (ID, E) L -> is_string ID ->
  exists E', lookup L ID E'.
induction on 2. intros IsL Mem IsID. Mem: case Mem.
  %Mem-Here
   search.
  %Mem-Later
   Is: case IsL. Is: case Is.
   Or: apply is_string_eq_or_not to Is IsID. Eq: case Or.
     %A = ID
      search.
     %A = ID -> false
      apply IH to Is1 Mem IsID. search.


Theorem lookup_is_value : forall L ID E,
  is_list (is_pair is_string is_value) L -> lookup L ID E ->
  is_value E.
induction on 2. intros IsL Lkp. Lkp: case Lkp.
  %Lkp-Here
   Is: case IsL. case Is. search.
  %Lkp-Later
   Is: case IsL. apply IH to Is1 Lkp1. search.


Theorem lookup_is_key : forall L ID E,
  is_list (is_pair is_string is_value) L -> lookup L ID E ->
  is_string ID.
induction on 2. intros IsL Lkp. Lkp: case Lkp.
  %Lkp-Here
   Is: case IsL. case Is. search.
  %Lkp-Later
   Is: case IsL. apply IH to Is1 Lkp1. search.


Theorem lookup_string_value_list_or_no : forall L X,
  is_list (is_pair is_string is_value) L -> is_string X ->
  (exists V, lookup L X V) \/ no_lookup L X.
induction on 1. intros IsL IsX. IsL: case IsL.
  %nil
   search.
  %cons
   Is: case IsL. Or: apply is_string_eq_or_not to Is IsX. E: case Or.
     %A = X
      search.
     %A != X
      Or: apply IH to IsL1 IsX. L: case Or.
        %lookup T X V
         search.
        %no_lookup T X
         search.


Theorem mem_is : forall L IDE,
  is_list (is_pair is_string is_value) L -> mem IDE L ->
  is_pair is_string is_value IDE.
induction on 2. intros Is M. M: case M.
  %Mem-Here
   case Is. search.
  %Mem-Later
   case Is. apply IH to _ M. search.


Theorem zip_is : forall A B L,
  is_list is_string A -> is_list is_value B -> zip A B L ->
  is_list (is_pair is_string is_value) L.
induction on 3. intros IsA IsB Z. Z: case Z.
  %Zip-Nil
   search.
  %Zip-Cons
   IsA: case IsA. IsB: case IsB. apply IH to _ _ Z. search.


Theorem select_is : forall L X L',
  is_list (is_pair is_string is_value) L -> select X L' L ->
  is_list (is_pair is_string is_value) L'.
induction on 2. intros Is S. S: case S.
  %Slct-First
   case Is. search.
  %Slct-Later
   case Is. apply IH to _ S. search.


Theorem domain_is : forall L D,
  is_list (is_pair is_string is_value) L -> domain L D ->
  is_list is_string D.
induction on 2. intros IsL D. D: case D.
  %Dmn-Nil
   search.
  %Dmn-Cons
   Is: case IsL. case Is. apply IH to _ D. search.


Theorem names_is : forall L N,
  is_list (is_list (is_pair is_string is_value)) L -> names L N ->
  is_list is_string N.
induction on 2. intros Is N. N: case N.
  %Names-Nil
   search.
  %Names-Cons
   case Is. IsNRest: apply IH to _ N1.
   IsNScope: apply domain_is to _ N.
   apply append_list_string_is to _ _ N2. search.


Theorem domain_exists : forall L,
  is_list (is_pair is_string is_value) L -> exists D, domain L D.
induction on 1. intros Is. Is: case Is.
  %nil
   search.
  %cons
   case Is. apply IH to Is1. search.


Theorem names_exists : forall L,
  is_list (is_list (is_pair is_string is_value)) L ->
  exists N, names L N.
induction on 1. intros Is. Is: case Is.
  %nil
   search.
  %cons
   D: apply domain_exists to Is. N: apply IH to Is1.
   IsD: apply domain_is to Is D. IsN: apply names_is to _ N.
   apply append_list_string_total to IsD IsN. search.


%--------------------------------------------
% Theorems about function contexts
% [(string, (string, value, [string], stmt))]
%--------------------------------------------
Theorem is_list_mem_lookup_funCtx : forall L ID E,
  is_list (is_pair is_string
          (is_pair is_string
          (is_pair is_value
          (is_pair (is_list is_string) is_stmt)))) L ->
  mem (ID, E) L -> is_string ID ->
  exists E', lookup L ID E'.
induction on 2. intros IsL Mem IsID. Mem: case Mem.
  %Mem-Here
   search.
  %Mem-Later
   Is: case IsL. Is: case Is.
   Or: apply is_string_eq_or_not to Is IsID. Eq: case Or.
     %A = ID
      search.
     %A = ID -> false
      apply IH to Is1 Mem IsID. search.


Theorem mem_is_funCtx : forall L IDE,
  is_list (is_pair is_string
          (is_pair is_string
          (is_pair is_value
          (is_pair (is_list is_string) is_stmt)))) L -> mem IDE L ->
  is_pair is_string
      (is_pair is_string (is_pair is_value
                         (is_pair (is_list is_string) is_stmt))) IDE.
induction on 2. intros Is M. M: case M.
  %Mem-Here
   case Is. search.
  %Mem-Later
   case Is. apply IH to _ M. search.


Theorem lookup_is_value_funCtx : forall L ID E,
  is_list (is_pair is_string
          (is_pair is_string
          (is_pair is_value
          (is_pair (is_list is_string) is_stmt)))) L ->
  lookup L ID E ->
  is_pair is_string (is_pair is_value
                       (is_pair (is_list is_string) is_stmt)) E.
intros Is L. M: apply lookup_mem to L. Is: apply mem_is_funCtx to _ M.
case Is1. search.


Theorem lookup_is_key_funCtx : forall L ID E,
  is_list (is_pair is_string
          (is_pair is_string
          (is_pair is_value
          (is_pair (is_list is_string) is_stmt)))) L ->
  lookup L ID E ->
  is_string ID.
intros Is L. M: apply lookup_mem to L. Is: apply mem_is_funCtx to _ M.
case Is1. search.


%--------------------------------------------
% Theorems about remove_all
%--------------------------------------------
Theorem remove_all_mem[Key, Item] :
  forall (L : list (pair Key Item)) K L' I,
    remove_all L K L' -> mem (K, I) L' -> false.
induction on 1. intros RA M. RA: case RA.
  %RA-Nil
   case M.
  %RA-Remove
   apply IH to RA M.
  %RA-Keep
   M: case M.
     %Mem-Here
      backchain RA.
     %Mem-Later
      apply IH to RA1 M.


Theorem remove_all_lookup_other[Key, Item] :
  forall (L : list (pair Key Item)) K L' X I,
    remove_all L K L' -> lookup L' X I -> (K = X -> false) ->
    lookup L X I.
induction on 1. intros R L N. R: case R.
  %RA-Nil
   case L.
  %RA-Remove
   apply IH to R L _. search.
  %RA-Keep
   L: case L.
     %Lkp-First
      search.
     %Lkp-Later
      apply IH to R1 L1 _. search.


Theorem remove_all_lookup_other_back[Key, Item] :
  forall (L : list (pair Key Item)) K L' X I,
    remove_all L K L' -> lookup L X I -> (K = X -> false) ->
    lookup L' X I.
induction on 1. intros R L N. R: case R.
  %RA-Nil
   case L.
  %RA-Remove
   L: case L.
     %Lkp-First
      apply N to _.
     %Lkp-Later
      apply IH to R L1 _. search.
  %RA-Keep
   L: case L.
     %Lkp-First
      search.
     %Lkp-Later
      apply IH to R1 L1 _. search.


Theorem remove_all_lookups : forall LA LB K LA' LB' X I,
    is_list (is_pair is_string is_value) LA ->
    is_list (is_pair is_string is_value) LB ->
    is_string K -> is_string X ->
    (forall X I, lookup LA X I -> lookup LB X I) ->
    remove_all LA K LA' -> remove_all LB K LB' -> lookup LA' X I ->
    lookup LB' X I.
intros IsA IsB IsK IsX Lkp RA RB L.
Or: apply is_string_eq_or_not to IsK IsX. E: case Or.
  %X = K
   M: apply lookup_mem to L. apply remove_all_mem to RA M.
  %X != K
   L': apply remove_all_lookup_other to RA L E. LB: apply Lkp to L'.
   apply remove_all_lookup_other_back to RB LB _. search.


Theorem remove_all_no_lookup_back[Key, Item] :
  forall (L : list (pair Key Item)) K L' X,
    remove_all L K L' -> no_lookup L X -> no_lookup L' X.
induction on 1. intros RA N. RA: case RA.
  %RA-Nil
   search.
  %RA-Remove
   N: case N. apply IH to RA N1. search.
  %RA-Keep
   N: case N. apply IH to RA1 N1. search.


Theorem remove_all_no_lookup : forall L K L' X,
  is_list (is_pair is_string is_value) L ->
  is_string K -> is_string X ->
  remove_all L K L' -> no_lookup L' X -> no_lookup L X \/ X = K.
induction on 4. intros IsL IsK IsX RA N. RA: case RA.
  %RA-Nil
   search.
  %RA-Remove
   Is: case IsL. Or: apply IH to _ _ _ RA N. E: case Or.
     %no_lookup Rest X
      Or: apply is_string_eq_or_not to IsK IsX. NE: case Or.
        %K = X
         search.
        %K != X
         search.
     %X = K
      search.
  %RA-Keep
   N: case N. Is: case IsL. Or: apply IH to _ _ _ RA1 N1. E: case Or.
     %no_lookup Rest X
      Or: apply is_string_eq_or_not to IsK IsX. NE: case Or.
        %K = X
         search.
        %K != X
         search.
     %X = K
      search.


%--------------------------------------------
% Theorems about length
%--------------------------------------------
Theorem length_exists_list_pair_string_value : forall L,
  is_list (is_list (is_pair is_string is_value)) L ->
  exists N, length L N.
induction on 1. intros IsL. IsL: case IsL.
  %nil
   search.
  %cons
   Len: apply IH to IsL1. Is: apply length_is to Len.
   apply plus_integer_total to _ Is with N1 = 1. search.


Theorem length_exists_value : forall L,
  is_list is_value L -> exists N, length L N.
induction on 1. intros IsL. IsL: case IsL.
  %nil
   search.
  %cons
   Len: apply IH to IsL1. Is: apply length_is to Len.
   apply plus_integer_total to _ Is with N1 = 1. search.


%--------------------------------------------
% Theorems about zip
%--------------------------------------------
Theorem zip_exists[A, B] : forall (A : list A) (B : list B) N,
  length A N -> length B N -> exists Z, zip A B Z.
induction on 1. intros LA LB. LA: case LA.
  %A = []
   LB: case LB.
     %B = []
      search.
     %B cons
      GEq: apply length_geq_0 to LB.
      Or: apply greatereq_integer_greater_or_eq to GEq. L: case Or.
        %N' > 0
         apply length_is to LB. apply lt_plus_one to LB1 _.
         apply greater_less_impossible to L _.
        %N' = 0
         case LB1.
  %A cons
   LB: case LB.
     %B = []
      GEq: apply length_geq_0 to LA.
      Or: apply greatereq_integer_greater_or_eq to GEq. L: case Or.
        %N' > 0
         apply length_is to LA. apply lt_plus_one to LA1 _.
         apply greater_less_impossible to L _.
        %N1 = 0
         case LA1.
     %B cons
      apply length_is to LA. apply length_is to LB.
      apply plus_integer_unique_addend to _ _ _ LA1 LB1.
      apply IH to LA LB. search.


Theorem zip_is_string_value : forall A B Z,
  is_list is_string A -> is_list is_value B -> zip A B Z ->
  is_list (is_pair is_string is_value) Z.
induction on 3. intros IsA IsB Z. Z: case Z.
  %Zip-Nil
   search.
  %Zip-Cons
   case IsA. case IsB. apply IH to _ _ Z. search.


%--------------------------------------------


Theorem mem_lookup : forall L X V,
  is_list (is_pair is_string is_value) L -> mem (X, V) L ->
  exists V', lookup L X V'.
induction on 2. intros IsL M. M: case M.
  %Mem-Here
   search.
  %Mem-Later
   IsL: case IsL. Is: apply mem_is to _ M. IsA: case IsL.
   IsB: case Is. Or: apply is_string_eq_or_not to IsA IsB. E: case Or.
     %A = X
      search.
     %A != X
      apply IH to _ M. search.


Theorem replaceScopes_lookup_all_scopes : forall X V A B A' B',
    is_list (is_list (is_pair is_string is_value)) A ->
    is_list (is_list (is_pair is_string is_value)) B ->
    lookup_all_scopes A B ->
    replaceScopes X V A A' -> replaceScopes X V B B' ->
    lookup_all_scopes A' B'.
induction on 4. intros IsA IsB LAS RA RB. RA: case RA.
  %RS-FirstScope
   RB: case RB.
     %RS-FirstScope
      LAS: case LAS (keep). unfold.
        %lookup
         intros L. L: case L.
           %Lkp-Here (X = X1)
            search.
           %Lkp-Later (X != X1)
            LL: apply remove_all_lookup_other to RA1 L1 _.
            LB: apply LAS1 to LL.
            apply remove_all_lookup_other_back to RB1 LB _. search.
        %no_lookup
         intros X N. N: case N. case IsB. IsP: apply mem_is to _ RB.
         case IsP. case IsA.
         Or: apply remove_all_no_lookup to _ _ _ RA1 N1. NL: case Or.
           %no_lookup L X1
            NL1: apply LAS2 to _ NL.
            apply remove_all_no_lookup_back to RB1 NL1. search.
           %X1 = X
            apply N to _.
        %rest
         search.
     %RS-Later
      case IsA. LA: apply mem_lookup to _ RA. LAS: case LAS.
      LB: apply LAS to LA. apply no_lookup to RB LB.
  %RS-Later
   RB: case RB.
     %RS-FirstScope
      LAS: case LAS. case IsB. IsP: apply mem_is to _ RB. case IsP.
      LB: apply LAS1 to _ RA. apply no_lookup_mem to LB RB.
     %RS-Later
      LAS: case LAS. case IsA. case IsB. apply IH to _ _ _ RA1 RB1.
      search.




/********************************************************************
 Evaluation-produced values and contexts have is relations
 ********************************************************************/
 Theorem lookupScopes_is : forall L X V,
  is_list (is_list (is_pair is_string is_value)) L ->
  lookupScopes X L V -> is_value V /\ is_string X.
induction on 2. intros Is L. L: case L.
  %LS-FirstScope
   case Is. apply lookup_is_value to _ L. apply lookup_is_key to _ L.
   search.
  %LS-Later
   case Is. apply IH to _ L1. search.


Theorem remove_all_is : forall L X L',
  is_list (is_pair is_string is_value) L -> remove_all L X L' ->
  is_list (is_pair is_string is_value) L'.
induction on 2. intros IsL R. R: case R.
  %RA-Nil
   search.
  %RA-Remove
   Is: case IsL. apply IH to _ R. search.
  %RA-Keep
   Is: case IsL. apply IH to _ R1. search.


Theorem replaceScopes_is : forall L X V L',
  is_list (is_list (is_pair is_string is_value)) L -> is_value V ->
  replaceScopes X V L L' ->
  is_list (is_list (is_pair is_string is_value)) L'.
induction on 3. intros IsL IsV R. R: case R.
  %RS-FirstScope
   case IsL. apply remove_all_is to _ R1. IsP: apply mem_is to _ R.
   case IsP. search.
  %RS-Later
   case IsL. apply IH to _ _ R1. search.


Theorem lookupRecFieldVal_is : forall RFVs F V,
  is_recFieldVals RFVs -> lookupRecFieldVal RFVs F V -> is_value V.
induction on 2. intros Is LRFV. LRFV: case LRFV.
  %LRFV-Here
   case Is. search.
  %LRFV-Later
   case Is. apply IH to _ LRFV1. search.


Theorem replaceRecVal_is : forall F V RFVs RFVs',
  is_value V -> is_recFieldVals RFVs ->
  replaceRecVal F V RFVs RFVs' -> is_recFieldVals RFVs'.
induction on 3. intros IsV IsRFVs RRV. RRV: case RRV.
  %RRV-Here
   Is: case IsRFVs. search.
  %RRV-Later
   Is: case IsRFVs. apply IH to _ _ RRV1. search.


Theorem updateRecFields_is : forall Fs V RFVs RFVs',
  is_value V -> is_list is_string Fs -> is_recFieldVals RFVs ->
  updateRecFields Fs V RFVs RFVs' -> is_recFieldVals RFVs'.
induction on 4. intros IsV IsFs IsRFVs U. U: case U.
  %URF-One
   apply replaceRecVal_is to _ _ U. case IsFs. search.
  %URF-Step
   IsFs: case IsFs. IsRV: apply lookupRecFieldVal_is to _ U.
   case IsRV. apply IH to _ _ _ U1. apply replaceRecVal_is to _ _ U2.
   search.


Extensible_Theorem
  evalExpr_isValue : forall FE EE E V O,
    IsE : is_expr E ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    Ev : evalExpr FE EE E V O ->
    is_value V
  on Ev as IH_V_E,
  evalStmt_isCtx : forall FE EE EE' S O,
    IsS : is_stmt S ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    Ev : evalStmt FE EE S EE' O ->
    is_list (is_list (is_pair is_string is_value)) EE'
  on Ev as IH_C_S,
  evalArgs_isValue : forall FE EE A V O,
    IsA : is_args A ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    Ev : evalArgs FE EE A V O ->
    is_list is_value V
  on Ev as IH_V_A,
  evalRecFields_isValue : forall FE EE RF V O,
    IsRF : is_recFieldExprs RF ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    Ev : evalRecFields FE EE RF V O ->
    is_recFieldVals V
  on Ev as IH_V_RF.
%evalExpr_isValue
 %E-Num
  case IsE. search.
 %E-Plus
  case IsE. IsI1: apply IH_V_E to _ _ _ Ev1.
  IsI2: apply IH_V_E to _ _ _ Ev2. case IsI1. case IsI2.
  apply plus_integer_is_integer to _ _ Ev3. search.
 %E-Minus
  case IsE. IsI1: apply IH_V_E to _ _ _ Ev1.
  IsI2: apply IH_V_E to _ _ _ Ev2. case IsI1. case IsI2.
  apply minus_integer_is_integer to _ _ Ev3. search.
 %E-Mult
  case IsE. IsI1: apply IH_V_E to _ _ _ Ev1.
  IsI2: apply IH_V_E to _ _ _ Ev2. case IsI1. case IsI2.
  apply multiply_integer_is_integer to _ _ Ev3. search.
 %E-Div
  case IsE. IsI1: apply IH_V_E to _ _ _ Ev1.
  IsI2: apply IH_V_E to _ _ _ Ev2. case IsI1. case IsI2.
  apply divide_integer_is_integer to _ _ Ev3. search.
 %E-True
  search.
 %E-False
  search.
 %E-And-True
  search.
 %E-And-False1
  search.
 %E-And-False2
  search.
 %E-Or-True1
  search.
 %E-Or-True2
  search.
 %E-Or-False
  search.
 %E-Not-True
  search.
 %E-Not-False
  search.
 %E-Greater-True
  search.
 %E-Greater-False
  search.
 %E-Eq-True
  search.
 %E-Eq-False
  search.
 %E-String
  case IsE. search.
 %E-AppString
  case IsE. IsI1: apply IH_V_E to _ _ _ Ev1.
  IsI2: apply IH_V_E to _ _ _ Ev2. case IsI1. case IsI2.
  apply is_string_append to _ _ Ev3. search.
 %E-Name
  case IsE. apply lookupScopes_is to _ Ev1. search.
 %E-Call
  IsF: apply lookup_is_value_funCtx to _ Ev1. IsF: case IsF.
  IsF: case IsF1. IsF: case IsF2. case IsE. apply IH_V_A to _ _ _ Ev2.
  apply zip_is to _ _ Ev3. apply IH_C_S to _ _ _ Ev4.
  apply lookupScopes_is to _ Ev6. search.
 %E-RecBuild
  case IsE. apply IH_V_RF to _ _ _ Ev1. search.
 %E-RecAccess
  Is: case IsE. IsRV: apply IH_V_E to _ _ _ Ev1. case IsRV.
  apply lookupRecFieldVal_is to _ Ev2. search.
%evalStmt_isCtx
 %E-Noop
  search.
 %E-Seq
  case IsS. apply IH_C_S to _ _ _ Ev1. apply IH_C_S to _ _ _ Ev2.
  search.
 %E-Declare
  case IsS. apply IH_V_E to _ _ _ Ev1. case IsEE. search.
 %E-Assign
  case IsS. apply IH_V_E to _ _ _ Ev1.
  apply replaceScopes_is to _ _ Ev2. search.
 %E-RecUpdate
  case IsS. IsRV: apply lookupScopes_is to _ Ev2. case IsRV.
  apply IH_V_E to _ _ _ Ev1. apply updateRecFields_is to _ _ _ Ev3.
  apply replaceScopes_is to _ _ Ev4. search.
 %E-If-True
  case IsS. Is': apply IH_C_S to _ _ _ Ev2. case Is'. search.
 %E-If-False
  case IsS. Is': apply IH_C_S to _ _ _ Ev2. case Is'. search.
 %E-While-True
  case IsS. IsEE4+: apply IH_C_S to _ _ _ Ev2. case IsEE4+.
  apply IH_C_S to _ _ _ Ev3. search.
 %E-While-False
  case IsS. search.
 %E-ScopeStmt
  case IsS. Is: apply IH_C_S to _ _ _ Ev1. case Is. search.
 %E-Print-Int
  case IsS. search.
 %E-Print-True
  case IsS. search.
 %E-Print-False
  case IsS. search.
 %E-Print-String
  case IsS. search.
%evalArgs_isValue
 %EA-Nil
  search.
 %EA-Cons
  case IsA. apply IH_V_E to _ _ _ Ev1. apply IH_V_A to _ _ _ Ev2.
  search.
%evalRecFields_isValue
 %ERF-Nil
  search.
 %ERF-Cons
  case IsRF. apply IH_V_E to _ _ _ Ev1. apply IH_V_RF to _ _ _ Ev2.
  search.


Theorem append_values_is : forall LA LB L,
  is_list is_value LA -> is_list is_value LB -> LA ++ LB = L ->
  is_list is_value L.
induction on 1. intros IsA IsB App. IsA: case IsA.
  %nil
   case App. search.
  %cons
   App: case App. apply IH to IsA1 IsB App. search.


/*
  We put this in a separate group from the other is theorems above as
  a deliberate choice to prevent extensions from making their values
  depend on printed values.
 */
Extensible_Theorem
  evalExpr_isOutput : forall FE EE E V O,
    IsE : is_expr E ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    Ev : evalExpr FE EE E V O ->
    is_list is_value O
  on Ev as IH_E,
  evalStmt_isOutput : forall FE EE EE' S O,
    IsS : is_stmt S ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    Ev : evalStmt FE EE S EE' O ->
    is_list is_value O
  on Ev as IH_S,
  evalArgs_isOutput : forall FE EE A V O,
    IsA : is_args A ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    Ev : evalArgs FE EE A V O ->
    is_list is_value O
  on Ev as IH_A,
  evalRecFields_isOutput : forall FE EE RF V O,
    IsRF : is_recFieldExprs RF ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    Ev : evalRecFields FE EE RF V O ->
    is_list is_value O
  on Ev as IH_RF.
%evalExpr_isOutput
 %E-Num
  search.
 %E-Plus
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply append_values_is to _ _ Ev4. search.
 %E-Minus
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply append_values_is to _ _ Ev4. search.
 %E-Mult
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply append_values_is to _ _ Ev4. search.
 %E-Div
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply append_values_is to _ _ Ev4. search.
 %E-True
  search.
 %E-False
  search.
 %E-And-True
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply append_values_is to _ _ Ev3. search.
 %E-And-False1
  case IsE. apply IH_E to _ _ _ Ev1. search.
 %E-And-False2
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply append_values_is to _ _ Ev3. search.
 %E-Or-True1
  case IsE. apply IH_E to _ _ _ Ev1. search.
 %E-Or-True2
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply append_values_is to _ _ Ev3. search.
 %E-Or-False
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply append_values_is to _ _ Ev3. search.
 %E-Not-True
  case IsE. apply IH_E to _ _ _ Ev1. search.
 %E-Not-False
  case IsE. apply IH_E to _ _ _ Ev1. search.
 %E-Greater-True
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply append_values_is to _ _ Ev4. search.
 %E-Greater-False
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply append_values_is to _ _ Ev4. search.
 %E-Eq-True
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply append_values_is to _ _ Ev3. search.
 %E-Eq-False
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply append_values_is to _ _ Ev4. search.
 %E-String
  search.
 %E-AppString
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply append_values_is to _ _ Ev4. search.
 %E-Name
  search.
 %E-Call
  IsFP: apply lookup_is_value_funCtx to _ Ev1. IsF: case IsFP.
  IsF: case IsF1. IsF: case IsF2. case IsE.
  apply evalArgs_isValue to _ _ _ Ev2. apply zip_is to _ _ Ev3.
  apply IH_S to _ _ _ Ev4. apply IH_A to _ _ _ Ev2.
  apply append_values_is to _ _ Ev5. search.
 %E-RecBuild
  case IsE. apply IH_RF to _ _ _ Ev1. search.
 %E-RecAccess
  case IsE. apply IH_E to _ _ _ Ev1. search.
%evalStmt_isOutput
 %E-Noop
  search.
 %E-Seq
  case IsS. apply IH_S to _ _ _ Ev1.
  apply evalStmt_isCtx to _ _ _ Ev1. apply IH_S to _ _ _ Ev2.
  apply append_values_is to _ _ Ev3. search.
 %E-Declare
  case IsS. apply IH_E to _ _ _ Ev1. search.
 %E-Assign
  case IsS. apply IH_E to _ _ _ Ev1. search.
 %E-RecUpdate
  case IsS. apply IH_E to _ _ _ Ev1. search.
 %E-If-True
  case IsS. apply IH_E to _ _ _ Ev1. apply IH_S to _ _ _ Ev2.
  apply append_values_is to _ _ Ev3. search.
 %E-If-False
  case IsS. apply IH_E to _ _ _ Ev1. apply IH_S to _ _ _ Ev2.
  apply append_values_is to _ _ Ev3. search.
 %E-While-True
  case IsS. apply IH_E to _ _ _ Ev1. apply IH_S to _ _ _ Ev2.
  Is: apply evalStmt_isCtx to _ _ _ Ev2. case Is.
  apply IH_S to _ _ _ Ev3. apply append_values_is to _ _ Ev4.
  apply append_values_is to _ _ Ev5. search.
 %E-While-False
  case IsS. apply IH_E to _ _ _ Ev1. search.
 %E-ScopeStmt
  case IsS. apply IH_S to _ _ _ Ev1. search.
 %E-Print-Int
  case IsS. apply IH_E to _ _ _ Ev1.
  IsV: apply evalExpr_isValue to _ _ _ Ev1. case IsV.
  apply append_values_is to _ _ Ev2. search.
 %E-Print-True
  case IsS. apply IH_E to _ _ _ Ev1.
  apply append_values_is to _ _ Ev2. search.
 %E-Print-False
  case IsS. apply IH_E to _ _ _ Ev1.
  apply append_values_is to _ _ Ev2. search.
 %E-Print-String
  case IsS. apply IH_E to _ _ _ Ev1.
  apply evalExpr_isValue to _ _ _ Ev1.
  apply append_values_is to _ _ Ev2. search.
%evalArgs_isOutput
 %EA-Nil
  search.
 %EA-Cons
  case IsA. apply IH_E to _ _ _ Ev1. apply IH_A to _ _ _ Ev2.
  apply append_values_is to _ _ Ev3. search.
%evalRecFields_isOutput
 %ERF-Nil
  search.
 %ERF-Cons
  case IsRF. apply IH_E to _ _ _ Ev1. apply IH_RF to _ _ _ Ev2.
  apply append_values_is to _ _ Ev3. search.




/********************************************************************
 Gathered function evaluation information has is relations
 ********************************************************************/
Extensible_Theorem
  paramName_is : forall P N,
    IsP : is_param P ->
    PN : paramName P N ->
    is_string N
  on PN.
%PN-Param
 case IsP. search.


Theorem paramNames_is : forall Ps Ns,
  is_list is_param Ps -> paramNames Ps Ns -> is_list is_string Ns.
induction on 2. intros IsPs PN. PN: case PN.
  %PNs-Empty
   search.
  %PNs-Cons
   case IsPs. apply paramName_is to _ PN. apply IH to _ PN1. search.


Extensible_Theorem
  getFunEvalInfo_is : forall F Name RetVar RVVal PNames Body,
    IsF : is_fun F ->
    GEFI : getFunEvalInfo F Name RetVar RVVal PNames Body ->
    is_string Name /\ is_string RetVar /\ is_value RVVal /\
      is_list is_string PNames /\ is_stmt Body
  on GEFI.
%GEFI-Fun
 case IsF. apply paramNames_is to _ GEFI1. search.


Theorem getFunEvalCtx_is : forall Fs Ctx,
  is_list is_fun Fs -> getFunEvalCtx Fs Ctx ->
  is_list (is_pair is_string (is_pair is_string
          (is_pair is_value
          (is_pair (is_list is_string) is_stmt)))) Ctx.
induction on 2. intros IsFs GEFC. GEFC: case GEFC.
  %GEFC-Empty
   search.
  %GEFC-Cons
   case IsFs. apply getFunEvalInfo_is to _ GEFC. apply IH to _ GEFC1.
   search.




/********************************************************************
 Program evaluation results have is_list is_value
 ********************************************************************/
Extensible_Theorem
  evalProgram_isOutput : forall A P O,
    IsP : is_program P ->
    IsA : is_list is_value A ->
    Ev : evalProgram A P O ->
    is_list is_value O
  on Ev.
%E-Program
 Is: case IsP. apply getFunEvalInfo_is to _ Ev2.
 apply zip_is to _ _ Ev3. apply getFunEvalCtx_is to _ Ev1.
 apply evalStmt_isOutput to _ _ _ Ev4. search.




/********************************************************************
 Evaluation does not make unwanted modifications to contexts
 ********************************************************************/
Define names_same : list (list (pair string ItemA)) ->
                    list (list (pair string ItemB)) -> prop by
names_same [] [];
names_same (A::ARest) (B::BRest) :=
  (forall X IA, mem (X, IA) A -> exists IB, mem (X, IB) B) /\
  (forall X IB, mem (X, IB) B -> exists IA, mem (X, IA) A) /\
  names_same ARest BRest.


Theorem names_same_symmetric[A, B] :
  forall (A : list (list (pair string A)))
         (B : list (list (pair string B))),
    names_same A B -> names_same B A.
induction on 1. intros NS. NS: case NS.
  %last
   search.
  %step
   apply IH to NS2. search.


Theorem names_same_reflexive : forall L,
  is_list (is_list (is_pair is_string is_value)) L -> names_same L L.
induction on 1. intros IsL. IsL: case IsL.
  %nil
   search.
  %cons
   apply IH to IsL1. search.


Theorem names_same_transitive[ItemA, ItemB, ItemC] :
  forall (A : list (list (pair string ItemA)))
         (B : list (list (pair string ItemB)))
         (C : list (list (pair string ItemC))),
    names_same A B -> names_same B C -> names_same A C.
induction on 1. intros NAB NBC. NAB: case NAB.
  %last
   case NBC. search.
  %step
   NBC: case NBC. rename B2 to C1. rename BRest1 to CRest. unfold.
     %mem A1 -> mem C1
      intros MA. MB: apply NAB to MA. apply NBC to MB. search.
     %mem C1 -> mem A1
      intros MC. MB: apply NBC1 to MC. apply NAB1 to MB. search.
     %rest
      apply IH to NAB2 NBC2. search.


Theorem names_same_names[ItemA, ItemB] :
  forall (A : list (list (pair string ItemA)))
         (B : list (list (pair string ItemB))) NA NB X,
    names_same A B -> names A NA -> names B NB -> mem X NA ->
    mem X NB.
induction on 1. intros NS NA NB M. NS: case NS.
  %last
   case NA. case M.
  %step
   NA: case NA. NB: case NB. Or: apply mem_append to M NA2.
   M': case Or.
     %mem X NScope
      MA1: apply mem_domain to NA M'. MB1: apply NS to MA1.
      M'': apply domain_mem to MB1 NB.
      apply mem_append_left to M'' NB2. search.
     %mem X NRest
      M'': apply IH to NS2 NA1 NB1 M'.
      apply mem_append_right to M'' NB2. search.


Theorem names_same_names_back[ItemA, ItemB] :
  forall (A : list (list (pair string ItemA)))
         (B : list (list (pair string ItemB))) NA NB X,
    names_same A B -> names A NA -> names B NB -> mem X NB ->
    mem X NA.
induction on 1. intros NS NA NB M. NS: case NS.
  %last
   case NB. case M.
  %step
   NB: case NB. NA: case NA. Or: apply mem_append to M NB2.
   M': case Or.
     %mem X NScope
      MB1: apply mem_domain to NB M'. MA1: apply NS1 to MB1.
      M'': apply domain_mem to MA1 NA.
      apply mem_append_left to M'' NA2. search.
     %mem X NRest
      M'': apply IH to NS2 NA1 NB1 M'.
      apply mem_append_right to M'' NA2. search.


Theorem replaceScopes_names_same : forall L K I R,
    is_list (is_list (is_pair is_string is_value)) L ->
    replaceScopes K I L R -> names_same L R.
induction on 2. intros IsL R. R: case R.
  %RS-FirstScope
   unfold.
     %mem L -> mem LRemain
      intros M. case IsL. IsX: apply mem_is to _ M. IsX: case IsX.
      IsK: apply mem_is to _ R. IsK: case IsK.
      Or: apply is_string_eq_or_not to IsK IsX. E: case Or.
        %X = K
         search.
        %X != K
         apply mem_before_remove_all_after to R1 M _.
           intros Eq. case Eq. backchain E.
         search.
     %mem LRemain -> mem L
      intros M. M: case M.
        %Mem-Here:  X = K
         search.
        %Mem-Later
         apply mem_after_remove_all_before to R1 M. search.
     %rest
      Is: case IsL. backchain names_same_reflexive.
  %RS-Later
   case IsL. apply IH to _ R1. search.


Theorem names_same_add_scope[I, V] :
  forall (A : list (list (pair string I)))
         (B : list (list (pair string V))),
    names_same A B -> names_same ([]::A) ([]::B).
intros NS. unfold.
  %mem A -> mem B
   intros M. case M.
  %mem B -> mem A
   intros M. case M.
  %rest
   search.


%Evaluation doesn't change the names present in older scopes in ctxs
%This will be important for extension evaluation and projection,
%   showing fresh_names still holds after evaluating one term
Extensible_Theorem
  evalStmt_names_same : forall S FE Scope EE EE' O,
    IsS : is_stmt S ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value))
              (Scope::EE) ->
    Ev : evalStmt FE (Scope::EE) S EE' O ->
    exists Scope' EE'', EE' = Scope'::EE'' /\ names_same EE EE''
  on Ev as IH_S.
%E-Noop
 NS: apply names_same_reflexive to IsEE. case NS. search.
%E-Seq
 case IsS. NS_A: apply IH_S to _ _ _ Ev1.
 apply evalStmt_isCtx to _ _ _ Ev1. NS_B: apply IH_S to _ _ _ Ev2.
 apply names_same_transitive to NS_A NS_B. search.
%E-Declare
 case IsS. case IsEE. exists ((X, V)::Scope), EE. split. search.
 backchain names_same_reflexive.
%E-Assign
 case IsS. NS: apply replaceScopes_names_same to _ Ev2. case NS.
 search.
%E-RecUpdate
 case IsS. NS: apply replaceScopes_names_same to _ Ev4. case NS.
 search.
%E-If-True
 case IsS. NS: apply IH_S to _ _ _ Ev2. case NS. search.
%E-If-False
 case IsS. NS: apply IH_S to _ _ _ Ev2. case NS. search.
%E-While-True
 case IsS. NS_B: apply IH_S to _ _ _ Ev2. NS_B': case NS_B.
 IsEE''+: apply evalStmt_isCtx to _ _ _ Ev2. case IsEE''+.
 NS_W: apply IH_S to _ _ _ Ev3.
 NS: apply names_same_transitive to NS_B'2 NS_W. search.
%E-While-False
 case IsS. NS: apply names_same_reflexive to IsEE. case NS. search.
%E-ScopeStmt
 case IsS. NS: apply IH_S to _ _ _ Ev1. case NS. search.
%E-Print-Int
 case IsS. NS: apply names_same_reflexive to IsEE. case NS. search.
%E-Print-True
 case IsS. NS: apply names_same_reflexive to IsEE. case NS. search.
%E-Print-False
 case IsS. NS: apply names_same_reflexive to IsEE. case NS. search.
%E-Print-String
 case IsS. NS: apply names_same_reflexive to IsEE. case NS. search.


Theorem names_same_length[A, B] :
  forall (A : list (list (pair string A)))
         (B : list (list (pair string B))) L,
    names_same A B -> length A L -> length B L.
induction on 2. intros NS L. L: case L.
  %nil
   case NS. search.
  %cons
   NS: case NS. apply IH to NS2 L. search.


Theorem evalStmt_keep_scopes : forall FE Scope EE S EE' N O,
  is_stmt S ->
  is_list (is_pair is_string
          (is_pair is_string
          (is_pair is_value
          (is_pair (is_list is_string) is_stmt)))) FE ->
  is_list (is_list (is_pair is_string is_value)) (Scope::EE) ->
  evalStmt FE (Scope::EE) S EE' O -> length (Scope::EE) N ->
  length EE' N.
intros IsE IsFE IsEE Ev L.
NS: apply evalStmt_names_same to _ _ _ Ev. L: case L.
apply names_same_length to NS L. search.




/********************************************************************
 Evaluation unique
 ********************************************************************/
Theorem replaceRecVal_unique : forall F V L A B,
  replaceRecVal F V L A -> replaceRecVal F V L B -> A = B.
induction on 1. intros A B. A: case A.
  %RRV-Here
   B: case B.
     %RRV-Here
      search.
     %RRV-Later
      apply B to _.
  %RRV-Later
   B: case B.
     %RRV-Here
      apply A to _.
     %RRV-Later
      apply IH to A1 B1. search.


Theorem lookupRecFieldVal_unique : forall RFVs F VA VB,
  lookupRecFieldVal RFVs F VA -> lookupRecFieldVal RFVs F VB ->
  VA = VB.
induction on 1. intros LA LB. LA: case LA.
  %LRFV-Here
   LB: case LB.
     %LRFV-Here
      search.
     %LRFV-Later
      apply LB to _.
  %LRFV-Later
   LB: case LB.
     %LRFV-Here
      apply LA to _.
     %LRFV-Later
      apply IH to LA1 LB1. search.


Theorem updateRecFields_unique : forall F V L OutA OutB,
  updateRecFields F V L OutA -> updateRecFields F V L OutB ->
  OutA = OutB.
induction on 1. intros UA UB. UA: case UA.
  %URF-One
   UB: case UB.
     %URF-One
      apply replaceRecVal_unique to UA UB. search.
     %URF-Step
      case UB1.
  %URF-Step
   UB: case UB.
     %URF-One
      case UA1.
     %URF-Step
      apply lookupRecFieldVal_unique to UA UB. apply IH to UA1 UB1.
      apply replaceRecVal_unique to UA2 UB2. search.




/********************************************************************
 Extension size and projection version for evaluation
 ********************************************************************/
Ext_Size evalExpr FE EE E V O,
         evalArgs FE EE E V O,
         evalRecFields FE EE E F O,
         evalStmt FE EE S EE' O.
Proj_Rel evalExpr FE EE E V O,
         evalArgs FE EE E V O,
         evalRecFields FE EE E F O,
         evalStmt FE EE S EE' O.




/********************************************************************
 Evaluation doesn't change if you add extra scopes with new names
 ********************************************************************/
/*
  Two contexts are related by adding some scopes declaring only fresh
  names relative to the rest of the context.
  Note the length of the last bit ensures there is only one valid
  splitting location, a fact important for dropping added scopes in
  proving evaluation is maintained under newNameScopes-related
  contexts.
  The one with added scopes is the first one.
*/
Define newNameScopes : list (list (pair string Item)) -> integer ->
                       list (list (pair string Item)) ->
                       list (list (pair string Item)) -> prop by
newNameScopes Scopes Len A B :=
  exists N SNames BNames,
    length B Len /\ %B has Len scopes in it
    drop N A B /\ %A is just B with N new scopes
    %extra scopes only have new names
    take N A Scopes /\ names Scopes SNames /\ names B BNames /\
    (forall X, mem X SNames -> mem X BNames -> false);
%same scope on front, related rest
newNameScopes Scopes Len (S::AR) (S::BR) :=
  newNameScopes Scopes Len AR BR.


Theorem lookupScopes_drop_not_mem :
  forall X B (V : value) N A Scopes SNames BNames,
    is_list (is_list (is_pair is_string is_value)) A ->
    is_string X ->
    lookupScopes X B V -> drop N A B -> take N A Scopes ->
    names Scopes SNames -> names B BNames ->
    (forall Z, mem Z SNames -> mem Z BNames -> false) ->
    lookupScopes X A V.
induction on 4. intros IsA IsX L D T NS NB NMems. D: case D.
  %Drop-0
   T: case T.
     %Take-0
      search.
     %Take-Step
      GEq: apply take_geq_0 to T1. apply take_is_integer to T1.
      L': apply lt_plus_one to T _.
      apply greatereq_less_integer_false to GEq L'.
  %Drop-Step
   T: case T.
     %Take-0
      GEq: apply drop_geq_0 to D1. apply drop_is_integer to D1.
      L': apply lt_plus_one to D _.
      apply greatereq_less_integer_false to GEq L'.
     %Take-Step
      NS: case NS. apply drop_is_integer to D1.
      Is: case IsA. apply take_is_integer to T1.
      apply plus_integer_unique_addend to _ _ _ D T.
      apply IH to _ _ L D1 T1 NS1 NB _.
        intros MN MB. MS: apply mem_append_right to MN NS2.
        apply NMems to MS MB.
      Or: apply lookup_string_value_list_or_no to Is IsX. L: case Or.
        %lookup X1 X V
         M: apply lookup_mem to L1. MNS: apply domain_mem to M NS.
         MBN: apply lookupScopes_names to L NB.
         M': apply mem_append_left to MNS NS2. apply NMems to M' MBN.
        %no_lookp X1 X
         search.


Theorem newNameScopes_lookupScopes : forall N Len A B X V,
  is_list (is_list (is_pair is_string is_value)) A -> is_string X ->
  newNameScopes N Len A B -> lookupScopes X B V -> lookupScopes X A V.
induction on 4. intros IsA IsX NNS LkpB. L: case LkpB (keep).
  %LS-FirstScope
   NNS: case NNS.
     %end
      apply lookupScopes_drop_not_mem to _ IsX LkpB NNS1 _ NNS3 NNS4 _.
      search.
     %step
      search.
  %LS-Later
   NNS: case NNS.
     %end
      apply lookupScopes_drop_not_mem to _ IsX LkpB NNS1 _ NNS3 NNS4 _.
      search.
     %step
      case IsA. apply IH to _ IsX NNS L1. search.


Theorem replaceScopes_drop_not_mem :
  forall A X V B RB N Scopes SNames BNames,
    is_list (is_list (is_pair is_string is_value)) A -> is_string X ->
    replaceScopes X V B RB -> drop N A B -> take N A Scopes ->
    names Scopes SNames -> names B BNames ->
    (forall Z, mem Z SNames -> mem Z BNames -> false) ->
    exists RA, Scopes ++ RB = RA /\ replaceScopes X V A RA.
induction on 4. intros IsA IsX R D T NS NB NMems. D: case D.
  %Drop-0
   T: case T.
     %Take-0
      search.
     %Take-Step
      GEq: apply take_geq_0 to T1. apply take_is_integer to T1.
      L': apply lt_plus_one to T _.
      apply greatereq_less_integer_false to GEq L'.
  %Drop-Step
   T: case T.
     %Take-0
      GEq: apply drop_geq_0 to D1. apply drop_is_integer to D1.
      L': apply lt_plus_one to D _.
      apply greatereq_less_integer_false to GEq L'.
     %Take-Step
      NS: case NS. apply drop_is_integer to D1. Is: case IsA.
      apply take_is_integer to T1.
      apply plus_integer_unique_addend to _ _ _ D T.
      R': apply IH to _ _ R D1 T1 NS1 NB _.
        intros MN MB. MS: apply mem_append_right to MN NS2.
        apply NMems to MS MB.
      Or: apply lookup_string_value_list_or_no to Is IsX. L: case Or.
        %lookup X1 X V
         M: apply lookup_mem to L. MNS: apply domain_mem to M NS.
         MBN: apply replaceScopes_names to R NB.
         M': apply mem_append_left to MNS NS2. apply NMems to M' MBN.
        %no_lookp X1 X
         search.


Theorem replaceScopes_names_forward : forall X V L R LN RN Z,
  is_list (is_list (is_pair is_string is_value)) L -> is_string X ->
  replaceScopes X V L R -> names L LN  -> names R RN ->
  mem Z LN -> mem Z RN.
induction on 3. intros IsL IsX R NL NR M. R: case R.
  %RS-FirstScope
   NL: case NL. NR: case NR. NR: case NR.
   Or: apply mem_append to M NL2. M': case Or.
     %mem Z NScope
      Is: case IsL. IsNScope: apply domain_is to _ NL.
      IsZ: apply mem_is_string to _ M'.
      Or: apply is_string_eq_or_not to IsX IsZ. E: case Or.
        %X = Z
         case NR2. search.
        %X != Z
         apply remove_all_names to R1 NL NR M' _.
         apply mem_append_left to _ NR2 with A = Z. search.
     %mem Z NRest
      apply names_unique to NL1 NR1.
      apply mem_append_right to M' NR2. search.
  %RS-Later
   Is: case IsL. NL: case NL. NR: case NR.
   Or: apply mem_append to M NL2. M': case Or.
     %mem Z NScope
      apply domain_unique to NL NR. apply mem_append_left to M' NR2.
      search.
     %mem Z NRest
      M'': apply IH to _ IsX R1 NL1 NR1 M'.
      apply mem_append_right to M'' NR2. search.


Theorem replaceScopes_names_backward : forall X V L R LN RN Z,
  is_list (is_list (is_pair is_string is_value)) L -> is_string X ->
  replaceScopes X V L R -> names L LN  -> names R RN ->
  mem Z RN -> mem Z LN.
induction on 3. intros IsL IsX R NL NR M. R: case R.
  %RS-FirstScope
   NL: case NL. NR: case NR. NR: case NR.
   Or: apply mem_append to M NR2. M': case Or.
     %mem Z X::DRest
      M': case M'.
        %Mem-Here:  Z = X
         M'': apply domain_mem to R NL.
         apply mem_append_left to M'' NL2. search.
        %Mem-Later:  mem Z DRest
         MLRemain: apply mem_domain to NR M'.
         ML1: apply mem_after_remove_all_before to R1 MLRemain.
         MNScope: apply domain_mem to ML1 NL.
         apply mem_append_left to MNScope NL2. search.
     %mem Z NRest1
      apply names_unique to NL1 NR1. apply mem_append_right to M' NL2.
      search.
  %RS-Later
   NL: case NL. NR: case NR. apply domain_unique to NL NR.
   Or: apply mem_append to M NR2. M': case Or.
     %mem Z NScope1
      apply mem_append_left to M' NL2. search.
     %mem Z NRest1
      case IsL. M'': apply IH to _ _ R1 NL1 NR1 M'.
      apply mem_append_right to M'' NL2. search.


Theorem replaceScopes_keep_scopes[Key, Item] :
  forall L (K : Key) (I : Item) R N,
    replaceScopes K I L R -> length L N -> length R N.
induction on 1. intros R L. R: case R.
  %RS-FirstScope
   case L. search.
  %RS-Later
   case L. apply IH to R1 _. search.


Theorem newNameScopes_replaceScopes : forall S Len A B X V RB,
  is_list (is_list (is_pair is_string is_value)) A ->
  is_list (is_list (is_pair is_string is_value)) B ->
  is_string X -> is_value V ->
  newNameScopes S Len A B -> replaceScopes X V B RB ->
  exists RA, replaceScopes X V A RA /\ newNameScopes S Len RA RB.
induction on 5. intros IsA IsB IsX IsV NNS R. NNS: case NNS.
  %end
   R: case R (keep).
     %RS-FirstScope
      R': apply replaceScopes_drop_not_mem to _ IsX R NNS1 _ NNS3 _ _.
      exists RA. split. search. ScopesLen: apply take_length to NNS2.
      D: apply append_drop to R' ScopesLen.
      IsReplaced: apply replaceScopes_is to _ _ R.
      NRepl: apply names_exists to IsReplaced.
      unfold. exists N, SNames, N1. split.
        %length
         case NNS. search.
        %drop
         search.
        %take
         Len: apply take_length to NNS2.
         apply append_take to R' Len. search.
        %SNames
         search.
        %replaced names
         search.
        %not mems
         intros MS MN. MBN: apply replaceScopes_names_backward to
                               _ IsX R NNS4 NRepl MN.
         apply NNS5 to MS MBN.
     %RS-Later
      R': apply replaceScopes_drop_not_mem to _ IsX R NNS1 _ NNS3 _ _.
      exists RA. split. search. IsLN: apply replaceScopes_is to _ _ R.
      NamesLNew: apply names_exists to IsLN.
      Len: apply take_length to NNS2.
      unfold. exists N, SNames, N1. split.
        %length
         Len': case NNS. apply replaceScopes_keep_scopes to R2 Len'.
         search.
        %drop
         apply append_drop to R' Len. search.
        %take
         apply append_take to R' Len. search.
        %names Scopes
         search.
        %names New
         search.
        %not mems
         intros MS MN. MBN: apply replaceScopes_names_backward to
                               _ _ R NNS4 NamesLNew MN.
         apply NNS5 to MS MBN.
  %step
   R: case R.
     %RS-FirstScope
      search.
     %RS-Later
      case IsA. case IsB. apply IH to _ _ IsX _ NNS R1. search.


Theorem newNameScopes_length [V] :
  forall N Len (A B : list (list (pair string V))) BLen,
    newNameScopes N Len A B -> length B BLen -> Len <= BLen.
induction on 1. intros NNS Len. NNS: case NNS.
  %end
   apply length_unique to Len NNS. apply length_is to Len.
   backchain is_integer_lesseq.
  %step
   Len: case Len. LEq: apply IH to NNS Len. apply length_is to Len.
   L: apply lt_plus_one to Len1 _.
   apply lesseq_less_integer_transitive to LEq L.
   backchain less_integer_lesseq.


Theorem newNameScopes_reflexive : forall EE,
  is_list (is_list (is_pair is_string is_value)) EE ->
  exists Len, length EE Len /\ newNameScopes [] Len EE EE.
intros IsEE. Len: apply length_exists_list_pair_string_value to IsEE.
exists N. split. search. Names: apply names_exists to IsEE. unfold.
exists 0, [], N1. split.
  %length
   search.
  %drop
   search.
  %take
   search.
  %names []
   search.
  %names EE
   search.
  %mems
   intros M. case M.


Theorem newNameScopes_same[V] :
  forall Len (A B : list (list (pair string V))),
    newNameScopes [] Len A B -> A = B.
induction on 1. intros NNS. NNS: case NNS.
  %last
   case NNS2. Drop: case NNS1.
     %Drop-0
      search.
     %Drop-Step
      apply drop_is_integer to Drop1. P: assert 1 + -1 = 0.
      apply plus_integer_unique_addend to _ _ _ Drop P.
      GEq: apply drop_geq_0 to Drop1. LEq: case GEq. case LEq.
  %step
   apply IH to NNS. search.


Extensible_Theorem
  evalExpr_rel :
    forall FE EE_A EE_B E VA VB O_A O_B Vars,
      IsE : is_expr E ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsA : is_list (is_list (is_pair is_string is_value)) EE_A ->
      IsB : is_list (is_list (is_pair is_string is_value)) EE_B ->
      EvA : evalExpr FE EE_A E VA O_A ->
      EvB : evalExpr FE EE_B E VB O_B ->
      Vars : vars E Vars ->
      Rel : (forall X V, mem X Vars -> lookupScopes X EE_B V ->
                         lookupScopes X EE_A V) ->
      VA = VB /\ O_A = O_B
    on EvA as IH_E,
  /*
    Note we have the same scope on the front of both contexts for
    evaluation.  This is necessary for declare, where we will add a
    new binding to the front scope on both and still need
    newNameScopes for the result.

    **For extensions introducing new statements, this means they
      must introduce a new scope before adding any new assignments.**
  */
  evalStmt_newNameScopes_output :
    forall FE EE_A EE_B S EE_A' EE_B' O_A O_B N Len Scope,
      IsS : is_stmt S ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsA : is_list (is_list (is_pair is_string is_value))
               (Scope::EE_A) ->
      IsB : is_list (is_list (is_pair is_string is_value))
               (Scope::EE_B) ->
      EvA : evalStmt FE (Scope::EE_A) S EE_A' O_A ->
      EvB : evalStmt FE (Scope::EE_B) S EE_B' O_B ->
      NNS : newNameScopes N Len EE_A EE_B ->
      O_A = O_B
    on EvA as IH_O_S,
  evalStmt_newNameScopes :
    forall FE EE_A EE_B S EE_A' EE_B' O_A O_B N Len Scope,
      IsS : is_stmt S ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsA : is_list (is_list (is_pair is_string is_value))
               (Scope::EE_A) ->
      IsB : is_list (is_list (is_pair is_string is_value))
               (Scope::EE_B) ->
      EvA : evalStmt FE (Scope::EE_A) S EE_A' O_A ->
      EvB : evalStmt FE (Scope::EE_B) S EE_B' O_B ->
      NNS : newNameScopes N Len EE_A EE_B ->
      newNameScopes N Len EE_A' EE_B'
    on EvA as IH_C_S,
  evalArgs_rel :
    forall FE EE_A EE_B A VA VB O_A O_B Vars,
      IsA : is_args A ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsA : is_list (is_list (is_pair is_string is_value)) EE_A ->
      IsB : is_list (is_list (is_pair is_string is_value)) EE_B ->
      EvA : evalArgs FE EE_A A VA O_A ->
      EvB : evalArgs FE EE_B A VB O_B ->
      Vars : varsArgs A Vars ->
      Rel : (forall X V, mem X Vars -> lookupScopes X EE_B V ->
                         lookupScopes X EE_A V) ->
      VA = VB /\ O_A = O_B
    on EvA as IH_A,
  evalRecFields_rel :
    forall FE EE_A EE_B RF VA VB O_A O_B Vars,
      IsRF : is_recFieldExprs RF ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsA : is_list (is_list (is_pair is_string is_value)) EE_A ->
      IsB : is_list (is_list (is_pair is_string is_value)) EE_B ->
      EvA : evalRecFields FE EE_A RF VA O_A ->
      EvB : evalRecFields FE EE_B RF VB O_B ->
      Vars : varsRecFields RF Vars ->
      Rel : (forall X V, mem X Vars -> lookupScopes X EE_B V ->
                         lookupScopes X EE_A V) ->
      VA = VB /\ O_A = O_B
    on EvA as IH_RF.
%evalExpr_rel
 %E-Num
  case EvB. search.
 %E-Plus
  case IsE. EvB: case EvB. Vars: case Vars.
  apply IH_E to _ _ _ _ EvA1 EvB Vars _.
    intros M L. M': apply mem_append_left to M Vars2.
    apply Rel to M' L. search.
  apply IH_E to _ _ _ _ EvA2 EvB1 Vars1 _.
    intros M L. M': apply mem_append_right to M Vars2.
    apply Rel to M' L. search.
  apply plus_integer_unique to EvA3 EvB2.
  apply append_unique to EvA4 EvB3. search.
 %E-Minus
  case IsE. EvB: case EvB. Vars: case Vars.
  apply IH_E to _ _ _ _ EvA1 EvB Vars _.
    intros M L. M': apply mem_append_left to M Vars2.
    apply Rel to M' L. search.
  apply IH_E to _ _ _ _ EvA2 EvB1 Vars1 _.
    intros M L. M': apply mem_append_right to M Vars2.
    apply Rel to M' L. search.
  apply minus_integer_unique to EvA3 EvB2.
  apply append_unique to EvA4 EvB3. search.
 %E-Mult
  case IsE. EvB: case EvB. Vars: case Vars.
  apply IH_E to _ _ _ _ EvA1 EvB Vars _.
    intros M L. M': apply mem_append_left to M Vars2.
    apply Rel to M' L. search.
  apply IH_E to _ _ _ _ EvA2 EvB1 Vars1 _.
    intros M L. M': apply mem_append_right to M Vars2.
    apply Rel to M' L. search.
  apply multiply_integer_unique to EvA3 EvB2.
  apply append_unique to EvA4 EvB3. search.
 %E-Div
  case IsE. EvB: case EvB. Vars: case Vars.
  apply IH_E to _ _ _ _ EvA1 EvB Vars _.
    intros M L. M': apply mem_append_left to M Vars2.
    apply Rel to M' L. search.
  apply IH_E to _ _ _ _ EvA2 EvB1 Vars1 _.
    intros M L. M': apply mem_append_right to M Vars2.
    apply Rel to M' L. search.
  apply divide_integer_unique to EvA3 EvB2.
  apply append_unique to EvA4 EvB3. search.
 %E-True
  case EvB. search.
 %E-False
  case EvB. search.
 %E-And-True
  case IsE. Vars: case Vars. EvB: case EvB.
    %E-And-True
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. M': apply mem_append_left to M Vars2.
       apply Rel to M' L. search.
     apply IH_E to _ _ _ _ EvA2 EvB1 Vars1 _.
       intros M L. M': apply mem_append_right to M Vars2.
       apply Rel to M' L. search.
     apply append_unique to EvA3 EvB2. search.
    %E-And-False1
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. M': apply mem_append_left to M Vars2.
       apply Rel to M' L. search.
    %E-And-False2
     apply IH_E to _ _ _ _ EvA2 EvB1 Vars1 _.
       intros M L. M': apply mem_append_right to M Vars2.
       apply Rel to M' L. search.
 %E-And-False1
  case IsE. Vars: case Vars. EvB: case EvB.
    %E-And-True
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. M': apply mem_append_left to M Vars2.
       apply Rel to M' L. search.
    %E-And-False1
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. M': apply mem_append_left to M Vars2.
       apply Rel to M' L. search.
     search.
    %E-And-False2
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. M': apply mem_append_left to M Vars2.
       apply Rel to M' L. search.
 %E-And-False2
  case IsE. Vars: case Vars. EvB: case EvB.
    %E-And-True
     apply IH_E to _ _ _ _ EvA2 EvB1 Vars1 _.
       intros M L. M': apply mem_append_right to M Vars2.
       apply Rel to M' L. search.
    %E-And-False1
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. M': apply mem_append_left to M Vars2.
       apply Rel to M' L. search.
    %E-And-False2
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. M': apply mem_append_left to M Vars2.
       apply Rel to M' L. search.
     apply IH_E to _ _ _ _ EvA2 EvB1 Vars1 _.
       intros M L. M': apply mem_append_right to M Vars2.
       apply Rel to M' L. search.
     apply append_unique to EvA3 EvB2. search.
 %E-Or-True1
  case IsE. Vars: case Vars. EvB: case EvB.
    %E-Or-True1
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. M': apply mem_append_left to M Vars2.
       apply Rel to M' L. search.
     search.
    %E-Or-True2
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. M': apply mem_append_left to M Vars2.
       apply Rel to M' L. search.
    %E-Or-False
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. M': apply mem_append_left to M Vars2.
       apply Rel to M' L. search.
 %E-Or-True2
  case IsE. Vars: case Vars. EvB: case EvB.
    %E-Or-True1
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. M': apply mem_append_left to M Vars2.
       apply Rel to M' L. search.
    %E-Or-True2
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. M': apply mem_append_left to M Vars2.
       apply Rel to M' L. search.
     apply IH_E to _ _ _ _ EvA2 EvB1 Vars1 _.
       intros M L. M': apply mem_append_right to M Vars2.
       apply Rel to M' L. search.
     apply append_unique to EvA3 EvB2. search.
    %E-Or-False
     apply IH_E to _ _ _ _ EvA2 EvB1 Vars1 _.
       intros M L. M': apply mem_append_right to M Vars2.
       apply Rel to M' L. search.
 %E-Or-False
  case IsE. Vars: case Vars. EvB: case EvB.
    %E-Or-True1
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. M': apply mem_append_left to M Vars2.
       apply Rel to M' L. search.
    %E-Or-True2
     apply IH_E to _ _ _ _ EvA2 EvB1 Vars1 _.
       intros M L. M': apply mem_append_right to M Vars2.
       apply Rel to M' L. search.
    %E-Or-False
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. M': apply mem_append_left to M Vars2.
       apply Rel to M' L. search.
     apply IH_E to _ _ _ _ EvA2 EvB1 Vars1 _.
       intros M L. M': apply mem_append_right to M Vars2.
       apply Rel to M' L. search.
     apply append_unique to EvA3 EvB2. search.
 %E-Not-True
  case IsE. Vars: case Vars. EvB: case EvB.
    %E-Not-True
     apply IH_E to _ _ _ _ EvA1 EvB _ _. search.
    %E-Not-False
     apply IH_E to _ _ _ _ EvA1 EvB _ _.
 %E-Not-False
  case IsE. Vars: case Vars. EvB: case EvB.
    %E-Not-True
     apply IH_E to _ _ _ _ EvA1 EvB _ _.
    %E-Not-False
     apply IH_E to _ _ _ _ EvA1 EvB _ _. search.
 %E-Greater-True
  case IsE. Vars: case Vars. EvB: case EvB.
    %E-Greater-True
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. M': apply mem_append_left to M Vars2.
       apply Rel to M' L. search.
     apply IH_E to _ _ _ _ EvA2 EvB1 Vars1 _.
       intros M L. M': apply mem_append_right to M Vars2.
       apply Rel to M' L. search.
     apply append_unique to EvA4 EvB3. search.
    %E-Greater-False
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. M': apply mem_append_left to M Vars2.
       apply Rel to M' L. search.
     apply IH_E to _ _ _ _ EvA2 EvB1 Vars1 _.
       intros M L. M': apply mem_append_right to M Vars2.
       apply Rel to M' L. search.
     case EvA3. apply less_lesseq_flip_false to _ EvB2.
 %E-Greater-False
  case IsE. Vars: case Vars. EvB: case EvB.
    %E-Greater-True
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. M': apply mem_append_left to M Vars2.
       apply Rel to M' L. search.
     apply IH_E to _ _ _ _ EvA2 EvB1 Vars1 _.
       intros M L. M': apply mem_append_right to M Vars2.
       apply Rel to M' L. search.
     case EvB2. apply less_lesseq_flip_false to _ EvA3.
    %E-Greater-False
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. M': apply mem_append_left to M Vars2.
       apply Rel to M' L. search.
     apply IH_E to _ _ _ _ EvA2 EvB1 Vars1 _.
       intros M L. M': apply mem_append_right to M Vars2.
       apply Rel to M' L. search.
     apply append_unique to EvA4 EvB3. search.
 %E-Eq-True
  case IsE. Vars: case Vars. EvB: case EvB.
    %E-Eq-True
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. M': apply mem_append_left to M Vars2.
       apply Rel to M' L. search.
     apply IH_E to _ _ _ _ EvA2 EvB1 Vars1 _.
       intros M L. M': apply mem_append_right to M Vars2.
       apply Rel to M' L. search.
     apply append_unique to EvA3 EvB2. search.
    %E-Eq-False
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. M': apply mem_append_left to M Vars2.
       apply Rel to M' L. search.
     apply IH_E to _ _ _ _ EvA2 EvB1 Vars1 _.
       intros M L. M': apply mem_append_right to M Vars2.
       apply Rel to M' L. search.
     apply EvB2 to _.
 %E-Eq-False
  case IsE. Vars: case Vars. EvB: case EvB.
    %E-Eq-True
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. M': apply mem_append_left to M Vars2.
       apply Rel to M' L. search.
     apply IH_E to _ _ _ _ EvA2 EvB1 Vars1 _.
       intros M L. M': apply mem_append_right to M Vars2.
       apply Rel to M' L. search.
     apply EvA3 to _.
    %E-Eq-False
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. M': apply mem_append_left to M Vars2.
       apply Rel to M' L. search.
     apply IH_E to _ _ _ _ EvA2 EvB1 Vars1 _.
       intros M L. M': apply mem_append_right to M Vars2.
       apply Rel to M' L. search.
     apply append_unique to EvA4 EvB3. search.
 %E-String
  case EvB. search.
 %E-AppString
  case IsE. Vars: case Vars. EvB: case EvB.
  apply IH_E to _ _ _ _ EvA1 EvB Vars _.
    intros M L. M': apply mem_append_left to M Vars2.
    apply Rel to M' L. search.
  apply IH_E to _ _ _ _ EvA2 EvB1 Vars1 _.
    intros M L. M': apply mem_append_right to M Vars2.
    apply Rel to M' L. search.
  apply append_unique to EvA4 EvB3.
  apply append_unique to EvA3 EvB2. search.
 %E-Name
  case IsE. EvB: case EvB. case Vars. LA: apply Rel to _ EvB.
  apply lookupScopes_unique to EvA1 LA. search.
 %E-Call
  case IsE. EvB: case EvB. apply lookup_unique to EvA1 EvB.
  Vars: case Vars. apply IH_A to _ _ _ _ EvA2 EvB1 Vars _.
  apply zip_unique to EvA3 EvB2. apply evalArgs_isValue to _ _ _ EvA2.
  IsFP: apply lookup_is_value_funCtx to _ EvA1. IsF: case IsFP.
  IsF: case IsF1. IsF: case IsF2. IsIE: apply zip_is to _ _ EvA3.
  NNS': apply newNameScopes_reflexive to _ with EE = [].
  NNS'': apply IH_C_S to _ _ _ _ EvA4 EvB3 NNS'1.
  apply evalStmt_isCtx to _ _ _ EvA4.
  apply evalStmt_isCtx to _ _ _ EvB3.
  LA: apply newNameScopes_lookupScopes to _ _ NNS'' EvB5.
  apply lookupScopes_unique to LA EvA6.
  apply IH_O_S to _ _ _ _ EvA4 EvB3 NNS'1.
  apply append_unique to EvA5 EvB4. search.
 %E-RecBuild
  case IsE. Vars: case Vars. EvB: case EvB.
  apply IH_RF to _ _ _ _ EvA1 EvB _ _. search.
 %E-RecAccess
  case IsE. Vars: case Vars. EvB: case EvB.
  apply IH_E to _ _ _ _ EvA1 EvB _ _.
  apply lookupRecFieldVal_unique to EvA2 EvB1. search.
%evalStmt_newNameScopes_output
 %E-Noop
  case EvB. search.
 %E-Seq
  case IsS. EvB: case EvB. NNS': apply IH_C_S to _ _ _ _ EvA1 EvB _.
  apply evalStmt_isCtx to _ _ _ EvA1.
  apply evalStmt_isCtx to _ _ _ EvB.
  apply IH_O_S to _ _ _ _ EvA1 EvB _.
  LenB: apply length_exists_list_pair_string_value to IsB.
  LenA: apply length_exists_list_pair_string_value to IsA.
  IsN2: apply length_is to LenA. IsN1: apply length_is to LenB.
  LenEE1: apply evalStmt_keep_scopes to _ _ _ EvA1 LenA.
  LenEE2: apply evalStmt_keep_scopes to _ _ _ EvB LenB.
  LenB': case LenB (keep). LenA': case LenA (keep).
  GEqB: apply length_geq_0 to LenB'. apply length_is to LenB'.
  LB: apply lt_plus_one to LenB'1 _. apply length_is to LenA'.
  GEqA: apply length_geq_0 to LenA'. LA: apply lt_plus_one to LenA'1 _.
  LEqA: case GEqA. LEqB: case GEqB.
  LA': apply lesseq_less_integer_transitive to LEqA LA.
  LB': apply lesseq_less_integer_transitive to LEqB LB.
  GA: apply less_integer_flip_greater to LA'.
  GB: apply less_integer_flip_greater to LB'.
  apply length_cons to LenEE1 GA. apply length_cons to LenEE2 GB.
  NNS': case NNS'.
    %end
     apply length_unique to LenEE2 NNS'.
     LEq: apply newNameScopes_length to NNS LenB'.
     apply less_lesseq_flip_false to LB LEq.
    %step
     apply IH_O_S to _ IsFE _ _ EvA2 EvB1 NNS'.
     apply append_unique to EvA3 EvB2. search.
 %E-Declare
  Is: case IsS. Vars: apply vars_exist to Is2. EvB: case EvB.
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  apply IH_E to _ _ _ _ EvA1 EvB Vars _.
    intros M L. apply vars_is to _ Vars. apply mem_is_string to _ M.
    apply newNameScopes_lookupScopes to _ _ NNS' L. search.
  search.
 %E-Assign
  Is: case IsS. Vars: apply vars_exist to Is1. EvB: case EvB.
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  apply IH_E to _ _ _ _ EvA1 EvB Vars _.
    intros M L. apply vars_is to _ Vars. apply mem_is_string to _ M.
    apply newNameScopes_lookupScopes to _ _ NNS' L. search.
  search.
 %E-RecUpdate
  Is: case IsS. Vars: apply vars_exist to Is2. EvB: case EvB.
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  apply IH_E to _ _ _ _ EvA1 EvB Vars _.
    intros M L. apply vars_is to _ Vars. apply mem_is_string to _ M.
    apply newNameScopes_lookupScopes to _ _ NNS' L. search.
  search.
 %E-If-True
  Is: case IsS. Vars: apply vars_exist to Is.
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  EvB: case EvB.
    %E-If-True
     NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS' L. search.
     apply IH_O_S to _ _ _ _ EvA2 EvB1 _.
     apply append_unique to EvA3 EvB2. search.
    %E-If-False
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS' L. search.
 %E-If-False
  Is: case IsS. Vars: apply vars_exist to Is.
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  EvB: case EvB.
    %E-If-True
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS' L. search.
    %E-If-False
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS' L. search.
     apply IH_O_S to _ _ _ _ EvA2 EvB1 _.
     apply append_unique to EvA3 EvB2. search.
 %E-While-True
  Is: case IsS. Vars: apply vars_exist to Is.
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  EvB: case EvB.
    %E-While-True
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS' L. search.
     apply IH_O_S to _ _ _ _ EvA2 EvB1 _.
     NNS'': apply IH_C_S to _ _ _ _ EvA2 EvB1 _. NNS'': case NNS''.
       %end
        LenA: apply length_exists_list_pair_string_value to IsA.
        LenB: apply length_exists_list_pair_string_value to IsB.
        IsN1: apply length_is to LenA. IsN2: apply length_is to LenB.
        PA: apply plus_integer_total to _ IsN1 with N1 = 1.
        PB: apply plus_integer_total to _ IsN2 with N1 = 1.
        LenEEA++: assert length ([]::Scope::EE_A) N4.
        LenEEB++: assert length ([]::Scope::EE_B) N5.
        LenEE1+: apply evalStmt_keep_scopes to _ _ _ EvA2 LenEEA++.
        LenEE2+: apply evalStmt_keep_scopes to _ _ _ EvB1 LenEEB++.
        apply length_unique to LenEE2+ NNS''.
        LEq: apply newNameScopes_length to NNS' LenB.
        L: apply lt_plus_one to PB _.
        apply less_lesseq_flip_false to L LEq.
       %step
        NNS'': case NNS''.
          %end
           LenB: apply length_exists_list_pair_string_value to IsB.
           IsN1: apply length_is to LenB.
           PB: apply plus_integer_total to _ IsN1 with N1 = 1.
           LenEEB++: assert length ([]::Scope::EE_B) N3.
           LenEE2+: apply evalStmt_keep_scopes to _ _ _ EvB1 LenEEB++.
           LenEE2: case LenEE2+. apply length_unique to LenEE2 NNS''.
           apply length_is to LenEE2.
           apply plus_integer_unique_addend to _ _ _ PB LenEE1.
           LenB': case LenB. apply length_is to LenB'.
           LEq: apply newNameScopes_length to NNS LenB'.           
           L: apply lt_plus_one to LenB'1 _.
           apply less_lesseq_flip_false to L LEq.
          %step
           apply IH_O_S to _ _ _ _ EvA2 EvB1 _.
           IsAR+: apply evalStmt_isCtx to _ _ _ EvA2. case IsAR+.
           IsBR+: apply evalStmt_isCtx to _ _ _ EvB1. case IsBR+.
           apply IH_O_S to _ _ _ _ EvA3 EvB2 _.
           apply append_unique to EvA4 EvB3.
           apply append_unique to EvA5 EvB4. search.
    %E-While-False
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS' L. search.
 %E-While-False
  Is: case IsS. Vars: apply vars_exist to Is.
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  EvB: case EvB.
    %E-While-True
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS' L. search.
    %E-While-False
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS' L. search.
     search.
 %E-ScopeStmt
  case IsS. EvB: case EvB. apply IH_O_S to _ _ _ _ EvA1 EvB _. search.
 %E-Print-Int
  Is: case IsS. Vars: apply vars_exist to Is.
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  EvB: case EvB.
    %E-Print-Int
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS' L. search.
     apply append_unique to EvA2 EvB1. search.
    %E-Print-True
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS' L. search.
    %E-Print-False
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS' L. search.
    %E-Print-String
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS' L. search.
 %E-Print-True
  Is: case IsS. Vars: apply vars_exist to Is.
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  EvB: case EvB.
    %E-Print-Int
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS' L. search.
    %E-Print-True
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS' L. search.
     apply append_unique to EvA2 EvB1. search.
    %E-Print-False
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS' L. search.
    %E-Print-String
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS' L. search.
 %E-Print-False
  Is: case IsS. Vars: apply vars_exist to Is.
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  EvB: case EvB.
    %E-Print-Int
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS' L. search.
    %E-Print-True
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS' L. search.
    %E-Print-False
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS' L. search.
     apply append_unique to EvA2 EvB1. search.
    %E-Print-String
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS' L. search.
 %E-Print-String
  Is: case IsS. Vars: apply vars_exist to Is.
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  EvB: case EvB.
    %E-Print-Int
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS' L. search.
    %E-Print-True
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS' L. search.
    %E-Print-False
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS' L. search.
    %E-Print-String
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS' L. search.
     apply append_unique to EvA2 EvB1. search.
%evalStmt_newNameScopes
 %E-Noop
  case EvB. search.
 %E-Seq
  case IsS. EvB: case EvB. NNS': apply IH_C_S to _ _ _ _ EvA1 EvB _.
  apply evalStmt_isCtx to _ _ _ EvA1.
  apply evalStmt_isCtx to _ _ _ EvB.
  LenB: apply length_exists_list_pair_string_value to IsB.
  LenA: apply length_exists_list_pair_string_value to IsA.
  IsN2: apply length_is to LenA. IsN1: apply length_is to LenB.
  LenEE1: apply evalStmt_keep_scopes to _ _ _ EvA1 LenA.
  LenEE2: apply evalStmt_keep_scopes to _ _ _ EvB LenB.
  LenB': case LenB (keep). LenA': case LenA (keep).
  GEqB: apply length_geq_0 to LenB'. apply length_is to LenB'.
  LB: apply lt_plus_one to LenB'1 _. apply length_is to LenA'.
  GEqA: apply length_geq_0 to LenA'.
  LA: apply lt_plus_one to LenA'1 _.
  LEqA: case GEqA. LEqB: case GEqB.
  LA': apply lesseq_less_integer_transitive to LEqA LA.
  LB': apply lesseq_less_integer_transitive to LEqB LB.
  GA: apply less_integer_flip_greater to LA'.
  GB: apply less_integer_flip_greater to LB'.
  apply length_cons to LenEE1 GA. apply length_cons to LenEE2 GB.
  NNS': case NNS'.
    %end
     apply length_unique to LenEE2 NNS'.
     LEq: apply newNameScopes_length to NNS LenB'.
     apply less_lesseq_flip_false to LB LEq.
    %step
     apply IH_C_S to _ IsFE _ _ EvA2 EvB1 NNS'. search.
 %E-Declare
  Is: case IsS. Vars: apply vars_exist to Is2.
  NNS+: assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  EvB: case EvB. apply IH_E to _ _ _ _ EvA1 EvB Vars _.
    intros M L. apply vars_is to _ Vars. apply mem_is_string to _ M.
    apply newNameScopes_lookupScopes to _ _ NNS+ L. search.
  search.
 %E-Assign
  Is: case IsS. Vars: apply vars_exist to Is1.
  NNS+: assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  EvB: case EvB. apply IH_E to _ _ _ _ EvA1 EvB Vars _.
    intros M L. apply vars_is to _ Vars. apply mem_is_string to _ M.
    apply newNameScopes_lookupScopes to _ _ NNS+ L. search.
  apply evalExpr_isValue to _ _ _ EvA1.
  R: apply newNameScopes_replaceScopes to _ _ _ _ NNS+ EvB1.
  apply replaceScopes_unique to R EvA2. search.
 %E-RecUpdate
  Is: case IsS. Vars: apply vars_exist to Is2.
  NNS+: assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  EvB: case EvB. apply IH_E to _ _ _ _ EvA1 EvB Vars _.
    intros M L. apply vars_is to _ Vars. apply mem_is_string to _ M.
    apply newNameScopes_lookupScopes to _ _ NNS+ L. search.
  apply evalExpr_isValue to _ _ _ EvA1.
  LA: apply newNameScopes_lookupScopes to _ _ NNS+ EvB1.
  apply lookupScopes_unique to LA EvA2.
  IsR: apply lookupScopes_is to _ EvA2. case IsR.
  apply updateRecFields_unique to EvA3 EvB2.
  apply updateRecFields_is to _ _ _ EvB2.
  R: apply newNameScopes_replaceScopes to _ _ _ _ NNS+ EvB3.
  apply replaceScopes_unique to R EvA4. search.
 %E-If-True
  Is: case IsS. Vars: apply vars_exist to Is.
  NNS+: assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  EvB: case EvB.
    %E-If-True
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS+ L. search.
     NNS'': apply IH_C_S to _ _ _ _ EvA2 EvB1 _. NNS'': case NNS''.
       %end
        LenB: apply length_exists_list_pair_string_value to IsB.
        LenB': case LenB (keep).
        LEq: apply newNameScopes_length to NNS LenB'.
        IsN1: apply length_is to LenB.
        P: apply plus_integer_total to _ IsN1 with N1 = 1.
        LenEEB++: assert length ([]::Scope::EE_B) N3.
        LenEE_B'+: apply evalStmt_keep_scopes to _ _ _ EvB1 LenEEB++.
        L: apply lt_plus_one to P _. apply length_is to LenB'.
        L': apply lt_plus_one to LenB'1 _.
        L'': apply less_integer_transitive to L' L.
        apply length_unique to NNS'' LenEE_B'+.
        apply less_lesseq_flip_false to L'' LEq.
       %step
        search.
    %E-If-False
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS+ L. search.
 %E-If-False
  Is: case IsS. Vars: apply vars_exist to Is.
  NNS+: assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  EvB: case EvB.
    %E-If-True
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS+ L. search.
    %E-If-False
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS+ L. search.
     NNS'': apply IH_C_S to _ _ _ _ EvA2 EvB1 _. NNS'': case NNS''.
       %end
        LenB: apply length_exists_list_pair_string_value to IsB.
        LenB': case LenB (keep).
        LEq: apply newNameScopes_length to NNS LenB'.
        IsN1: apply length_is to LenB.
        P: apply plus_integer_total to _ IsN1 with N1 = 1.
        LenEEB++: assert length ([]::Scope::EE_B) N3.
        LenEE_B'+: apply evalStmt_keep_scopes to _ _ _ EvB1 LenEEB++.
        L: apply lt_plus_one to P _. apply length_is to LenB'.
        L': apply lt_plus_one to LenB'1 _.
        L'': apply less_integer_transitive to L' L.
        apply length_unique to NNS'' LenEE_B'+.
        apply less_lesseq_flip_false to L'' LEq.
       %step
        search.
 %E-While-True
  Is: case IsS. Vars: apply vars_exist to Is.
  NNS+: assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  EvB: case EvB.
    %E-While-True
     NNS'': apply IH_C_S to _ _ _ _ EvA2 EvB1 _. NNS'': case NNS''.
       %end
        LenA: apply length_exists_list_pair_string_value to IsA.
        LenB: apply length_exists_list_pair_string_value to IsB.
        IsN1: apply length_is to LenA. IsN2: apply length_is to LenB.
        PA: apply plus_integer_total to _ IsN1 with N1 = 1.
        PB: apply plus_integer_total to _ IsN2 with N1 = 1.
        LenEEA++: assert length ([]::Scope::EE_A) N4.
        LenEEB++: assert length ([]::Scope::EE_B) N5.
        LenEE1+: apply evalStmt_keep_scopes to _ _ _ EvA2 LenEEA++.
        LenEE2+: apply evalStmt_keep_scopes to _ _ _ EvB1 LenEEB++.
        apply length_unique to LenEE2+ NNS''.
        LEq: apply newNameScopes_length to NNS+ LenB.
        L: apply lt_plus_one to PB _.
        apply less_lesseq_flip_false to L LEq.
       %step
        NNS'': case NNS''.
          %end
           LenB: apply length_exists_list_pair_string_value to IsB.
           IsN1: apply length_is to LenB.
           PB: apply plus_integer_total to _ IsN1 with N1 = 1.
           LenEEB++: assert length ([]::Scope::EE_B) N3.
           LenEE2+: apply evalStmt_keep_scopes to _ _ _ EvB1 LenEEB++.
           LenEE2: case LenEE2+. apply length_unique to LenEE2 NNS''.
           apply length_is to LenEE2.
           apply plus_integer_unique_addend to _ _ _ PB LenEE1.
           LenB': case LenB. apply length_is to LenB'.
           LEq: apply newNameScopes_length to NNS LenB'.           
           L: apply lt_plus_one to LenB'1 _.
           apply less_lesseq_flip_false to L LEq.
          %step
           IsAR+: apply evalStmt_isCtx to _ _ _ EvA2. case IsAR+.
           IsBR+: apply evalStmt_isCtx to _ _ _ EvB1. case IsBR+.
           apply IH_C_S to _ _ _ _ EvA3 EvB2 _. search.
    %E-While-False
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS+ L. search.
 %E-While-False
  Is: case IsS. Vars: apply vars_exist to Is.
  NNS+: assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  EvB: case EvB.
    %E-While-True
     apply IH_E to _ _ _ _ EvA1 EvB Vars _.
       intros M L. apply vars_is to _ Vars.
       apply mem_is_string to _ M.
       apply newNameScopes_lookupScopes to _ _ NNS+ L. search.
    %E-While-False
     search.
 %E-ScopeStmt
  case IsS. EvB: case EvB. NNS': apply IH_C_S to _ _ _ _ EvA1 EvB _.
  NNS': case NNS'.
    %end
     LenB: apply length_exists_list_pair_string_value to IsB.
     LenB': case LenB (keep). IsN1: apply length_is to LenB.
     LEq: apply newNameScopes_length to NNS LenB'.
     P: apply plus_integer_total to _ IsN1 with N1 = 1.
     Len++: assert length ([]::Scope::EE_B) N3.
     LenFinal: apply evalStmt_keep_scopes to _ _ _ EvB Len++.
     apply length_unique to LenFinal NNS'.
     L: apply lt_plus_one to P _. apply length_is to LenB'.
     L': apply lt_plus_one to LenB'1 _.
     L'': apply less_integer_transitive to L' L.
     apply less_lesseq_flip_false to L'' LEq.
    %step
     search.
 %E-Print-Int
  EvB: case EvB.
    %E-Print-Int
     search.
    %E-Print-True
     search.
    %E-Print-False
     search.
    %E-Print-String
     search.
 %E-Print-True
  EvB: case EvB.
    %E-Print-Int
     search.
    %E-Print-True
     search.
    %E-Print-False
     search.
    %E-Print-String
     search.
 %E-Print-False
  EvB: case EvB.
    %E-Print-Int
     search.
    %E-Print-True
     search.
    %E-Print-False
     search.
    %E-Print-String
     search.
 %E-Print-String
  EvB: case EvB.
    %E-Print-Int
     search.
    %E-Print-True
     search.
    %E-Print-False
     search.
    %E-Print-String
     search.
%evalArgs_rel
 EvA: case EvA (keep).
   %EA-Nil
    case EvB. search.
   %EA-Cons
    Is: case IsA. Vars: case Vars. EvB: case EvB.
    apply IH_E to _ _ _ _ EvA1 EvB Vars _.
      intros M L. M': apply mem_append_left to M Vars2.
      apply Rel to M' L. search.
    apply IH_A to _ _ _ _ EvA2 EvB1 Vars1 _.
      intros M L. M': apply mem_append_right to M Vars2.
      apply Rel to M' L. search.
    apply append_unique to EvA3 EvB2. search.
%evalRecFields_rel
 EvA: case EvA (keep).
   %ERF-Nil
    case EvB. search.
   %ERF-Cons
    Is: case IsRF. Vars: case Vars. EvB: case EvB.
    apply IH_E to _ _ _ _ EvA1 EvB Vars _.
      intros M L. M': apply mem_append_left to M Vars2.
      apply Rel to M' L. search.
    apply IH_RF to _ _ _ _ EvA2 EvB1 Vars1 _.
      intros M L. M': apply mem_append_right to M Vars2.
      apply Rel to M' L. search.
    apply append_unique to EvA3 EvB2. search.




/********************************************************************
 Evaluation is Unique
 ********************************************************************/
Theorem evalExpr_unique : forall FE EE E VA OA VB OB,
  is_expr E ->
  is_list (is_pair is_string
          (is_pair is_string
          (is_pair is_value
          (is_pair (is_list is_string) is_stmt)))) FE ->
  is_list (is_list (is_pair is_string is_value)) EE ->
  evalExpr FE EE E VA OA ->
  evalExpr FE EE E VB OB ->
  VA = VB /\ OA = OB.
intros IsE IsFE IsEE EvA EvB. Vars: apply vars_exist to IsE.
apply evalExpr_rel to _ _ _ _ EvA EvB Vars _. search.


Theorem evalStmt_unique : forall FE Scope EE S EE_A OA EE_B OB,
  is_stmt S ->
  is_list (is_pair is_string
          (is_pair is_string
          (is_pair is_value
          (is_pair (is_list is_string) is_stmt)))) FE ->
  is_list (is_list (is_pair is_string is_value)) (Scope::EE) ->
  evalStmt FE (Scope::EE) S EE_A OA ->
  evalStmt FE (Scope::EE) S EE_B OB ->
  EE_A = EE_B /\ OA = OB.
intros IsS IsFE IsEE EvA EvB. IsEE': case IsEE.
LN: apply newNameScopes_reflexive to IsEE'1.
apply evalStmt_newNameScopes_output to _ _ _ _ EvA EvB _.
NNS: apply evalStmt_newNameScopes to _ _ _ _ EvA EvB _.
apply newNameScopes_same to NNS. search.


Theorem evalArgs_unique : forall FE EE A VA OA VB OB,
  is_args A ->
  is_list (is_pair is_string
          (is_pair is_string
          (is_pair is_value
          (is_pair (is_list is_string) is_stmt)))) FE ->
  is_list (is_list (is_pair is_string is_value)) EE ->
  evalArgs FE EE A VA OA ->
  evalArgs FE EE A VB OB ->
  VA = VB /\ OA = OB.
intros IsA IsFE IsEE EvA EvB. Vars: apply varsArgs_exist to IsA.
apply evalArgs_rel to _ _ _ _ EvA EvB Vars _. search.


Theorem evalRecFields_unique : forall FE EE RF VA OA VB OB,
  is_recFieldExprs RF ->
  is_list (is_pair is_string
          (is_pair is_string
          (is_pair is_value
          (is_pair (is_list is_string) is_stmt)))) FE ->
  is_list (is_list (is_pair is_string is_value)) EE ->
  evalRecFields FE EE RF VA OA ->
  evalRecFields FE EE RF VB OB ->
  VA = VB /\ OA = OB.
intros IsRF IsFE IsEE EvA EvB.
Vars: apply varsRecFields_exist to IsRF.
apply evalRecFields_rel to _ _ _ _ EvA EvB Vars _. search.




/********************************************************************
 Evaluation across newNameScopes exists
 ********************************************************************/
/*
  Not only is evaluation related when the same term evaluates across
  newNameScopes, but a term must evaluate under the added-to context
  when it evaluates under the original one.  We will use this fact for
  proving projection constraints and Ext_Ind for evaluation.  Due to
  its use for Ext_Ind, we use the extension size versions of the
  various evaluation relations so we can use the inductive hypotheses
  there with the new derivations we produce with this.
*/
Extensible_Theorem
  evalExpr_rel_exists_ES :
    forall FE EE_A EE_B E V O ES Vars,
      IsE : is_expr E ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsA : is_list (is_list (is_pair is_string is_value)) EE_A ->
      IsB : is_list (is_list (is_pair is_string is_value)) EE_B ->
      EvB : <evalExpr {ES}> FE EE_B E V O ES ->
      Vars : vars E Vars ->
      Rel : (forall X V, mem X Vars -> lookupScopes X EE_B V ->
                         lookupScopes X EE_A V) ->
      <evalExpr {ES}> FE EE_A E V O ES
    on EvB as IH_E,
  evalStmt_newNameScopes_exists_ES :
    forall FE EE_A EE_B S EE_B' O N Len Scope ES,
      IsS : is_stmt S ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsA : is_list (is_list (is_pair is_string is_value))
               (Scope::EE_A) ->
      IsB : is_list (is_list (is_pair is_string is_value))
               (Scope::EE_B) ->
      EvB : <evalStmt {ES}> FE (Scope::EE_B) S EE_B' O ES ->
      NNS : newNameScopes N Len EE_A EE_B ->
      exists EE_A', <evalStmt {ES}> FE (Scope::EE_A) S EE_A' O ES
    on EvB as IH_S,
  evalArgs_rel_exists_ES :
    forall FE EE_A EE_B A V O ES Vars,
      IsA : is_args A ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsA : is_list (is_list (is_pair is_string is_value)) EE_A ->
      IsB : is_list (is_list (is_pair is_string is_value)) EE_B ->
      EvB : <evalArgs {ES}> FE EE_B A V O ES ->
      Vars : varsArgs A Vars ->
      Rel : (forall X V, mem X Vars -> lookupScopes X EE_B V ->
                         lookupScopes X EE_A V) ->
      <evalArgs {ES}> FE EE_A A V O ES
    on EvB as IH_A,
  evalRecFields_rel_exists_ES :
    forall FE EE_A EE_B RF V O ES Vars,
      IsRF : is_recFieldExprs RF ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsA : is_list (is_list (is_pair is_string is_value)) EE_A ->
      IsB : is_list (is_list (is_pair is_string is_value)) EE_B ->
      EvB : <evalRecFields {ES}> FE EE_B RF V O ES ->
      Vars : varsRecFields RF Vars ->
      Rel : (forall X V, mem X Vars -> lookupScopes X EE_B V ->
                         lookupScopes X EE_A V) ->
      <evalRecFields {ES}> FE EE_A RF V O ES
    on EvB as IH_RF.
%evalExpr_rel_exists
 %E-Num
  search.
 %E-Plus
  case IsE. Vars: case Vars.
  EvA1: apply IH_E to _ _ _ _ EvB2 Vars _ with EE_A = EE_A.
    intros M L. M': apply mem_append_left to M Vars2.
    apply Rel to M' L. search.
  EvA2: apply IH_E to _ _ _ _ EvB3 Vars1 _ with EE_A = EE_A.
    intros M L. M': apply mem_append_right to M Vars2.
    apply Rel to M' L. search.
  search.
 %E-Minus
  case IsE. Vars: case Vars.
  EvA1: apply IH_E to _ _ _ _ EvB2 Vars _ with EE_A = EE_A.
    intros M L. M': apply mem_append_left to M Vars2.
    apply Rel to M' L. search.
  EvA2: apply IH_E to _ _ _ _ EvB3 Vars1 _ with EE_A = EE_A.
    intros M L. M': apply mem_append_right to M Vars2.
    apply Rel to M' L. search.
  search.
 %E-Mult
  case IsE. Vars: case Vars.
  EvA1: apply IH_E to _ _ _ _ EvB2 Vars _ with EE_A = EE_A.
    intros M L. M': apply mem_append_left to M Vars2.
    apply Rel to M' L. search.
  EvA2: apply IH_E to _ _ _ _ EvB3 Vars1 _ with EE_A = EE_A.
    intros M L. M': apply mem_append_right to M Vars2.
    apply Rel to M' L. search.
  search.
 %E-Div
  case IsE. Vars: case Vars.
  EvA1: apply IH_E to _ _ _ _ EvB2 Vars _ with EE_A = EE_A.
    intros M L. M': apply mem_append_left to M Vars2.
    apply Rel to M' L. search.
  EvA2: apply IH_E to _ _ _ _ EvB3 Vars1 _ with EE_A = EE_A.
    intros M L. M': apply mem_append_right to M Vars2.
    apply Rel to M' L. search.
  search.
 %E-True
  search.
 %E-False
  search.
 %E-And-True
  case IsE. Vars: case Vars.
  EvA1: apply IH_E to _ _ _ _ EvB2 Vars _ with EE_A = EE_A.
    intros M L. M': apply mem_append_left to M Vars2.
    apply Rel to M' L. search.
  EvA2: apply IH_E to _ _ _ _ EvB3 Vars1 _ with EE_A = EE_A.
    intros M L. M': apply mem_append_right to M Vars2.
    apply Rel to M' L. search.
  search.
 %E-And-False1
  case IsE. Vars: case Vars.
  apply IH_E to _ _ _ _ EvB1 Vars _ with EE_A = EE_A.
    intros M L. M': apply mem_append_left to M Vars2.
    apply Rel to M' L. search.
  search.
 %E-And-False2
  case IsE. Vars: case Vars.
  EvA1: apply IH_E to _ _ _ _ EvB2 Vars _ with EE_A = EE_A.
    intros M L. M': apply mem_append_left to M Vars2.
    apply Rel to M' L. search.
  EvA2: apply IH_E to _ _ _ _ EvB3 Vars1 _ with EE_A = EE_A.
    intros M L. M': apply mem_append_right to M Vars2.
    apply Rel to M' L. search.
  search.
 %E-Or-True1
  case IsE. Vars: case Vars.
  apply IH_E to _ _ _ _ EvB1 Vars _ with EE_A = EE_A.
    intros M L. M': apply mem_append_left to M Vars2.
    apply Rel to M' L. search.
  search.
 %E-Or-True2
  case IsE. Vars: case Vars.
  EvA1: apply IH_E to _ _ _ _ EvB2 Vars _ with EE_A = EE_A.
    intros M L. M': apply mem_append_left to M Vars2.
    apply Rel to M' L. search.
  EvA2: apply IH_E to _ _ _ _ EvB3 Vars1 _ with EE_A = EE_A.
    intros M L. M': apply mem_append_right to M Vars2.
    apply Rel to M' L. search.
  search.
 %E-Or-False
  case IsE. Vars: case Vars.
  EvA1: apply IH_E to _ _ _ _ EvB2 Vars _ with EE_A = EE_A.
    intros M L. M': apply mem_append_left to M Vars2.
    apply Rel to M' L. search.
  EvA2: apply IH_E to _ _ _ _ EvB3 Vars1 _ with EE_A = EE_A.
    intros M L. M': apply mem_append_right to M Vars2.
    apply Rel to M' L. search.
  search.
 %E-Not-True
  case IsE. Vars: case Vars. apply IH_E to _ _ _ _ EvB1 Vars Rel.
  search.
 %E-Not-False
  case IsE. Vars: case Vars. apply IH_E to _ _ _ _ EvB1 Vars Rel.
  search.
 %E-Greater-True
  case IsE. Vars: case Vars.
  EvA1: apply IH_E to _ _ _ _ EvB2 Vars _ with EE_A = EE_A.
    intros M L. M': apply mem_append_left to M Vars2.
    apply Rel to M' L. search.
  EvA2: apply IH_E to _ _ _ _ EvB3 Vars1 _ with EE_A = EE_A.
    intros M L. M': apply mem_append_right to M Vars2.
    apply Rel to M' L. search.
  search.
 %E-Greater-False
  case IsE. Vars: case Vars.
  EvA1: apply IH_E to _ _ _ _ EvB2 Vars _ with EE_A = EE_A.
    intros M L. M': apply mem_append_left to M Vars2.
    apply Rel to M' L. search.
  EvA2: apply IH_E to _ _ _ _ EvB3 Vars1 _ with EE_A = EE_A.
    intros M L. M': apply mem_append_right to M Vars2.
    apply Rel to M' L. search.
  search.
 %E-Eq-True
  case IsE. Vars: case Vars.
  EvA1: apply IH_E to _ _ _ _ EvB2 Vars _ with EE_A = EE_A.
    intros M L. M': apply mem_append_left to M Vars2.
    apply Rel to M' L. search.
  EvA2: apply IH_E to _ _ _ _ EvB3 Vars1 _ with EE_A = EE_A.
    intros M L. M': apply mem_append_right to M Vars2.
    apply Rel to M' L. search.
  search.
 %E-Eq-False
  case IsE. Vars: case Vars.
  EvA1: apply IH_E to _ _ _ _ EvB2 Vars _ with EE_A = EE_A.
    intros M L. M': apply mem_append_left to M Vars2.
    apply Rel to M' L. search.
  EvA2: apply IH_E to _ _ _ _ EvB3 Vars1 _ with EE_A = EE_A.
    intros M L. M': apply mem_append_right to M Vars2.
    apply Rel to M' L. search.
  search.
 %E-String
  search.
 %E-AppString
  case IsE. Vars: case Vars.
  EvA1: apply IH_E to _ _ _ _ EvB2 Vars _ with EE_A = EE_A.
    intros M L. M': apply mem_append_left to M Vars2.
    apply Rel to M' L. search.
  EvA2: apply IH_E to _ _ _ _ EvB3 Vars1 _ with EE_A = EE_A.
    intros M L. M': apply mem_append_right to M Vars2.
    apply Rel to M' L. search.
  search.
 %E-Name
  case IsE. case Vars. apply Rel to _ EvB1. search.
 %E-Call
  case IsE. Vars: case Vars.
  EvA2: apply IH_A to _ _ _ _ EvB3 Vars Rel. search.
 %E-RecBuild
  case IsE. Vars: case Vars. apply IH_RF to _ _ _ _ EvB1 Vars Rel.
  search.
 %E-RecAccess
  case IsE. Vars: case Vars. apply IH_E to _ _ _ _ EvB1 Vars Rel.
  search.
%evalStmt_newNameScopes_exists
 %E-Noop
  search.
 %E-Seq
  case IsS. EvA1: apply IH_S to _ _ _ _ EvB2 NNS.
  EvB1': apply drop_ext_size_evalStmt to EvB2.
  EvA1': apply drop_ext_size_evalStmt to EvA1.
  NNS': apply evalStmt_newNameScopes to _ _ _ _ EvA1' EvB1' NNS.
  apply evalStmt_isCtx to _ _ _ EvB1'.
  apply evalStmt_isCtx to _ _ _ EvA1'.
  Len_EE_A+: apply length_exists_list_pair_string_value to IsA.
  Len_EE_A': apply evalStmt_keep_scopes to _ _ _ EvA1' Len_EE_A+.
  Len: case Len_EE_A+. GEq: apply length_geq_0 to Len.
  apply length_is to Len. L: apply lt_plus_one to Len1 _.
  LEq: case GEq. apply lesseq_less_integer_transitive to LEq L.
  apply length_cons to Len_EE_A' _. NNS': case NNS'.
    %final
     LenB+: apply length_exists_list_pair_string_value to IsB.
     L': apply evalStmt_keep_scopes to _ _ _ EvB1' LenB+.
     apply length_unique to NNS' L'.
     LenB: case LenB+. apply length_is to LenB.
     LEq: apply newNameScopes_length to _ LenB.
     L: apply lt_plus_one to LenB1 _.
     apply less_lesseq_flip_false to L1 LEq1.
    %step
     EvA2: apply IH_S to _ _ _ _ EvB3 NNS'. search.
 %E-Declare
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  Is: case IsS. Vars: apply vars_exist to Is2.
  EvA1: apply IH_E to _ _ _ _ EvB1 Vars _ with EE_A = Scope::EE_A.
    intros M L. apply vars_is to _ Vars. apply mem_is_string to _ M.
    apply newNameScopes_lookupScopes to _ _ NNS' L. search.
  search.
 %E-Assign
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  Is: case IsS. Vars: apply vars_exist to Is1.
  EvA1: apply IH_E to _ _ _ _ EvB1 Vars _ with EE_A = Scope::EE_A.
    intros M L. apply vars_is to _ Vars. apply mem_is_string to _ M.
    apply newNameScopes_lookupScopes to _ _ NNS' L. search.
  EvB1': apply drop_ext_size_evalExpr to EvB1.
  apply evalExpr_isValue to _ _ _ EvB1'.
  apply newNameScopes_replaceScopes to _ _ _ _ NNS' EvB2. search.
 %E-RecUpdate
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  Is: case IsS. Vars: apply vars_exist to Is2.
  EvA1: apply IH_E to _ _ _ _ EvB1 Vars _ with EE_A = Scope::EE_A.
    intros M L. apply vars_is to _ Vars. apply mem_is_string to _ M.
    apply newNameScopes_lookupScopes to _ _ NNS' L. search.
  EvB1': apply drop_ext_size_evalExpr to EvB1.
  apply evalExpr_isValue to _ _ _ EvB1'.
  apply newNameScopes_lookupScopes to _ _ NNS' EvB2.
  IsRF: apply lookupScopes_is to _ EvB2. case IsRF.
  apply updateRecFields_is to _ _ _ EvB3.
  apply newNameScopes_replaceScopes to _ _ _ _ NNS' EvB4. search.
 %E-If-True
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  Is: case IsS. Vars: apply vars_exist to Is.
  EvA1: apply IH_E to _ _ _ _ EvB2 Vars _ with EE_A = Scope::EE_A.
    intros M L. apply vars_is to _ Vars. apply mem_is_string to _ M.
    apply newNameScopes_lookupScopes to _ _ NNS' L. search.
  EvB1': apply drop_ext_size_evalExpr to EvB2.
  EvA2: apply IH_S to _ _ _ _ EvB3 NNS'.
  LenA: apply length_exists_list_pair_string_value to IsA.
  IsN1: apply length_is to LenA.
  P: apply plus_integer_total to _ IsN1 with N1 = 1.
  LenA'+: assert length ([]::Scope::EE_A) N4.
  EvA2': apply drop_ext_size_evalStmt to EvA2.
  Len'': apply evalStmt_keep_scopes to _ _ _ EvA2' LenA'+.
  apply cons_length to LenA'+. apply length_cons to Len'' _. search.
 %E-If-False
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  Is: case IsS. Vars: apply vars_exist to Is.
  EvA1: apply IH_E to _ _ _ _ EvB2 Vars _ with EE_A = Scope::EE_A.
    intros M L. apply vars_is to _ Vars. apply mem_is_string to _ M.
    apply newNameScopes_lookupScopes to _ _ NNS' L. search.
  EvB1': apply drop_ext_size_evalExpr to EvB2.
  EvA2: apply IH_S to _ _ _ _ EvB3 NNS'.
  LenA: apply length_exists_list_pair_string_value to IsA.
  IsN1: apply length_is to LenA.
  P: apply plus_integer_total to _ IsN1 with N1 = 1.
  LenA'+: assert length ([]::Scope::EE_A) N4.
  EvA2': apply drop_ext_size_evalStmt to EvA2.
  Len'': apply evalStmt_keep_scopes to _ _ _ EvA2' LenA'+.
  apply cons_length to LenA'+. apply length_cons to Len'' _. search.
 %E-While-True
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  Is: case IsS. Vars: apply vars_exist to Is.
  EvA1: apply IH_E to _ _ _ _ EvB3 Vars _ with EE_A = Scope::EE_A.
    intros M L. apply vars_is to _ Vars. apply mem_is_string to _ M.
    apply newNameScopes_lookupScopes to _ _ NNS' L. search.
  EvB1': apply drop_ext_size_evalExpr to EvB3.
  EvA2: apply IH_S to _ _ _ _ EvB4 NNS'.
  LenA: apply length_exists_list_pair_string_value to IsA.
  IsN1: apply length_is to LenA.
  P: apply plus_integer_total to _ IsN1 with N1 = 1.
  LenA'+: assert length ([]::Scope::EE_A) N6.
  EvA2': apply drop_ext_size_evalStmt to EvA2.
  Len'': apply evalStmt_keep_scopes to _ _ _ EvA2' LenA'+.
  apply cons_length to LenA'+. apply length_cons to Len'' _.
  apply cons_length to LenA. Len': case Len'' (keep).
  apply length_is to Len'.
  apply plus_integer_unique_addend to _ _ _ P Len'1.
  apply length_cons to Len' _.
  LenB: apply length_exists_list_pair_string_value to IsB.
  IsN7: apply length_is to LenB.
  P': apply plus_integer_total to _ IsN7 with N1 = 1.
  LenB'+: assert length ([]::Scope::EE_B) N8.
  EvB2': apply drop_ext_size_evalStmt to EvB4.
  LenB'': apply evalStmt_keep_scopes to _ _ _ EvB2' LenB'+.
  LenB': case LenB'' (keep). apply length_is to LenB'.
  apply plus_integer_unique_addend to _ _ _ LenB'1 P'.
  apply cons_length to LenB. apply length_cons to LenB' _.
  NNS'': apply evalStmt_newNameScopes to _ _ _ _ EvA2' EvB2' _.
  LenB-: case LenB (keep).
  LEq: apply newNameScopes_length to NNS LenB-. NNS_: case NNS''.
    %last
     apply length_unique to LenB'' NNS_.
     L: apply lt_plus_one to LenB'1 _. apply length_is to LenB-.
     L': apply lt_plus_one to LenB-1 _.
     L'': apply less_integer_transitive to L' L.
     apply less_lesseq_flip_false to L'' LEq.
    %step
     NNS_: case NNS_.
       %last
        apply length_unique to LenB' NNS_. apply length_is to LenB-.
        L: apply lt_plus_one to LenB-1 _.
        apply less_lesseq_flip_false to L LEq.
       %step
        Is+: apply evalStmt_isCtx to _ _ _ EvB2'. case Is+.
        Is+: apply evalStmt_isCtx to _ _ _ EvA2'. case Is+.
        apply IH_S to _ _ _ _ EvB5 NNS_. search.
 %E-While-False
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  Is: case IsS. Vars: apply vars_exist to Is.
  EvA1: apply IH_E to _ _ _ _ EvB1 Vars _ with EE_A = Scope::EE_A.
    intros M L. apply vars_is to _ Vars. apply mem_is_string to _ M.
    apply newNameScopes_lookupScopes to _ _ NNS' L. search.
  search.
 %E-ScopeStmt
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  case IsS. EvA1: apply IH_S to _ _ _ _ EvB1 NNS'.
  LenA+: apply length_exists_list_pair_string_value to IsA.
  IsN1: apply length_is to LenA+.
  P: apply plus_integer_total to _ IsN1 with N1 = 1.
  LenA++: assert length ([]::Scope::EE_A) N3.
  EvA1': apply drop_ext_size_evalStmt to EvA1.
  LenA': apply evalStmt_keep_scopes to _ _ _ EvA1' LenA++.
  apply cons_length to LenA++. apply length_cons to LenA' _. search.
 %E-Print-Int
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  Is: case IsS. Vars: apply vars_exist to Is.
  EvA1: apply IH_E to _ _ _ _ EvB1 Vars _ with EE_A = Scope::EE_A.
    intros M L. apply vars_is to _ Vars. apply mem_is_string to _ M.
    apply newNameScopes_lookupScopes to _ _ NNS' L. search.
  search.
 %E-Print-True
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  Is: case IsS. Vars: apply vars_exist to Is.
  EvA1: apply IH_E to _ _ _ _ EvB1 Vars _ with EE_A = Scope::EE_A.
    intros M L. apply vars_is to _ Vars. apply mem_is_string to _ M.
    apply newNameScopes_lookupScopes to _ _ NNS' L. search.
  search.
 %E-Print-False
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  Is: case IsS. Vars: apply vars_exist to Is.
  EvA1: apply IH_E to _ _ _ _ EvB1 Vars _ with EE_A = Scope::EE_A.
    intros M L. apply vars_is to _ Vars. apply mem_is_string to _ M.
    apply newNameScopes_lookupScopes to _ _ NNS' L. search.
  search.
 %E-Print-String
  NNS': assert newNameScopes N Len (Scope::EE_A) (Scope::EE_B).
  Is: case IsS. Vars: apply vars_exist to Is.
  EvA1: apply IH_E to _ _ _ _ EvB1 Vars _ with EE_A = Scope::EE_A.
    intros M L. apply vars_is to _ Vars. apply mem_is_string to _ M.
    apply newNameScopes_lookupScopes to _ _ NNS' L. search.
  search.
%evalArgs_rel_exists
 %EA-Nil
  search.
 %EA-Cons
  case IsA. Vars: case Vars.
  apply IH_E to _ _ _ _ EvB2 Vars _ with EE_A = EE_A.
    intros M L. M': apply mem_append_left to M Vars2.
    apply Rel to M' L. search.
  apply IH_A to _ _ _ _ EvB3 Vars1 _ with EE_A = EE_A.
    intros M L. M': apply mem_append_right to M Vars2.
    apply Rel to M' L. search.
  search.
%evalRecFields_rel_exists
 %ERF-Nil
  search.
 %ERF-Cons
  case IsRF. Vars: case Vars.
  apply IH_E to _ _ _ _ EvB2 Vars _ with EE_A = EE_A.
    intros M L. M': apply mem_append_left to M Vars2.
    apply Rel to M' L. search.
  apply IH_RF to _ _ _ _ EvB3 Vars1 _ with EE_A = EE_A.
    intros M L. M': apply mem_append_right to M Vars2.
    apply Rel to M' L. search.
  search.


Theorem evalExpr_rel_exists :
  forall FE EE_A EE_B E V O Vars,
    is_expr E ->
    is_list (is_pair is_string
            (is_pair is_string
            (is_pair is_value
            (is_pair (is_list is_string) is_stmt)))) FE ->
    is_list (is_list (is_pair is_string is_value)) EE_A ->
    is_list (is_list (is_pair is_string is_value)) EE_B ->
    evalExpr FE EE_B E V O ->
    vars E Vars ->
    (forall X V, mem X Vars -> lookupScopes X EE_B V ->
                 lookupScopes X EE_A V) ->
    evalExpr FE EE_A E V O.
intros IsE IsFE IsA IsB Ev Vars Rel.
Ev': apply add_ext_size_evalExpr to Ev.
E: apply evalExpr_rel_exists_ES to IsE IsFE IsA IsB Ev' Vars Rel.
apply drop_ext_size_evalExpr to E. search.
Theorem evalStmt_newNameScopes_exists :
  forall FE EE_A EE_B S EE_B' O N Len Scope,
    is_stmt S ->
    is_list (is_pair is_string
            (is_pair is_string
            (is_pair is_value
            (is_pair (is_list is_string) is_stmt)))) FE ->
    is_list (is_list (is_pair is_string is_value))
       (Scope::EE_A) ->
    is_list (is_list (is_pair is_string is_value))
       (Scope::EE_B) ->
    evalStmt FE (Scope::EE_B) S EE_B' O ->
    newNameScopes N Len EE_A EE_B ->
    exists EE_A', evalStmt FE (Scope::EE_A) S EE_A' O.
intros IsS IsFE IsA IsB Ev NNS.
Ev': apply add_ext_size_evalStmt to Ev.
E: apply evalStmt_newNameScopes_exists_ES to IsS IsFE IsA IsB Ev' NNS.
apply drop_ext_size_evalStmt to E. search.
Theorem evalArgs_rel_exists :
  forall FE EE_A EE_B A V O Vars,
    is_args A ->
    is_list (is_pair is_string
            (is_pair is_string
            (is_pair is_value
            (is_pair (is_list is_string) is_stmt)))) FE ->
    is_list (is_list (is_pair is_string is_value)) EE_A ->
    is_list (is_list (is_pair is_string is_value)) EE_B ->
    evalArgs FE EE_B A V O ->
    varsArgs A Vars ->
    (forall X V, mem X Vars -> lookupScopes X EE_B V ->
                 lookupScopes X EE_A V) ->
    evalArgs FE EE_A A V O.
intros IsAr IsFE IsA IsB Ev Vars Rel.
Ev': apply add_ext_size_evalArgs to Ev.
E: apply evalArgs_rel_exists_ES to IsAr IsFE IsA IsB Ev' Vars Rel.
apply drop_ext_size_evalArgs to E. search.
Theorem evalRecFields_rel_exists :
  forall FE EE_A EE_B RF V O Vars ,
    is_recFieldExprs RF ->
    is_list (is_pair is_string
            (is_pair is_string
            (is_pair is_value
            (is_pair (is_list is_string) is_stmt)))) FE ->
    is_list (is_list (is_pair is_string is_value)) EE_A ->
    is_list (is_list (is_pair is_string is_value)) EE_B ->
    evalRecFields FE EE_B RF V O ->
    varsRecFields RF Vars ->
    (forall X V, mem X Vars -> lookupScopes X EE_B V ->
                 lookupScopes X EE_A V) ->
    evalRecFields FE EE_A RF V O.
intros IsRF IsFE IsA IsB Ev Vars Rel.
Ev': apply add_ext_size_evalRecFields to Ev.
E: apply evalRecFields_rel_exists_ES to
            IsRF IsFE IsA IsB Ev' Vars Rel.
apply drop_ext_size_evalRecFields to E. search.




/********************************************************************
 Evaluation with scopes_same
 ********************************************************************/
Theorem scopes_same_lookupScopes_exists : forall A B X V,
  is_list (is_list (is_pair is_string is_value)) B -> is_string X ->
  scopes_same A B -> lookupScopes X A V -> lookupScopes X B V.
induction on 4. intros IsB IsX SS L. L: case L.
  %LS-FirstScope
   SS: case SS. apply SS to L. search.
  %LS-Later
   SS: case SS. IsB: case IsB.
   Or: apply lookup_string_value_list_or_no to IsB IsX. N: case Or.
     %lookup B1 X V
      L': apply SS1 to N. apply no_lookup to L L'.
     %no_lookup B1 X
      apply IH to _ IsX SS2 L1. search.


Theorem scopes_same_lookupScopes : forall A B X VA VB,
  is_list (is_list (is_pair is_string is_value)) B -> is_string X ->
  scopes_same A B -> lookupScopes X A VA -> lookupScopes X B VB ->
  VA = VB.
intros IsB IsX SS LA LB.
LB': apply scopes_same_lookupScopes_exists to _ _ SS LA.
apply lookupScopes_unique to LB LB'. search.


Theorem remove_all_exists : forall X EE,
  is_list (is_pair is_string is_value) EE -> is_string X ->
  exists EE', remove_all EE X EE'.
induction on 1. intros IsEE IsX. Is: case IsEE.
  %nil
   search.
  %cons
   RA: apply IH to Is1 IsX. IsP: case Is.
   Or: apply is_string_eq_or_not to IsP IsX. E: case Or.
     %A = X
      search.
     %A != X
      search.


Theorem scopes_same_replaceScopes_exists : forall A B X V A',
  is_list (is_list (is_pair is_string is_value)) A ->
  is_list (is_list (is_pair is_string is_value)) B -> is_string X ->
  scopes_same A B -> replaceScopes X V A A' ->
  exists B', replaceScopes X V B B'.
induction on 5. intros IsA IsB IsX SS RS. RS: case RS.
  %RS-FirstScope
   SS: case SS. IsB: case IsB.
   Or: apply lookup_string_value_list_or_no to IsB IsX. L: case Or.
     %lookup B1 X V1
      apply lookup_mem to L. apply remove_all_exists to IsB IsX.
      search.
     %no_lookup B1 X
      case IsA. L': apply mem_lookup to _ RS. LB: apply SS to L'.
      apply no_lookup to L LB.
  %RS-Later
   SS: case SS. case IsA. IsB: case IsB. apply IH to _ _ IsX SS2 RS1.
   Or: apply lookup_string_value_list_or_no to IsB IsX. L: case Or.
     %lookup B1 X V
      L': apply SS1 to L. apply no_lookup to RS L'.
     %no_lookup B1 X
      search.


Theorem scopes_same_replaceScopes_scopes_same : forall A B X V A' B',
  is_list (is_list (is_pair is_string is_value)) A ->
  is_list (is_list (is_pair is_string is_value)) B -> is_string X ->
  scopes_same A B -> replaceScopes X V A A' ->
  replaceScopes X V B B' -> scopes_same A' B'.
induction on 5. intros IsA IsB IsX SS RSA RSB. RSA: case RSA.
  %RS-FirstScope
   RSB: case RSB.
     %RS-FirstScope
      SS: case SS. unfold.
        %lookup forward
         intros L. L: case L.
           %Lkp-Here
            search.
           %Lkp-Later
            L': apply remove_all_lookup_other to RSA1 L1 _.
            LB: apply SS to L'.
            apply remove_all_lookup_other_back to RSB1 LB _. search.
        %lookup backward
         intros L. L: case L.
           %Lkp-Here
            search.
           %Lkp-Later
            L': apply remove_all_lookup_other to RSB1 L1 _.
            LA: apply SS1 to L'.
            apply remove_all_lookup_other_back to RSA1 LA _. search.
        %rest
         search.
     %RS-Later
      case IsA. LA: apply mem_lookup to _ RSA. SS: case SS.
      LB: apply SS to LA. apply no_lookup to RSB LB.
  %RS-Later
   RSB: case RSB.
     %RS-FirstScope
      case IsB. LB: apply mem_lookup to _ RSB. SS: case SS.
      LA: apply SS1 to LB. apply no_lookup to RSA LA.
     %RS-Later
      SS: case SS. case IsA. case IsB.
      apply IH to _ _ _ SS2 RSA1 RSB1. search.


Theorem scopes_same_add_scope : forall A B,
  scopes_same A B -> scopes_same ([]::A) ([]::B).
intros SS. unfold.
  %lookup forward
   intros. search.
  %lookup back
   intros. search.
  %rest
   search.


Extensible_Theorem
  evalExpr_scopes_same :
    forall E FE EE_A VA OA EE_B VB OB,
      IsE : is_expr E ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsA : is_list (is_list (is_pair is_string is_value)) EE_A ->
      IsB : is_list (is_list (is_pair is_string is_value)) EE_B ->
      SS : scopes_same EE_A EE_B ->
      EvA : evalExpr FE EE_A E VA OA ->
      EvB : evalExpr FE EE_B E VB OB ->
      VA = VB /\ OA = OB
    on EvA as IH_E,
  evalStmt_scopes_same :
    forall S FE EE_A EE_A' OA EE_B EE_B' OB,
      IsS : is_stmt S ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsA : is_list (is_list (is_pair is_string is_value)) EE_A ->
      IsB : is_list (is_list (is_pair is_string is_value)) EE_B ->
      SS : scopes_same EE_A EE_B ->
      EvA : evalStmt FE EE_A S EE_A' OA ->
      EvB : evalStmt FE EE_B S EE_B' OB ->
      OA = OB
    on EvA as IH_S,
  evalStmt_scopes_same_ctx :
    forall S FE EE_A EE_A' OA EE_B EE_B' OB,
      IsS : is_stmt S ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsA : is_list (is_list (is_pair is_string is_value)) EE_A ->
      IsB : is_list (is_list (is_pair is_string is_value)) EE_B ->
      SS : scopes_same EE_A EE_B ->
      EvA : evalStmt FE EE_A S EE_A' OA ->
      EvB : evalStmt FE EE_B S EE_B' OB ->
      scopes_same EE_A' EE_B'
    on EvA as IH_S_C,
  evalArgs_scopes_same :
    forall A FE EE_A VA OA EE_B VB OB,
      IsA : is_args A ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsA : is_list (is_list (is_pair is_string is_value)) EE_A ->
      IsB : is_list (is_list (is_pair is_string is_value)) EE_B ->
      SS : scopes_same EE_A EE_B ->
      EvA : evalArgs FE EE_A A VA OA ->
      EvB : evalArgs FE EE_B A VB OB ->
      VA = VB /\ OA = OB
    on EvA as IH_A,
  evalRecFields_scopes_same :
    forall RF FE EE_A VA OA EE_B VB OB,
      IsRF : is_recFieldExprs RF ->
      IsFE : is_list (is_pair is_string
                     (is_pair is_string
                     (is_pair is_value
                     (is_pair (is_list is_string) is_stmt)))) FE ->
      IsA : is_list (is_list (is_pair is_string is_value)) EE_A ->
      IsB : is_list (is_list (is_pair is_string is_value)) EE_B ->
      SS : scopes_same EE_A EE_B ->
      EvA : evalRecFields FE EE_A RF VA OA ->
      EvB : evalRecFields FE EE_B RF VB OB ->
      VA = VB /\ OA = OB
    on EvA as IH_RF.
%evalExpr_scopes_same
 %E-Num
  case EvB. search.
 %E-Plus
  case IsE. EvB: case EvB. apply IH_E to _ _ _ _ SS EvA1 EvB.
  apply IH_E to _ _ _ _ _ EvA2 EvB1. apply append_unique to EvA4 EvB3.
  apply plus_integer_unique to EvA3 EvB2. search.
 %E-Minus
  case IsE. EvB: case EvB. apply IH_E to _ _ _ _ SS EvA1 EvB.
  apply IH_E to _ _ _ _ _ EvA2 EvB1. apply append_unique to EvA4 EvB3.
  apply minus_integer_unique to EvA3 EvB2. search.
 %E-Mult
  case IsE. EvB: case EvB. apply IH_E to _ _ _ _ SS EvA1 EvB.
  apply IH_E to _ _ _ _ _ EvA2 EvB1. apply append_unique to EvA4 EvB3.
  apply multiply_integer_unique to EvA3 EvB2. search.
 %E-Div
  case IsE. EvB: case EvB. apply IH_E to _ _ _ _ SS EvA1 EvB.
  apply IH_E to _ _ _ _ _ EvA2 EvB1. apply append_unique to EvA4 EvB3.
  apply divide_integer_unique to EvA3 EvB2. search.
 %E-True
  case EvB. search.
 %E-False
  case EvB. search.
 %E-And-True
  case IsE. EvB: case EvB.
    %E-And-True
     apply IH_E to _ _ _ _ SS EvA1 EvB.
     apply IH_E to _ _ _ _ _ EvA2 EvB1.
     apply append_unique to EvA3 EvB2. search.
    %E-And-False1
     apply IH_E to _ _ _ _ SS EvA1 EvB.
    %E-And-False2
     apply IH_E to _ _ _ _ SS EvA2 EvB1.
 %E-And-False1
  case IsE. EvB: case EvB.
    %E-And-True
     apply IH_E to _ _ _ _ SS EvA1 EvB.
    %E-And-False1
     apply IH_E to _ _ _ _ SS EvA1 EvB. search.
    %E-And-False2
     apply IH_E to _ _ _ _ SS EvA1 EvB.
 %E-And-False2
  case IsE. EvB: case EvB.
    %E-And-True
     apply IH_E to _ _ _ _ _ EvA2 EvB1.
    %E-And-False1
     apply IH_E to _ _ _ _ SS EvA1 EvB.
    %E-And-False2
     apply IH_E to _ _ _ _ SS EvA1 EvB.
     apply IH_E to _ _ _ _ _ EvA2 EvB1.
     apply append_unique to EvA3 EvB2. search.
 %E-Or-True1
  case IsE. EvB: case EvB.
    %E-Or-True1
     apply IH_E to _ _ _ _ SS EvA1 EvB. search.
    %E-Or-True2
     apply IH_E to _ _ _ _ SS EvA1 EvB.
    %E-Or-False
     apply IH_E to _ _ _ _ SS EvA1 EvB.
 %E-Or-True2
  case IsE. EvB: case EvB.
    %E-Or-True1
     apply IH_E to _ _ _ _ SS EvA1 EvB.
    %E-Or-True2
     apply IH_E to _ _ _ _ SS EvA1 EvB.
     apply IH_E to _ _ _ _ _ EvA2 EvB1.
     apply append_unique to EvA3 EvB2. search.
    %E-Or-False
     apply IH_E to _ _ _ _ _ EvA2 EvB1.
 %E-Or-False
  case IsE. EvB: case EvB.
    %E-Or-True1
     apply IH_E to _ _ _ _ SS EvA1 EvB.
    %E-Or-True2
     apply IH_E to _ _ _ _ _ EvA2 EvB1.
    %E-Or-False
     apply IH_E to _ _ _ _ SS EvA1 EvB.
     apply IH_E to _ _ _ _ _ EvA2 EvB1.
     apply append_unique to EvA3 EvB2. search.
 %E-Not-True
  case IsE. EvB: case EvB.
    %E-Not-True
     apply IH_E to _ _ _ _ SS EvA1 EvB. search.
    %E-Not-False
     apply IH_E to _ _ _ _ SS EvA1 EvB.
 %E-Not-False
  case IsE. EvB: case EvB.
    %E-Not-True
     apply IH_E to _ _ _ _ SS EvA1 EvB.
    %E-Not-False
     apply IH_E to _ _ _ _ SS EvA1 EvB. search.
 %E-Greater-True
  case IsE. EvB: case EvB.
    %E-Greater-True
     apply IH_E to _ _ _ _ SS EvA1 EvB.
     apply IH_E to _ _ _ _ _ EvA2 EvB1.
     apply append_unique to EvA4 EvB3. search.
    %E-Greater-False
     apply IH_E to _ _ _ _ SS EvA1 EvB.
     apply IH_E to _ _ _ _ _ EvA2 EvB1.
     apply greater_lesseq_integer_false to EvA3 EvB2.
 %E-Greater-False
  case IsE. EvB: case EvB.
    %E-Greater-True
     apply IH_E to _ _ _ _ SS EvA1 EvB.
     apply IH_E to _ _ _ _ _ EvA2 EvB1.
     apply greater_lesseq_integer_false to EvB2 EvA3.
    %E-Greater-False
     apply IH_E to _ _ _ _ SS EvA1 EvB.
     apply IH_E to _ _ _ _ _ EvA2 EvB1.
     apply append_unique to EvA4 EvB3. search.
 %E-Eq-True
  case IsE. EvB: case EvB.
    %E-Eq-True
     apply IH_E to _ _ _ _ SS EvA1 EvB.
     apply IH_E to _ _ _ _ _ EvA2 EvB1.
     apply append_unique to EvA3 EvB2. search.
    %E-Eq-False
     apply IH_E to _ _ _ _ SS EvA1 EvB.
     apply IH_E to _ _ _ _ _ EvA2 EvB1. apply EvB2 to _.
 %E-Eq-False
  case IsE. EvB: case EvB.
    %E-Eq-True
     apply IH_E to _ _ _ _ SS EvA1 EvB.
     apply IH_E to _ _ _ _ _ EvA2 EvB1. apply EvA3 to _.
    %E-Eq-False
     apply IH_E to _ _ _ _ SS EvA1 EvB.
     apply IH_E to _ _ _ _ _ EvA2 EvB1.
     apply append_unique to EvA4 EvB3. search.
 %E-String
  case EvB. search.
 %E-AppString
  case IsE. EvB: case EvB. apply IH_E to _ _ _ _ SS EvA1 EvB.
  apply IH_E to _ _ _ _ _ EvA2 EvB1.
  apply append_unique to EvA3 EvB2.
  apply append_unique to EvA4 EvB3. search.
 %E-Name
  case IsE. EvB: case EvB.
  apply scopes_same_lookupScopes to _ _ _ EvA1 EvB. search.
 %E-Call
  case IsE. EvB: case EvB. apply lookup_unique to EvB EvA1.
  apply IH_A to _ _ _ _ SS EvA2 EvB1. apply zip_unique to EvA3 EvB2.
  IsFP: apply lookup_is_value_funCtx to _ EvA1. IsFP: case IsFP.
  IsFP: case IsFP1. IsFP: case IsFP2.
  apply evalArgs_isValue to _ _ _ EvA2. apply zip_is to _ _ EvA3.
  apply evalStmt_unique to _ _ _ EvA4 EvB3.
  apply lookupScopes_unique to EvA6 EvB5.
  apply append_unique to EvA5 EvB4. search.
 %E-RecBuild
  case IsE. EvB: case EvB. apply IH_RF to _ _ _ _ SS EvA1 EvB. search.
 %E-RecAccess
  case IsE. EvB: case EvB. apply IH_E to _ _ _ _ SS EvA1 EvB.
  apply lookupRecFieldVal_unique to EvA2 EvB1. search.
%evalStmt_scopes_same
 %E-Noop
  case EvB. search.
 %E-Seq
  case IsS. EvB: case EvB. apply IH_S_C to _ _ _ _ _ EvA1 EvB.
  apply evalStmt_isCtx to _ _ _ EvA1.
  apply evalStmt_isCtx to _ _ _ EvB.
  apply IH_S to _ _ _ _ _ EvA1 EvB. apply IH_S to _ _ _ _ _ EvA2 EvB1.
  apply append_unique to EvA3 EvB2. search.
 %E-Declare
  case IsS. EvB: case EvB. apply IH_E to _ _ _ _ _ EvA1 EvB. search.
 %E-Assign
  case IsS. EvB: case EvB. apply IH_E to _ _ _ _ _ EvA1 EvB. search.
 %E-RecUpdate
  case IsS. EvB: case EvB. apply IH_E to _ _ _ _ _ EvA1 EvB. search.
 %E-If-True
  case IsS. EvB: case EvB.
   %E-If-True
    apply IH_E to _ _ _ _ _ EvA1 EvB.
    apply IH_S to _ _ _ _ _ EvA2 EvB1.
    apply append_unique to EvA3 EvB2. search.
   %E-If-False
    apply IH_E to _ _ _ _ _ EvA1 EvB.
 %E-If-False
  case IsS. EvB: case EvB.
    %E-If-True
     apply IH_E to _ _ _ _ _ EvA1 EvB.
    %E-If-False
     apply IH_E to _ _ _ _ _ EvA1 EvB.
     apply IH_S to _ _ _ _ _ EvA2 EvB1.
     apply append_unique to EvA3 EvB2. search.
 %E-While-True
  case IsS. EvB: case EvB.
    %E-While-True
     SS': apply scopes_same_add_scope to SS.
     apply IH_E to _ _ _ _ _ EvA1 EvB.
     apply IH_S to _ _ _ _ _ EvA2 EvB1.
     SS1: apply IH_S_C to _ _ _ _ _ EvA2 EvB1. SS1': case SS1.
     IsEE1+: apply evalStmt_isCtx to _ _ _ EvA2. case IsEE1+.
     IsEE2+: apply evalStmt_isCtx to _ _ _ EvB1. case IsEE2+.
     apply IH_S to _ _ _ _ _ EvA3 EvB2.
     apply append_unique to EvA4 EvB3.
     apply append_unique to EvA5 EvB4. search.
    %E-While-False
     apply IH_E to _ _ _ _ _ EvA1 EvB.
 %E-While-False
  case IsS. EvB: case EvB.
    %E-While-True
     apply IH_E to _ _ _ _ _ EvA1 EvB.
    %E-While-False
     apply IH_E to _ _ _ _ _ EvA1 EvB. search.
 %E-ScopeStmt
  case IsS. EvB: case EvB. apply scopes_same_add_scope to SS.
  apply IH_S to _ _ _ _ _ EvA1 EvB. search.
 %E-Print-Int
  case IsS. EvB: case EvB.
    %E-Print-Int
     apply IH_E to _ _ _ _ _ EvA1 EvB.
     apply append_unique to EvA2 EvB1. search.
    %E-Print-True
     apply IH_E to _ _ _ _ _ EvA1 EvB.
    %E-Print-False
     apply IH_E to _ _ _ _ _ EvA1 EvB.
    %E-Print-String
     apply IH_E to _ _ _ _ _ EvA1 EvB.
 %E-Print-True
  case IsS. EvB: case EvB.
    %E-Print-Int
     apply IH_E to _ _ _ _ _ EvA1 EvB.
    %E-Print-True
     apply IH_E to _ _ _ _ _ EvA1 EvB.
     apply append_unique to EvA2 EvB1. search.
    %E-Print-False
     apply IH_E to _ _ _ _ _ EvA1 EvB.
    %E-Print-String
     apply IH_E to _ _ _ _ _ EvA1 EvB.
 %E-Print-False
  case IsS. EvB: case EvB.
    %E-Print-Int
     apply IH_E to _ _ _ _ _ EvA1 EvB.
    %E-Print-True
     apply IH_E to _ _ _ _ _ EvA1 EvB.
    %E-Print-False
     apply IH_E to _ _ _ _ _ EvA1 EvB.
     apply append_unique to EvA2 EvB1. search.
    %E-Print-String
     apply IH_E to _ _ _ _ _ EvA1 EvB.
 %E-Print-String
  case IsS. EvB: case EvB.
    %E-Print-Int
     apply IH_E to _ _ _ _ _ EvA1 EvB.
    %E-Print-True
     apply IH_E to _ _ _ _ _ EvA1 EvB.
    %E-Print-False
     apply IH_E to _ _ _ _ _ EvA1 EvB.
    %E-Print-String
     apply IH_E to _ _ _ _ _ EvA1 EvB.
     apply append_unique to EvA2 EvB1. search.
%evalStmt_scopes_same_ctx
 %E-Noop
  case EvB. search.
 %E-Seq
  case IsS. EvB: case EvB. apply IH_S_C to _ _ _ _ _ EvA1 EvB.
  apply evalStmt_isCtx to _ _ _ EvA1.
  apply evalStmt_isCtx to _ _ _ EvB.
  apply IH_S_C to _ _ _ _ _ EvA2 EvB1. search.
 %E-Declare
  case IsS. EvB: case EvB. apply IH_E to _ _ _ _ _ EvA1 EvB.
  SS: case SS. unfold.
    %lookup forward
     intros L. L: case L.
       %Lkp-Here
        search.
       %Lkp-Later
        apply SS to L1. search.
    %lookup back
     intros L. L: case L.
       %Lkp-Here
        search.
       %Lkp-Later
        apply SS1 to L1. search.
    %rest
     search.
 %E-Assign
  case IsS. EvB: case EvB. apply IH_E to _ _ _ _ _ EvA1 EvB.
  apply scopes_same_replaceScopes_scopes_same to _ _ _ _ EvA2 EvB1.
  search.
 %E-RecUpdate
  case IsS. EvB: case EvB. apply IH_E to _ _ _ _ _ EvA1 EvB.
  apply scopes_same_lookupScopes to _ _ _ EvA2 EvB1.
  apply lookupScopes_is to _ EvA2.
  apply updateRecFields_unique to EvA3 EvB2.
  apply scopes_same_replaceScopes_scopes_same to _ _ _ _ EvA4 EvB3.
  search.
 %E-If-True
  case IsS. EvB: case EvB.
    %E-If-True
     apply scopes_same_add_scope to SS.
     SS': apply IH_S_C to _ _ _ _ _ EvA2 EvB1. case SS'. search.
    %E-If-False
     apply IH_E to _ _ _ _ _ EvA1 EvB.
 %E-If-False
  case IsS. EvB: case EvB.
    %E-If-True
     apply IH_E to _ _ _ _ _ EvA1 EvB.
    %E-If-False
     apply scopes_same_add_scope to SS.
     SS': apply IH_S_C to _ _ _ _ _ EvA2 EvB1. case SS'. search.
 %E-While-True
  case IsS. EvB: case EvB.
    %E-While-True
     apply scopes_same_add_scope to SS.
     SS1: apply IH_S_C to _ _ _ _ _ EvA2 EvB1. case SS1.
     IsEE1+: apply evalStmt_isCtx to _ _ _ EvA2. case IsEE1+.
     IsEE2+: apply evalStmt_isCtx to _ _ _ EvB1. case IsEE2+.
     apply IH_S_C to _ _ _ _ _ EvA3 EvB2. search.
    %E-While-False
     apply IH_E to _ _ _ _ _ EvA1 EvB.
 %E-While-False
  case IsS. EvB: case EvB.
    %E-While-True
     apply IH_E to _ _ _ _ _ EvA1 EvB.
    %E-While-False
     search.
 %E-ScopeStmt
  case IsS. EvB: case EvB. apply scopes_same_add_scope to SS.
  SS': apply IH_S_C to _ _ _ _ _ EvA1 EvB. case SS'. search.
 %E-Print-Int
  case IsS. EvB: case EvB.
    %E-Print-Int
     search.
    %E-Print-True
     apply IH_E to _ _ _ _ _ EvA1 EvB.
    %E-Print-False
     apply IH_E to _ _ _ _ _ EvA1 EvB.
    %E-Print-String
     apply IH_E to _ _ _ _ _ EvA1 EvB.
 %E-Print-True
  case IsS. EvB: case EvB.
    %E-Print-Int
     apply IH_E to _ _ _ _ _ EvA1 EvB.
    %E-Print-True
     search.
    %E-Print-False
     apply IH_E to _ _ _ _ _ EvA1 EvB.
    %E-Print-String
     apply IH_E to _ _ _ _ _ EvA1 EvB.
 %E-Print-False
  case IsS. EvB: case EvB.
    %E-Print-Int
     apply IH_E to _ _ _ _ _ EvA1 EvB.
    %E-Print-True
     apply IH_E to _ _ _ _ _ EvA1 EvB.
    %E-Print-False
     search.
    %E-Print-String
     apply IH_E to _ _ _ _ _ EvA1 EvB.
 %E-Print-String
  case IsS. EvB: case EvB.
    %E-Print-Int
     apply IH_E to _ _ _ _ _ EvA1 EvB.
    %E-Print-True
     apply IH_E to _ _ _ _ _ EvA1 EvB.
    %E-Print-False
     apply IH_E to _ _ _ _ _ EvA1 EvB.
    %E-Print-String
     search.
%evalArgs_scopes_same
 %EA-Nil
  case EvB. search.
 %EA-Cons
  case IsA. EvB: case EvB. apply IH_E to _ _ _ _ _ EvA1 EvB.
  apply IH_A to _ _ _ _ _ EvA2 EvB1. apply append_unique to EvA3 EvB2.
  search.
%evalRecFields_scopes_same
 %ERF-Nil
  case EvB. search.
 %ERF-Cons
  case IsRF. EvB: case EvB. apply IH_E to _ _ _ _ _ EvA1 EvB.
  apply IH_RF to _ _ _ _ _ EvA2 EvB1.
  apply append_unique to EvA3 EvB2. search.


Extensible_Theorem
  evalExpr_scopes_same_exists : forall E FE EE_A V O EE_B,
    IsE : is_expr E ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsA : is_list (is_list (is_pair is_string is_value)) EE_A ->
    IsB : is_list (is_list (is_pair is_string is_value)) EE_B ->
    SS : scopes_same EE_A EE_B ->
    EvA : evalExpr FE EE_A E V O ->
    evalExpr FE EE_B E V O
  on EvA as IH_E,
  evalStmt_scopes_same_exists : forall S FE EE_A EE_A' O EE_B,
    IsS : is_stmt S ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsA : is_list (is_list (is_pair is_string is_value)) EE_A ->
    IsB : is_list (is_list (is_pair is_string is_value)) EE_B ->
    SS : scopes_same EE_A EE_B ->
    EvA : evalStmt FE EE_A S EE_A' O ->
    exists EE_B', evalStmt FE EE_B S EE_B' O
  on EvA as IH_S,
  evalArgs_scopes_same_exists : forall A FE EE_A V O EE_B,
    IsA : is_args A ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsA : is_list (is_list (is_pair is_string is_value)) EE_A ->
    IsB : is_list (is_list (is_pair is_string is_value)) EE_B ->
    SS : scopes_same EE_A EE_B ->
    EvA : evalArgs FE EE_A A V O ->
    evalArgs FE EE_B A V O
  on EvA as IH_A,
  evalRecFields_scopes_same_exists : forall RF FE EE_A V O EE_B,
    IsRF : is_recFieldExprs RF ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsA : is_list (is_list (is_pair is_string is_value)) EE_A ->
    IsB : is_list (is_list (is_pair is_string is_value)) EE_B ->
    SS : scopes_same EE_A EE_B ->
    EvA : evalRecFields FE EE_A RF V O ->
    evalRecFields FE EE_B RF V O
  on EvA as IH_RF.
%evalExpr_scopes_same_exists
 %E-Num
  search.
 %E-Plus
  case IsE. EvB1: apply IH_E to _ _ _ _ SS EvA1.
  EvB2: apply IH_E to _ _ _ _ SS EvA2. search.
 %E-Minus
  case IsE. EvB1: apply IH_E to _ _ _ _ SS EvA1.
  EvB2: apply IH_E to _ _ _ _ SS EvA2. search.
 %E-Mult
  case IsE. EvB1: apply IH_E to _ _ _ _ SS EvA1.
  EvB2: apply IH_E to _ _ _ _ SS EvA2. search.
 %E-Div
  case IsE. EvB1: apply IH_E to _ _ _ _ SS EvA1.
  EvB2: apply IH_E to _ _ _ _ SS EvA2. search.
 %E-True
  search.
 %E-False
  search.
 %E-And-True
  case IsE. EvB1: apply IH_E to _ _ _ _ SS EvA1.
  EvB2: apply IH_E to _ _ _ _ SS EvA2. search.
 %E-And-False1
  case IsE. EvB1: apply IH_E to _ _ _ _ SS EvA1. search.
 %E-And-False2
  case IsE. EvB1: apply IH_E to _ _ _ _ SS EvA1.
  EvB2: apply IH_E to _ _ _ _ SS EvA2. search.
 %E-Or-True1
  case IsE. EvB1: apply IH_E to _ _ _ _ SS EvA1. search.
 %E-Or-True2
  case IsE. EvB1: apply IH_E to _ _ _ _ SS EvA1.
  EvB2: apply IH_E to _ _ _ _ SS EvA2. search.
 %E-Or-False
  case IsE. EvB1: apply IH_E to _ _ _ _ SS EvA1.
  EvB2: apply IH_E to _ _ _ _ SS EvA2. search.
 %E-Not-True
  case IsE. EvB1: apply IH_E to _ _ _ _ SS EvA1. search.
 %E-Not-False
  case IsE. EvB1: apply IH_E to _ _ _ _ SS EvA1. search.
 %E-Greater-True
  case IsE. EvB1: apply IH_E to _ _ _ _ SS EvA1.
  EvB2: apply IH_E to _ _ _ _ SS EvA2. search.
 %E-Greater-False
  case IsE. EvB1: apply IH_E to _ _ _ _ SS EvA1.
  EvB2: apply IH_E to _ _ _ _ SS EvA2. search.
 %E-Eq-True
  case IsE. EvB1: apply IH_E to _ _ _ _ SS EvA1.
  EvB2: apply IH_E to _ _ _ _ SS EvA2. search.
 %E-Eq-False
  case IsE. EvB1: apply IH_E to _ _ _ _ SS EvA1.
  EvB2: apply IH_E to _ _ _ _ SS EvA2. search.
 %E-String
  search.
 %E-AppString
  case IsE. EvB1: apply IH_E to _ _ _ _ SS EvA1.
  EvB2: apply IH_E to _ _ _ _ SS EvA2. search.
 %E-Name
  case IsE. apply scopes_same_lookupScopes_exists to _ _ SS EvA1.
  search.
 %E-Call
  case IsE. EvB: apply IH_A to _ _ _ _ SS EvA2. search.
 %E-RecBuild
  case IsE. apply IH_RF to _ _ _ _ SS EvA1. search.
 %E-RecAccess
  case IsE. apply IH_E to _ _ _ _ SS EvA1. search.
%evalStmt_scopes_same_exists
 %E-Noop
  search.
 %E-Seq
  case IsS. EvB1: apply IH_S to _ _ _ _ SS EvA1.
  SS': apply evalStmt_scopes_same_ctx to _ _ _ _ _ EvA1 EvB1.
  apply evalStmt_isCtx to _ _ _ EvA1.
  apply evalStmt_isCtx to _ _ _ EvB1.
  apply IH_S to _ _ _ _ SS' EvA2. search.
 %E-Declare
  case IsS. EvB: apply IH_E to _ _ _ _ SS EvA1. case SS. search.
 %E-Assign
  case IsS. EvB: apply IH_E to _ _ _ _ SS EvA1.
  apply scopes_same_replaceScopes_exists to _ _ _ SS EvA2. search.
 %E-RecUpdate
  case IsS. EvB: apply IH_E to _ _ _ _ SS EvA1.
  apply scopes_same_replaceScopes_exists to _ _ _ SS EvA4.
  apply scopes_same_lookupScopes_exists to _ _ SS EvA2. search.
 %E-If-True
  case IsS. EvB1: apply IH_E to _ _ _ _ SS EvA1.
  SS1: apply scopes_same_add_scope to SS.
  EvB2: apply IH_S to _ _ _ _ SS1 EvA2.
  SS2: apply evalStmt_scopes_same_ctx to _ _ _ _ _ EvA2 EvB2.
  case SS2. search.
 %E-If-False
  case IsS. EvB1: apply IH_E to _ _ _ _ SS EvA1.
  SS1: apply scopes_same_add_scope to SS.
  EvB2: apply IH_S to _ _ _ _ SS1 EvA2.
  SS2: apply evalStmt_scopes_same_ctx to _ _ _ _ _ EvA2 EvB2.
  case SS2. search.
 %E-While-True
  case IsS. EvB1: apply IH_E to _ _ _ _ SS EvA1.
  SS1: apply scopes_same_add_scope to SS.
  EvB2: apply IH_S to _ _ _ _ SS1 EvA2.
  SS2: apply evalStmt_scopes_same_ctx to _ _ _ _ _ EvA2 EvB2.
  SS2': case SS2. IsEE2+: apply evalStmt_isCtx to _ _ _ EvA2.
  IsBR+: apply evalStmt_isCtx to _ _ _ EvB2. case IsEE2+. case IsBR+.
  apply IH_S to _ _ _ _ SS2'2 EvA3. search.
 %E-While-False
  case IsS. apply IH_E to _ _ _ _ SS EvA1. search.
 %E-ScopeStmt
  case IsS. SS': apply scopes_same_add_scope to SS.
  EvB: apply IH_S to _ _ _ _ SS' EvA1.
  SS'': apply evalStmt_scopes_same_ctx to _ _ _ _ _ EvA1 EvB.
  case SS''. search.
 %E-PrintInt
  case IsS. apply IH_E to _ _ _ _ SS EvA1. search.
 %E-Print-True
  case IsS. apply IH_E to _ _ _ _ SS EvA1. search.
 %E-Print-False
  case IsS. apply IH_E to _ _ _ _ SS EvA1. search.
 %E-Print-String
  case IsS. apply IH_E to _ _ _ _ SS EvA1. search.
%evalArgs_scopes_same_exists
 %EA-Nil
  search.
 %EA-Cons
  case IsA. EvB1: apply IH_E to _ _ _ _ SS EvA1.
  apply IH_A to _ _ _ _ SS EvA2. search.
%evalRecFields_scopes_same_exists
 %ERF-Nil
  search.
 %ERF-Cons
  case IsRF. EvB1: apply IH_E to _ _ _ _ SS EvA1.
  apply IH_RF to _ _ _ _ SS EvA2. search.




/********************************************************************
 Projection Constraints for Evaluation
 ********************************************************************/
%projection evaluates with same output
Projection_Constraint proj_evalExpr_exists :
  forall E E' FE EE V O,
    Pr : |{expr}- E ~~> E' ->
    IsE : is_expr E ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    Ev : evalExpr FE EE E V O ->
    exists V', evalExpr FE EE E' V' O.


%projection evaluates
Projection_Constraint proj_evalStmt_exists :
  forall Names S S' FE EE EE' O,
    Pr : Names |{stmt}- S ~~> S' ->
    Names : names EE Names ->
    IsS : is_stmt S ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    Ev : evalStmt FE EE S EE' O ->
    exists EE'', evalStmt FE EE S' EE'' O.
%projection evaluates to a related context
Projection_Constraint proj_evalStmt_rel :
  forall Names S S' FE EE EE' O EE_P O_P,
    Pr : Names |{stmt}- S ~~> S' ->
    Names : names EE Names ->
    IsS : is_stmt S ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    Ev : evalStmt FE EE S EE' O ->
    Ev_P : evalStmt FE EE S' EE_P O_P ->
    scopes_same EE' EE_P.


/*
  We don't include any projection constraints for argument and record
  field expression evaluation because we introduced properties above
  to make the types nonextensible, so there cannot actually be
  projecting syntax for them.
*/




/********************************************************************
 Evaluation Ext_Ind for statements, expressions, and associated terms
 ********************************************************************/
Ext_Ind forall FE EE E V O, evalExpr FE EE E V O with
           IsFE : is_list (is_pair is_string
                          (is_pair is_string
                          (is_pair is_value
                          (is_pair (is_list is_string) is_stmt)))) FE,
           IsEE : is_list (is_list (is_pair is_string is_value)) EE,
           IsE : is_expr E;
        forall FE EE A V O, evalArgs FE EE A V O with
           IsFE : is_list (is_pair is_string
                          (is_pair is_string
                          (is_pair is_value
                          (is_pair (is_list is_string) is_stmt)))) FE,
           IsEE : is_list (is_list (is_pair is_string is_value)) EE,
           IsA : is_args A;
        forall FE EE RF V O, evalRecFields FE EE RF V O with
           IsFE : is_list (is_pair is_string
                          (is_pair is_string
                          (is_pair is_value
                          (is_pair (is_list is_string) is_stmt)))) FE,
           IsEE : is_list (is_list (is_pair is_string is_value)) EE,
           IsRF : is_recFieldExprs RF;
        forall FE EE S EE' O, evalStmt FE EE S EE' O with
           IsFE : is_list (is_pair is_string
                          (is_pair is_string
                          (is_pair is_value
                          (is_pair (is_list is_string) is_stmt)))) FE,
           IsEE : is_list (is_list (is_pair is_string is_value)) EE,
           IsS : is_stmt S.
%evalExpr
 %E-Num
  search.
 %E-Plus
  Acc': case Acc (keep). LE_N2: apply ext_size_pos_evalExpr to R2.
  LE_N3: apply ext_size_pos_evalExpr to R3.
  OrN2: apply lt_left to R1 _ _.
  apply ext_size_is_int_evalExpr to R3.
  OrN3: apply lt_right to R1 _ _ _.
  Is: case IsE. Ev1: apply drop_ext_size_evalExpr to R2.
  LN2: case OrN2.
    %N2 < N
     A2: apply Acc' to _ LN2. apply IH4 to R2 A2 _ _ _.
     Ev: apply drop_ext_size_evalExpr to R2. LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
    %N2 = N
     apply IH4 to R2 Acc _ _ _. Ev: apply drop_ext_size_evalExpr to R2.
     LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
 %E-Minus
  Acc': case Acc (keep). LE_N2: apply ext_size_pos_evalExpr to R2.
  LE_N3: apply ext_size_pos_evalExpr to R3.
  OrN2: apply lt_left to R1 _ _.
  apply ext_size_is_int_evalExpr to R3.
  OrN3: apply lt_right to R1 _ _ _.
  Is: case IsE. Ev1: apply drop_ext_size_evalExpr to R2.
  LN2: case OrN2.
    %N2 < N
     A2: apply Acc' to _ LN2. apply IH4 to R2 A2 _ _ _.
     Ev: apply drop_ext_size_evalExpr to R2. LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
    %N2 = N
     apply IH4 to R2 Acc _ _ _. Ev: apply drop_ext_size_evalExpr to R2.
     LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
 %E-Mult
  Acc': case Acc (keep). LE_N2: apply ext_size_pos_evalExpr to R2.
  LE_N3: apply ext_size_pos_evalExpr to R3.
  OrN2: apply lt_left to R1 _ _.
  apply ext_size_is_int_evalExpr to R3.
  OrN3: apply lt_right to R1 _ _ _.
  Is: case IsE. Ev1: apply drop_ext_size_evalExpr to R2.
  LN2: case OrN2.
    %N2 < N
     A2: apply Acc' to _ LN2. apply IH4 to R2 A2 _ _ _.
     Ev: apply drop_ext_size_evalExpr to R2. LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
    %N2 = N
     apply IH4 to R2 Acc _ _ _. Ev: apply drop_ext_size_evalExpr to R2.
     LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
 %E-Div
  Acc': case Acc (keep). LE_N2: apply ext_size_pos_evalExpr to R2.
  LE_N3: apply ext_size_pos_evalExpr to R3.
  OrN2: apply lt_left to R1 _ _.
  apply ext_size_is_int_evalExpr to R3.
  OrN3: apply lt_right to R1 _ _ _.
  Is: case IsE. Ev1: apply drop_ext_size_evalExpr to R2.
  LN2: case OrN2.
    %N2 < N
     A2: apply Acc' to _ LN2. apply IH4 to R2 A2 _ _ _.
     Ev: apply drop_ext_size_evalExpr to R2. LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
    %N2 = N
     apply IH4 to R2 Acc _ _ _. Ev: apply drop_ext_size_evalExpr to R2.
     LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
 %E-True
  search.
 %E-False
  search.
 %E-And-True
  Acc': case Acc (keep). LE_N2: apply ext_size_pos_evalExpr to R2.
  LE_N3: apply ext_size_pos_evalExpr to R3.
  OrN2: apply lt_left to R1 _ _.
  apply ext_size_is_int_evalExpr to R3.
  OrN3: apply lt_right to R1 _ _ _.
  Is: case IsE. Ev1: apply drop_ext_size_evalExpr to R2.
  LN2: case OrN2.
    %N2 < N
     A2: apply Acc' to _ LN2. apply IH4 to R2 A2 _ _ _.
     Ev: apply drop_ext_size_evalExpr to R2. LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
    %N2 = N
     apply IH4 to R2 Acc _ _ _. Ev: apply drop_ext_size_evalExpr to R2.
     LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
 %E-And-False1
  case IsE. apply IH4 to R1 Acc _ _ _. search.
 %E-And-False2
  Acc': case Acc (keep). LE_N2: apply ext_size_pos_evalExpr to R2.
  LE_N3: apply ext_size_pos_evalExpr to R3.
  OrN2: apply lt_left to R1 _ _.
  apply ext_size_is_int_evalExpr to R3.
  OrN3: apply lt_right to R1 _ _ _.
  Is: case IsE. Ev1: apply drop_ext_size_evalExpr to R2.
  LN2: case OrN2.
    %N2 < N
     A2: apply Acc' to _ LN2. apply IH4 to R2 A2 _ _ _.
     Ev: apply drop_ext_size_evalExpr to R2. LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
    %N2 = N
     apply IH4 to R2 Acc _ _ _. Ev: apply drop_ext_size_evalExpr to R2.
     LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
 %E-Or-True1
  case IsE. apply IH4 to R1 Acc _ _ _. search.
 %E-Or-True2
  Acc': case Acc (keep). LE_N2: apply ext_size_pos_evalExpr to R2.
  LE_N3: apply ext_size_pos_evalExpr to R3.
  OrN2: apply lt_left to R1 _ _.
  apply ext_size_is_int_evalExpr to R3.
  OrN3: apply lt_right to R1 _ _ _.
  Is: case IsE. Ev1: apply drop_ext_size_evalExpr to R2.
  LN2: case OrN2.
    %N2 < N
     A2: apply Acc' to _ LN2. apply IH4 to R2 A2 _ _ _.
     Ev: apply drop_ext_size_evalExpr to R2. LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
    %N2 = N
     apply IH4 to R2 Acc _ _ _. Ev: apply drop_ext_size_evalExpr to R2.
     LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
 %E-Or-False
  Acc': case Acc (keep). LE_N2: apply ext_size_pos_evalExpr to R2.
  LE_N3: apply ext_size_pos_evalExpr to R3.
  OrN2: apply lt_left to R1 _ _.
  apply ext_size_is_int_evalExpr to R3.
  OrN3: apply lt_right to R1 _ _ _.
  Is: case IsE. Ev1: apply drop_ext_size_evalExpr to R2.
  LN2: case OrN2.
    %N2 < N
     A2: apply Acc' to _ LN2. apply IH4 to R2 A2 _ _ _.
     Ev: apply drop_ext_size_evalExpr to R2. LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
    %N2 = N
     apply IH4 to R2 Acc _ _ _. Ev: apply drop_ext_size_evalExpr to R2.
     LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
 %E-Not-True
  case IsE. apply IH4 to R1 Acc _ _ _. search.
 %E-Not-False
  case IsE. apply IH4 to R1 Acc _ _ _. search.
 %E-Greater-True
  Acc': case Acc (keep). LE_N2: apply ext_size_pos_evalExpr to R2.
  LE_N3: apply ext_size_pos_evalExpr to R3.
  OrN2: apply lt_left to R1 _ _.
  apply ext_size_is_int_evalExpr to R3.
  OrN3: apply lt_right to R1 _ _ _.
  Is: case IsE. Ev1: apply drop_ext_size_evalExpr to R2.
  LN2: case OrN2.
    %N2 < N
     A2: apply Acc' to _ LN2. apply IH4 to R2 A2 _ _ _.
     Ev: apply drop_ext_size_evalExpr to R2. LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
    %N2 = N
     apply IH4 to R2 Acc _ _ _. Ev: apply drop_ext_size_evalExpr to R2.
     LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
 %E-Greater-False
  Acc': case Acc (keep). LE_N2: apply ext_size_pos_evalExpr to R2.
  LE_N3: apply ext_size_pos_evalExpr to R3.
  OrN2: apply lt_left to R1 _ _.
  apply ext_size_is_int_evalExpr to R3.
  OrN3: apply lt_right to R1 _ _ _.
  Is: case IsE. Ev1: apply drop_ext_size_evalExpr to R2.
  LN2: case OrN2.
    %N2 < N
     A2: apply Acc' to _ LN2. apply IH4 to R2 A2 _ _ _.
     Ev: apply drop_ext_size_evalExpr to R2. LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
    %N2 = N
     apply IH4 to R2 Acc _ _ _. Ev: apply drop_ext_size_evalExpr to R2.
     LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
 %E-Eq-True
  Acc': case Acc (keep). LE_N2: apply ext_size_pos_evalExpr to R2.
  LE_N3: apply ext_size_pos_evalExpr to R3.
  OrN2: apply lt_left to R1 _ _.
  apply ext_size_is_int_evalExpr to R3.
  OrN3: apply lt_right to R1 _ _ _.
  Is: case IsE. Ev1: apply drop_ext_size_evalExpr to R2.
  LN2: case OrN2.
    %N2 < N
     A2: apply Acc' to _ LN2. apply IH4 to R2 A2 _ _ _.
     Ev: apply drop_ext_size_evalExpr to R2. LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
    %N2 = N
     apply IH4 to R2 Acc _ _ _. Ev: apply drop_ext_size_evalExpr to R2.
     LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
 %E-Eq-False
  Acc': case Acc (keep). LE_N2: apply ext_size_pos_evalExpr to R2.
  LE_N3: apply ext_size_pos_evalExpr to R3.
  OrN2: apply lt_left to R1 _ _.
  apply ext_size_is_int_evalExpr to R3.
  OrN3: apply lt_right to R1 _ _ _.
  Is: case IsE. Ev1: apply drop_ext_size_evalExpr to R2.
  LN2: case OrN2.
    %N2 < N
     A2: apply Acc' to _ LN2. apply IH4 to R2 A2 _ _ _.
     Ev: apply drop_ext_size_evalExpr to R2. LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
    %N2 = N
     apply IH4 to R2 Acc _ _ _. Ev: apply drop_ext_size_evalExpr to R2.
     LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
 %E-String
  search.
 %E-AppString
  Acc': case Acc (keep). LE_N2: apply ext_size_pos_evalExpr to R2.
  LE_N3: apply ext_size_pos_evalExpr to R3.
  OrN2: apply lt_left to R1 _ _.
  apply ext_size_is_int_evalExpr to R3.
  OrN3: apply lt_right to R1 _ _ _.
  Is: case IsE. Ev1: apply drop_ext_size_evalExpr to R2.
  LN2: case OrN2.
    %N2 < N
     A2: apply Acc' to _ LN2. apply IH4 to R2 A2 _ _ _.
     Ev: apply drop_ext_size_evalExpr to R2. LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
    %N2 = N
     apply IH4 to R2 Acc _ _ _. Ev: apply drop_ext_size_evalExpr to R2.
     LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH4 to R3 Acc _ _ _. search.
 %E-Name
  search.
 %E-Call
  Acc': case Acc (keep). LE_N2: apply ext_size_pos_evalArgs to R3.
  LE_N3: apply ext_size_pos_evalStmt to R5.
  OrN2: apply lt_left to R1 _ _. apply ext_size_is_int_evalStmt to R5.
  OrN3: apply lt_right to R1 _ _ _. Is: case IsE.
  IsFP: apply lookup_is_value_funCtx to _ R2. IsFP: case IsFP.
  IsFP: case IsFP1. IsFP: case IsFP2.
  EvA: apply drop_ext_size_evalArgs to R3.
  apply evalArgs_isValue to _ _ _ EvA. apply zip_is to _ _ R4.
  LN2: case OrN2.
    %N2 < N
     A2: apply Acc' to _ LN2. apply IH5 to R3 A2 _ _ _.
     LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH7 to R5 A3 _ _ _. search.
       %N3 = N
        apply IH7 to R5 Acc _ _ _. search.
    %N2 = N
     apply IH5 to R3 Acc _ _ _. LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH7 to R5 A3 _ _ _. search.
       %N3 = N
        apply IH7 to R5 Acc _ _ _. search.
 %E-RecBuild
  case IsE. apply IH6 to R1 Acc _ _ _. search.
 %E-RecAccess
  case IsE. apply IH4 to R1 Acc _ _ _. search.
%evalArgs
 %EA-Nil
  search.
 %EA-Cons
  Acc': case Acc (keep). LE_N2: apply ext_size_pos_evalExpr to R2.
  LE_N3: apply ext_size_pos_evalArgs to R3.
  OrN2: apply lt_left to R1 _ _.
  apply ext_size_is_int_evalArgs to R3.
  OrN3: apply lt_right to R1 _ _ _. Is: case IsA. LN2: case OrN2.
    %N2 < N
     A2: apply Acc' to _ LN2. apply IH to R2 A2 _ _ _.
     Ev: apply drop_ext_size_evalExpr to R2. LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH5 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH5 to R3 Acc _ _ _. search.
    %N2 = N
     apply IH4 to R2 Acc _ _ _. Ev: apply drop_ext_size_evalExpr to R2.
     LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH5 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH5 to R3 Acc _ _ _. search.
%evalRecFields
 %ERF-Nil
  search.
 %ERF-Cons
  Acc': case Acc (keep). LE_N2: apply ext_size_pos_evalExpr to R2.
  LE_N3: apply ext_size_pos_evalRecFields to R3.
  OrN2: apply lt_left to R1 _ _.
  apply ext_size_is_int_evalRecFields to R3.
  OrN3: apply lt_right to R1 _ _ _. Is: case IsRF. LN2: case OrN2.
    %N2 < N
     A2: apply Acc' to _ LN2. apply IH to R2 A2 _ _ _.
     Ev: apply drop_ext_size_evalExpr to R2. LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH6 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH6 to R3 Acc _ _ _. search.
    %N2 = N
     apply IH4 to R2 Acc _ _ _. Ev: apply drop_ext_size_evalExpr to R2.
     LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH6 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH6 to R3 Acc _ _ _. search.
%evalStmt
 %E-Noop
  search.
 %E-Seq
  Acc': case Acc (keep). LE_N2: apply ext_size_pos_evalStmt to R2.
  LE_N3: apply ext_size_pos_evalStmt to R3.
  OrN2: apply lt_left to R1 _ _.
  apply ext_size_is_int_evalStmt to R3.
  OrN3: apply lt_right to R1 _ _ _.
  Is: case IsS. Ev1: apply drop_ext_size_evalStmt to R2.
  LN2: case OrN2.
    %N2 < N
     A2: apply Acc' to _ LN2. apply IH7 to R2 A2 _ _ _.
     Ev: apply drop_ext_size_evalStmt to R2.
     apply evalStmt_isCtx to _ _ _ Ev. LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH7 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH7 to R3 Acc _ _ _. search.
    %N2 = N
     apply IH7 to R2 Acc _ _ _. Ev: apply drop_ext_size_evalStmt to R2.
     apply evalStmt_isCtx to _ _ _ Ev. LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH7 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH7 to R3 Acc _ _ _. search.
 %E-Declare
  case IsS. apply IH4 to R1 Acc _ _ _. search.
 %E-Assign
  case IsS. apply IH4 to R1 Acc _ _ _. search.
 %E-RecUpdate
  case IsS. apply IH4 to R1 Acc _ _ _. search.
 %E-If-True
  Acc': case Acc (keep). LE_N2: apply ext_size_pos_evalExpr to R2.
  LE_N3: apply ext_size_pos_evalStmt to R3.
  OrN2: apply lt_left to R1 _ _.
  apply ext_size_is_int_evalStmt to R3.
  OrN3: apply lt_right to R1 _ _ _.
  Is: case IsS. Ev1: apply drop_ext_size_evalExpr to R2.
  LN2: case OrN2.
    %N2 < N
     A2: apply Acc' to _ LN2. apply IH4 to R2 A2 _ _ _.
     Ev: apply drop_ext_size_evalExpr to R2. LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH7 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH7 to R3 Acc _ _ _. search.
    %N2 = N
     apply IH4 to R2 Acc _ _ _. Ev: apply drop_ext_size_evalExpr to R2.
     LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH7 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH7 to R3 Acc _ _ _. search.
 %E-If-False
  Acc': case Acc (keep). LE_N2: apply ext_size_pos_evalExpr to R2.
  LE_N3: apply ext_size_pos_evalStmt to R3.
  OrN2: apply lt_left to R1 _ _.
  apply ext_size_is_int_evalStmt to R3.
  OrN3: apply lt_right to R1 _ _ _.
  Is: case IsS. Ev1: apply drop_ext_size_evalExpr to R2.
  LN2: case OrN2.
    %N2 < N
     A2: apply Acc' to _ LN2. apply IH4 to R2 A2 _ _ _.
     Ev: apply drop_ext_size_evalExpr to R2. LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH7 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH7 to R3 Acc _ _ _. search.
    %N2 = N
     apply IH4 to R2 Acc _ _ _. Ev: apply drop_ext_size_evalExpr to R2.
     LN3: case OrN3.
       %N3 < N
        A3: apply Acc' to _ LN3. apply IH7 to R3 A3 _ _ _. search.
       %N3 = N
        apply IH7 to R3 Acc _ _ _. search.
 %E-While-True
  LE_N2: apply ext_size_pos_evalExpr to R3.
  LE_N4: apply ext_size_pos_evalStmt to R5.
  LE_N5: apply ext_size_pos_evalStmt to R4. Is: case IsS.
  EvCond: apply drop_ext_size_evalExpr to R3.
  EvBody: apply drop_ext_size_evalStmt to R4.
  IsEE4+: apply evalStmt_isCtx to _ _ _ EvBody. case IsEE4+.
  apply ext_size_is_int_evalExpr to R3.
  apply ext_size_is_int_evalStmt to R5.
  apply ext_size_is_int_evalStmt to R4.
  LE_N2_N5: apply lte_left to R2 _ _ _.
  LE_N4_N5: apply lte_right to R2 _ _ _.
  apply lesseq_integer__add_positives to _ _ R2.
  Or3: apply lt_left to R1 _ _.
  apply plus_integer_is_integer to _ _ R2.
  LE_N5_N: apply lte_right to R1 _ _ _.
  LE_N2_N: apply lesseq_integer_transitive to LE_N2_N5 LE_N5_N.
  LE_N4_N: apply lesseq_integer_transitive to LE_N4_N5 LE_N5_N.
  Or2: apply lesseq_integer_less_or_eq to LE_N2_N.
  Or4: apply lesseq_integer_less_or_eq to LE_N4_N.
  Acc': case Acc (keep).
  assert <evalExpr {P}> FE EE Cond trueVal O2.
    LN3: case Or3.
      %N3 < N
       A3: apply Acc' to _ LN3. apply IH4 to R3 A3 _ _ _. search.
      %N3 = N
       apply IH4 to R3 Acc _ _ _. search.
  assert <evalStmt {P}> FE ([]::EE) Body (Scope::EE3) O3.
    LN2: case Or2.
      %N2 < N
       A2: apply Acc' to _ LN2. apply IH7 to R4 A2 _ _ _. search.
      %N3 = N
       apply IH7 to R4 Acc _ _ _. search.
  assert <evalStmt {P}> FE EE3 (while Cond Body) EE' O4.
    LN4: case Or4.
      %N4 < N
       A4: apply Acc' to _ LN4. apply IH7 to R5 A4 _ _ _. search.
      %N4 = N
       apply IH7 to R5 Acc _ _ _. search.
  search.
 %E-While-False
  case IsS. apply IH4 to R1 Acc _ _ _. search.
 %E-ScopeStmt
  case IsS. apply IH7 to R1 Acc _ _ _. search.
 %E-Print-Int
  case IsS. apply IH4 to R1 Acc _ _ _. search.
 %E-Print-True
  case IsS. apply IH4 to R1 Acc _ _ _. search.
 %E-Print-False
  case IsS. apply IH4 to R1 Acc _ _ _. search.
 %E-Print-String
  case IsS. apply IH4 to R1 Acc _ _ _. search.




/********************************************************************
 Gathered function evaluation information unique
 ********************************************************************/
Extensible_Theorem
  paramName_unique : forall P NA NB,
    IsP : is_param P ->
    PA : paramName P NA ->
    PB : paramName P NB ->
    NA = NB
  on PA.
%PN-Param
 case PB. search.


Theorem paramNames_unique : forall P NA NB,
  is_list is_param P -> paramNames P NA -> paramNames P NB -> NA = NB.
induction on 2. intros IsP PA PB. PA: case PA.
  %PNs-Empty
   case PB. search.
  %PNs-Cons
   PB: case PB. case IsP. apply paramName_unique to _ PA PB.
   apply IH to _ PA1 PB1. search.


%a parameter's projection has the same name as it;
%new parameter constructors should just be extra info around same name
Projection_Constraint proj_paramName_forward : forall P P' N,
  Pr : |{param}- P ~~> P' ->
  IsP : is_param P ->
  PN : paramName P N ->
  paramName P' N.

%if a parameter's projection gives info, the original gives the same
Projection_Constraint proj_paramName_back : forall P P' N,
  Pr : |{param}- P ~~> P' ->
  IsP : is_param P ->
  PN : paramName P' N ->
  paramName P N.


Extensible_Theorem
  getFunEvalInfo_unique : forall F NA RA VA PA BA NB RB VB PB BB,
    IsF : is_fun F ->
    GFEIA : getFunEvalInfo F NA RA VA PA BA ->
    GFEIB : getFunEvalInfo F NB RB VB PB BB ->
    NA = NB /\ RA = RB /\ VA = VB /\ PA = PB /\ BA = BB
  on GFEIA.
%GFEI-Fun
 GFEIB: case GFEIB. case IsF.
 apply paramNames_unique to _ GFEIA1 GFEIB. search.


Theorem getFunEvalCtx_unique : forall Fs FCA FCB,
  is_list is_fun Fs -> getFunEvalCtx Fs FCA -> getFunEvalCtx Fs FCB ->
  FCA = FCB.
induction on 2. intros IsFs GFECA GFECB. GFECA: case GFECA.
  %GFEC-Empty
   case GFECB. search.
  %GFEC-Cons
   GFECB: case GFECB. case IsFs.
   apply getFunEvalInfo_unique to _ GFECA GFECB.
   apply IH to _ GFECA1 GFECB1. search.


%a function's projection gives the same information as it
Projection_Constraint proj_getFunEvalInfo_forward :
  forall F F' N R V P B,
    Pr : |{fun}- F ~~> F' ->
    IsF : is_fun F ->
    GFEI : getFunEvalInfo F N R V P B ->
    getFunEvalInfo F' N R V P B.

%if a function's projection gives info, the original gives the same
Projection_Constraint proj_getFunEvalInfo_back :
  forall F F' N R V P B,
    Pr : |{fun}- F ~~> F' ->
    IsF : is_fun F ->
    GFEI : getFunEvalInfo F' N R V P B ->
    getFunEvalInfo F N R V P B.




/********************************************************************
 Program evaluation unique
 ********************************************************************/
Extensible_Theorem
  evalProgram_unique : forall A P OA OB,
    IsA : is_list is_value A ->
    IsP : is_program P ->
    EvA : evalProgram A P OA ->
    EvB : evalProgram A P OB ->
    OA = OB
  on EvA.
%E-Program
 EvB: case EvB. case IsP. apply getFunEvalCtx_unique to _ EvA1 EvB.
 apply getFunEvalInfo_unique to _ EvA2 EvB1.
 apply zip_unique to EvA3 EvB2. apply getFunEvalCtx_is to _ EvA1.
 apply getFunEvalInfo_is to _ EvA2. apply zip_is to _ _ EvA3.
 apply evalStmt_unique to _ _ _ EvA4 EvB3. search.


%a program's projection evaluates the same as it
Projection_Constraint proj_evalProgram : forall P P' A O,
  Pr : |{program}- P ~~> P' ->
  IsP : is_program P ->
  IsA : is_list is_value A ->
  Ev : evalProgram A P O ->
  evalProgram A P' O.

%if a program's projection evaluates, the original evaluates the same
Projection_Constraint proj_evalProgram_back : forall P P' A O,
  Pr : |{program}- P ~~> P' ->
  IsP : is_program P ->
  IsA : is_list is_value A ->
  Ev : evalProgram A P' O ->
  evalProgram A P O.




/********************************************************************
 Type preservation
 ********************************************************************/
Define related_all_scopes :
    list (list (pair string typ)) ->
    list (list (pair string value)) -> prop by
  related_all_scopes [] [];
  related_all_scopes (A::ARest) (B::BRest) :=
    (forall X T,
       lookup A X T -> exists V, lookup B X V /\ valueType V T) /\
    (forall X, no_lookup A X -> no_lookup B X) /\
    related_all_scopes ARest BRest.


Theorem related_all_scopes_add : forall A B AS BS X V T,
  related_all_scopes (AS::A) (BS::B) -> valueType V T ->
  related_all_scopes (((X, T)::AS)::A) (((X, V)::BS)::B).
intros RAS. R: case RAS. unfold.
  %lookup
   intros LkpA LkpB. LkpA: case LkpA.
     %Lkp-Here
      search.
     %Lkp-Later
      apply R to LkpA1. search.
  %no_lookup
   intros N. N: case N. apply R1 to N1. search.
  %rest
   search.


Theorem related_all_scopes_add_scope : forall A B,
  related_all_scopes A B -> related_all_scopes ([]::A) ([]::B).
intros R. unfold.
  %lookup
   intros L. case L.
  %no_lookup
   intros N. search.
  %rest
   search.


Theorem related_all_scopes_lookupScopes : forall A B X V T,
  related_all_scopes A B -> lookupScopes X A T ->
  lookupScopes X B V -> valueType V T.
induction on 1. intros R LA LB. LA: case LA.
  %LS-FirstScope
   R: case R. LB: case LB.
     %LS-FirstScope
      L: apply R to LA. apply lookup_unique to LB L. search.
     %LS-Later
      L: apply R to LA. apply no_lookup to LB L.
  %LS-Later
   R: case R. LB: case LB.
     %LS-FirstScope
      N: apply R1 to LA. apply no_lookup to N LB.
     %LS-Later
      apply IH to R2 LA1 LB1. search.


Define valueTypeList : list value -> list typ -> prop by
  valueTypeList [] [];
  valueTypeList (V::VRest) (T::TRest) :=
    valueType V T /\ valueTypeList VRest TRest.


Theorem valueTypeList_related_all_scopes :
  forall Vs Tys Ns VScope TScope,
    valueTypeList Vs Tys -> zip Ns Vs VScope -> zip Ns Tys TScope ->
    related_all_scopes [TScope] [VScope].
induction on 1. intros VTL ZV ZT. VTL: case VTL.
  %nil
   case ZV. case ZT. unfold.
     intros L. case L.
     intros. search.
     search.
  %cons
   ZV: case ZV. ZT: case ZT. R: apply IH to VTL1 ZV ZT. R: case R.
   unfold.
     %lookup
      intros L. L: case L.
        %Lkp-Here
         search.
        %Lkp-Later
         apply R to L1. search.
     %no_lookup
      intros N. N: case N. apply R1 to N1. search.
     %rest
      search.


Theorem valFieldTys_lookup : forall Fields FieldTys F V Ty,
  valFieldTys Fields FieldTys -> lookupRecFieldVal Fields F V ->
  lookupRecFieldTy FieldTys F Ty -> valueType V Ty.
induction on 1. intros VFT LV LT. VFT: case VFT.
  %VFT-Nil
   case LV.
  %VFT-Cons
   LV: case LV.
     %LRFV-Here
      LT: case LT.
        %LRF-Here
         search.
        %LRF-Later
         apply LT to _.
     %LRFV-Later
      LT: case LT.
        %LRF-Here
         apply LV to _.
        %LRF-Later
         apply IH to VFT1 LV1 LT1. search.


Theorem related_all_scopes_replaceScopes : forall ET EE X V EE' Ty,
  is_list (is_list (is_pair is_string is_typ)) ET ->
  is_list (is_list (is_pair is_string is_value)) EE ->
  related_all_scopes ET EE -> replaceScopes X V EE EE' ->
  lookupScopes X ET Ty -> valueType V Ty ->
  related_all_scopes ET EE'.
induction on 4. intros IsET IsEE RAS RS LTy VTy. RS: case RS.
  %RS-FirstScope
   RAS: case RAS. LTy: case LTy.
     %LS-FirstScope
      unfold.
        %lookup
         intros L. case IsET. IsX: apply lookup_is_key_type to _ LTy.
         IsX1: apply lookup_is_key_type to _ L.
         Or: apply is_string_eq_or_not to IsX IsX1. E: case Or.
           %X = X1
            apply lookup_unique to LTy L. search.
           %X != X1
            LNew: apply RAS to L.
            apply remove_all_lookup_other_back to RS1 LNew _. search.
        %no_lookup
         intros N. unfold.
           %X != X1
            intros E. case E. apply no_lookup to N LTy.
           %no_lookup LRemain X1
            N': apply RAS1 to N.
            apply remove_all_no_lookup_back to RS1 N'. search.
        %rest
         search.
     %LS-Later
      N: apply RAS1 to LTy. apply no_lookup_mem to N RS.
  %RS-Later
   RAS: case RAS. LTy: case LTy.
     %LS-FirstScope
      apply RAS to LTy. apply no_lookup to RS _.
     %LS-Later
      case IsET. case IsEE. apply IH to _ _ RAS2 RS1 LTy1 _. search.


Theorem replaceRecVal_typePres : forall L Tys F VTy V L',
  valFieldTys L Tys -> lookupRecFieldTy Tys F VTy ->
  valueType V VTy -> replaceRecVal F V L L' -> valFieldTys L' Tys.
induction on 4. intros VFT L VTy RRV. RRV: case RRV.
  %RRV-Here
   case VFT. L: case L.
     %LRF-Here
      search.
     %LRF-Later
      apply L to _.
  %RRV-Later
   VFT: case VFT. L: case L.
     %LRF-Here
      apply RRV to _.
     %LRF-Later
      apply IH to VFT1 L1 VTy RRV1. search.


Theorem updateRecFields_typePres : forall Fs FTys Ty V FVals Out,
  nestedFieldTy Fs FTys Ty -> updateRecFields Fs V FVals Out ->
  valueType V Ty -> valFieldTys FVals FTys -> valFieldTys Out FTys.
induction on 2. intros NFT URF VTy VFT. URF: case URF.
  %URF-One
   NFT: case NFT.
     %NFT-LastField
      apply replaceRecVal_typePres to _ _ _ URF. search.
     %NFT-StepField
      case NFT1.
  %URF-Step
   NFT: case NFT.
     %NFT-LastField
      case URF1.
     %NFT-StepField
      RVTy: apply valFieldTys_lookup to VFT URF NFT. case RVTy.
      apply IH to NFT1 URF1 VTy _.
      apply replaceRecVal_typePres to _ _ _ URF2. search.


Extensible_Theorem
  evalExpr_typePres : forall E FT ET Ty FE EE O V,
    IsE : is_expr E ->
    IsFT : is_list (is_pair is_string
                   (is_pair is_typ (is_list is_typ))) FT ->
    IsET : is_list (is_list (is_pair is_string is_typ)) ET ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    Ty : typeOf FT ET E Ty ->
    Ev : evalExpr FE EE E V O ->
    Funs : (forall F RetTy ArgTys ArgNames Body RetVar RVVal,
              lookup FT F (RetTy, ArgTys) ->
              lookup FE F (RetVar, RVVal, ArgNames, Body) ->
              exists Scope TyEnv',
                zip ArgNames ArgTys Scope /\
                valueType RVVal RetTy /\
                stmtOK FT [((RetVar, RetTy)::Scope)] Body TyEnv') ->
    Ctxs : related_all_scopes ET EE ->
    valueType V Ty
  on Ev as IH_E,
  evalStmt_typePres : forall S FT ET ET' FE EE EE' O,
    IsS : is_stmt S ->
    IsFT : is_list (is_pair is_string
                   (is_pair is_typ (is_list is_typ))) FT ->
    IsET : is_list (is_list (is_pair is_string is_typ)) ET ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    Ty : stmtOK FT ET S ET' ->
    Ev : evalStmt FE EE S EE' O ->
    Funs : (forall F RetTy ArgTys ArgNames Body RetVar RVVal,
              lookup FT F (RetTy, ArgTys) ->
              lookup FE F (RetVar, RVVal, ArgNames, Body) ->
              exists Scope TyEnv',
                zip ArgNames ArgTys Scope /\
                valueType RVVal RetTy /\
                stmtOK FT [((RetVar, RetTy)::Scope)] Body TyEnv') ->
    Ctxs : related_all_scopes ET EE ->
    related_all_scopes ET' EE'
  on Ev as IH_S,
  evalArgs_typePres : forall A FT ET Tys FE EE O Vs,
    IsA : is_args A ->
    IsFT : is_list (is_pair is_string
                   (is_pair is_typ (is_list is_typ))) FT ->
    IsET : is_list (is_list (is_pair is_string is_typ)) ET ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    Ty : typeOfArgs FT ET A Tys ->
    Ev : evalArgs FE EE A Vs O ->
    Funs : (forall F RetTy ArgTys ArgNames Body RetVar RVVal,
              lookup FT F (RetTy, ArgTys) ->
              lookup FE F (RetVar, RVVal, ArgNames, Body) ->
              exists Scope TyEnv',
                zip ArgNames ArgTys Scope /\
                valueType RVVal RetTy /\
                stmtOK FT [((RetVar, RetTy)::Scope)] Body TyEnv') ->
    Ctxs : related_all_scopes ET EE ->
    valueTypeList Vs Tys
  on Ev as IH_A,
  evalRecFields_typePres : forall RF FT ET FTys FE EE O FVs,
    IsRF : is_recFieldExprs RF ->
    IsFT : is_list (is_pair is_string
                   (is_pair is_typ (is_list is_typ))) FT ->
    IsET : is_list (is_list (is_pair is_string is_typ)) ET ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    Ty : typeOfRecFields FT ET RF FTys ->
    Ev : evalRecFields FE EE RF FVs O ->
    Funs : (forall F RetTy ArgTys ArgNames Body RetVar RVVal,
              lookup FT F (RetTy, ArgTys) ->
              lookup FE F (RetVar, RVVal, ArgNames, Body) ->
              exists Scope TyEnv',
                zip ArgNames ArgTys Scope /\
                valueType RVVal RetTy /\
                stmtOK FT [((RetVar, RetTy)::Scope)] Body TyEnv') ->
    Ctxs : related_all_scopes ET EE ->
    valFieldTys FVs FTys
  on Ev as IH_RF.
%evalExpr_typePres
 %E-Num
  case Ty. search.
 %E-Plus
  case Ty. search.
 %E-Minus
  case Ty. search.
 %E-Mult
  case Ty. search.
 %E-Div
  case Ty. search.
 %E-True
  case Ty. search.
 %E-False
  case Ty. search.
 %E-And-True
  case Ty. search.
 %E-And-False1
  case Ty. search.
 %E-And-False2
  case Ty. search.
 %E-Or-True1
  case Ty. search.
 %E-Or-True2
  case Ty. search.
 %E-Or-False
  case Ty. search.
 %E-Not-True
  case Ty. search.
 %E-Not-False
  case Ty. search.
 %E-Greater-True
  case Ty. search.
 %E-Greater-False
  case Ty. search.
 %E-Eq-True
  case Ty. search. search. search.
 %E-Eq-False
  case Ty. search. search. search.
 %E-String
  case Ty. search.
 %E-AppString
  case Ty. search.
 %E-Name
  Ty: case Ty. apply related_all_scopes_lookupScopes to _ Ty Ev1.
  search.
 %E-Call
  case IsE. Ty: case Ty. F: apply Funs to Ty Ev1.
  IsP: apply lookup_is_value_funCtx to _ Ev1. Is: case IsP.
  Is: case Is1. Is: case Is2. apply evalArgs_isValue to _ _ _ Ev2.
  apply zip_is_string_value to _ _ Ev3.
  IsP: apply lookup_is_value_funTyCtx to _ Ty. case IsP.
  apply zip_is_string_ty to _ _ F.
  VTL: apply IH_A to _ _ _ _ _ Ty1 Ev2 _ _.
  VTL': assert valueTypeList (RVVal::ArgVals) (Ty::ArgTys).
  ZE: assert zip (RetVar::ArgNames) (RVVal::ArgVals)
                 ((RetVar, RVVal)::InitEnv).
  ZT: assert zip (RetVar::ArgNames) (Ty::ArgTys)
                 ((RetVar, Ty)::Scope).
  apply valueTypeList_related_all_scopes to VTL' ZE ZT.
  R: apply IH_S to _ _ _ _ _ F2 Ev4 _ _.
  apply stmtOK_older_scopes_same to _ _ _ F2.
  apply stmtOK_first_scope_lookup_same to _ _ _ F2 _.
  apply related_all_scopes_lookupScopes to R _ Ev6. search.
 %E-RecBuild
  case IsE. Ty: case Ty. apply IH_RF to _ _ _ _ _ Ty Ev1 _ _. search.
 %E-RecAccess
  case IsE. Ty: case Ty. VT: apply IH_E to _ _ _ _ _ Ty Ev1 _ _.
  VFT: case VT. apply valFieldTys_lookup to VFT Ev2 Ty1. search.
%evalStmt_typePres
 %E-Noop
  case Ty. search.
 %E-Seq
  case IsS. Ty: case Ty. apply IH_S to _ _ _ _ _ Ty Ev1 _ _.
  apply stmtOK_isCtx to _ _ _ Ty. apply evalStmt_isCtx to _ _ _ Ev1.
  apply IH_S to _ _ _ _ _ Ty1 Ev2 _ _. search.
 %E-Declare
  case IsS. Ty: case Ty. apply IH_E to _ _ _ _ _ Ty1 Ev1 _ _.
  R: case Ctxs. unfold.
    %lookup
     intros L. L: case L.
       %Lkp-Here
        search.
       %Lkp-Later
        apply R to L1. exists V1. split.
          %lookup ((X, V)::Scope) X1 V1
           search.
          %valueType V1 T
           search.
    %no_lookup
     intros N. N: case N. apply R1 to N1. search.
    %rest
     search.
 %E-Assign
  case IsS. Ty: case Ty. apply IH_E to _ _ _ _ _ Ty1 Ev1 _ _.
  apply related_all_scopes_replaceScopes to _ _ Ctxs Ev2 Ty _. search.
 %E-RecUpdate
  case IsS. Ty: case Ty. apply IH_E to _ _ _ _ _ Ty1 Ev1 _ _.
  RFTy: apply related_all_scopes_lookupScopes to Ctxs Ty Ev2.
  case RFTy. apply updateRecFields_typePres to Ty2 Ev3 _ _.
  apply related_all_scopes_replaceScopes to _ _ Ctxs Ev4 Ty _. search.
 %E-If-True
  case IsS. Ty: case Ty. apply related_all_scopes_add_scope to Ctxs.
  R': apply IH_S to _ _ _ _ _ Ty1 Ev2 _ _.
  apply stmtOK_older_scopes_same to _ _ _ Ty1. case R'. search.
 %E-If-False
  case IsS. Ty: case Ty. apply related_all_scopes_add_scope to Ctxs.
  R': apply IH_S to _ _ _ _ _ Ty2 Ev2 _ _.
  apply stmtOK_older_scopes_same to _ _ _ Ty2. case R'. search.
 %E-While-True
  case IsS. Ty: case Ty. apply related_all_scopes_add_scope to Ctxs.
  R': apply IH_S to _ _ _ _ _ Ty1 Ev2 _ _.
  apply stmtOK_older_scopes_same to _ _ _ Ty1. case R'.
  Is: apply evalStmt_isCtx to _ _ _ Ev2. case Is.
  apply IH_S to _ _ _ _ _ _ Ev3 _ _. search.
 %E-While-False
  case IsS. Ty: case Ty. search.
 %E-ScopeStmt
  case IsS. Ty: case Ty. apply related_all_scopes_add_scope to Ctxs.
  R: apply IH_S to _ _ _ _ _ Ty Ev1 _ _.
  apply stmtOK_older_scopes_same to _ _ _ Ty. case R. search.
 %E-Print-Int
  case IsS. Ty: case Ty.
    %T-Print-Int
     search.
    %T-Print-Bool
     search.
    %T-Print-False
     search.
 %E-Print-True
  case IsS. Ty: case Ty.
    %T-Print-Int
     search.
    %T-Print-Bool
     search.
    %T-Print-String
     search.
 %E-Print-False
  case IsS. Ty: case Ty.
    %T-Print-Int
     search.
    %T-Print-Bool
     search.
    %T-Print-String
     search.
 %E-Print-String
  case IsS. Ty: case Ty.
    %T-Print-Int
     search.
    %T-Print-Bool
     search.
    %T-Print-String
     search.
%evalArgs_typePres
 Ev: case Ev.
   %EA-Nil
    case Ty. search.
   %EA-Cons
    case IsA. Ty: case Ty. apply IH_E to _ _ _ _ _ Ty Ev1 _ _.
    apply IH_A to _ _ _ _ _ Ty1 Ev2 _ _. search.
%evalRecFields_typePres
 Ev: case Ev.
   %ERF-Nil
    case Ty. search.
   %ERF-Cons
    case IsRF. Ty: case Ty. apply IH_E to _ _ _ _ _ Ty Ev1 _ _.
    apply IH_RF to _ _ _ _ _ Ty1 Ev2 _ _. search.




/********************************************************************
 Gathered function typing and evaluation information agrees
 ********************************************************************/
Extensible_Theorem
  paramTy_paramName_same : forall P NT T N,
    PT : paramTy P NT T ->
    PN : paramName P N ->
    NT = N
  on PT.
%PT-Param
 case PN. search.


Theorem paramTys_values_names_zip_same : forall Ps PTys Tys Ns,
  paramTys Ps PTys -> values PTys Tys -> paramNames Ps Ns ->
  zip Ns Tys PTys.
induction on 1. intros PT V PN. PT: case PT.
  %nil
   case V. case PN. search.
  %cons
   V: case V. PN: case PN. apply IH to PT1 V PN1.
   apply paramTy_paramName_same to PT PN. search.


Extensible_Theorem
  funOK_getFunEvalInfo_related :
    forall F FT Name RetVar RVVal PNames Body,
      IsF : is_fun F ->
      IsFT : is_list (is_pair is_string
                     (is_pair is_typ (is_list is_typ))) FT ->
      FOK : funOK FT F ->
      GFEI : getFunEvalInfo F Name RetVar RVVal PNames Body ->
      exists RetTy ArgTys Scope TyEnv',
        lookup FT Name (RetTy, ArgTys) /\
        zip PNames ArgTys Scope /\
        valueType RVVal RetTy /\
        stmtOK FT [((RetVar, RetTy)::Scope)] Body TyEnv' /\
        lookup FT Name (RetTy, ArgTys)
  on FOK.
%T-Fun
 GFEI: case GFEI.
 Z: apply paramTys_values_names_zip_same to FOK1 FOK4 GFEI.
 exists RetTy, PTys, ParamTys, FinalTC. search.


Theorem funsOK_getFunEvalCtx_related : forall Fs FT FE,
  is_list is_fun Fs ->
  is_list (is_pair is_string (is_pair is_typ (is_list is_typ))) FT ->
  funsOK FT Fs -> getFunEvalCtx Fs FE ->
  %literally what we require for type preservation
  (forall F RetTy ArgTys ArgNames Body RetVar RVVal,
     lookup FT F (RetTy, ArgTys) ->
     lookup FE F (RetVar, RVVal, ArgNames, Body) ->
     exists Scope TyEnv',
       zip ArgNames ArgTys Scope /\
       valueType RVVal RetTy /\
       stmtOK FT [((RetVar, RetTy)::Scope)] Body TyEnv').
induction on 3. intros IsFs IsFT FOK GFEC LT LE. FOK: case FOK.
  %FOK-Nil
   case GFEC. case LE.
  %FOK-Cons
   GFE: case GFEC. case IsFs.
   Y: apply funOK_getFunEvalInfo_related to _ _ FOK GFE. L: case LE.
     %Lkp-Here
      exists Scope, TyEnv'. apply lookup_unique to LT Y4. search.
     %Lkp-Later
      X: apply IH to _ _ FOK1 GFE1. backchain X.



/********************************************************************
 Evaluation prints only basic values
 ********************************************************************/
/*
  Only basic values can be printed.  Record values, and anything else
  introduced by extensions, can only be printed by printing primitive
  values representing them.
*/
Define output_forms : list value -> prop by
  output_forms [];
  output_forms (intVal I::Rest) := output_forms Rest;
  output_forms (trueVal::Rest) := output_forms Rest;
  output_forms (falseVal::Rest) := output_forms Rest;
  output_forms (stringVal S::Rest) := output_forms Rest.


Theorem output_forms_append : forall OA OB O,
  output_forms OA -> output_forms OB -> OA ++ OB = O ->
  output_forms O.
induction on 3. intros OA OB A. A: case A.
  %nil
   search.
  %cons
   OA: case OA.
     %int
      apply IH to _ _ A. search.
     %true
      apply IH to _ _ A. search.
     %false
      apply IH to _ _ A. search.
     %string
      apply IH to _ _ A. search.


Extensible_Theorem
  evalExpr_output_forms : forall E FE EE V O,
    IsE : is_expr E ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    Ev : evalExpr FE EE E V O ->
    output_forms O
  on Ev as IH_E,
  evalStmt_output_forms : forall S FE EE EE' O,
    IsS : is_stmt S ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    Ev : evalStmt FE EE S EE' O ->
    output_forms O
  on Ev as IH_S,
  evalArgs_output_forms : forall A FE EE Vs O,
    IsA : is_args A ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    Ev : evalArgs FE EE A Vs O ->
    output_forms O
  on Ev as IH_A,
  evalRecFields_output_forms : forall RF FE EE Fields O,
    IsRF : is_recFieldExprs RF ->
    IsFE : is_list (is_pair is_string
                   (is_pair is_string
                   (is_pair is_value
                   (is_pair (is_list is_string) is_stmt)))) FE ->
    IsEE : is_list (is_list (is_pair is_string is_value)) EE ->
    Ev : evalRecFields FE EE RF Fields O ->
    output_forms O
  on Ev as IH_RF.
%evalExpr_output_forms
 %E-Num
  search.
 %E-Plus
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply output_forms_append to _ _ Ev4. search.
 %E-Minus
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply output_forms_append to _ _ Ev4. search.
 %E-Mult
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply output_forms_append to _ _ Ev4. search.
 %E-Div
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply output_forms_append to _ _ Ev4. search.
 %E-True
  search.
 %E-False
  search.
 %E-And-True
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply output_forms_append to _ _ Ev3. search.
 %E-And-False1
  case IsE. apply IH_E to _ _ _ Ev1. search.
 %E-And-False2
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply output_forms_append to _ _ Ev3. search.
 %E-Or-True1
  case IsE. apply IH_E to _ _ _ Ev1. search.
 %E-Or-True2
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply output_forms_append to _ _ Ev3. search.
 %E-Or-False
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply output_forms_append to _ _ Ev3. search.
 %E-Not-True
  case IsE. apply IH_E to _ _ _ Ev1. search.
 %E-Not-False
  case IsE. apply IH_E to _ _ _ Ev1. search.
 %E-Greater-True
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply output_forms_append to _ _ Ev4. search.
 %E-Greater-False
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply output_forms_append to _ _ Ev4. search.
 %E-Eq-True
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply output_forms_append to _ _ Ev3. search.
 %E-Eq-False
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply output_forms_append to _ _ Ev4. search.
 %E-String
  search.
 %E-AppString
  case IsE. apply IH_E to _ _ _ Ev1. apply IH_E to _ _ _ Ev2.
  apply output_forms_append to _ _ Ev4. search.
 %E-Name
  search.
 %E-Call
  case IsE. IsF: apply lookup_is_value_funCtx to _ Ev1. IsF: case IsF.
  IsF: case IsF1. IsF: case IsF2. apply IH_A to _ _ _ Ev2.
  apply evalArgs_isValue to _ _ _ Ev2. apply zip_is to _ _ Ev3.
  apply IH_S to _ _ _ Ev4. apply output_forms_append to _ _ Ev5.
  search.
 %E-RecBuild
  case IsE. apply IH_RF to _ _ _ Ev1. search.
 %E-RecAccess
  case IsE. apply IH_E to _ _ _ Ev1. search.
%evalStmt_output_forms
 %E-Noop
  search.
 %E-Seq
  case IsS. apply IH_S to _ _ _ Ev1.
  apply evalStmt_isCtx to _ _ _ Ev1. apply IH_S to _ _ _ Ev2.
  apply output_forms_append to _ _ Ev3. search.
 %E-Declare
  case IsS. apply IH_E to _ _ _ Ev1. search.
 %E-Assign
  case IsS. apply IH_E to _ _ _ Ev1. search.
 %E-RecUpdate
  case IsS. apply IH_E to _ _ _ Ev1. search.
 %E-If-True
  case IsS. apply IH_E to _ _ _ Ev1. apply IH_S to _ _ _ Ev2.
  apply output_forms_append to _ _ Ev3. search.
 %E-If-False
  case IsS. apply IH_E to _ _ _ Ev1. apply IH_S to _ _ _ Ev2.
  apply output_forms_append to _ _ Ev3. search.
 %E-While-True
  case IsS. apply IH_E to _ _ _ Ev1. apply IH_S to _ _ _ Ev2.
  IsEE4+: apply evalStmt_isCtx to _ _ _ Ev2. case IsEE4+.
  apply IH_S to _ _ _ Ev3. apply output_forms_append to _ _ Ev4.
  apply output_forms_append to _ _ Ev5. search.
 %E-While-False
  case IsS. apply IH_E to _ _ _ Ev1. search.
 %E-ScopeStmt
  case IsS. apply IH_S to _ _ _ Ev1. search.
 %E-Print-Int
  case IsS. apply IH_E to _ _ _ Ev1.
  apply output_forms_append to _ _ Ev2. search.
 %E-Print-True
  case IsS. apply IH_E to _ _ _ Ev1.
  apply output_forms_append to _ _ Ev2. search.
 %E-Print-False
  case IsS. apply IH_E to _ _ _ Ev1.
  apply output_forms_append to _ _ Ev2. search.
 %E-Print-String
  case IsS. apply IH_E to _ _ _ Ev1.
  apply output_forms_append to _ _ Ev2. search.
%evalArgs_output_forms
 %EA-Nil
  search.
 %EA-Cons
  case IsA. apply IH_E to _ _ _ Ev1. apply IH_A to _ _ _ Ev2.
  apply output_forms_append to _ _ Ev3. search.
%evalRecFields_output_forms
 %ERF-Nil
  search.
 %ERF-Cons
  case IsRF. apply IH_E to _ _ _ Ev1. apply IH_RF to _ _ _ Ev2.
  apply output_forms_append to _ _ Ev3. search.




/********************************************************************
 Program evaluation prints only basic values
 ********************************************************************/
Extensible_Theorem
  evalProgram_output_forms : forall A P O,
    IsA : is_list is_value A ->
    IsP : is_program P ->
    Ev : evalProgram A P O ->
    output_forms O
  on Ev.
%E-Program
 case IsP. apply getFunEvalCtx_is to _ Ev1.
 apply getFunEvalInfo_is to _ Ev2. apply zip_is to _ _ Ev3.
 apply evalStmt_output_forms to _ _ _ Ev4. search.




/********************************************************************
 Gathered function evaluation information always exists
 ********************************************************************/
Extensible_Theorem
  paramName_exists : forall P,
    IsP : is_param P ->
    exists N, paramName P N
  on IsP.
%param
 search.


Theorem paramNames_exists : forall Ps,
  is_list is_param Ps -> exists Ns, paramNames Ps Ns.
induction on 1. intros IsPs. Is: case IsPs.
  %nil
   search.
  %cons
   apply paramName_exists to Is. apply IH to Is1. search.


Extensible_Theorem
  getFunEvalInfo_exists : forall F,
    IsF : is_fun F ->
    exists N R V P B, getFunEvalInfo F N R V P B
  on IsF.
%fun
 apply paramNames_exists to IsF5. search.


Theorem getFunEvalCtx_exists : forall Fs,
  is_list is_fun Fs -> exists Ctx, getFunEvalCtx Fs Ctx.
induction on 1. intros Is. Is: case Is.
  %nil
   search.
  %cons
   apply getFunEvalInfo_exists to Is. apply IH to Is1. search.
