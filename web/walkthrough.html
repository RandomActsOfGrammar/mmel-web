<html>
<head>
<title>Tool Walkthrough</title>
<link href="style.css" rel="stylesheet" type="text/css">
<script src="actions.js"></script>
<link rel="icon" href="images/favicon.png" type="image/x-icon">
</head>
<body class="mmel">
<div id="header-logo">
<a href="index.html">
<img class="header-logo" src="images/MMEL.png"
     alt="Modular Metatheory for Extensible Languages logo">
</a>
</div>
<div class="section">
  <a href="index.html">
    <h1>Tool Walkthrough</h1>
  </a>
  <p>
    This walkthrough covers the use of Sterling and Extensibella for
    modular language specification and modular metatheory.  We will
    cover the processes of using the tools for writing language
    specifications, reasoning about them, and composing the modular
    proofs to form a full proof.  Our focus here is on the use of the
    tools together; see the <a href="sterling/tutorial.html">Sterling
    tutorial</a> for a tutorial on developing Sterling specifications
    and the <a href="extensibella/walkthrough.html">Extensibella
    walkthrough</a> for a walkthrough of reasoning steps for proving
    properties in a much simpler language.
  </p>

  <p>
    Our language here is the example language from our
    paper <a href="https://arxiv.org/abs/2312.14374">"A Modular
    Approach to Metatheoretic Reasoning for Extensible Languages"</a>.
    The specifications and proofs can be downloaded as
    a <a href="extensibella/examples/library/library.tar.gz">tarball</a>.
  </p>
</div>

<div class="section">
  <h2>Preparing the Sterling Standard Library for Reasoning</h2>
  <p>
    Sterling contains a standard library with useful relations defined
    for use in writing language specifications, which is included in
    Sterling modules automatically.  It has an accompanying
    Extensibella module with properties about these relations.  To
    prepare for reasoning about modules, go to the Sterling standard
    library directory (<code>sterling/stdLib</code>) and run
    <pre class="code">
./build_extensibella</pre>
    This only needs to be done once to reason about all languages.  It
    should be done again each time Sterling is updated in case the
    standard library has expanded.
  </p>
</div>

<div class="section">
  <h2>Host Language</h2>
  <p>
    We start by writing the host language of our language library.
  </p>

  <h3>Sterling Language Specification</h3>
  <p>
    We start by writing a specification of our host language in
    Sterling.  This will be
    the <code class="sterling">library:host</code> module.  It defines
    syntax categories and constructors for statements, expressions,
    and types:
  </p>
  <span class="highlight">syntax.sos</span>
  <a class="fold-link" href="javascript:void" id="togglehost/syntax.sos"
     onclick="toggleFile('host/syntax.sos')">[Expand File]</a>
  <pre class="code sterling" id="host/syntax.sos" style="height: 105px;">
Module library:host

s ::= skipS <span class="comment">/*just "skip" is a bad idea for Extensibella*/</span>
    | decl(string, ty, e)
    | assign(string, e)
    | seq(s, s)
    | ifte(e, s, s)
    | while(e, s)

e ::= var(string)
    | intlit(int)
    | trueE | falseE <span class="comment">/*just "true" and "false" are bad for Extensibella*/</span>
    | add(e, e)
    | eq(e, e)
    | gt(e, e)
    | not(e)

ty ::= intTy <span class="comment">/*just "int" is built-in*/</span>
     | bool

Translation s :
Translation e :
Translation ty :</pre>

  <p>
    We also define the language semantics by declaring relations
    (<code class="sterling">Judgment</code>s in Sterling) and defining
    them via rules.  For our host language we will defining typing
    judgments for statements and expressions, as well as a relation
    defining the set of variables in an expression.  For statement
    typing and evaluation, the relations relate the context before the
    statement, the statement itself, and the context after the
    statement.
  </p>
  <span class="highlight">vars.sos</span>
  <a class="fold-link" href="javascript:void" id="togglehost/vars.sos"
     onclick="toggleFile('host/vars.sos')">[Expand File]</a>
  <pre class="code sterling" id="host/vars.sos" style="max-height: 105px;">
Module library:host

<span class="comment">/*We don't have a built-in set type, so we use a list instead*/</span>
Judgment vars: e* [string]

--------------- [VR-var]
vars var(N) [N]


----------------- [VR-intlit]
vars intlit(I) []


------------- [VR-true]
vars trueE []


-------------- [VR-false]
vars falseE []


vars E1 Vr1
vars E2 Vr2
Vr1 ++ Vr2 = V
------------------ [VR-add]
vars add(E1, E2) V


vars E1 Vr1
vars E2 Vr2
Vr1 ++ Vr2 = V
----------------- [VR-eq]
vars eq(E1, E2) V


vars E1 Vr1
vars E2 Vr2
Vr1 ++ Vr2 = V
----------------- [VR-gt]
vars gt(E1, E2) V


vars E Vr
-------------- [VR-not]
vars not(E) Vr</pre>

  <span class="highlight">typing.sos</span>
  <a class="fold-link" href="javascript:void" id="togglehost/typing.sos"
     onclick="toggleFile('host/typing.sos')">[Expand File]</a>
  <pre class="code sterling" id="host/typing.sos" style="max-height: 105px;">
Module library:host

<span class="comment">/*We use the standard library's lookup and no_lookup relations rather
  than writing our own here.*/</span>

<span class="comment">/*Gamma |- e* : ty*/</span>
Judgment ty_e : [(string, ty)] e* ty
<span class="comment">/*Gamma |- s* -| Gamma*/</span>
Judgment ty_s : [(string, ty)] s* [(string, ty)]

lookup G N Ty
---------------- [T-var]
ty_e G var(N) Ty


---------------------- [T-intlit]
ty_e G intlit(I) intTy


----------------- [T-true]
ty_e G trueE bool


------------------ [T-false]
ty_e G falseE bool


ty_e G E1 intTy
ty_e G E2 intTy
------------------------ [T-add]
ty_e G add(E1, E2) intTy


ty_e G E1 intTy
ty_e G E2 intTy
---------------------- [T-eq]
ty_e G eq(E1, E2) bool


ty_e G E1 intTy
ty_e G E2 intTy
---------------------- [T-gt]
ty_e G gt(E1, E2) bool


ty_e G E bool
------------------ [T-not]
ty_e G not(E) bool





-------------- [TS-skip]
ty_s G skipS G


ty_s G S1 G1
ty_s G1 S2 G2
--------------------- [TS-seq]
ty_s G seq(S1, S2) G2


ty_e G E Ty
no_lookup G N
-------------------------------- [TS-decl]
ty_s G decl(N, Ty, E) (N, Ty)::G


ty_e G E Ty
lookup G N Ty
--------------------- [TS-assign]
ty_s G assign(N, E) G


ty_e G E bool
ty_s G S1 G1
ty_s G S2 G2
------------------------ [TS-ifte]
ty_s G ifte(E, S1, S2) G


ty_e G E bool
ty_s G S G1
-------------------- [TS-while]
ty_s G while(E, S) G</pre>

  <span class="highlight">eval.sos</span>
  <a class="fold-link" href="javascript:void" id="togglehost/eval.sos"
     onclick="toggleFile('host/eval.sos')">[Expand File]</a>
  <pre class="code sterling" id="host/eval.sos" style="max-height: 105px;">
Module library:host

Judgment value: e*

--------------- [V-Int]
value intlit(I)


----------- [V-True]
value trueE


------------ [V-False]
value falseE

<span class="comment">/*We use the standard library's lookup and select relations rather
  than writing our own here.*/</span>

<span class="comment">/*gamma |- e* \Downarrow e*/</span>
Judgment eval_e : [(string, e)] e* e
<span class="comment">/*gamma |- s* -| gamma*/</span>
Judgment eval_s : [(string, e)] s* [(string, e)]

lookup G N V
----------------- [E-var]
eval_e G var(N) V


---------------------------- [E-intlit]
eval_e G intlit(I) intlit(I)


-------------------- [E-true]
eval_e G trueE trueE


---------------------- [E-false]
eval_e G falseE falseE


eval_e G E1 intlit(I1)
eval_e G E2 intlit(I2)
I1 + I2 = I
------------------------------ [E-add]
eval_e G add(E1, E2) intlit(I)


eval_e G E1 V1
eval_e G E2 V2
V1 = V2
------------------------- [E-eq-True]
eval_e G eq(E1, E2) trueE


eval_e G E1 V1
eval_e G E2 V2
V1 != V2
-------------------------- [E-eq-False]
eval_e G eq(E1, E2) falseE


eval_e G E1 intlit(I1)
eval_e G E2 intlit(I2)
I1 > I2
------------------------- [E-gt-True]
eval_e G gt(E1, E2) trueE


eval_e G E1 intlit(I1)
eval_e G E2 intlit(I2)
I1 <= I2
-------------------------- [E-gt-False]
eval_e G gt(E1, E2) falseE


eval_e G E falseE
--------------------- [E-not-True]
eval_e G not(E) trueE


eval_e G E trueE
---------------------- [E-not-False]
eval_e G not(E) falseE





---------------- [X-skip]
eval_s G skipS G


eval_e G E V
--------------------------------- [X-decl]
eval_s G decl(N, Ty, E) (N, V)::G


eval_e G E V
select (N, VOld) NewG G
---------------------------------- [X-assign]
eval_s G assign(N, E) (N, V)::NewG


eval_s G S1 G1
eval_s G1 S2 G2
----------------------- [X-seq]
eval_s G seq(S1, S2) G2


eval_e G E trueE
eval_s G S1 G1
--------------------------- [X-ifte-True]
eval_s G ifte(E, S1, S2) G1


eval_e G E falseE
eval_s G S2 G1
--------------------------- [X-ifte-False]
eval_s G ifte(E, S1, S2) G1


eval_e G E trueE
eval_s G S G1
eval_s G1 while(E, S) G2
------------------------ [X-while-True]
eval_s G while(E, S) G2


eval_e G E falseE
---------------------- [X-while-False]
eval_s G while(E, S) G</pre>

  <p>
    Once we have the specification written, we can check it for errors
    and compile it for Extensibella.  The specification files must be
    in a <code>library/host</code> directory.  To run Sterling from
    the directory containing the <code>library</code> directory, run
    <pre class="code">
sterling --extensibella library:host</pre>
    This will compile a modular specification for Extensibella
    reasoning.
  </p>


  <h3>Extensibella Reasoning</h3>
  <p>
    We can now introduce and prove properties about our host language.
    We will create a file named <code>host.xthm</code> and declare our
    properties in it, in the order we want to prove them.  The order
    determines which properties may be used as lemmas for proving
    other properties occurring later in the order.  We prove the
    properties as we declare them.
  </p>

  <p>
    The best way to write Extensibella proofs
    is <a href="extensibella/referenceGuide.html#emacs">using Proof
      General</a>, in which the proof file is built in Emacs and the
    commands in it are run directly in Emacs.  The other choice is to
    run Extensibella in the terminal and type in commands directly.
    To do this, run Extensibella without arguments:
    <pre class="code">
extensibella</pre>
    Note this does not save the interaction; the commands must be
    copied to a file separately to save them.
  </p>

  <span class="highlight">host.xthm</span>
  <a class="fold-link" href="javascript:void" id="togglehost.xthm"
     onclick="toggleFile('host.xthm')">[Expand File]</a>
  <pre class="code extensibella" id="host.xthm" style="max-height: 105px;">
Module library:host.

Translation_Constraint trans_e_unique : forall E E1 E2,
  |{e}- E ~~> E1 -> |{e}- E ~~> E2 -> E1 = E2.
Translation_Constraint trans_e_is : forall E E',
  |{e}- E ~~> E' -> is_e E -> is_e E'.

Translation_Constraint trans_s_unique : forall S S1 S2,
  |{s}- S ~~> S1 -> |{s}- S ~~> S2 -> S1 = S2.
Translation_Constraint trans_s_is : forall S S',
  |{s}- S ~~> S' -> is_s S -> is_s S'.

Translation_Constraint trans_ty_unique : forall Ty Ty1 Ty2,
  |{ty}- Ty ~~> Ty1 -> |{ty}- Ty ~~> Ty2 -> Ty1 = Ty2.
Translation_Constraint trans_ty_is : forall Ty Ty',
  |{ty}- Ty ~~> Ty' -> is_ty Ty -> is_ty Ty'.


Ext_Ind is_e E with |{e}- E ~~> T.


Extensible_Theorem
  is_e_var_or_not : forall E,
    IsE: is_e E ->
    (exists N, E = var N) \/ ((exists N, E = var N) -> false)
  on IsE.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(1);" id="toggleproof1">[Show Proof]</a>
<div class="proof" id="proof1" style="display: none;">
search. search. search. search. search. search. search. search.</div>
Extensible_Theorem
  is_e_intlit_or_not : forall E,
    IsE: is_e E ->
    (exists I, E = intlit I) \/ ((exists I, E = intlit I) -> false)
  on IsE.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(2);" id="toggleproof2">[Show Proof]</a>
<div class="proof" id="proof2" style="display: none;">
search. search. search. search. search. search. search. search.</div>
Extensible_Theorem
  is_e_trueE_or_not : forall E,
    IsE: is_e E ->
    E = trueE \/ (E = trueE -> false)
  on IsE.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(3);" id="toggleproof3">[Show Proof]</a>
<div class="proof" id="proof3" style="display: none;">
search. search. search. search. search. search. search. search.</div>
Extensible_Theorem
  is_e_falseE_or_not : forall E,
    IsE: is_e E ->
    E = falseE \/ (E = falseE -> false)
  on IsE.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(4);" id="toggleproof4">[Show Proof]</a>
<div class="proof" id="proof4" style="display: none;">
search. search. search. search. search. search. search. search.</div>
Extensible_Theorem
  is_e_add_or_not : forall E,
    IsE: is_e E ->
    (exists E1 E2, E = add E1 E2) \/
    ((exists E1 E2, E = add E1 E2) -> false)
  on IsE.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(5);" id="toggleproof5">[Show Proof]</a>
<div class="proof" id="proof5" style="display: none;">
search. search. search. search. search. search. search. search.</div>
Extensible_Theorem
  is_e_eqC_or_not : forall E,
    IsE: is_e E ->
    (exists E1 E2, E = eq E1 E2) \/
    ((exists E1 E2, E = eq E1 E2) -> false)
  on IsE.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(6);" id="toggleproof6">[Show Proof]</a>
<div class="proof" id="proof6" style="display: none;">
search. search. search. search. search. search. search. search.</div>
Extensible_Theorem
  is_e_gt_or_not : forall E,
    IsE: is_e E ->
    (exists E1 E2, E = gt E1 E2) \/
    ((exists E1 E2, E = gt E1 E2) -> false)
  on IsE.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(7);" id="toggleproof7">[Show Proof]</a>
<div class="proof" id="proof7" style="display: none;">
search. search. search. search. search. search. search. search.</div>
Extensible_Theorem
  is_e_not_or_not : forall E,
    IsE: is_e E ->
    (exists E', E = not E') \/
    ((exists E', E = not E') -> false)
  on IsE.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(8);" id="toggleproof8">[Show Proof]</a>
<div class="proof" id="proof8" style="display: none;">
search. search. search. search. search. search. search. search.</div>
Extensible_Theorem
  is_e_eq_or_not : forall E1 E2,
    IsE1: is_e E1 ->
    IsE2: is_e E2 ->
    E1 = E2 \/ (E1 = E2 -> false)
  on IsE1.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(9);" id="toggleproof9">[Show Proof]</a>
<div class="proof" id="proof9" style="display: none;">
<span class="comment">%var</span>
 Or: apply is_e_var_or_not to IsE2. E: case Or.
   <span class="comment">%var</span>
    Is: case IsE2. Or: apply is_string_eq_or_not to IsE3 Is.
    E: case Or.
      <span class="comment">%S = N</span>
       search.
      <span class="comment">%S != N</span>
       right. intros Eq. case Eq. backchain E.
   <span class="comment">%not var</span>
    right. intros Eq. backchain E. case Eq. search.
<span class="comment">%intlit</span>
 Or: apply is_e_intlit_or_not to IsE2. E: case Or.
   <span class="comment">%var</span>
    Is: case IsE2. Or: apply is_integer_eq_or_not to IsE3 Is.
    E: case Or.
      <span class="comment">%S = N</span>
       search.
      <span class="comment">%S != N</span>
       right. intros Eq. case Eq. backchain E.
   <span class="comment">%not var</span>
    right. intros Eq. backchain E. case Eq. search.
<span class="comment">%trueE</span>
 Or: apply is_e_trueE_or_not to IsE2. E: case Or.
   <span class="comment">%E2 = trueE</span>
    search.
   <span class="comment">%E2 != trueE</span>
    right. intros Eq. case Eq. backchain E.
<span class="comment">%falseE</span>
 Or: apply is_e_falseE_or_not to IsE2. E: case Or.
   <span class="comment">%E2 = falseE</span>
    search.
   <span class="comment">%E2 != falseE</span>
    right. intros Eq. case Eq. backchain E.
<span class="comment">%add</span>
 Or: apply is_e_add_or_not to IsE2. E: case Or.
   <span class="comment">%add</span>
    Is: case IsE2. Or: apply IH to IsE3 Is. E: case Or.
      <span class="comment">%E3 = E4</span>
       Or: apply IH to IsE4 Is1. E: case Or.
         <span class="comment">%E = E5</span>
          search.
         <span class="comment">%E != E5</span>
          right. intros Eq. case Eq. backchain E.
      <span class="comment">%E3 != E4</span>
       right. intros Eq. case Eq. backchain E.
   <span class="comment">%not add</span>
    right. intros Eq. backchain E. case Eq. search.
<span class="comment">%eq</span>
 Or: apply is_e_eqC_or_not to IsE2. E: case Or.
   <span class="comment">%add</span>
    Is: case IsE2. Or: apply IH to IsE3 Is. E: case Or.
      <span class="comment">%E3 = E4</span>
       Or: apply IH to IsE4 Is1. E: case Or.
         <span class="comment">%E = E5</span>
          search.
         <span class="comment">%E != E5</span>
          right. intros Eq. case Eq. backchain E.
      <span class="comment">%E3 != E4</span>
       right. intros Eq. case Eq. backchain E.
   <span class="comment">%not add</span>
    right. intros Eq. backchain E. case Eq. search.
<span class="comment">%gt</span>
 Or: apply is_e_gt_or_not to IsE2. E: case Or.
   <span class="comment">%add</span>
    Is: case IsE2. Or: apply IH to IsE3 Is. E: case Or.
      <span class="comment">%E3 = E4</span>
       Or: apply IH to IsE4 Is1. E: case Or.
         <span class="comment">%E = E5</span>
          search.
         <span class="comment">%E != E5</span>
          right. intros Eq. case Eq. backchain E.
      <span class="comment">%E3 != E4</span>
       right. intros Eq. case Eq. backchain E.
   <span class="comment">%not add</span>
    right. intros Eq. backchain E. case Eq. search.
<span class="comment">%not</span>
 Or: apply is_e_not_or_not to IsE2. E: case Or.
   <span class="comment">%not</span>
    Is: case IsE2. Or: apply IH to IsE3 Is. E: case Or.
      <span class="comment">%E = E'</span>
       search.
      <span class="comment">%E != E'</span>
       right. intros Eq. case Eq. backchain E.
   <span class="comment">%not not</span>
    right. intros Eq. backchain E. case Eq. search.</div>


Extensible_Theorem
  vars_unique : forall E V1 V2,
    Vars1 : vars E V1 ->
    Vars2 : vars E V2 ->
    V1 = V2
  on Vars1.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(10);" id="toggleproof10">[Show Proof]</a>
<div class="proof" id="proof10" style="display: none;">
<span class="comment">%VR-var</span>
 case Vars2. search.
<span class="comment">%VR-intlit</span>
 case Vars2. search.
<span class="comment">%VR-true</span>
 case Vars2. search.
<span class="comment">%VR-false</span>
 case Vars2. search.
<span class="comment">%VR-add</span>
 V: case Vars2. apply IH to Vars3 V. apply IH to Vars4 V1.
 apply append_unique to Vars5 V2. search.
<span class="comment">%VR-eq</span>
 V: case Vars2. apply IH to Vars3 V. apply IH to Vars4 V1.
 apply append_unique to Vars5 V2. search.
<span class="comment">%VR-gt</span>
 V: case Vars2. apply IH to Vars3 V. apply IH to Vars4 V1.
 apply append_unique to Vars5 V2. search.
<span class="comment">%VR-not</span>
 V: case Vars2. apply IH to Vars3 V. search.</div>


Translation_Constraint trans_e_vars_exist : forall E E' V,
  |{e}- E ~~> E' -> vars E V -> exists V', vars E' V'.

<span class="comment">%Rationale for TC:
%Evaluation depends on the variables in an expression.  In fact, by
%the property vars_eval_same_result below, evaluation is determined
%*entirely* by the variables in an expression.  Therefore making the
%variables in an expression be a subset of those in its translation
%gives other extensions a handle on understanding the behavior of an
%unknown expression in particular contexts.</span>
Translation_Constraint trans_e_vars : forall E E' V V' X,
  |{e}- E ~~> E' -> vars E V -> vars E' V' ->
  mem X V -> mem X V'.


Theorem append__is_list__is_string : forall L1 L2 L,
  is_list is_string L1 -> is_list is_string L2 -> L1 ++ L2 = L ->
  is_list is_string L.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(11);" id="toggleproof11">[Show Proof]</a>
<div class="proof" id="proof11" style="display: none;">
induction on 1. intros IsL1 IsL2 App. IsL1': case IsL1.
  <span class="comment">%1:  is_list []</span>
   case App. search.
  <span class="comment">%2:  is_list (H::T)</span>
   App: case App. apply IH to IsL1'1 _ _. search.</div>

Extensible_Theorem
  vars_is : forall E V,
    IsE : is_e E ->
    Vars : vars E V ->
    is_list is_string V
  on Vars.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(12);" id="toggleproof12">[Show Proof]</a>
<div class="proof" id="proof12" style="display: none;">
<span class="comment">%VR-var</span>
 case IsE. search.
<span class="comment">%VR-intlit</span>
 search.
<span class="comment">%VR-true</span>
 search.
<span class="comment">%VR-false</span>
 search.
<span class="comment">%VR-add</span>
 Is: case IsE. IsA: apply IH to _ Vars1. IsB: apply IH to _ Vars2.
 apply append__is_list__is_string to _ _ Vars3. search.
<span class="comment">%VR-eq</span>
 Is: case IsE. IsA: apply IH to _ Vars1. IsB: apply IH to _ Vars2.
 apply append__is_list__is_string to _ _ Vars3. search.
<span class="comment">%VR-gt</span>
 Is: case IsE. IsA: apply IH to _ Vars1. IsB: apply IH to _ Vars2.
 apply append__is_list__is_string to _ _ Vars3. search.
<span class="comment">%VR-not</span>
 case IsE. apply IH to _ Vars1. search.</div>


Theorem append__is_list__is_string__total : forall L1 L2,
  is_list is_string L1 -> is_list is_string L2 ->
  exists L, L1 ++ L2 = L.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(13);" id="toggleproof13">[Show Proof]</a>
<div class="proof" id="proof13" style="display: none;">
induction on 1. intros IsL1 IsL2. IsL1': case IsL1.
  <span class="comment">%1: L1 = []</span>
   search.
  <span class="comment">%2: L1 = H::T</span>
   apply IH to IsL1'1 _. search.</div>

Extensible_Theorem
  vars_exist : forall E,
    IsE : is_e E ->
    exists V, vars E V
  on IsE.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(14);" id="toggleproof14">[Show Proof]</a>
<div class="proof" id="proof14" style="display: none;">
<span class="comment">%var</span>
 search.
<span class="comment">%intlit</span>
 search.
<span class="comment">%trueE</span>
 search.
<span class="comment">%falseE</span>
 search.
<span class="comment">%add</span>
 V1: apply IH to IsE1. V2: apply IH to IsE2.
 Is1: apply vars_is to _ V1. Is2: apply vars_is to _ V2.
 apply append__is_list__is_string__total to Is1 Is2. search.
<span class="comment">%eq</span>
 V1: apply IH to IsE1. V2: apply IH to IsE2.
 Is1: apply vars_is to _ V1. Is2: apply vars_is to _ V2.
 apply append__is_list__is_string__total to Is1 Is2. search.
<span class="comment">%gt</span>
 V1: apply IH to IsE1. V2: apply IH to IsE2.
 Is1: apply vars_is to _ V1. Is2: apply vars_is to _ V2.
 apply append__is_list__is_string__total to Is1 Is2. search.
<span class="comment">%not</span>
 apply IH to IsE1. search.</div>


Extensible_Theorem
  value_empty_typable : forall V G Ty,
    Value: value V ->
    Ty: ty_e G V Ty ->
    ty_e [] V Ty
  on Value.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(15);" id="toggleproof15">[Show Proof]</a>
<div class="proof" id="proof15" style="display: none;">
<span class="comment">%V-Int</span>
 case Ty. search.
<span class="comment">%V-True</span>
 case Ty. search.
<span class="comment">%V-False</span>
 case Ty. search.</div>


Theorem lookup_is : forall G X V,
  is_list (is_pair is_string is_e) G -> lookup G X V -> is_e V.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(16);" id="toggleproof16">[Show Proof]</a>
<div class="proof" id="proof16" style="display: none;">
induction on 2. intros Is L. L: case L.
  <span class="comment">%Lkp-Here</span>
   Is: case Is. case Is. search.
  <span class="comment">%Lkp-Later</span>
   case Is. apply IH to _ L1. search.</div>


Extensible_Theorem
  eval_e_is : forall G E V,
    IsE : is_e E ->
    IsCtx : is_list (is_pair is_string is_e) G ->
    Ev : eval_e G E V ->
    is_e V
  on Ev.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(17);" id="toggleproof17">[Show Proof]</a>
<div class="proof" id="proof17" style="display: none;">
<span class="comment">%E-var</span>
 apply lookup_is to _ Ev1. search.
<span class="comment">%E-intlit</span>
 search.
<span class="comment">%E-true</span>
 search.
<span class="comment">%E-false</span>
 search.
<span class="comment">%E-add</span>
 case IsE. Is1: apply IH to _ _ Ev1. Is2: apply IH to _ _ Ev2.
 case Is1. case Is2. apply plus_integer_is_integer to _ _ Ev3. search.
<span class="comment">%E-eq-True</span>
 search.
<span class="comment">%E-eq-False</span>
 search.
<span class="comment">%E-gt-True</span>
 search.
<span class="comment">%E-gt-False</span>
 search.
<span class="comment">%E-not-True</span>
 search.
<span class="comment">%E-not-False</span>
 search.</div>


Extensible_Theorem
  type_preservation_e : forall TG EG E Ty V,
    Ty: ty_e TG E Ty ->
    Ev: eval_e EG E V ->
    Rel: (forall X Ty V,
             lookup TG X Ty -> lookup EG X V -> ty_e [] V Ty) ->
    ty_e [] V Ty
  on Ev.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(18);" id="toggleproof18">[Show Proof]</a>
<div class="proof" id="proof18" style="display: none;">
<span class="comment">%E-var</span>
 Ty: case Ty. apply Rel to Ty Ev1. search.
<span class="comment">%E-intlit</span>
 case Ty. search.
<span class="comment">%E-true</span>
 case Ty. search.
<span class="comment">%E-false</span>
 case Ty. search.
<span class="comment">%E-add</span>
 case Ty. search.
<span class="comment">%E-eq-True</span>
 case Ty. search.
<span class="comment">%E-eq-False</span>
 case Ty. search.
<span class="comment">%E-gt-True</span>
 case Ty. search.
<span class="comment">%E-gt-False</span>
 case Ty. search.
<span class="comment">%E-not-True</span>
 case Ty. search.
<span class="comment">%E-not-False</span>
 case Ty. search.</div>


<span class="comment">%lemma for type_preservation_s</span>
Extensible_Theorem
  var_types_maintained : forall G S G' X Ty,
    Ty: ty_s G S G' ->
    Lkp: lookup G X Ty ->
    lookup G' X Ty
  on Ty.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(19);" id="toggleproof19">[Show Proof]</a>
<div class="proof" id="proof19" style="display: none;">
<span class="comment">%TS-skip</span>
 search.
<span class="comment">%TS-seq</span>
 Lkp': apply IH to Ty1 Lkp. apply IH to Ty2 Lkp'. search.
<span class="comment">%TS-decl</span>
 NEq: assert N = X -> false.
   intros E. case E. apply no_lookup to Ty2 Lkp.
 search.
<span class="comment">%TS-assign</span>
 search.
<span class="comment">%TS-ifte</span>
 search.
<span class="comment">%TS-while</span>
 search.</div>


Extensible_Theorem
  type_preservation_s : forall TG EG S TG' EG' X Ty V,
    Ty: ty_s TG S TG' ->
    Ev: eval_s EG S EG' ->
    Rel: (forall X Ty V,
             lookup TG X Ty -> lookup EG X V -> ty_e [] V Ty) ->
    LkpTy: lookup TG' X Ty ->
    LkpV: lookup EG' X V ->
    ty_e [] V Ty
  on Ev.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(20);" id="toggleproof20">[Show Proof]</a>
<div class="proof" id="proof20" style="display: none;">
<span class="comment">%X-skip</span>
 case Ty. backchain Rel.
<span class="comment">%X-decl</span>
 Ty: case Ty. TE: apply type_preservation_e to Ty Ev1 Rel.
 LT: case LkpTy.
   <span class="comment">%Lkp-Here</span>
    LV: case LkpV.
      <span class="comment">%Lkp-Here</span>
       search.
      <span class="comment">%Lkp-Later</span>
       apply LV to _.
   <span class="comment">%Lkp-Later</span>
    LV: case LkpV.
      <span class="comment">%Lkp-Here</span>
       apply LT to _.
      <span class="comment">%Lkp-Later</span>
       backchain Rel.
<span class="comment">%X-assign</span>
 Ty: case Ty. TE: apply type_preservation_e to Ty Ev1 Rel.
 LV: case LkpV.
   <span class="comment">%Lkp-Here</span>
    apply lookup_unique to Ty1 LkpTy. search.
   <span class="comment">%Lkp-Later</span>
    assert X = N -> false. intros E. case E. backchain LV.
    apply lookup_after_select_before to LV1 Ev2 _.
    apply Rel to LkpTy _. search.
<span class="comment">%X-seq</span>
 Ty: case Ty.
 Rel': assert forall X1 Ty1 V1,
                lookup G2 X1 Ty1 -> lookup G1 X1 V1 -> ty_e [] V1 Ty1.
   intros LT LV. apply IH to Ty Ev1 Rel LT LV. search.
 apply IH to Ty1 Ev2 Rel' LkpTy LkpV. search.
<span class="comment">%X-ifte-True</span>
 Ty: case Ty. L: apply var_types_maintained to Ty1 LkpTy.
 apply IH to Ty1 Ev2 Rel L LkpV. search.
<span class="comment">%X-ifte-False</span>
 Ty: case Ty. L: apply var_types_maintained to Ty2 LkpTy.
 apply IH to Ty2 Ev2 Rel L LkpV. search.
<span class="comment">%X-while-True</span>
 Ty: case Ty (keep).
 Rel': assert forall X1 Ty1 V1,
               lookup TG' X1 Ty1 -> lookup G1 X1 V1 -> ty_e [] V1 Ty1.
   intros LT LV. L: apply var_types_maintained to Ty2 LT.
   apply IH to Ty2 Ev2 Rel L LV. search.
 apply IH to Ty Ev3 Rel' LkpTy LkpV. search.
<span class="comment">%X-while-False</span>
 Ty: case Ty. backchain Rel.</div>


Translation_Constraint trans_eval_e : forall G E E' V,
  |{e}- E ~~> E' -> eval_e G E V ->
  is_list (is_pair is_string is_e) G -> is_e E ->
  exists V', eval_e G E' V'.


Extensible_Theorem
  eval_e_unique : forall G E V1 V2,
    Ev1: eval_e G E V1 ->
    Ev2: eval_e G E V2 ->
    V1 = V2
  on Ev1.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(21);" id="toggleproof21">[Show Proof]</a>
<div class="proof" id="proof21" style="display: none;">
<span class="comment">%E-var</span>
 Ev2: case Ev2. apply lookup_unique to Ev3 Ev2. search.
<span class="comment">%E-intlit</span>
 case Ev2. search.
<span class="comment">%E-true</span>
 case Ev2. search.
<span class="comment">%E-false</span>
 case Ev2. search.
<span class="comment">%E-add</span>
 Ev2: case Ev2. apply IH to Ev3 Ev2. apply IH to Ev4 Ev6.
 apply plus_integer_unique to Ev5 Ev7. search.
<span class="comment">%E-eq-True</span>
 Ev2: case Ev2.
   <span class="comment">%E-eq-True</span>
    search.
   <span class="comment">%E-eq-False</span>
    apply IH to Ev3 Ev2. apply IH to Ev4 Ev5. apply Ev6 to _.
<span class="comment">%E-eq-False</span>
 Ev2: case Ev2.
   <span class="comment">%E-eq-True</span>
    apply IH to Ev3 Ev2. apply IH to Ev4 Ev6. apply Ev5 to _.
   <span class="comment">%E-eq-False</span>
    search.
<span class="comment">%E-gt-True</span>
 Ev2: case Ev2.
   <span class="comment">%E-gt-True</span>
    search.
   <span class="comment">%E-gt-False</span>
    apply IH to Ev3 Ev2. apply IH to Ev4 Ev6.
    apply greater_lesseq_integer_false to Ev5 Ev7.
<span class="comment">%E-gt-False</span>
 Ev2: case Ev2.
   <span class="comment">%E-gt-True</span>
    apply IH to Ev3 Ev2. apply IH to Ev4 Ev6.
    apply greater_lesseq_integer_false to Ev7 Ev5.
   <span class="comment">%E-gt-False</span>
    search.
<span class="comment">%E-not-True</span>
 Ev2: case Ev2.
   <span class="comment">%E-not-True</span>
    search.
   <span class="comment">%E-not-False</span>
    apply IH to Ev3 Ev2.
<span class="comment">%E-not-False</span>
 Ev2: case Ev2.
   <span class="comment">%E-not-True</span>
    apply IH to Ev3 Ev2.
   <span class="comment">%E-not-False</span>
    search.</div>


Translation_Constraint trans_s_eval : forall S S' G G2,
  |{s}- S ~~> S' -> eval_s G S G2 -> exists G', eval_s G S' G'.


Ext_Ind eval_s G S G1 with |{s}- S ~~> T.


Translation_Constraint trans_s_eval_results :
  forall S S' G G1 G2 X V,
    |{s}- S ~~> S' -> eval_s G S G1 -> eval_s G S' G2 ->
    lookup G1 X V -> lookup G2 X V.
Translation_Constraint trans_s_eval_results_back :
  forall S S' G G1 G2 X V,
    |{s}- S ~~> S' -> eval_s G S G1 -> eval_s G S' G2 ->
    lookup G2 X V -> lookup G1 X V.


Extensible_Theorem
  eval_e_value : forall G E V,
    Ev: eval_e G E V ->
    AllVal: (forall X XV, mem (X, XV) G -> value XV) ->
    value V
  on Ev.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(22);" id="toggleproof22">[Show Proof]</a>
<div class="proof" id="proof22" style="display: none;">
<span class="comment">%E-var</span>
 M: apply lookup_mem to Ev1. apply AllVal to M. search.
<span class="comment">%E-intlit</span>
 search.
<span class="comment">%E-true</span>
 search.
<span class="comment">%E-false</span>
 search.
<span class="comment">%E-add</span>
 search.
<span class="comment">%E-eq-True</span>
 search.
<span class="comment">%E-eq-False</span>
 search.
<span class="comment">%E-gt-True</span>
 search.
<span class="comment">%E-gt-False</span>
 search.
<span class="comment">%E-not-True</span>
 search.
<span class="comment">%E-not-False</span>
 search.</div>


Extensible_Theorem
  eval_s_value : forall G S G' Y YV,
    Ev: eval_s G S G' ->
    AllVal: (forall X XV, mem (X, XV) G -> value XV) ->
    Mem: mem (Y, YV) G' ->
    value YV
  on Ev.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(23);" id="toggleproof23">[Show Proof]</a>
<div class="proof" id="proof23" style="display: none;">
<span class="comment">%X-skip</span>
 backchain AllVal.
<span class="comment">%X-decl</span>
 V: apply eval_e_value to Ev1 AllVal. M: case Mem.
   <span class="comment">%Mem-Here</span>
    search.
   <span class="comment">%Mem-Later</span>
    backchain AllVal.
<span class="comment">%X-assign</span>
 V: apply eval_e_value to Ev1 AllVal. M: case Mem.
   <span class="comment">%Mem-Here</span>
    search.
   <span class="comment">%Mem-Later</span>
    M': apply mem_after_select_before to Ev2 M. backchain AllVal.
<span class="comment">%X-seq</span>
 AllVal': assert forall X XV, mem (X, XV) G3 -> value XV.
   intros M. apply IH to Ev1 AllVal M. search.
 apply IH to Ev2 AllVal' Mem. search.
<span class="comment">%X-ifte-True</span>
 apply IH to Ev2 AllVal Mem. search.
<span class="comment">%X-ifte-False</span>
 apply IH to Ev2 AllVal Mem. search.
<span class="comment">%X-while-True</span>
 AllVal': assert forall X XV, mem (X, XV) G3 -> value XV.
   intros M. apply IH to Ev2 AllVal M. search.
 apply IH to Ev3 AllVal' Mem. search.
<span class="comment">%X-while-False</span>
 backchain AllVal.</div>


<span class="comment">%helpers for vars_eval_same_result</span>
Theorem vars_equiv_left :
  forall (G1 : list (pair string e)) G2 D D1 D2,
    (forall X U1 U2, mem X D -> lookup G1 X U1 ->
                     lookup G2 X U2 -> U1 = U2) ->
    D1 ++ D2 = D ->
    (forall X U1 U2, mem X D1 -> lookup G1 X U1 ->
                     lookup G2 X U2 -> U1 = U2).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(24);" id="toggleproof24">[Show Proof]</a>
<div class="proof" id="proof24" style="display: none;">
intros Equiv J Mem Lkp1 Lkp2. backchain Equiv with X = X.
backchain mem_append_left.</div>
Theorem vars_equiv_right :
  forall (G1 : list (pair string e)) G2 D D1 D2,
    (forall X U1 U2, mem X D -> lookup G1 X U1 ->
                     lookup G2 X U2 -> U1 = U2) ->
    D1 ++ D2 = D ->
    (forall X U1 U2, mem X D2 -> lookup G1 X U1 ->
                     lookup G2 X U2 -> U1 = U2).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(25);" id="toggleproof25">[Show Proof]</a>
<div class="proof" id="proof25" style="display: none;">
intros Equiv J Mem Lkp1 Lkp2. backchain Equiv with X = X.
backchain mem_append_right.</div>


Extensible_Theorem
  vars_eval_same_result : forall G1 G2 E D V1 V2,
    Equiv : (forall X U1 U2,
                mem X D ->
                lookup G1 X U1 ->
                lookup G2 X U2 -> U1 = U2) ->
    Vars : vars E D ->
    Ev1 : eval_e G1 E V1 ->
    Ev2 : eval_e G2 E V2 ->
    V1 = V2
  on Ev1.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(26);" id="toggleproof26">[Show Proof]</a>
<div class="proof" id="proof26" style="display: none;">
<span class="comment">%E-var</span>
 Ev2: case Ev2. case Vars. apply Equiv to _ Ev3 Ev2. search.
<span class="comment">%E-intlit</span>
 case Ev2. search.
<span class="comment">%E-true</span>
 case Ev2. search.
<span class="comment">%E-false</span>
 case Ev2. search.
<span class="comment">%E-add</span>
 Ev2: case Ev2. Vars: case Vars.
 apply IH to _ Vars Ev3 Ev2. backchain vars_equiv_left.
 apply IH to _ Vars1 Ev4 Ev6. backchain vars_equiv_right.
 apply plus_integer_unique to Ev5 Ev7. search.
<span class="comment">%E-eq-True</span>
 Ev2: case Ev2.
   <span class="comment">%E-eq-True</span>
    search.
   <span class="comment">%E-eq-False</span>
    Vars: case Vars.
    apply IH to _ Vars Ev3 Ev2. backchain vars_equiv_left.
    apply IH to _ Vars1 Ev4 Ev5. backchain vars_equiv_right.
    apply Ev6 to _.
<span class="comment">%E-eq-False</span>
 Ev2: case Ev2.
   <span class="comment">%E-eq-True</span>
    Vars: case Vars.
    apply IH to _ Vars Ev3 Ev2. backchain vars_equiv_left.
    apply IH to _ Vars1 Ev4 Ev6. backchain vars_equiv_right.
    apply Ev5 to _.
   <span class="comment">%E-eq-False</span>
    search.
<span class="comment">%E-gt-True</span>
 Ev2: case Ev2.
   <span class="comment">%E-gt-True</span>
    search.
   <span class="comment">%E-gt-False</span>
    Vars: case Vars.
    apply IH to _ Vars Ev3 Ev2. backchain vars_equiv_left.
    apply IH to _ Vars1 Ev4 Ev6. backchain vars_equiv_right.
    apply greater_lesseq_integer_false to Ev5 Ev7.
<span class="comment">%E-gt-False</span>
 Ev2: case Ev2.
   <span class="comment">%E-gt-True</span>
    Vars: case Vars.
    apply IH to _ Vars Ev3 Ev2. backchain vars_equiv_left.
    apply IH to _ Vars1 Ev4 Ev6. backchain vars_equiv_right.
    apply greater_lesseq_integer_false to Ev7 Ev5.
   <span class="comment">%E-gt-False</span>
    search.
<span class="comment">%E-not-True</span>
 Ev2: case Ev2.
   <span class="comment">%E-not-True</span>
    search.
   <span class="comment">%E-not-False</span>
    Vars: case Vars. apply IH to _ _ Ev3 Ev2.
<span class="comment">%E-not-False</span>
 Ev2: case Ev2.
   <span class="comment">%E-not-True</span>
    Vars: case Vars. apply IH to _ _ Ev3 Ev2.
   <span class="comment">%E-not-False</span>
    search.</div></pre>

  <p>
    Once this file is written, it can be checked with
    <pre class="code">
extensibella --check host.xthm</pre>
    This ensures all the proofs in the file are valid.
  </p>

  <p>
    To reason about modules building on this one, we need to compile
    it:
    <pre class="code">
extensibella --compile host.xthm</pre>
    This takes the information about the theorems declared, their
    order, and any proof-level definitions in the file and stores them
    in the Extensibella <code>generated</code> directory.  This allows
    the extensions to find this necessary information without needing
    to know the location of the Extensibella file for the host module.
  </p>
</div>

<div class="section">
  <h2>List Extension</h2>
  <p>
    We add an extension introducing syntax for lists.
  </p>

  <h3>Sterling Language Specification</h3>
  <p>
    Our Sterling language specification builds on the host language
    module, adding new constructors for its statement, expression, and
    type categories.  Each new constructor is also given a
    translation to the host syntax.  Note the translation constraints
    we wrote in the host language require only that the translation
    has the same variables and evaluates if the translating syntax
    evaluates, so we have freedom to write translations that may
    otherwise look unusual, such as <code>null(E)</code> translating
    to <code>E</code>.
  </p>
  <span class="highlight">syntax.sos</span>
  <a class="fold-link" href="javascript:void" id="togglelist/syntax.sos"
     onclick="toggleFile('list/syntax.sos')">[Expand File]</a>
  <pre class="code sterling" id="list/syntax.sos" style="max-height: 105px;">
Module library:list

Builds on library:host

e ::= ...
    | nil
    | cons(e, e)
    | null(e)
    | head(e)
    | tail(e)

ty ::= ...
     | list(ty)

s ::= ...
    | splitlist(string, string, e)


------------------- [P-null]
|{e}- null(E) ~~> E


------------------- [P-head]
|{e}- head(E) ~~> E


------------------- [P-tail]
|{e}- tail(E) ~~> E


------------------- [P-nil]
|{e}- nil ~~> trueE


--------------------------------- [P-cons]
|{e}- cons(E1, E2) ~~> eq(E1, E2)


Hd != Tl
----------------------------------------- [P-splitlist]
|{s}- splitlist(Hd, Tl, E) ~~>
      seq(seq(assign(Hd, E),
              assign(Tl, tail(var(Hd)))),
              assign(Hd, head(var(Hd))))


---------------------- [P-list]
|{ty}- list(Ty) ~~> Ty</pre>

  <p>
    We also extend the definitions of the relations introduced by the
    host language, introducing new rules pertaining to the new syntax
    introduced by the extension.
  </p>
  <span class="highlight">vars.sos</span>
  <a class="fold-link" href="javascript:void" id="togglelist/vars.sos"
     onclick="toggleFile('list/vars.sos')">[Expand File]</a>
  <pre class="code sterling" id="list/vars.sos" style="height: 105px;">
Module library:list

----------- [VR-nil]
vars nil []


vars E1 Vr1
vars E2 Vr2
Vr1 ++ Vr2 = V
------------------- [VR-cons]
vars cons(E1, E2) V


vars E V
-------------- [VR-null]
vars null(E) V


vars E V
-------------- [VR-head]
vars head(E) V


vars E V
-------------- [VR-tail]
vars tail(E) V</pre>

  <span class="highlight">typing.sos</span>
  <a class="fold-link" href="javascript:void" id="togglelist/typing.sos"
     onclick="toggleFile('list/typing.sos')">[Expand File]</a>
  <pre class="code sterling" id="list/typing.sos" style="height: 105px;">
Module library:list

------------------- [T-nil]
ty_e G nil list(Ty)


ty_e G E1 Ty
ty_e G E2 list(Ty)
---------------------------- [T-cons]
ty_e G cons(E1, E2) list(Ty)


ty_e G E list(Ty)
------------------- [T-null]
ty_e G null(E) bool


ty_e G E list(Ty)
----------------- [T-head]
ty_e G head(E) Ty


ty_e G E list(Ty)
----------------------- [T-tail]
ty_e G tail(E) list(Ty)





ty_e G E list(Ty)
lookup G Hd Ty
lookup G Tl list(Ty)
----------------------------- [TS-splitlist]
ty_s G splitlist(Hd, Tl, E) G</pre>

  <span class="highlight">eval.sos</span>
  <a class="fold-link" href="javascript:void" id="togglelist/eval.sos"
     onclick="toggleFile('list/eval.sos')">[Expand File]</a>
  <pre class="code sterling" id="list/eval.sos" style="height: 105px;">
Module library:list

--------- [V-nil]
value nil


value E1
value E2
------------------ [V-cons]
value cons(E1, E2)





---------------- [E-nil]
eval_e G nil nil


eval_e G E1 V1
eval_e G E2 V2
---------------------------------- [E-cons]
eval_e G cons(E1, E2) cons(V1, V2)


eval_e G E nil
---------------------- [E-null-true]
eval_e G null(E) trueE


eval_e G E cons(V1, V2)
----------------------- [E-null-false]
eval_e G null(E) falseE


eval_e G E cons(V1, V2)
----------------------- [E-head]
eval_e G head(E) V1


eval_e G E cons(V1, V2)
----------------------- [E-tail]
eval_e G tail(E) V2





eval_e G E cons(V1, V2)
Hd != Tl <span class="comment">/*Need this to prove ext_ind*/</span>
select (Hd, VHd) GHd G
select (Tl, VTl) GTl GHd
----------------------------------------------------- [X-splitlist]
eval_s G splitlist(Hd, Tl, E) (Hd, V1)::(Tl, V2)::GTl</pre>

  <p>
    Again we check the specification and compile it for Extensibella
    by running
    <pre class="code">
sterling --extensibella library:list</pre>
    As before, the Sterling code for this module must be in a
    directory <code>library/list</code>, and this command run from the
    directory containing the <code>library</code> directory.
  </p>


  <h3>Extensibella Reasoning</h3>
  <p>
    The <code>list</code> extension is expected to contribute to the
    proofs of the properties it imports from the host language,
    proving the cases arising from the new rules it introduces.  To
    create a skeleton of the Extensibella file for the module in a
    file named <code>list.xthm</code>, run
    <pre class="code">
extensibella --generate library:list list.xthm</pre>
    The skeleton contains a list of the imported properties to prove.
  </p>
  <span class="highlight">Empty list.xthm</span>
  <a class="fold-link" href="javascript:void" id="toggleskeleton.xthm"
     onclick="toggleFile('skeleton.xthm')">[Expand File]</a>
  <pre class="code extensibella" id="skeleton.xthm" style="max-height: 105px;">
Module library:list.


Prove_Constraint library:host:trans_e_unique.


Prove_Constraint library:host:trans_e_is.


Prove_Constraint library:host:trans_s_unique.


Prove_Constraint library:host:trans_s_is.


Prove_Constraint library:host:trans_ty_unique.


Prove_Constraint library:host:trans_ty_is.


Prove_Ext_Ind library:host:is_e.


Prove library:host:is_e_var_or_not.


Prove library:host:is_e_intlit_or_not.


Prove library:host:is_e_trueE_or_not.


Prove library:host:is_e_falseE_or_not.


Prove library:host:is_e_add_or_not.


Prove library:host:is_e_eqC_or_not.


Prove library:host:is_e_gt_or_not.


Prove library:host:is_e_not_or_not.


Prove library:host:is_e_eq_or_not.


Prove library:host:vars_unique.


Prove_Constraint library:host:trans_e_vars_exist.


Prove_Constraint library:host:trans_e_vars.


Prove library:host:vars_is.


Prove library:host:vars_exist.


Prove library:host:value_empty_typable.


Prove library:host:eval_e_is.


Prove library:host:type_preservation_e.


Prove library:host:var_types_maintained.


Prove library:host:type_preservation_s.


Prove_Constraint library:host:trans_eval_e.


Prove library:host:eval_e_unique.


Prove_Constraint library:host:trans_s_eval.


Prove_Ext_Ind library:host:eval_s.


Prove_Constraint library:host:trans_s_eval_results.


Prove_Constraint library:host:trans_s_eval_results_back.


Prove library:host:eval_e_value.


Prove library:host:eval_s_value.


Prove library:host:vars_eval_same_result.</pre>

  <p>
    Extensibella expects only the new cases for these proofs.  The new
    proof cases can be proven interactively as before.
  </p>

  <span class="highlight">list.xthm</span>
  <a class="fold-link" href="javascript:void" id="togglelist.xthm"
     onclick="toggleFile('list.xthm')">[Expand File]</a>
  <pre class="code extensibella" id="list.xthm" style="max-height: 105px;">
Module library:list.


Prove_Constraint library:host:trans_e_unique.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(27);" id="toggleproof27">[Show Proof]</a>
<div class="proof" id="proof27" style="display: none;">
<span class="comment">%P-null</span>
 case Hyp1. search.
<span class="comment">%P-head</span>
 case Hyp1. search.
<span class="comment">%P-tail</span>
 case Hyp1. search.
<span class="comment">%P-nil</span>
 case Hyp1. search.
<span class="comment">%P-cons</span>
 case Hyp1. search.</div>
Prove_Constraint library:host:trans_e_is.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(28);" id="toggleproof28">[Show Proof]</a>
<div class="proof" id="proof28" style="display: none;">
<span class="comment">%P-null</span>
 case Hyp1. search.
<span class="comment">%P-head</span>
 case Hyp1. search.
<span class="comment">%P-tail</span>
 case Hyp1. search.
<span class="comment">%P-nil</span>
 case Hyp1. search.
<span class="comment">%P-cons</span>
 case Hyp1. search.</div>


Prove_Constraint library:host:trans_s_unique.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(29);" id="toggleproof29">[Show Proof]</a>
<div class="proof" id="proof29" style="display: none;">
<span class="comment">%P-splitlist</span>
 case Hyp1. search.</div>
Prove_Constraint library:host:trans_s_is.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(30);" id="toggleproof30">[Show Proof]</a>
<div class="proof" id="proof30" style="display: none;">
<span class="comment">%P-splitlist</span>
 case Hyp1. search.</div>


Prove_Constraint library:host:trans_ty_unique.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(31);" id="toggleproof31">[Show Proof]</a>
<div class="proof" id="proof31" style="display: none;">
<span class="comment">%P-list</span>
 case Hyp1. search.</div>
Prove_Constraint library:host:trans_ty_is.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(32);" id="toggleproof32">[Show Proof]</a>
<div class="proof" id="proof32" style="display: none;">
<span class="comment">%P-list</span>
 case Hyp1. search.</div>


Prove_Ext_Ind library:host:is_e.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(33);" id="toggleproof33">[Show Proof]</a>
<div class="proof" id="proof33" style="display: none;">
<span class="comment">%nil</span>
 search.
<span class="comment">%cons</span>
 Trans: assert |{e}- cons E1 E2 ~~> eq E1 E2. Acc: case Acc.
 ESTrans: assert <is_e {ES}> (eq E1 E2) N4.
 IsN2: apply ext_ind_is_int_is_e to Rel3.
 IsN3: apply ext_ind_is_int_is_e to Rel4.
 IsN4: apply plus_integer_is_integer to _ _ Rel2.
 L: apply lt_plus_one to Rel1 IsN4.
 N2Pos: apply ext_ind_pos_is_e to Rel3.
 N3Pos: apply ext_ind_pos_is_e to Rel4.
 N4Pos: apply lesseq_integer__add_positive to N2Pos N3Pos Rel2.
 A: apply Acc to _ L. TTrans: apply IH to ESTrans A.
 LN2: assert N2 < N.
   Or: apply lt_left to Rel2 N2Pos N3Pos. E: case Or.
     apply less_integer_transitive to E L. search.
     search.
 LN3: assert N3 < N.
   Or: apply lt_right to Rel2 IsN3 N2Pos N3Pos. E: case Or.
     apply less_integer_transitive to E L. search.
     search.
 AN2: apply Acc to N2Pos LN2. AN3: apply Acc to N3Pos LN3.
 apply IH to Rel3 AN2. apply IH to Rel4 AN3. search.
<span class="comment">%null</span>
 Trans: assert |{e}- null E1 ~~> E1.
 IsN2: apply ext_ind_is_int_is_e to Rel2.
 L: apply lt_plus_one to Rel1 IsN2. Acc: case Acc.
 N2Pos: apply ext_ind_pos_is_e to Rel2. AN2: apply Acc to N2Pos L.
 apply IH to Rel2 AN2. search.
<span class="comment">%head</span>
 Trans: assert |{e}- head E1 ~~> E1.
 IsN2: apply ext_ind_is_int_is_e to Rel2.
 L: apply lt_plus_one to Rel1 IsN2. Acc: case Acc.
 N2Pos: apply ext_ind_pos_is_e to Rel2. AN2: apply Acc to N2Pos L.
 apply IH to Rel2 AN2. search.
<span class="comment">%tail</span>
 Trans: assert |{e}- tail E1 ~~> E1.
 IsN2: apply ext_ind_is_int_is_e to Rel2.
 L: apply lt_plus_one to Rel1 IsN2. Acc: case Acc.
 N2Pos: apply ext_ind_pos_is_e to Rel2. AN2: apply Acc to N2Pos L.
 apply IH to Rel2 AN2. search.</div>


Prove library:host:is_e_var_or_not.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(34);" id="toggleproof34">[Show Proof]</a>
<div class="proof" id="proof34" style="display: none;">
search. search. search. search. search.</div>
Prove library:host:is_e_intlit_or_not.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(35);" id="toggleproof35">[Show Proof]</a>
<div class="proof" id="proof35" style="display: none;">
search. search. search. search. search.</div>
Prove library:host:is_e_trueE_or_not.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(36);" id="toggleproof36">[Show Proof]</a>
<div class="proof" id="proof36" style="display: none;">
search. search. search. search. search.</div>
Prove library:host:is_e_falseE_or_not.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(37);" id="toggleproof37">[Show Proof]</a>
<div class="proof" id="proof37" style="display: none;">
search. search. search. search. search.</div>
Prove library:host:is_e_add_or_not.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(38);" id="toggleproof38">[Show Proof]</a>
<div class="proof" id="proof38" style="display: none;">
search. search. search. search. search.</div>
Prove library:host:is_e_eqC_or_not.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(39);" id="toggleproof39">[Show Proof]</a>
<div class="proof" id="proof39" style="display: none;">
search. search. search. search. search.</div>
Prove library:host:is_e_gt_or_not.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(40);" id="toggleproof40">[Show Proof]</a>
<div class="proof" id="proof40" style="display: none;">
search. search. search. search. search.</div>
Prove library:host:is_e_not_or_not.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(41);" id="toggleproof41">[Show Proof]</a>
<div class="proof" id="proof41" style="display: none;">
search. search. search. search. search.</div>
Extensible_Theorem
  is_e_nil_or_not : forall E,
    IsE: is_e E ->
    E = library:list:nil \/ (E = library:list:nil -> false)
  on IsE.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(42);" id="toggleproof42">[Show Proof]</a>
<div class="proof" id="proof42" style="display: none;">
search. search. search. search. search. search. search. search.
search. search. search. search. search. search.</div>
Extensible_Theorem
  is_e_cons_or_not : forall E,
    IsE: is_e E ->
    (exists E1 E2, E = cons E1 E2) \/
    ((exists E1 E2, E = cons E1 E2) -> false)
  on IsE.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(43);" id="toggleproof43">[Show Proof]</a>
<div class="proof" id="proof43" style="display: none;">
search. search. search. search. search. search. search. search.
search. search. search. search. search. search.</div>
Extensible_Theorem
  is_e_null_or_not : forall E,
    IsE: is_e E ->
    (exists E', E = null E') \/
    ((exists E', E = null E') -> false)
  on IsE.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(44);" id="toggleproof44">[Show Proof]</a>
<div class="proof" id="proof44" style="display: none;">
search. search. search. search. search. search. search. search.
search. search. search. search. search. search.</div>
Extensible_Theorem
  is_e_head_or_not : forall E,
    IsE: is_e E ->
    (exists E', E = head E') \/
    ((exists E', E = head E') -> false)
  on IsE.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(45);" id="toggleproof45">[Show Proof]</a>
<div class="proof" id="proof45" style="display: none;">
search. search. search. search. search. search. search. search.
search. search. search. search. search. search.</div>
Extensible_Theorem
  is_e_tail_or_not : forall E,
    IsE: is_e E ->
    (exists E', E = tail E') \/
    ((exists E', E = tail E') -> false)
  on IsE.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(46);" id="toggleproof46">[Show Proof]</a>
<div class="proof" id="proof46" style="display: none;">
search. search. search. search. search. search. search. search.
search. search. search. search. search. search.</div>
Prove library:host:is_e_eq_or_not.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(47);" id="toggleproof47">[Show Proof]</a>
<div class="proof" id="proof47" style="display: none;">
<span class="comment">%nil</span>
 Or: apply is_e_nil_or_not to IsE2. E: case Or.
   <span class="comment">%nil</span>
    search.
   <span class="comment">%not nil</span>
    right. intros Eq. case Eq. backchain E.
<span class="comment">%cons</span>
 Or: apply is_e_cons_or_not to IsE2. E: case Or.
   <span class="comment">%cons</span>
    Is: case IsE2. Or: apply IH to IsE3 Is. E: case Or.
      <span class="comment">%E3 = E4</span>
       Or: apply IH to IsE4 Is1. E: case Or.
         <span class="comment">%E = E5</span>
          search.
         <span class="comment">%E != E5</span>
          right. intros Eq. case Eq. backchain E.
      <span class="comment">%E3 != E4</span>
       right. intros Eq. case Eq. backchain E.
   <span class="comment">%not cons</span>
    right. intros Eq. backchain E. case Eq. search.
<span class="comment">%null</span>
 Or: apply is_e_null_or_not to IsE2. E: case Or.
   <span class="comment">%null</span>
    Is: case IsE2. Or: apply IH to IsE3 Is. E: case Or.
      <span class="comment">%E = E'</span>
       search.
      <span class="comment">%E != E'</span>
       right. intros Eq. case Eq. backchain E.
   <span class="comment">%not null</span>
    right. intros Eq. backchain E. case Eq. search.
<span class="comment">%head</span>
 Or: apply is_e_head_or_not to IsE2. E: case Or.
   <span class="comment">%head</span>
    Is: case IsE2. Or: apply IH to IsE3 Is. E: case Or.
      <span class="comment">%E = E'</span>
       search.
      <span class="comment">%E != E'</span>
       right. intros Eq. case Eq. backchain E.
   <span class="comment">%not head</span>
    right. intros Eq. backchain E. case Eq. search.
<span class="comment">%tail</span>
 Or: apply is_e_tail_or_not to IsE2. E: case Or.
   <span class="comment">%tail</span>
    Is: case IsE2. Or: apply IH to IsE3 Is. E: case Or.
      <span class="comment">%E = E'</span>
       search.
      <span class="comment">%E != E'</span>
       right. intros Eq. case Eq. backchain E.
   <span class="comment">%not tail</span>
    right. intros Eq. backchain E. case Eq. search.</div>


Prove library:host:vars_unique.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(48);" id="toggleproof48">[Show Proof]</a>
<div class="proof" id="proof48" style="display: none;">
<span class="comment">%VR-nil</span>
 case Vars2. search.
<span class="comment">%VR-cons</span>
 V: case Vars2. apply IH to Vars3 V. apply IH to Vars4 V1.
 apply append_unique to Vars5 V2. search.
<span class="comment">%VR-null</span>
 V: case Vars2. apply IH to Vars3 V. search.
<span class="comment">%VR-head</span>
 V: case Vars2. apply IH to Vars3 V. search.
<span class="comment">%VR-tail</span>
 V: case Vars2. apply IH to Vars3 V. search.</div>


Prove_Constraint library:host:trans_e_vars_exist.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(49);" id="toggleproof49">[Show Proof]</a>
<div class="proof" id="proof49" style="display: none;">
<span class="comment">%P-null</span>
 case Hyp1. search.
<span class="comment">%P-head</span>
 case Hyp1. search.
<span class="comment">%P-tail</span>
 case Hyp1. search.
<span class="comment">%P-nil</span>
 search.
<span class="comment">%P-cons</span>
 case Hyp1. search.</div>
Prove_Constraint library:host:trans_e_vars.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(50);" id="toggleproof50">[Show Proof]</a>
<div class="proof" id="proof50" style="display: none;">
<span class="comment">%P-null</span>
 V: case Hyp1. apply vars_unique to V Hyp2. search.
<span class="comment">%P-head</span>
 V: case Hyp1. apply vars_unique to V Hyp2. search.
<span class="comment">%P-tail</span>
 V: case Hyp1. apply vars_unique to V Hyp2. search.
<span class="comment">%P-nil</span>
 case Hyp1. case Hyp2. search.
<span class="comment">%P-cons</span>
 V: case Hyp1. V': case Hyp2. apply vars_unique to V V'.
 apply vars_unique to V1 V'1. apply append_unique to V2 V'2. search.</div>


Prove library:host:vars_is.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(51);" id="toggleproof51">[Show Proof]</a>
<div class="proof" id="proof51" style="display: none;">
<span class="comment">%VR-nil</span>
 search.
<span class="comment">%VR-cons</span>
 Is: case IsE. apply IH to Is Vars1. apply IH to Is1 Vars2.
 apply append__is_list__is_string to _ _ Vars3. search.
<span class="comment">%VR-null</span>
 Is: case IsE. apply IH to Is Vars1. search.
<span class="comment">%VR-head</span>
 Is: case IsE. apply IH to Is Vars1. search.
<span class="comment">%VR-tail</span>
 Is: case IsE. apply IH to Is Vars1. search.</div>


Prove library:host:vars_exist.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(52);" id="toggleproof52">[Show Proof]</a>
<div class="proof" id="proof52" style="display: none;">
<span class="comment">%nil</span>
 search.
<span class="comment">%cons</span>
 V1: apply IH to IsE1. V2: apply IH to IsE2.
 Is1: apply vars_is to IsE1 V1. Is2: apply vars_is to IsE2 V2.
 apply append__is_list__is_string__total to Is1 Is2. search.
<span class="comment">%null</span>
 apply IH to IsE1. search.
<span class="comment">%head</span>
 apply IH to IsE1. search.
<span class="comment">%tail</span>
 apply IH to IsE1. search.</div>


Prove library:host:value_empty_typable.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(53);" id="toggleproof53">[Show Proof]</a>
<div class="proof" id="proof53" style="display: none;">
<span class="comment">%V-nil</span>
 case Ty. search.
<span class="comment">%V-cons</span>
 Ty: case Ty. apply IH to Value1 Ty. apply IH to Value2 Ty1. search.</div>


Prove library:host:eval_e_is.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(54);" id="toggleproof54">[Show Proof]</a>
<div class="proof" id="proof54" style="display: none;">
<span class="comment">%E-nil</span>
 search.
<span class="comment">%E-cons</span>
 case IsE. apply IH to _ _ Ev1. apply IH to _ _ Ev2. search.
<span class="comment">%E-null-true</span>
 search.
<span class="comment">%E-null-False</span>
 search.
<span class="comment">%E-head</span>
 case IsE. IsV: apply IH to _ _ Ev1. case IsV. search.
<span class="comment">%E-tail</span>
 case IsE. IsV: apply IH to _ _ Ev1. case IsV. search.</div>


Prove library:host:type_preservation_e.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(55);" id="toggleproof55">[Show Proof]</a>
<div class="proof" id="proof55" style="display: none;">
<span class="comment">%E-nil</span>
 case Ty. search.
<span class="comment">%E-cons</span>
 Ty: case Ty. apply IH to Ty Ev1 Rel. apply IH to Ty1 Ev2 Rel. search.
<span class="comment">%E-null-true</span>
 case Ty. search.
<span class="comment">%E-null-false</span>
 case Ty. search.
<span class="comment">%E-head</span>
 Ty: case Ty. TV: apply IH to Ty Ev1 Rel. case TV. search.
<span class="comment">%E-tail</span>
 Ty: case Ty. TV: apply IH to Ty Ev1 Rel. case TV. search.</div>


Prove library:host:var_types_maintained.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(56);" id="toggleproof56">[Show Proof]</a>
<div class="proof" id="proof56" style="display: none;">
<span class="comment">%TS-splitlist</span>
 search.</div>


Prove library:host:type_preservation_s.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(57);" id="toggleproof57">[Show Proof]</a>
<div class="proof" id="proof57" style="display: none;">
<span class="comment">%X-splitlist</span>
 Ty: case Ty. TyCons: apply type_preservation_e to Ty Ev1 Rel.
 TyV: case TyCons. LV: case LkpV.
   <span class="comment">%Lkp-Here</span>
    apply lookup_unique to LkpTy Ty1. search.
   <span class="comment">%Lkp-Later</span>
    LV: case LV1.
      <span class="comment">%Lkp-Here</span>
       apply lookup_unique to Ty2 LkpTy. search.
      <span class="comment">%Lkp-Later</span>
       assert X = Tl -> false. intros E. case E. backchain LV1.
       assert X = Hd -> false. intros E. case E. backchain LV.
       L: apply lookup_after_select_before to LV2 Ev4 _.
       L': apply lookup_after_select_before to L Ev3 _.
       apply Rel to _ L'. search.</div>


Prove_Constraint library:host:trans_eval_e.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(58);" id="toggleproof58">[Show Proof]</a>
<div class="proof" id="proof58" style="display: none;">
<span class="comment">%P-null</span>
 case Hyp1. search. search.
<span class="comment">%P-head</span>
 case Hyp1. search.
<span class="comment">%P-tail</span>
 case Hyp1. search.
<span class="comment">%P-nil</span>
 search.
<span class="comment">%P-cons</span>
 case Hyp1. case Hyp3. Is1: apply eval_e_is to _ _ H1.
 Is2: apply eval_e_is to _ _ H2. Or: apply is_e_eq_or_not to Is1 Is2.
 E: case Or.
   <span class="comment">%V1 = V2</span>
    search.
   <span class="comment">%V1 != V2</span>
    search.</div>


Prove library:host:eval_e_unique.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(59);" id="toggleproof59">[Show Proof]</a>
<div class="proof" id="proof59" style="display: none;">
<span class="comment">%E-nil</span>
 case Ev2. search.
<span class="comment">%E-cons</span>
 Ev2: case Ev2. apply IH to Ev3 Ev2. apply IH to Ev4 Ev5. search.
<span class="comment">%E-null-true</span>
 Ev2: case Ev2.
   <span class="comment">%E-null-true</span>
    search.
   <span class="comment">%E-null-false</span>
    apply IH to Ev3 Ev2.
<span class="comment">%E-null-false</span>
 Ev2: case Ev2.
   <span class="comment">%E-null-true</span>
    apply IH to Ev3 Ev2.
   <span class="comment">%E-null-false</span>
    search.
<span class="comment">%E-head</span>
 Ev2: case Ev2. apply IH to Ev3 Ev2. search.
<span class="comment">%E-tail</span>
 Ev2: case Ev2. apply IH to Ev3 Ev2. search.</div>


Prove_Constraint library:host:trans_s_eval.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(60);" id="toggleproof60">[Show Proof]</a>
<div class="proof" id="proof60" style="display: none;">
<span class="comment">%Trans-splitlist</span>
 Ev: case Hyp1. exists (Hd, V1)::(Tl, V2)::GTl. unfold.
 exists (Tl, V2)::(Hd, cons V1 V2)::GTl. split.
   <span class="comment">%eval first two assigns</span>
    unfold. exists (Hd, cons V1 V2)::GHd. split.
      <span class="comment">%eval first Hd assign</span>
       search.
      <span class="comment">%eval Tl assign</span>
       search.
   <span class="comment">%eval latter assign to Hd</span>
    assert Tl = Hd -> false. intros E. case E. backchain Ev1. search.</div>
Prove_Ext_Ind library:host:eval_s.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(61);" id="toggleproof61">[Show Proof]</a>
<div class="proof" id="proof61" style="display: none;">
<span class="comment">%P-splitlist</span>
 assert |{s}- splitlist Hd Tl E ~~>
             (seq (seq (assign Hd E)
                       (assign Tl (tail (var Hd))))
                       (assign Hd (head (var Hd)))). unfold.
 exists (seq (seq (assign Hd E)
                  (assign Tl (tail (var Hd))))
                  (assign Hd (head (var Hd)))), VHd, GHd, VTl. split.
   <span class="comment">%eval trans</span>
    unfold. exists (Tl, V2)::(Hd, cons V1 V2)::GTl. split.
      <span class="comment">%eval first two assigns</span>
       unfold. exists (Hd, cons V1 V2)::GHd. split.
         <span class="comment">%eval first Hd assign</span>
          search.
         <span class="comment">%eval Tl assign</span>
          search.
      <span class="comment">%eval latter assign to Hd</span>
       assert Tl = Hd -> false. intros E. case E. backchain Rel2.
       search.
   <span class="comment">%trans</span>
    search.
   <span class="comment">%eval E</span>
    search.
   <span class="comment">%Hd != Tl</span>
    search.
   <span class="comment">%select Hd</span>
    search.
   <span class="comment">%select Tl</span>
    search.</div>


Prove_Constraint library:host:trans_s_eval_results.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(62);" id="toggleproof62">[Show Proof]</a>
<div class="proof" id="proof62" style="display: none;">
<span class="comment">%X-splitlist</span>
 EvTr: case Hyp2. EvTr: case EvTr. EvTr: case EvTr. EvTr: case EvTr2.
 EvTr: case EvTr2. EvTr: case EvTr2. case EvTr2.
   <span class="comment">%Lkp-Here</span>
    EvTr: case EvTr1. EvTr: case EvTr1. EvTr: case EvTr1. L: case EvTr1.
      <span class="comment">%Lkp-Here:  Hd = Tl</span>
       apply Hyp4 to _.
      <span class="comment">%Lkp-Later:  lookup NewG1 Hd (cons V4 V5)</span>
       STl: case EvTr4.
         <span class="comment">%Tl = Hd</span>
          apply L to _.
         <span class="comment">%select (Tl, VOld1) L1 NewG</span>
          SHd: case EvTr2.
            <span class="comment">%Hd = Tl</span>
             apply L to _.
            <span class="comment">%select (Hd, VOld2) L2 (Hd, cons V3 V2)::L1</span>
             EvSL: case Hyp1. case L1.
               <span class="comment">%Lkp-Here</span>
                apply eval_e_unique to EvTr EvSL. LX: case Hyp3.
                  <span class="comment">%Lkp-Here:  X = Hd</span>
                   search.
                  <span class="comment">%Lkp-Later:  lookup (Tl, V7)::GTl X V</span>
                   LX: case LX1.
                     <span class="comment">%Lkp-Here:  X = Tl</span>
                      search.
                     <span class="comment">%Lkp-Later:  lookup X V GTl</span>
                      assert X = Tl -> false.
                        intros E. case E. backchain LX1.
                      L2: apply lookup_after_select_before to LX2 EvSL3 _.
                      assert X = Hd -> false.
                        intros E. case E. backchain LX.
                      L3: apply lookup_after_select_before to L2 EvSL2 _.
                      L4: apply select_lookup to L3 EvTr3 _.
                      L5: apply select_lookup to L4 STl _.
                      L5': assert lookup ((Hd, cons V6 V7)::L1) X V.
                      apply select_lookup to L5' SHd _. search.
               <span class="comment">%Lkp-Later</span>
                apply H1 to _.
   <span class="comment">%Lkp-Later</span>
    apply H1 to _.</div>


Prove_Constraint library:host:trans_s_eval_results_back.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(63);" id="toggleproof63">[Show Proof]</a>
<div class="proof" id="proof63" style="display: none;">
<span class="comment">%X-splitlist</span>
 EvSL: case Hyp1. EvTr: case Hyp2. EvTr: case EvTr. EvTr: case EvTr1.
 EvTr: case EvTr. apply eval_e_unique to EvTr EvSL. EvTr: case EvTr2.
 EvTr: case EvTr1. EvTr: case EvTr2. EvTr: case EvTr1.
 EvTr: case EvTr2. LHd: case EvTr2.
   <span class="comment">%Lkp-Here</span>
    EvTr: case EvTr3.
      <span class="comment">%Slct-Here:  Hd = Tl</span>
       apply EvSL1 to _.
      <span class="comment">%Slct-Later</span>
       LX: case Hyp3.
         <span class="comment">%Lkp-Here:  X = Hd</span>
          STl: case EvTr5.
            <span class="comment">%Slct-Here:  Tl = X</span>
             apply EvSL1 to _.
            <span class="comment">%Slct-Later</span>
             L: case EvTr1.
               <span class="comment">%Lkp-Here:  X = Tl</span>
                apply EvSL1 to _.
               <span class="comment">%Lkp-Later</span>
                L': case L1.
                  <span class="comment">%Lkp-Here</span>
                   search.
                  <span class="comment">%Lkp-Later:  X != X</span>
                   apply L' to _.
         <span class="comment">%Lkp-Later:  lookup (Tl, V5)::L1 X V</span>
          LX: case LX1.
            <span class="comment">%Lkp-Here:  X = Tl</span>
             search.
            <span class="comment">%Lkp-Later:  lookup L1 X V</span>
             assert X = Hd -> false. intros E. case E. backchain LX.
             assert X = Tl -> false. intros E. case E. backchain LX1.
             L1: apply lookup_after_select_before to LX2 EvTr2 _.
             L2: apply lookup_after_select_before to L1 EvTr5 _.
             L': case L2.
               <span class="comment">%Lkp-Here:  X = Hd</span>
                apply LX to _.
               <span class="comment">%Lkp-Later</span>
                L3: apply lookup_after_select_before to L'1 EvTr4 _.
                L4: apply select_lookup to L3 EvSL2 _.
                apply select_lookup to L4 EvSL3 _. search.
   <span class="comment">%Lkp-Later</span>
    apply LHd to _.</div>


Prove library:host:eval_e_value.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(64);" id="toggleproof64">[Show Proof]</a>
<div class="proof" id="proof64" style="display: none;">
<span class="comment">%E-nil</span>
 search.
<span class="comment">%E-cons</span>
 apply IH to Ev1 AllVal. apply IH to Ev2 AllVal. search.
<span class="comment">%E-null-true</span>
 search.
<span class="comment">%E-null-false</span>
 search.
<span class="comment">%E-head</span>
 V: apply IH to Ev1 AllVal. case V. search.
<span class="comment">%E-tail</span>
 V: apply IH to Ev1 AllVal. case V. search.</div>


Prove library:host:eval_s_value.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(65);" id="toggleproof65">[Show Proof]</a>
<div class="proof" id="proof65" style="display: none;">
<span class="comment">%X-splitlist</span>
 VCons: apply eval_e_value to Ev1 AllVal. V: case VCons (keep).
 M: case Mem.
   <span class="comment">%Mem-Here:  (Hd, V1)</span>
    search.
   <span class="comment">%Mem-Later</span>
    M: case M.
      <span class="comment">%Mem-Here:  (Tl, V2)</span>
       search.
      <span class="comment">%Mem-Later</span>
       MGHd: apply mem_after_select_before to _ M.
       apply mem_after_select_before to _ MGHd. backchain AllVal.</div>


Prove library:host:vars_eval_same_result.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(66);" id="toggleproof66">[Show Proof]</a>
<div class="proof" id="proof66" style="display: none;">
<span class="comment">%E-nil</span>
 case Ev2. search.
<span class="comment">%E-cons</span>
 Ev2: case Ev2. Vars: case Vars.
 apply IH to _ Vars Ev3 Ev2. backchain vars_equiv_left.
 apply IH to _ Vars1 Ev4 Ev5. backchain vars_equiv_right. search.
<span class="comment">%E-null-true</span>
 Ev2: case Ev2.
   <span class="comment">%E-null-true</span>
    search.
   <span class="comment">%E-null-false</span>
    Vars: case Vars. apply IH to _ Vars Ev3 Ev2.
<span class="comment">%E-null-false</span>
 Ev2: case Ev2.
   <span class="comment">%E-null-true</span>
    Vars: case Vars. apply IH to _ Vars Ev3 Ev2.
   <span class="comment">%E-null-false</span>
    search.
<span class="comment">%E-head</span>
 Ev2: case Ev2. Vars: case Vars. apply IH to _ _ Ev3 Ev2. search.
<span class="comment">%E-tail</span>
 Ev2: case Ev2. Vars: case Vars. apply IH to _ _ Ev3 Ev2. search.</div></pre>

  <p>
    We can again check the completed file and compile it:
    <pre class="code">
extensibella --check --compile list.xthm</pre>
    We compile this because we will need it for composing the proofs
    even though we aren't adding any extensions on top of it.
  </p>
</div>

<div class="section">
  <h2>Security Extension</h2>
  <p>
    We also add an extension checking information flow to prevent
    private information from leaking to public variables.
  </p>

  <h3>Sterling Language Specification</h3>
  <p>
    Our specification for this extension introduces one new construct,
    a way to declare variables with a specific security level.  In
    addition to defining the relations from the host language for this
    construct, we declare and define new relations checking
    information flow relative to security levels.
  </p>

  <span class="highlight">syntax.sos</span>
  <a class="fold-link" href="javascript:void" id="togglesecurity/syntax.sos"
     onclick="toggleFile('security/syntax.sos')">[Expand File]</a>
  <pre class="code sterling" id="security/syntax.sos" style="max-height: 105px;">
Module library:security

Builds on library:host

s ::= ...
    | secdecl(string, ty, sl, e)

sl ::= public
     | private

Translation sl :


---------------------------------------------- [P-secdecl]
|{s}- secdecl(N, Ty, Sl, E) ~~> decl(N, Ty, E)</pre>

  <span class="highlight">typing.sos</span>
  <pre class="code sterling" id="security/typing.sos" style="max-height: 105px;">
Module library:security

ty_e G E Ty
no_lookup G N
--------------------------------------- [TS-secdecl]
ty_s G secdecl(N, Ty, Sl, E) (N, Ty)::G</pre>

  <span class="highlight">eval.sos</span>
  <pre class="code sterling" id="security/eval.sos" style="max-height: 105px;">
Module library:security

eval_e G E V
---------------------------------------- [X-secdecl]
eval_s G secdecl(N, Ty, Sl, E) (N, V)::G</pre>

  <span class="highlight">security.sos</span>
  <a class="fold-link" href="javascript:void" id="togglesecurity/security.sos"
     onclick="toggleFile('security/security.sos')">[Expand File]</a>
  <pre class="code sterling" id="security/security.sos" style="max-height: 105px;">
Module library:security

<span class="comment">/*We use the standard library's lookup relation rather than writing
  our own here.*/</span>

Fixed Judgment join : sl sl sl
<span class="comment">/*Sigma |- level e* sl*/</span>
Judgment level : [(string, sl)] e* sl
<span class="comment">/*Sigma sl |- secure s* Sigma*/</span>
Judgment secure : [(string, sl)] sl s* [(string, sl)]

========================= [J-public]
join public public public


====================== [J-private-l]
join private L private


====================== [J-private-r]
join L private private





------------------------- [L-int]
level SG intlit(I) public


--------------------- [L-true]
level SG trueE public


---------------------- [L-false]
level SG falseE public


lookup SG N L
----------------- [L-var]
level SG var(N) L


level SG E1 L1
level SG E2 L2
join L1 L2 L
---------------------- [L-add]
level SG add(E1, E2) L


level SG E1 L1
level SG E2 L2
join L1 L2 L
--------------------- [L-eq]
level SG eq(E1, E2) L


level SG E1 L1
level SG E2 L2
join L1 L2 L
--------------------- [L-gt]
level SG gt(E1, E2) L


level SG E L
----------------- [L-not]
level SG not(E) L


|{e}- E ~~> E1
level SG E1 Sl
-------------- [LF-level]*
level SG E Sl





--------------------- [S-skip]
secure SG Sl skipS SG


secure SG Sl S1 SG1
secure SG1 Sl S2 SG2
---------------------------- [S-seq]
secure SG Sl seq(S1, S2) SG2


level SG E public
no_lookup SG N
----------------------------------------------- [S-decl]
secure SG public decl(N, Ty, E) (N, public)::SG


level SG E L
lookup SG N private
---------------------------- [S-assign-private]
secure SG Sl assign(N, E) SG


level SG E public
lookup SG N public
-------------------------------- [S-assign-public]
secure SG public assign(N, E) SG


level SG E L
join L Sl Sl1
secure SG Sl1 S1 SG1
secure SG Sl1 S2 SG2
------------------------------- [S-ifte]
secure SG Sl ifte(E, S1, S2) SG


level SG E L
join L Sl Sl1
secure SG Sl1 S SG1
--------------------------- [S-while]
secure SG Sl while(E, S) SG


level SG E L
no_lookup SG N
-------------------------------------------------------- [S-secdecl-private]
secure SG Sl secdecl(N, Ty, private, E) (N, private)::SG


level SG E public
no_lookup SG N
---------------------------------------------------------- [S-secdecl-public]
secure SG public secdecl(N, Ty, public, E) (N, public)::SG


|{s}- S ~~> S1
secure SG Sl S1 SG1
------------------- [LF-secure]*
secure SG Sl S SG1</pre>

  <p>
    As before, we check this module and compile it for Extensibella:
    <pre class="code">
sterling --extensibella library:security</pre>
  </p>


  <h3>Extensibella Reasoning</h3>
  <p>
    The security extension also must prove the properties introduced
    by the host language, so we generate a proof skeleton for it as
    well:
    <pre class="code">
extensibella --generate library:security security.xthm</pre>
    The generated file has the same contents as the one generated for
    the list extension other than the module declaration at the
    beginning.
  </p>

  <p>
    The security extension adds proofs for the new cases in existing
    properties imported from the host language.  Additionally, it
    introduces new properties showing the correctness of the security
    analyses it introduces.  In particular,
    the <code>stmt_secure</code> property, the final property
    introduced by the security extension, ensures information cannot
    leak from private variables to public variables when the security
    analysis succeeds.
  </p>
  <span class="highlight">security.xthm</span>
  <a class="fold-link" href="javascript:void" id="togglesecurity.xthm"
     onclick="toggleFile('security.xthm')">[Expand File]</a>
  <pre class="code extensibella" id="security.xthm" style="max-height: 105px;">
Module library:security.


Prove_Constraint library:host:trans_e_unique.
Prove_Constraint library:host:trans_e_is.


Prove_Constraint library:host:trans_s_unique.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(67);" id="toggleproof67">[Show Proof]</a>
<div class="proof" id="proof67" style="display: none;">
<span class="comment">%secdecl</span>
 case Hyp1. search.</div>
Prove_Constraint library:host:trans_s_is.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(68);" id="toggleproof68">[Show Proof]</a>
<div class="proof" id="proof68" style="display: none;">
<span class="comment">%secdecl</span>
 case Hyp1. search.</div>


Prove_Constraint library:host:trans_ty_unique.
Prove_Constraint library:host:trans_ty_is.


Prove_Ext_Ind library:host:is_e.


Prove library:host:is_e_var_or_not.
Prove library:host:is_e_intlit_or_not.
Prove library:host:is_e_trueE_or_not.
Prove library:host:is_e_falseE_or_not.
Prove library:host:is_e_add_or_not.
Prove library:host:is_e_eqC_or_not.
Prove library:host:is_e_gt_or_not.
Prove library:host:is_e_not_or_not.
Prove library:host:is_e_eq_or_not.
Prove library:host:vars_unique.


Prove_Constraint library:host:trans_e_vars_exist.
Prove_Constraint library:host:trans_e_vars.


Prove library:host:vars_is.
Prove library:host:vars_exist.


Prove library:host:value_empty_typable.


Prove library:host:eval_e_is.

Prove library:host:type_preservation_e.

Prove library:host:var_types_maintained.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(69);" id="toggleproof69">[Show Proof]</a>
<div class="proof" id="proof69" style="display: none;">
<span class="comment">%TS-secdecl</span>
 assert N = X -> false.
   intros E. case E. apply no_lookup to Ty2 Lkp.
 search.</div>

Prove library:host:type_preservation_s.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(70);" id="toggleproof70">[Show Proof]</a>
<div class="proof" id="proof70" style="display: none;">
<span class="comment">%X-secdecl</span>
 Ty: case Ty. apply type_preservation_e to Ty Ev1 Rel. LT: case LkpTy.
   <span class="comment">%Lkp-Here</span>
    LV: case LkpV.
      <span class="comment">%Lkp-Here</span>
       search.
      <span class="comment">%Lkp-Later</span>
       apply LV to _.
   <span class="comment">%Lkp-Later</span>
    LV: case LkpV.
      <span class="comment">%Lkp-Here</span>
       apply LT to _.
      <span class="comment">%Lkp-Later</span>
       backchain Rel.</div>


Prove_Constraint library:host:trans_eval_e.


Prove library:host:eval_e_unique.


Prove_Constraint library:host:trans_s_eval.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(71);" id="toggleproof71">[Show Proof]</a>
<div class="proof" id="proof71" style="display: none;">
<span class="comment">%secdecl</span>
 case Hyp1. search.</div>


Prove_Ext_Ind library:host:eval_s.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(72);" id="toggleproof72">[Show Proof]</a>
<div class="proof" id="proof72" style="display: none;">
<span class="comment">%secdecl</span>
 search.</div>

Prove_Constraint library:host:trans_s_eval_results.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(73);" id="toggleproof73">[Show Proof]</a>
<div class="proof" id="proof73" style="display: none;">
<span class="comment">%secdecl</span>
 VS: case Hyp1. VD: case Hyp2. apply eval_e_unique to VS VD. search.</div>


Prove_Constraint library:host:trans_s_eval_results_back.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(74);" id="toggleproof74">[Show Proof]</a>
<div class="proof" id="proof74" style="display: none;">
<span class="comment">%secdecl</span>
 VS: case Hyp1. VD: case Hyp2. apply eval_e_unique to VS VD. search.</div>


Prove library:host:eval_e_value.


Prove library:host:eval_s_value.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(75);" id="toggleproof75">[Show Proof]</a>
<div class="proof" id="proof75" style="display: none;">
<span class="comment">%X-secdecl</span>
 apply eval_e_value to Ev1 _. case Mem. search. backchain AllVal.</div>


Prove library:host:vars_eval_same_result.



<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                         SECURITY THEOREMS                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>

<span class="comment">%because we don't have fixed types in Sterling, we make our own by
%adding this property</span>
Extensible_Theorem
  sl_form : forall SL,
    Is : is_sl SL ->
    SL = public \/ SL = private
  on Is.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(76);" id="toggleproof76">[Show Proof]</a>
<div class="proof" id="proof76" style="display: none;">
<span class="comment">%public</span>
 search.
<span class="comment">%private</span>
 search.</div>


Theorem join_unique : forall A B S1 S2,
  join A B S1 -> join A B S2 -> S1 = S2.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(77);" id="toggleproof77">[Show Proof]</a>
<div class="proof" id="proof77" style="display: none;">
intros J1 J2. case J1.
  <span class="comment">%J-public</span>
   case J2. search.
  <span class="comment">%J-private-l</span>
   case J2.
     <span class="comment">%J-private-l</span>
      search.
     <span class="comment">%J-private-r</span>
      search.
  <span class="comment">%J-private-r</span>
   case J2.
     <span class="comment">%J-private-l</span>
      search.
     <span class="comment">%J-private-r</span>
      search.</div>

Theorem join_public : forall A B,
  join A B public -> A = public /\ B = public.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(78);" id="toggleproof78">[Show Proof]</a>
<div class="proof" id="proof78" style="display: none;">
intros J. case J. search.</div>


Extensible_Theorem
  level_public_vars : forall SG E V X,
    Lev : level SG E public ->
    Vars : vars E V ->
    Mem : mem X V ->
    lookup SG X public
  on Lev.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(79);" id="toggleproof79">[Show Proof]</a>
<div class="proof" id="proof79" style="display: none;">
<span class="comment">%L-int</span>
 case Vars. case Mem.
<span class="comment">%L-true</span>
 case Vars. case Mem.
<span class="comment">%L-false</span>
 case Vars. case Mem.
<span class="comment">%L-var</span>
 case Vars. M: case Mem.
   <span class="comment">%Mem-Here</span>
    search.
   <span class="comment">%Mem-Later</span>
    case M.
<span class="comment">%L-add</span>
 V: case Vars. apply join_public to Lev3.
 Or: apply mem_append to Mem V2. M: case Or.
   <span class="comment">%mem X Vr1</span>
    apply IH to Lev1 V M. search.
   <span class="comment">%mem X Vr2</span>
    apply IH to Lev2 V1 M. search.
<span class="comment">%L-eq</span>
 V: case Vars. apply join_public to Lev3.
 Or: apply mem_append to Mem V2. M: case Or.
   <span class="comment">%mem X Vr1</span>
    apply IH to Lev1 V M. search.
   <span class="comment">%mem X Vr2</span>
    apply IH to Lev2 V1 M. search.
<span class="comment">%L-gt</span>
 V: case Vars. apply join_public to Lev3.
 Or: apply mem_append to Mem V2. M: case Or.
   <span class="comment">%mem X Vr1</span>
    apply IH to Lev1 V M. search.
   <span class="comment">%mem X Vr2</span>
    apply IH to Lev2 V1 M. search.
<span class="comment">%L-not</span>
 V: case Vars. apply IH to Lev1 V Mem. search.
<span class="comment">%LF-level</span>
 V: apply trans_e_vars_exist to Lev1 Vars.
 M: apply trans_e_vars to Lev1 Vars V Mem. apply IH to Lev2 V M.
 search.</div>


Define public_equiv :
  list (pair string sl) -> list (pair string e) ->
  list (pair string e) -> prop by
public_equiv S G1 G2 :=
  (forall X V,
      lookup S X public ->
      lookup G1 X V -> lookup G2 X V) /\
  (forall X V,
      lookup S X public ->
      lookup G2 X V -> lookup G1 X V).

Theorem public_equiv_trans : forall SG GA GB GC,
  public_equiv SG GA GB -> public_equiv SG GB GC ->
  public_equiv SG GA GC.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(80);" id="toggleproof80">[Show Proof]</a>
<div class="proof" id="proof80" style="display: none;">
intros PEAB PEBC. PEAB: case PEAB. PEBC: case PEBC. unfold.
  <span class="comment">%First part</span>
   intros LkpSec LkpA. LkpB: apply PEAB to LkpSec LkpA.
   apply PEBC to LkpSec LkpB. search.
  <span class="comment">%Second part</span>
   intros LkpSec LkpC. LkpB: apply PEBC1 to LkpSec LkpC.
   apply PEAB1 to LkpSec LkpB. search.</div>


Theorem public_equiv_symm : forall SG GA GB,
  public_equiv SG GA GB -> public_equiv SG GB GA.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(81);" id="toggleproof81">[Show Proof]</a>
<div class="proof" id="proof81" style="display: none;">
intros Rel. Rel: case Rel. unfold.
  <span class="comment">%First part</span>
   intros LkpSec LkpB. apply Rel1 to LkpSec LkpB. search.
  <span class="comment">%Second part</span>
   intros LkpSec LkpA. apply Rel to LkpSec LkpA. search.</div>


Theorem public_equiv_refl : forall SG G,
  public_equiv SG G G.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(82);" id="toggleproof82">[Show Proof]</a>
<div class="proof" id="proof82" style="display: none;">
intros. unfold.
  <span class="comment">%First part</span>
   intros. search.
  <span class="comment">%Second part</span>
   intros. search.</div>


Theorem level_secure : forall SG G1 G2 E V1 V2,
  is_e E -> level SG E public -> public_equiv SG G1 G2 ->
  eval_e G1 E V1 -> eval_e G2 E V2 ->
  V1 = V2.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(83);" id="toggleproof83">[Show Proof]</a>
<div class="proof" id="proof83" style="display: none;">
intros IsE Lev Equiv Ev1 Ev2. Vars: apply vars_exist to IsE.
Equiv: case Equiv. apply vars_eval_same_result to _ Vars Ev1 Ev2.
  intros Mem Lkp1 Lkp2. LkpS: apply level_public_vars to Lev Vars Mem.
  <span class="comment">%</span>
  L: apply Equiv to LkpS Lkp1. apply lookup_unique to L Lkp2. search.
search.</div>


Extensible_Theorem
  level_unique : forall SG E S1 S2,
    LevA : level SG E S1 ->
    LevB : level SG E S2 ->
    S1 = S2
  on LevA.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(84);" id="toggleproof84">[Show Proof]</a>
<div class="proof" id="proof84" style="display: none;">
<span class="comment">%L-int</span>
 case LevB. search.
<span class="comment">%L-true</span>
 case LevB. search.
<span class="comment">%L-false</span>
 case LevB. search.
<span class="comment">%L-var</span>
 L: case LevB. apply lookup_unique to LevA1 L. search.
<span class="comment">%L-add</span>
 L: case LevB. apply IH to LevA1 L. apply IH to LevA2 L1.
 apply join_unique to LevA3 L2. search.
<span class="comment">%L-eq</span>
 L: case LevB. apply IH to LevA1 L. apply IH to LevA2 L1.
 apply join_unique to LevA3 L2. search.
<span class="comment">%L-gt</span>
 L: case LevB. apply IH to LevA1 L. apply IH to LevA2 L1.
 apply join_unique to LevA3 L2. search.
<span class="comment">%L-not</span>
 L: case LevB. apply IH to LevA1 L. search.
<span class="comment">%LF-level</span>
 L: case LevB. apply trans_e_unique to LevA1 L. apply IH to LevA2 L1.
 search.</div>


Theorem level_not_public : forall SG G1 G2 E V1 V2,
  is_e E -> public_equiv SG G1 G2 -> level SG E public ->
  eval_e G1 E V1 -> eval_e G2 E V2 -> (V1 = V2 -> false) ->
  false.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(85);" id="toggleproof85">[Show Proof]</a>
<div class="proof" id="proof85" style="display: none;">
intros Is Equiv Lev Ev1 Ev2 NEq.
apply level_secure to Is Lev Equiv Ev1 Ev2. backchain NEq.</div>


Extensible_Theorem
  stmt_public_branch : forall SG SL SG2 S X,
    Sec : secure SG SL S SG2 ->
    LkpSec : lookup SG X public ->
    lookup SG2 X public
  on Sec.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(86);" id="toggleproof86">[Show Proof]</a>
<div class="proof" id="proof86" style="display: none;">
<span class="comment">%S-skip</span>
 search.
<span class="comment">%S-seq</span>
 L: apply IH to Sec1 LkpSec. apply IH to Sec2 L. search.
<span class="comment">%S-decl</span>
 assert N = X -> false.
   intros E. case E. apply no_lookup to Sec2 LkpSec.
 search.
<span class="comment">%S-assign-private</span>
 search.
<span class="comment">%S-assign-public</span>
 search.
<span class="comment">%S-ifte</span>
 search.
<span class="comment">%S-while</span>
 search.
<span class="comment">%S-secdecl-private</span>
 assert N = X -> false.
   intros E. case E. apply no_lookup to Sec2 LkpSec.
 search.
<span class="comment">%S-secdecl-public</span>
 assert N = X -> false.
   intros E. case E. apply no_lookup to Sec2 LkpSec.
 search.
<span class="comment">%LF-secure</span>
 apply IH to Sec2 LkpSec. search.</div>


Theorem public_equiv_swap : forall SG SG' GA GB,
  (forall X, lookup SG X public -> lookup SG' X public) ->
  public_equiv SG' GA GB -> public_equiv SG GA GB.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(87);" id="toggleproof87">[Show Proof]</a>
<div class="proof" id="proof87" style="display: none;">
intros LkpEquiv Eq. Eq: case Eq. unfold.
  <span class="comment">%First part</span>
   intros LkpSec LkpA. LkpSG': apply LkpEquiv to LkpSec.
   apply Eq to LkpSG' LkpA. search.
  <span class="comment">%Second part</span>
   intros LkpSec LkpB. LkpSG': apply LkpEquiv to LkpSec.
   apply Eq1 to LkpSG' LkpB. search.</div>


Extensible_Theorem
  stmt_not_public_no_public_change : forall S SG SL SG1 G G1,
    Sec : secure SG SL S SG1 ->
    NEq : (SL = public -> false) ->
    Ev : eval_s G S G1 ->
    public_equiv SG G G1
  on Ev.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(88);" id="toggleproof88">[Show Proof]</a>
<div class="proof" id="proof88" style="display: none;">
<span class="comment">%X-skip</span>
 case Sec. backchain public_equiv_refl.
<span class="comment">%X-decl</span>
 Sec: case Sec. apply NEq to _.
<span class="comment">%X-assign</span>
 Sec: case Sec.
   <span class="comment">%S-assign-private</span>
    unfold.
      <span class="comment">%1</span>
       intros LS LA. N: assert N = X -> false.
         intros E. case E. apply lookup_unique to Sec1 LS.
       assert X = N -> false. intros E. case E. backchain N.
       apply select_lookup to LA Ev2 _. search.
      <span class="comment">%2</span>
       intros LS LB. L: case LB.
         <span class="comment">%Lkp-Here</span>
          apply lookup_unique to Sec1 LS.
         <span class="comment">%Lkp-Later</span>
          assert X = N -> false. intros E. case E. backchain L.
          apply lookup_after_select_before to L1 Ev2 _. search.
   <span class="comment">%S-assign-public</span>
    apply NEq to _.
<span class="comment">%X-seq</span>
 Sec: case Sec. PE1: apply IH to Sec _ Ev1.
 PE2: apply IH to Sec1 _ Ev2.
 E: assert forall X, lookup SG X public -> lookup SG2 X public.
   intros L. L': apply stmt_public_branch to Sec L. search.
 PE': apply public_equiv_swap to E PE2.
 apply public_equiv_trans to PE1 PE'. search.
<span class="comment">%X-ifte-True</span>
 Sec: case Sec. assert Sl1 = public -> false.
   intros E. case E. backchain NEq. apply join_public to Sec1. search.
 apply IH to Sec2 _ Ev2. search.
<span class="comment">%X-ifte-False</span>
 Sec: case Sec. assert Sl1 = public -> false.
   intros E. case E. backchain NEq. apply join_public to Sec1. search.
 apply IH to Sec3 _ Ev2. search.
<span class="comment">%X-while-True</span>
 Sec: case Sec (keep).
 assert Sl1 = public -> false.
   intros E. case E. backchain NEq. apply join_public to Sec2. search.
 EqGG2: apply IH to Sec3 _ Ev2. EqG2G1: apply IH to _ _ Ev3.
 apply public_equiv_trans to EqGG2 EqG2G1. search.
<span class="comment">%X-while-False</span>
 unfold.
   <span class="comment">%First part</span>
    intros LkpSec LkpG1. search.
   <span class="comment">%Second part</span>
    intros LkpSec LkpG1. search.
<span class="comment">%X-secdecl</span>
 Sec: case Sec.
   <span class="comment">%S-secdecl-private</span>
    unfold.
      <span class="comment">%1</span>
       intros LkpSec LkpG. assert (N = X -> false).
         intros E. case E. apply no_lookup to Sec1 LkpSec.
       search.
      <span class="comment">%2</span>
       intros LkpSec LkpG+. Lkp: case LkpG+.
         <span class="comment">%LkpG+ here</span>
          apply no_lookup to Sec1 LkpSec.
         <span class="comment">%LkpG+ later</span>
          search.
   <span class="comment">%S-secdecl-private</span>
    apply NEq to _.
<span class="comment">%preservability</span>
 Sec: case Sec. apply trans_s_unique to Ev2 Sec. apply IH to _ _ Ev1.
 search.</div>


Theorem while_no_public_change : forall SG SL SG' Cond Body S G G2,
  secure SG SL (while Cond Body) SG' -> level SG Cond S ->
  (S = public -> false) -> eval_s G (while Cond Body) G2 ->
  public_equiv SG G G2.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(89);" id="toggleproof89">[Show Proof]</a>
<div class="proof" id="proof89" style="display: none;">
induction on 4. intros Sec Lev NEq Ev. Ev: case Ev.
  <span class="comment">%X-while-True</span>
   EqG1G2: apply IH to Sec Lev NEq Ev2. Sec: case Sec.
   EqGG1: apply stmt_not_public_no_public_change to Sec2 _ Ev1.
     intros Eq. case Eq. apply join_public to Sec1.
     apply level_unique to Lev Sec. backchain NEq.
   apply public_equiv_trans to EqGG1 EqG1G2. search.
  <span class="comment">%X-while-False</span>
   backchain public_equiv_refl.</div>


Extensible_Theorem
  stmt_secure : forall S SG SL SG1 GA GA' GB GB',
    Is : is_s S ->
    Sec : secure SG SL S SG1 ->
    Rel : public_equiv SG GA GB ->
    EvA : eval_s GA S GA' ->
    EvB : eval_s GB S GB' ->
    public_equiv SG1 GA' GB'
  on EvA.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(90);" id="toggleproof90">[Show Proof]</a>
<div class="proof" id="proof90" style="display: none;">
<span class="comment">%X-skip</span>
 case EvB. case Sec. search.
<span class="comment">%X-decl</span>
 EvB: case EvB. Sec: case Sec. Is: case Is.
 apply level_secure to _ _ Rel EvA1 EvB. unfold.
   <span class="comment">%1</span>
    intros LkpSec LkpA. LkpSec: case LkpSec.
      <span class="comment">%LkpSec here</span>
       LkpA: case LkpA.
         <span class="comment">%LkpA here</span>
          search.
         <span class="comment">%LkpA later</span>
          apply LkpA to _.
      <span class="comment">%LkpSec later</span>
       LkpA: case LkpA.
         <span class="comment">%LkpA here</span>
          apply LkpSec to _.
         <span class="comment">%LkpA later</span>
          Rel: case Rel. apply Rel to LkpSec1 LkpA1. search.
   <span class="comment">%2</span>
    intros LkpSec LkpB. LkpSec: case LkpSec.
      <span class="comment">%LkpSec here</span>
       LkpB: case LkpB.
         <span class="comment">%LkpB here</span>
          search.
         <span class="comment">%LkpB later</span>
          apply LkpB to _.
      <span class="comment">%LkpSec later</span>
       LkpB: case LkpB.
         <span class="comment">%LkpB here</span>
          apply LkpSec to _.
         <span class="comment">%LkpB later</span>
          Rel: case Rel. apply Rel1 to LkpSec1 LkpB1. search.
<span class="comment">%X-assign</span>
 EvB: case EvB. Is: case Is. Sec: case Sec.
   <span class="comment">%S-assign-private</span>
    unfold.
      <span class="comment">%1</span>
       intros LkpSec LkpA. LkpA: case LkpA.
         <span class="comment">%LkpA here</span>
          apply lookup_unique to Sec1 LkpSec.
         <span class="comment">%LkpA later</span>
          assert X = N -> false. intros E. case E. backchain LkpA.
          L: apply lookup_after_select_before to LkpA1 EvA2 _.
          R: case Rel. LB: apply R to _ L.
          apply select_lookup to LB EvB1 _. search.
      <span class="comment">%2</span>
       intros LkpSec LkpB. LkpB: case LkpB.
         <span class="comment">%LkpA here</span>
          apply lookup_unique to Sec1 LkpSec.
         <span class="comment">%LkpA later</span>
          assert X = N -> false. intros E. case E. backchain LkpB.
          L: apply lookup_after_select_before to LkpB1 EvB1 _.
          R: case Rel. LA: apply R1 to _ L.
          apply select_lookup to LA EvA2 _. search.
   <span class="comment">%S-assign-public</span>
    apply level_secure to _ Sec Rel EvA1 EvB. unfold.
      <span class="comment">%1</span>
       intros LkpSec LkpA. LkpA: case LkpA.
         <span class="comment">%LkpA here</span>
          search.
         <span class="comment">%LkpA later</span>
          assert X = N -> false. intros E. case E. backchain LkpA.
          LGA: apply lookup_after_select_before to LkpA1 EvA2 _.
          R: case Rel. LGB: apply R to LkpSec LGA.
          apply select_lookup to LGB EvB1 _. search.
      <span class="comment">%2</span>
       intros LkpSec LkpB. LkpB: case LkpB.
         <span class="comment">%LkpB here</span>
          search.
         <span class="comment">%LkpB later</span>
          assert X = N -> false. intros E. case E. backchain LkpB.
          LGB: apply lookup_after_select_before to LkpB1 EvB1 _.
          R: case Rel. LGA: apply R1 to LkpSec LGB.
          apply select_lookup to LGA EvA2 _. search.
<span class="comment">%X-seq</span>
 EvB: case EvB. Sec: case Sec. Is: case Is.
 apply IH to _ _ _ EvA1 EvB. apply IH to _ _ _ EvA2 EvB1. search.
<span class="comment">%X-ifte-True</span>
 Is: case Is. Sec: case Sec. EvB: case EvB.
   <span class="comment">%EvB by E-ifte-True</span>
    EqGA'GB': apply IH to _ _ _ EvA2 EvB1.
    LkpEq: assert forall X, lookup SG1 X public -> lookup SG2 X public.
      intros Lkp. apply stmt_public_branch to Sec2 Lkp. search.
    apply public_equiv_swap to LkpEq EqGA'GB'. search.
   <span class="comment">%EvB by E-ifte-False</span>
    NEq: assert L = public -> false.
      intros E. case E. apply level_not_public to Is _ Sec EvA1 EvB _.
    EqGAGA': apply stmt_not_public_no_public_change to Sec2 _ EvA2.
      intros E. case E. apply join_public to Sec1. backchain NEq.
    EqGBGB': apply stmt_not_public_no_public_change to Sec3 _ EvB1.
      intros E. case E. apply join_public to Sec1.  backchain NEq.
    EqGAGB': apply public_equiv_trans to Rel EqGBGB'.
    EqGA'GA: apply public_equiv_symm to EqGAGA'.
    EqGA'GB: apply public_equiv_trans to EqGA'GA Rel.
    apply public_equiv_trans to EqGA'GB EqGBGB'. search.
<span class="comment">%X-ifte-False</span>
 Is: case Is. Sec: case Sec. EvB: case EvB.
   <span class="comment">%EvB by E-ifte-True</span>
    NEq: assert L = public -> false.
      intros E. case E. apply level_not_public to Is _ _ EvA1 EvB _.
    EqGAGA': apply stmt_not_public_no_public_change to Sec3 _ EvA2.
      intros E. case E. apply join_public to Sec1. backchain NEq.
    EqGBGB': apply stmt_not_public_no_public_change to Sec2 _ EvB1.
      intros E. case E. apply join_public to Sec1. backchain NEq.
    EqGAGB': apply public_equiv_trans to Rel EqGBGB'.
    EqGA'GA: apply public_equiv_symm to EqGAGA'.
    EqGA'GB: apply public_equiv_trans to EqGA'GA Rel.
    apply public_equiv_trans to EqGA'GB EqGBGB'. search.
   <span class="comment">%EvB by E-ifte-False</span>
    EqGA'GB': apply IH to _ _ _ EvA2 EvB1.
    LkpEq: assert forall X, lookup SG1 X public -> lookup SG3 X public.
      intros Lkp. apply stmt_public_branch to Sec3 Lkp. search.
    apply public_equiv_swap to LkpEq EqGA'GB'. search.
<span class="comment">%X-while-True</span>
 Is: case Is (keep). Sec: case Sec (keep). EvB: case EvB.
   <span class="comment">%EvB by E-while-True</span>
    EqG1G3: apply IH to _ _ _ EvA2 EvB1.
    LEq: assert forall X, lookup SG1 X public -> lookup SG2 X public.
      intros Lkp. apply stmt_public_branch to Sec3 Lkp. search.
    apply public_equiv_swap to LEq EqG1G3.
    EqG1GA': apply IH to Is Sec _ EvA3 EvB2. search.
   <span class="comment">%EvB by X-while-False</span>
    SNEq: assert L = public -> false.
      intros E. case E. apply level_not_public to Is1 _ _ EvA1 EvB _.
    EqGAG1: apply stmt_not_public_no_public_change to Sec3 _ EvA2.
      intros E. case E. apply join_public to Sec2. backchain SNEq.
    EqG1GA': apply while_no_public_change to Sec Sec1 _ EvA3.
    EqGAGA': apply public_equiv_trans to EqGAG1 EqG1GA'.
    EqGA'GA: apply public_equiv_symm to EqGAGA'.
    apply public_equiv_trans to EqGA'GA Rel. search.
<span class="comment">%X-while-False</span>
 Is: case Is (keep). Sec: case Sec (keep). EvB: case EvB.
   <span class="comment">%EvB by E-while-True</span>
    SNEq: assert L = public -> false.
      intros E. case E. apply level_not_public to Is1 _ _ EvA1 EvB _.
    EqGBG2: apply stmt_not_public_no_public_change to Sec3 _ EvB1.
      intros E. case E. apply join_public to Sec2. backchain SNEq.
    EqGA'G2: apply public_equiv_trans to Rel EqGBG2.
    EqG2GB': apply while_no_public_change to Sec Sec1 _ EvB2.
    apply public_equiv_trans to EqGA'G2 EqG2GB'. search.
   <span class="comment">%EvB by E-while-False</span>
    search.
<span class="comment">%X-secdecl</span>
 EvB: case EvB. Is: case Is. Sec: case Sec.
   <span class="comment">%S-secdecl-private</span>
    unfold.
      <span class="comment">%1</span>
       intros LkpSec Lkp. LkpSec: case LkpSec. Lkp: case Lkp.
         <span class="comment">%Lkp here</span>
          apply LkpSec to _.
         <span class="comment">%Lkp later</span>
          Rel: case Rel. apply Rel to LkpSec1 Lkp1. search.
      <span class="comment">%2</span>
       intros LkpSec Lkp. LkpSec: case LkpSec. Lkp: case Lkp.
         <span class="comment">%Lkp here</span>
          apply LkpSec to _.
         <span class="comment">%Lkp later</span>
          Rel: case Rel. apply Rel1 to LkpSec1 Lkp1. search.
   <span class="comment">%S-secdecl-public</span>
    apply level_secure to _ Sec Rel EvA1 EvB. unfold.
      <span class="comment">%1</span>
       intros LkpSec Lkp. LkpSec: case LkpSec.
         <span class="comment">%LkpSec here</span>
          Lkp: case Lkp.
            <span class="comment">%Lkp here</span>
             search.
            <span class="comment">%Lkp later</span>
             apply Lkp to _.
         <span class="comment">%LkpSec later</span>
          Lkp: case Lkp.
            <span class="comment">%Lkp here</span>
             apply LkpSec to _.
            <span class="comment">%Lkp later</span>
             Rel: case Rel. apply Rel to LkpSec1 Lkp1. search.
      <span class="comment">%2</span>
       intros LkpSec Lkp. LkpSec: case LkpSec.
         <span class="comment">%LkpSec here</span>
          Lkp: case Lkp.
            <span class="comment">%Lkp here</span>
             search.
            <span class="comment">%Lkp later</span>
             apply Lkp to _.
         <span class="comment">%LkpSec later</span>
          Lkp: case Lkp.
            <span class="comment">%Lkp here</span>
             apply LkpSec to _.
            <span class="comment">%Lkp later</span>
             Rel: case Rel. apply Rel1 to LkpSec1 Lkp1. search.
<span class="comment">%preservability</span>
 Sec: case Sec. apply trans_s_unique to EvA2 Sec.
 EvBTrans: apply trans_s_eval to EvA2 EvB.
 IsCT: apply trans_s_is to Sec Is.
 Equiv: apply IH to _ Sec1 Rel EvA1 EvBTrans.
 LkpGB'G': assert forall X V, lookup GB' X V -> lookup G' X V.
   intros L. apply trans_s_eval_results to EvA2 EvB EvBTrans L. search.
 EqG'GB': assert public_equiv SG1 G' GB'.
   unfold.
     <span class="comment">%1</span>
      intros LkpSec LkpG'.
      apply trans_s_eval_results_back to Sec EvB EvBTrans LkpG'. search.
     <span class="comment">%2</span>
      intros LkpSec LkpGB'. backchain LkpGB'G'.
 apply public_equiv_trans to Equiv EqG'GB'. search.</div></pre>

  <p>
    We compile this so we can build the composition:
    <pre class="code">
extensibella --check --compile security.xthm</pre>
  </p>
</div>

<div class="section" id="composition">
  <h2>Proof Composition</h2>
  <p>
    In addition to checking proofs are modularly valid, Extensibella
    can also compose them to form a valid Abella proof of all the
    properties in the full language.  To build a composed proof for
    the host language with both extensions, we need to create a module
    bringing them all together.  We will call
    this <code>library:composed</code>.  This module will not
    introduce anything new to the language, only pulling in the
    previous pieces.
  </p>
  <span class="highlight">composed.sos</span>
  <pre class="code sterling" id="composed.sos">
Module library:composed

Builds on library:host
Builds on library:list
Builds on library:security</pre>

  <p>
    We will need to compile this twice, once for a regular
    Extensibella proof, the same way we have compiled the others, and
    once for the Extensibella composition, as these have slightly
    different requirements.
    <pre class="code">
sterling --extensibella library:composed
sterling --extensibellaFull library:composed</pre>
  </p>

  <p>
    We also need to create an Extensibella file for the composed
    module.  This is necessary for Extensibella to know what
    properties the modules in the composition add, if any.  Since we
    don't want to add any properties, this will simply be the file
    Extensibella generates, which includes the properties introduced
    by the host language and both extensions.  We also need to compile
    this file for the composition.
  </p>
    <pre class="code">
extensibella --generate library:composed composed.xthm
extensibella --check --compile composed.xthm</pre>
    <span class="highlight">composed.xthm</span>
    <a class="fold-link" href="javascript:void" id="togglecomposed.xthm"
       onclick="toggleFile('composed.xthm')">[Expand File]</a>
    <pre class="code extensibella" id="composed.xthm" style="max-height: 105px;">
Module library:composed.


Prove_Constraint library:host:trans_e_unique.


Prove_Constraint library:host:trans_e_is.


Prove_Constraint library:host:trans_s_unique.


Prove_Constraint library:host:trans_s_is.


Prove_Constraint library:host:trans_ty_unique.


Prove_Constraint library:host:trans_ty_is.


Prove_Ext_Ind library:host:is_e.


Prove library:host:is_e_var_or_not.


Prove library:host:is_e_intlit_or_not.


Prove library:host:is_e_trueE_or_not.


Prove library:host:is_e_falseE_or_not.


Prove library:host:is_e_add_or_not.


Prove library:host:is_e_eqC_or_not.


Prove library:host:is_e_gt_or_not.


Prove library:host:is_e_not_or_not.


Prove library:list:is_e_nil_or_not.


Prove library:list:is_e_cons_or_not.


Prove library:list:is_e_null_or_not.


Prove library:list:is_e_head_or_not.


Prove library:list:is_e_tail_or_not.


Prove library:host:is_e_eq_or_not.


Prove library:host:vars_unique.


Prove_Constraint library:host:trans_e_vars_exist.


Prove_Constraint library:host:trans_e_vars.


Prove library:host:vars_is.


Prove library:host:vars_exist.


Prove library:host:value_empty_typable.


Prove library:host:eval_e_is.


Prove library:host:type_preservation_e.


Prove library:host:var_types_maintained.


Prove library:host:type_preservation_s.


Prove_Constraint library:host:trans_eval_e.


Prove library:host:eval_e_unique.


Prove_Constraint library:host:trans_s_eval.


Prove_Ext_Ind library:host:eval_s.


Prove_Constraint library:host:trans_s_eval_results.


Prove_Constraint library:host:trans_s_eval_results_back.


Prove library:host:eval_e_value.


Prove library:host:eval_s_value.


Prove library:host:vars_eval_same_result.


Prove library:security:sl_form.


Prove library:security:level_public_vars.


Prove library:security:level_unique.


Prove library:security:stmt_public_branch.


Prove library:security:stmt_not_public_no_public_change.


Prove library:security:stmt_secure.</pre>

  <p>
    We now have all the pieces necessary to have Extensibella build
    the composition.  To do so, we give the name of the file to be
    output, along with the module for which we are building the
    composition, as well as all the proof files for the modules
    included in the composition:
    <pre class="code">
extensibella --compose out.thm library:composed host.xthm list.xthm security.xthm composed.xthm path/to/sterling/stdLib/stdLib.xthm</pre>
    Note we need to include the Extensibella proof file for the
    Sterling standard library as well, since the standard library is
    included in all Sterling modules, so its properties are also
    included in the Extensibella modules using them and their proofs
    are needed for the composition.
  </p>

  <p>
    The produced Abella file, <code>out.thm</code> in our example,
    contains the Abella specification of the language and Abella
    proofs of each property from any module in the composition.
  </p>
  <span class="highlight">out.thm</span>
  <a class="fold-link" href="javascript:void" id="toggleout.thm"
     onclick="toggleFile('out.thm')">[Expand File]</a>
  <pre class="code abella" id="out.thm" style="max-height: 105px;">
<span class="comment">/********************************************************************
 Extensibella Standard Library
 ********************************************************************/</span>
Kind $lib__bool   type.
Kind $lib__nat    type.
Kind $lib__pair   type -> type -> type.
Import "/path/to/extensibella/stdLib/bools".
Import "/path/to/extensibella/stdLib/integers".
Import "/path/to/extensibella/stdLib/integer_addition".
Import "/path/to/extensibella/stdLib/integer_multiplication".
Import "/path/to/extensibella/stdLib/integer_division".
Import "/path/to/extensibella/stdLib/integer_comparison".
Import "/path/to/extensibella/stdLib/lists".
Import "/path/to/extensibella/stdLib/strings".
Import "/path/to/extensibella/stdLib/pairs".
Import "/path/to/extensibella/stdLib/extSize_induction".


<span class="comment">/********************************************************************
 Language Definition
 ********************************************************************/</span>
Kind $ty__library-$-security-$-sl   type.
Kind $ty__library-$-host-$-s   type.
Kind $ty__library-$-host-$-e   type.
Kind $ty__library-$-host-$-ty   type.


Type library-$-security-$-secdecl   (list $char) -> ($ty__library-$-host-$-ty) -> ($ty__library-$-security-$-sl) -> ($ty__library-$-host-$-e) -> $ty__library-$-host-$-s.
Type library-$-security-$-public   $ty__library-$-security-$-sl.
Type library-$-security-$-private   $ty__library-$-security-$-sl.
Type library-$-list-$-nil   $ty__library-$-host-$-e.
Type library-$-list-$-cons   ($ty__library-$-host-$-e) -> ($ty__library-$-host-$-e) -> $ty__library-$-host-$-e.
Type library-$-list-$-null   ($ty__library-$-host-$-e) -> $ty__library-$-host-$-e.
Type library-$-list-$-head   ($ty__library-$-host-$-e) -> $ty__library-$-host-$-e.
Type library-$-list-$-tail   ($ty__library-$-host-$-e) -> $ty__library-$-host-$-e.
Type library-$-list-$-list   ($ty__library-$-host-$-ty) -> $ty__library-$-host-$-ty.
Type library-$-list-$-splitlist   (list $char) -> (list $char) -> ($ty__library-$-host-$-e) -> $ty__library-$-host-$-s.
Type library-$-host-$-skipS   $ty__library-$-host-$-s.
Type library-$-host-$-decl   (list $char) -> ($ty__library-$-host-$-ty) -> ($ty__library-$-host-$-e) -> $ty__library-$-host-$-s.
Type library-$-host-$-assign   (list $char) -> ($ty__library-$-host-$-e) -> $ty__library-$-host-$-s.
Type library-$-host-$-seq   ($ty__library-$-host-$-s) -> ($ty__library-$-host-$-s) -> $ty__library-$-host-$-s.
Type library-$-host-$-ifte   ($ty__library-$-host-$-e) -> ($ty__library-$-host-$-s) -> ($ty__library-$-host-$-s) -> $ty__library-$-host-$-s.
Type library-$-host-$-while   ($ty__library-$-host-$-e) -> ($ty__library-$-host-$-s) -> $ty__library-$-host-$-s.
Type library-$-host-$-var   (list $char) -> $ty__library-$-host-$-e.
Type library-$-host-$-intlit   ($lib__integer) -> $ty__library-$-host-$-e.
Type library-$-host-$-trueE   $ty__library-$-host-$-e.
Type library-$-host-$-falseE   $ty__library-$-host-$-e.
Type library-$-host-$-add   ($ty__library-$-host-$-e) -> ($ty__library-$-host-$-e) -> $ty__library-$-host-$-e.
Type library-$-host-$-eq   ($ty__library-$-host-$-e) -> ($ty__library-$-host-$-e) -> $ty__library-$-host-$-e.
Type library-$-host-$-gt   ($ty__library-$-host-$-e) -> ($ty__library-$-host-$-e) -> $ty__library-$-host-$-e.
Type library-$-host-$-not   ($ty__library-$-host-$-e) -> $ty__library-$-host-$-e.
Type library-$-host-$-intTy   $ty__library-$-host-$-ty.
Type library-$-host-$-bool   $ty__library-$-host-$-ty.


Define $fix__sterling-$-stdLib-$-range : ($lib__integer) -> ($lib__integer) -> (list ($lib__integer)) -> prop by
$fix__sterling-$-stdLib-$-range (Low) (High) (nil) := $greater_integer (Low) (High);
$fix__sterling-$-stdLib-$-range (Low) (High) ((Low)::(Rest)) := exists PlusOne, ($lesseq_integer (Low) (High)) /\ (($plus_integer ($posInt ($succ ($zero))) (Low) (PlusOne)) /\ ($fix__sterling-$-stdLib-$-range (PlusOne) (High) (Rest))).
Define $fix__sterling-$-stdLib-$-take : ($lib__integer) -> (list (Var_A)) -> (list (Var_A)) -> prop by
$fix__sterling-$-stdLib-$-take ($posInt ($zero)) (L) (nil);
$fix__sterling-$-stdLib-$-take (N) ((X)::(L)) ((X)::(F)) := exists N1, ($plus_integer ($posInt ($succ ($zero))) (N1) (N)) /\ ($fix__sterling-$-stdLib-$-take (N1) (L) (F)).
Define $fix__sterling-$-stdLib-$-drop : ($lib__integer) -> (list (Var_A)) -> (list (Var_A)) -> prop by
$fix__sterling-$-stdLib-$-drop ($posInt ($zero)) (L) (L);
$fix__sterling-$-stdLib-$-drop (N) ((X)::(L)) (R) := exists N1, ($plus_integer ($posInt ($succ ($zero))) (N1) (N)) /\ ($fix__sterling-$-stdLib-$-drop (N1) (L) (R)).
Define $fix__sterling-$-stdLib-$-zip : (list (Var_A)) -> (list (Var_B)) -> (list ($lib__pair (Var_A) (Var_B))) -> prop by
$fix__sterling-$-stdLib-$-zip (nil) (nil) (nil);
$fix__sterling-$-stdLib-$-zip ((A)::(ARest)) ((B)::(BRest)) (($pair_c (A) (B))::(Rest)) := $fix__sterling-$-stdLib-$-zip (ARest) (BRest) (Rest).
Define $fix__sterling-$-stdLib-$-values : (list ($lib__pair (Var_A) (Var_B))) -> (list (Var_B)) -> prop by
$fix__sterling-$-stdLib-$-values (nil) (nil);
$fix__sterling-$-stdLib-$-values (($pair_c (A) (B))::(Rest)) ((B)::(VRest)) := $fix__sterling-$-stdLib-$-values (Rest) (VRest).
Define $fix__sterling-$-stdLib-$-domain : (list ($lib__pair (Var_A) (Var_B))) -> (list (Var_A)) -> prop by
$fix__sterling-$-stdLib-$-domain (nil) (nil);
$fix__sterling-$-stdLib-$-domain (($pair_c (A) (B))::(Rest)) ((A)::(DRest)) := $fix__sterling-$-stdLib-$-domain (Rest) (DRest).
Define $fix__sterling-$-stdLib-$-count : (Var_A) -> (list (Var_A)) -> ($lib__integer) -> prop by
$fix__sterling-$-stdLib-$-count (X) (nil) ($posInt ($zero));
$fix__sterling-$-stdLib-$-count (X) ((X)::(Rest)) (N1) := exists N, ($fix__sterling-$-stdLib-$-count (X) (Rest) (N)) /\ ($plus_integer ($posInt ($succ ($zero))) (N) (N1));
$fix__sterling-$-stdLib-$-count (X) ((Y)::(Rest)) (N) := (((X) = (Y)) -> (false)) /\ ($fix__sterling-$-stdLib-$-count (X) (Rest) (N)).
Define $fix__sterling-$-stdLib-$-select : (Var_Item) -> (list (Var_Item)) -> (list (Var_Item)) -> prop by
$fix__sterling-$-stdLib-$-select (Item) (Rest) ((Item)::(Rest));
$fix__sterling-$-stdLib-$-select (Item) ((I)::(L1)) ((I)::(L2)) := $fix__sterling-$-stdLib-$-select (Item) (L1) (L2).
Define $fix__sterling-$-stdLib-$-permutation : (list (Var_A)) -> (list (Var_A)) -> prop by
$fix__sterling-$-stdLib-$-permutation (nil) (nil);
$fix__sterling-$-stdLib-$-permutation ((A)::(Rest)) (L) := exists L2, ($fix__sterling-$-stdLib-$-select (A) (L2) (L)) /\ ($fix__sterling-$-stdLib-$-permutation (Rest) (L2)).
Define $fix__sterling-$-stdLib-$-mem : (Var_Item) -> (list (Var_Item)) -> prop by
$fix__sterling-$-stdLib-$-mem (Item) ((Item)::(Rest));
$fix__sterling-$-stdLib-$-mem (Item) ((I)::(Rest)) := $fix__sterling-$-stdLib-$-mem (Item) (Rest).
Define $fix__sterling-$-stdLib-$-subset : (list (Var_A)) -> (list (Var_A)) -> prop by
$fix__sterling-$-stdLib-$-subset (nil) (L);
$fix__sterling-$-stdLib-$-subset ((X)::(Rest)) (Supset) := ($fix__sterling-$-stdLib-$-mem (X) (Supset)) /\ ($fix__sterling-$-stdLib-$-subset (Rest) (Supset)).
Define $fix__sterling-$-stdLib-$-not_mem : (Var_Item) -> (list (Var_Item)) -> prop by
$fix__sterling-$-stdLib-$-not_mem (Item) (nil);
$fix__sterling-$-stdLib-$-not_mem (Item) ((I)::(Rest)) := (((I) = (Item)) -> (false)) /\ ($fix__sterling-$-stdLib-$-not_mem (Item) (Rest)).
Define $fix__sterling-$-stdLib-$-no_lookup : (list ($lib__pair (Var_Key) (Var_Item))) -> (Var_Key) -> prop by
$fix__sterling-$-stdLib-$-no_lookup (nil) (Key);
$fix__sterling-$-stdLib-$-no_lookup (($pair_c (K) (V))::(Rest)) (Key) := (((K) = (Key)) -> (false)) /\ ($fix__sterling-$-stdLib-$-no_lookup (Rest) (Key)).
Define $fix__sterling-$-stdLib-$-lookup : (list ($lib__pair (Var_Key) (Var_Item))) -> (Var_Key) -> (Var_Item) -> prop by
$fix__sterling-$-stdLib-$-lookup (($pair_c (Key) (Value))::(Rest)) (Key) (Value);
$fix__sterling-$-stdLib-$-lookup (($pair_c (K) (V))::(Rest)) (Key) (Value) := (((K) = (Key)) -> (false)) /\ ($fix__sterling-$-stdLib-$-lookup (Rest) (Key) (Value)).
Define $ext__0__library-$-host-$-is_ty : ($ty__library-$-host-$-ty) -> prop by
$ext__0__library-$-host-$-is_ty (library-$-host-$-intTy);
$ext__0__library-$-host-$-is_ty (library-$-host-$-bool);
$ext__0__library-$-host-$-is_ty (library-$-list-$-list (Ty)) := $ext__0__library-$-host-$-is_ty (Ty).
Define $ext__0__library-$-host-$-is_e : ($ty__library-$-host-$-e) -> prop by
$ext__0__library-$-host-$-is_e (library-$-host-$-var (S)) := is_string (S);
$ext__0__library-$-host-$-is_e (library-$-host-$-intlit (I)) := is_integer (I);
$ext__0__library-$-host-$-is_e (library-$-host-$-trueE);
$ext__0__library-$-host-$-is_e (library-$-host-$-falseE);
$ext__0__library-$-host-$-is_e (library-$-host-$-add (E1) (E)) := ($ext__0__library-$-host-$-is_e (E1)) /\ ($ext__0__library-$-host-$-is_e (E));
$ext__0__library-$-host-$-is_e (library-$-host-$-eq (E1) (E)) := ($ext__0__library-$-host-$-is_e (E1)) /\ ($ext__0__library-$-host-$-is_e (E));
$ext__0__library-$-host-$-is_e (library-$-host-$-gt (E1) (E)) := ($ext__0__library-$-host-$-is_e (E1)) /\ ($ext__0__library-$-host-$-is_e (E));
$ext__0__library-$-host-$-is_e (library-$-host-$-not (E)) := $ext__0__library-$-host-$-is_e (E);
$ext__0__library-$-host-$-is_e (library-$-list-$-nil);
$ext__0__library-$-host-$-is_e (library-$-list-$-cons (E1) (E)) := ($ext__0__library-$-host-$-is_e (E1)) /\ ($ext__0__library-$-host-$-is_e (E));
$ext__0__library-$-host-$-is_e (library-$-list-$-null (E)) := $ext__0__library-$-host-$-is_e (E);
$ext__0__library-$-host-$-is_e (library-$-list-$-head (E)) := $ext__0__library-$-host-$-is_e (E);
$ext__0__library-$-host-$-is_e (library-$-list-$-tail (E)) := $ext__0__library-$-host-$-is_e (E).
Define $ext__0__library-$-security-$-is_sl : ($ty__library-$-security-$-sl) -> prop by
$ext__0__library-$-security-$-is_sl (library-$-security-$-public);
$ext__0__library-$-security-$-is_sl (library-$-security-$-private).
Define $ext__0__library-$-host-$-is_s : ($ty__library-$-host-$-s) -> prop by
$ext__0__library-$-host-$-is_s (library-$-host-$-skipS);
$ext__0__library-$-host-$-is_s (library-$-host-$-decl (S) (Ty) (E)) := (is_string (S)) /\ (($ext__0__library-$-host-$-is_ty (Ty)) /\ ($ext__0__library-$-host-$-is_e (E)));
$ext__0__library-$-host-$-is_s (library-$-host-$-assign (S) (E)) := (is_string (S)) /\ ($ext__0__library-$-host-$-is_e (E));
$ext__0__library-$-host-$-is_s (library-$-host-$-seq (S1) (S)) := ($ext__0__library-$-host-$-is_s (S1)) /\ ($ext__0__library-$-host-$-is_s (S));
$ext__0__library-$-host-$-is_s (library-$-host-$-ifte (E) (S1) (S)) := ($ext__0__library-$-host-$-is_e (E)) /\ (($ext__0__library-$-host-$-is_s (S1)) /\ ($ext__0__library-$-host-$-is_s (S)));
$ext__0__library-$-host-$-is_s (library-$-host-$-while (E) (S)) := ($ext__0__library-$-host-$-is_e (E)) /\ ($ext__0__library-$-host-$-is_s (S));
$ext__0__library-$-host-$-is_s (library-$-list-$-splitlist (S1) (S) (E)) := (is_string (S1)) /\ ((is_string (S)) /\ ($ext__0__library-$-host-$-is_e (E)));
$ext__0__library-$-host-$-is_s (library-$-security-$-secdecl (S) (Ty) (Sl) (E)) := (is_string (S)) /\ (($ext__0__library-$-host-$-is_ty (Ty)) /\ (($ext__0__library-$-security-$-is_sl (Sl)) /\ ($ext__0__library-$-host-$-is_e (E)))).
Define $ext__1__library-$-host-$-eval_e : (list ($lib__pair (list $char) ($ty__library-$-host-$-e))) -> ($ty__library-$-host-$-e) -> ($ty__library-$-host-$-e) -> prop by
$ext__1__library-$-host-$-eval_e (G) (library-$-host-$-var (N)) (V) := $fix__sterling-$-stdLib-$-lookup (G) (N) (V);
$ext__1__library-$-host-$-eval_e (G) (library-$-host-$-intlit (I)) (library-$-host-$-intlit (I));
$ext__1__library-$-host-$-eval_e (G) (library-$-host-$-trueE) (library-$-host-$-trueE);
$ext__1__library-$-host-$-eval_e (G) (library-$-host-$-falseE) (library-$-host-$-falseE);
$ext__1__library-$-host-$-eval_e (G) (library-$-host-$-add (E1) (E2)) (library-$-host-$-intlit (I)) := exists I1 I2, ($ext__1__library-$-host-$-eval_e (G) (E1) (library-$-host-$-intlit (I1))) /\ (($ext__1__library-$-host-$-eval_e (G) (E2) (library-$-host-$-intlit (I2))) /\ ($plus_integer (I1) (I2) (I)));
$ext__1__library-$-host-$-eval_e (G) (library-$-host-$-eq (E1) (E2)) (library-$-host-$-trueE) := exists V1 V2, ($ext__1__library-$-host-$-eval_e (G) (E1) (V1)) /\ (($ext__1__library-$-host-$-eval_e (G) (E2) (V2)) /\ ((V1) = (V2)));
$ext__1__library-$-host-$-eval_e (G) (library-$-host-$-eq (E1) (E2)) (library-$-host-$-falseE) := exists V1 V2, ($ext__1__library-$-host-$-eval_e (G) (E1) (V1)) /\ (($ext__1__library-$-host-$-eval_e (G) (E2) (V2)) /\ (((V1) = (V2)) -> (false)));
$ext__1__library-$-host-$-eval_e (G) (library-$-host-$-gt (E1) (E2)) (library-$-host-$-trueE) := exists I1 I2, ($ext__1__library-$-host-$-eval_e (G) (E1) (library-$-host-$-intlit (I1))) /\ (($ext__1__library-$-host-$-eval_e (G) (E2) (library-$-host-$-intlit (I2))) /\ ($greater_integer (I1) (I2)));
$ext__1__library-$-host-$-eval_e (G) (library-$-host-$-gt (E1) (E2)) (library-$-host-$-falseE) := exists I1 I2, ($ext__1__library-$-host-$-eval_e (G) (E1) (library-$-host-$-intlit (I1))) /\ (($ext__1__library-$-host-$-eval_e (G) (E2) (library-$-host-$-intlit (I2))) /\ ($lesseq_integer (I1) (I2)));
$ext__1__library-$-host-$-eval_e (G) (library-$-host-$-not (E)) (library-$-host-$-trueE) := $ext__1__library-$-host-$-eval_e (G) (E) (library-$-host-$-falseE);
$ext__1__library-$-host-$-eval_e (G) (library-$-host-$-not (E)) (library-$-host-$-falseE) := $ext__1__library-$-host-$-eval_e (G) (E) (library-$-host-$-trueE);
$ext__1__library-$-host-$-eval_e (G) (library-$-list-$-nil) (library-$-list-$-nil);
$ext__1__library-$-host-$-eval_e (G) (library-$-list-$-cons (E1) (E2)) (library-$-list-$-cons (V1) (V2)) := ($ext__1__library-$-host-$-eval_e (G) (E1) (V1)) /\ ($ext__1__library-$-host-$-eval_e (G) (E2) (V2));
$ext__1__library-$-host-$-eval_e (G) (library-$-list-$-null (E)) (library-$-host-$-trueE) := $ext__1__library-$-host-$-eval_e (G) (E) (library-$-list-$-nil);
$ext__1__library-$-host-$-eval_e (G) (library-$-list-$-null (E)) (library-$-host-$-falseE) := exists V1 V2, $ext__1__library-$-host-$-eval_e (G) (E) (library-$-list-$-cons (V1) (V2));
$ext__1__library-$-host-$-eval_e (G) (library-$-list-$-head (E)) (V1) := exists V2, $ext__1__library-$-host-$-eval_e (G) (E) (library-$-list-$-cons (V1) (V2));
$ext__1__library-$-host-$-eval_e (G) (library-$-list-$-tail (E)) (V2) := exists V1, $ext__1__library-$-host-$-eval_e (G) (E) (library-$-list-$-cons (V1) (V2)).
Define $ext__1__library-$-host-$-eval_s : (list ($lib__pair (list $char) ($ty__library-$-host-$-e))) -> ($ty__library-$-host-$-s) -> (list ($lib__pair (list $char) ($ty__library-$-host-$-e))) -> prop by
$ext__1__library-$-host-$-eval_s (G) (library-$-host-$-skipS) (G);
$ext__1__library-$-host-$-eval_s (G) (library-$-host-$-decl (N) (Ty) (E)) (($pair_c (N) (V))::(G)) := $ext__1__library-$-host-$-eval_e (G) (E) (V);
$ext__1__library-$-host-$-eval_s (G) (library-$-host-$-assign (N) (E)) (($pair_c (N) (V))::(NewG)) := exists VOld, ($ext__1__library-$-host-$-eval_e (G) (E) (V)) /\ ($fix__sterling-$-stdLib-$-select ($pair_c (N) (VOld)) (NewG) (G));
$ext__1__library-$-host-$-eval_s (G) (library-$-host-$-seq (S1) (S2)) (G2) := exists G1, ($ext__1__library-$-host-$-eval_s (G) (S1) (G1)) /\ ($ext__1__library-$-host-$-eval_s (G1) (S2) (G2));
$ext__1__library-$-host-$-eval_s (G) (library-$-host-$-ifte (E) (S1) (S2)) (G1) := ($ext__1__library-$-host-$-eval_e (G) (E) (library-$-host-$-trueE)) /\ ($ext__1__library-$-host-$-eval_s (G) (S1) (G1));
$ext__1__library-$-host-$-eval_s (G) (library-$-host-$-ifte (E) (S1) (S2)) (G1) := ($ext__1__library-$-host-$-eval_e (G) (E) (library-$-host-$-falseE)) /\ ($ext__1__library-$-host-$-eval_s (G) (S2) (G1));
$ext__1__library-$-host-$-eval_s (G) (library-$-host-$-while (E) (S)) (G2) := exists G1, ($ext__1__library-$-host-$-eval_e (G) (E) (library-$-host-$-trueE)) /\ (($ext__1__library-$-host-$-eval_s (G) (S) (G1)) /\ ($ext__1__library-$-host-$-eval_s (G1) (library-$-host-$-while (E) (S)) (G2)));
$ext__1__library-$-host-$-eval_s (G) (library-$-host-$-while (E) (S)) (G) := $ext__1__library-$-host-$-eval_e (G) (E) (library-$-host-$-falseE);
$ext__1__library-$-host-$-eval_s (G) (library-$-list-$-splitlist (Hd) (Tl) (E)) (($pair_c (Hd) (V1))::(($pair_c (Tl) (V2))::(GTl))) := exists VHd GHd VTl, ($ext__1__library-$-host-$-eval_e (G) (E) (library-$-list-$-cons (V1) (V2))) /\ ((((Hd) = (Tl)) -> (false)) /\ (($fix__sterling-$-stdLib-$-select ($pair_c (Hd) (VHd)) (GHd) (G)) /\ ($fix__sterling-$-stdLib-$-select ($pair_c (Tl) (VTl)) (GTl) (GHd))));
$ext__1__library-$-host-$-eval_s (G) (library-$-security-$-secdecl (N) (Ty) (Sl) (E)) (($pair_c (N) (V))::(G)) := $ext__1__library-$-host-$-eval_e (G) (E) (V).
Define $ext__0__library-$-host-$-value : ($ty__library-$-host-$-e) -> prop by
$ext__0__library-$-host-$-value (library-$-host-$-intlit (I));
$ext__0__library-$-host-$-value (library-$-host-$-trueE);
$ext__0__library-$-host-$-value (library-$-host-$-falseE);
$ext__0__library-$-host-$-value (library-$-list-$-nil);
$ext__0__library-$-host-$-value (library-$-list-$-cons (E1) (E2)) := ($ext__0__library-$-host-$-value (E1)) /\ ($ext__0__library-$-host-$-value (E2)).
Define $ext__1__library-$-host-$-ty_e : (list ($lib__pair (list $char) ($ty__library-$-host-$-ty))) -> ($ty__library-$-host-$-e) -> ($ty__library-$-host-$-ty) -> prop by
$ext__1__library-$-host-$-ty_e (G) (library-$-host-$-var (N)) (Ty) := $fix__sterling-$-stdLib-$-lookup (G) (N) (Ty);
$ext__1__library-$-host-$-ty_e (G) (library-$-host-$-intlit (I)) (library-$-host-$-intTy);
$ext__1__library-$-host-$-ty_e (G) (library-$-host-$-trueE) (library-$-host-$-bool);
$ext__1__library-$-host-$-ty_e (G) (library-$-host-$-falseE) (library-$-host-$-bool);
$ext__1__library-$-host-$-ty_e (G) (library-$-host-$-add (E1) (E2)) (library-$-host-$-intTy) := ($ext__1__library-$-host-$-ty_e (G) (E1) (library-$-host-$-intTy)) /\ ($ext__1__library-$-host-$-ty_e (G) (E2) (library-$-host-$-intTy));
$ext__1__library-$-host-$-ty_e (G) (library-$-host-$-eq (E1) (E2)) (library-$-host-$-bool) := ($ext__1__library-$-host-$-ty_e (G) (E1) (library-$-host-$-intTy)) /\ ($ext__1__library-$-host-$-ty_e (G) (E2) (library-$-host-$-intTy));
$ext__1__library-$-host-$-ty_e (G) (library-$-host-$-gt (E1) (E2)) (library-$-host-$-bool) := ($ext__1__library-$-host-$-ty_e (G) (E1) (library-$-host-$-intTy)) /\ ($ext__1__library-$-host-$-ty_e (G) (E2) (library-$-host-$-intTy));
$ext__1__library-$-host-$-ty_e (G) (library-$-host-$-not (E)) (library-$-host-$-bool) := $ext__1__library-$-host-$-ty_e (G) (E) (library-$-host-$-bool);
$ext__1__library-$-host-$-ty_e (G) (library-$-list-$-nil) (library-$-list-$-list (Ty));
$ext__1__library-$-host-$-ty_e (G) (library-$-list-$-cons (E1) (E2)) (library-$-list-$-list (Ty)) := ($ext__1__library-$-host-$-ty_e (G) (E1) (Ty)) /\ ($ext__1__library-$-host-$-ty_e (G) (E2) (library-$-list-$-list (Ty)));
$ext__1__library-$-host-$-ty_e (G) (library-$-list-$-null (E)) (library-$-host-$-bool) := exists Ty, $ext__1__library-$-host-$-ty_e (G) (E) (library-$-list-$-list (Ty));
$ext__1__library-$-host-$-ty_e (G) (library-$-list-$-head (E)) (Ty) := $ext__1__library-$-host-$-ty_e (G) (E) (library-$-list-$-list (Ty));
$ext__1__library-$-host-$-ty_e (G) (library-$-list-$-tail (E)) (library-$-list-$-list (Ty)) := $ext__1__library-$-host-$-ty_e (G) (E) (library-$-list-$-list (Ty)).
Define $ext__1__library-$-host-$-ty_s : (list ($lib__pair (list $char) ($ty__library-$-host-$-ty))) -> ($ty__library-$-host-$-s) -> (list ($lib__pair (list $char) ($ty__library-$-host-$-ty))) -> prop by
$ext__1__library-$-host-$-ty_s (G) (library-$-host-$-skipS) (G);
$ext__1__library-$-host-$-ty_s (G) (library-$-host-$-seq (S1) (S2)) (G2) := exists G1, ($ext__1__library-$-host-$-ty_s (G) (S1) (G1)) /\ ($ext__1__library-$-host-$-ty_s (G1) (S2) (G2));
$ext__1__library-$-host-$-ty_s (G) (library-$-host-$-decl (N) (Ty) (E)) (($pair_c (N) (Ty))::(G)) := ($ext__1__library-$-host-$-ty_e (G) (E) (Ty)) /\ ($fix__sterling-$-stdLib-$-no_lookup (G) (N));
$ext__1__library-$-host-$-ty_s (G) (library-$-host-$-assign (N) (E)) (G) := exists Ty, ($ext__1__library-$-host-$-ty_e (G) (E) (Ty)) /\ ($fix__sterling-$-stdLib-$-lookup (G) (N) (Ty));
$ext__1__library-$-host-$-ty_s (G) (library-$-host-$-ifte (E) (S1) (S2)) (G) := exists G1 G2, ($ext__1__library-$-host-$-ty_e (G) (E) (library-$-host-$-bool)) /\ (($ext__1__library-$-host-$-ty_s (G) (S1) (G1)) /\ ($ext__1__library-$-host-$-ty_s (G) (S2) (G2)));
$ext__1__library-$-host-$-ty_s (G) (library-$-host-$-while (E) (S)) (G) := exists G1, ($ext__1__library-$-host-$-ty_e (G) (E) (library-$-host-$-bool)) /\ ($ext__1__library-$-host-$-ty_s (G) (S) (G1));
$ext__1__library-$-host-$-ty_s (G) (library-$-list-$-splitlist (Hd) (Tl) (E)) (G) := exists Ty, ($ext__1__library-$-host-$-ty_e (G) (E) (library-$-list-$-list (Ty))) /\ (($fix__sterling-$-stdLib-$-lookup (G) (Hd) (Ty)) /\ ($fix__sterling-$-stdLib-$-lookup (G) (Tl) (library-$-list-$-list (Ty))));
$ext__1__library-$-host-$-ty_s (G) (library-$-security-$-secdecl (N) (Ty) (Sl) (E)) (($pair_c (N) (Ty))::(G)) := ($ext__1__library-$-host-$-ty_e (G) (E) (Ty)) /\ ($fix__sterling-$-stdLib-$-no_lookup (G) (N)).
Define $ext__0__library-$-host-$-vars : ($ty__library-$-host-$-e) -> (list (list $char)) -> prop by
$ext__0__library-$-host-$-vars (library-$-host-$-var (N)) ((N)::(nil));
$ext__0__library-$-host-$-vars (library-$-host-$-intlit (I)) (nil);
$ext__0__library-$-host-$-vars (library-$-host-$-trueE) (nil);
$ext__0__library-$-host-$-vars (library-$-host-$-falseE) (nil);
$ext__0__library-$-host-$-vars (library-$-host-$-add (E1) (E2)) (V) := exists Vr1 Vr2, ($ext__0__library-$-host-$-vars (E1) (Vr1)) /\ (($ext__0__library-$-host-$-vars (E2) (Vr2)) /\ ($append (Vr1) (Vr2) (V)));
$ext__0__library-$-host-$-vars (library-$-host-$-eq (E1) (E2)) (V) := exists Vr1 Vr2, ($ext__0__library-$-host-$-vars (E1) (Vr1)) /\ (($ext__0__library-$-host-$-vars (E2) (Vr2)) /\ ($append (Vr1) (Vr2) (V)));
$ext__0__library-$-host-$-vars (library-$-host-$-gt (E1) (E2)) (V) := exists Vr1 Vr2, ($ext__0__library-$-host-$-vars (E1) (Vr1)) /\ (($ext__0__library-$-host-$-vars (E2) (Vr2)) /\ ($append (Vr1) (Vr2) (V)));
$ext__0__library-$-host-$-vars (library-$-host-$-not (E)) (Vr) := $ext__0__library-$-host-$-vars (E) (Vr);
$ext__0__library-$-host-$-vars (library-$-list-$-nil) (nil);
$ext__0__library-$-host-$-vars (library-$-list-$-cons (E1) (E2)) (V) := exists Vr1 Vr2, ($ext__0__library-$-host-$-vars (E1) (Vr1)) /\ (($ext__0__library-$-host-$-vars (E2) (Vr2)) /\ ($append (Vr1) (Vr2) (V)));
$ext__0__library-$-host-$-vars (library-$-list-$-null (E)) (V) := $ext__0__library-$-host-$-vars (E) (V);
$ext__0__library-$-host-$-vars (library-$-list-$-head (E)) (V) := $ext__0__library-$-host-$-vars (E) (V);
$ext__0__library-$-host-$-vars (library-$-list-$-tail (E)) (V) := $ext__0__library-$-host-$-vars (E) (V).
Define $trans__library-$-host-$-ty : ($ty__library-$-host-$-ty) -> ($ty__library-$-host-$-ty) -> prop by
$trans__library-$-host-$-ty (library-$-list-$-list (Ty)) (Ty).
Define $trans__library-$-host-$-e : ($ty__library-$-host-$-e) -> ($ty__library-$-host-$-e) -> prop by
$trans__library-$-host-$-e (library-$-list-$-null (E)) (E);
$trans__library-$-host-$-e (library-$-list-$-head (E)) (E);
$trans__library-$-host-$-e (library-$-list-$-tail (E)) (E);
$trans__library-$-host-$-e (library-$-list-$-nil) (library-$-host-$-trueE);
$trans__library-$-host-$-e (library-$-list-$-cons (E1) (E2)) (library-$-host-$-eq (E1) (E2)).
Define $trans__library-$-host-$-s : ($ty__library-$-host-$-s) -> ($ty__library-$-host-$-s) -> prop by
$trans__library-$-host-$-s (library-$-list-$-splitlist (Hd) (Tl) (E)) (library-$-host-$-seq (library-$-host-$-seq (library-$-host-$-assign (Hd) (E)) (library-$-host-$-assign (Tl) (library-$-list-$-tail (library-$-host-$-var (Hd))))) (library-$-host-$-assign (Hd) (library-$-list-$-head (library-$-host-$-var (Hd))))) := ((Hd) = (Tl)) -> (false);
$trans__library-$-host-$-s (library-$-security-$-secdecl (N) (Ty) (Sl) (E)) (library-$-host-$-decl (N) (Ty) (E)).
Define $fix__library-$-security-$-join : ($ty__library-$-security-$-sl) -> ($ty__library-$-security-$-sl) -> ($ty__library-$-security-$-sl) -> prop by
$fix__library-$-security-$-join (library-$-security-$-public) (library-$-security-$-public) (library-$-security-$-public);
$fix__library-$-security-$-join (library-$-security-$-private) (L) (library-$-security-$-private);
$fix__library-$-security-$-join (L) (library-$-security-$-private) (library-$-security-$-private).
Define $ext__1__library-$-security-$-level : (list ($lib__pair (list $char) ($ty__library-$-security-$-sl))) -> ($ty__library-$-host-$-e) -> ($ty__library-$-security-$-sl) -> prop by
$ext__1__library-$-security-$-level (SG) (library-$-host-$-intlit (I)) (library-$-security-$-public);
$ext__1__library-$-security-$-level (SG) (library-$-host-$-trueE) (library-$-security-$-public);
$ext__1__library-$-security-$-level (SG) (library-$-host-$-falseE) (library-$-security-$-public);
$ext__1__library-$-security-$-level (SG) (library-$-host-$-var (N)) (L) := $fix__sterling-$-stdLib-$-lookup (SG) (N) (L);
$ext__1__library-$-security-$-level (SG) (library-$-host-$-add (E1) (E2)) (L) := exists L1 L2, ($ext__1__library-$-security-$-level (SG) (E1) (L1)) /\ (($ext__1__library-$-security-$-level (SG) (E2) (L2)) /\ ($fix__library-$-security-$-join (L1) (L2) (L)));
$ext__1__library-$-security-$-level (SG) (library-$-host-$-eq (E1) (E2)) (L) := exists L1 L2, ($ext__1__library-$-security-$-level (SG) (E1) (L1)) /\ (($ext__1__library-$-security-$-level (SG) (E2) (L2)) /\ ($fix__library-$-security-$-join (L1) (L2) (L)));
$ext__1__library-$-security-$-level (SG) (library-$-host-$-gt (E1) (E2)) (L) := exists L1 L2, ($ext__1__library-$-security-$-level (SG) (E1) (L1)) /\ (($ext__1__library-$-security-$-level (SG) (E2) (L2)) /\ ($fix__library-$-security-$-join (L1) (L2) (L)));
$ext__1__library-$-security-$-level (SG) (library-$-host-$-not (E)) (L) := $ext__1__library-$-security-$-level (SG) (E) (L);
$ext__1__library-$-security-$-level (SG) (library-$-list-$-nil ) (Sl) := exists E1, ($trans__library-$-host-$-e (library-$-list-$-nil ) (E1)) /\ ($ext__1__library-$-security-$-level (SG) (E1) (Sl));
$ext__1__library-$-security-$-level (SG) (library-$-list-$-cons (E2) (E)) (Sl) := exists E1, ($trans__library-$-host-$-e (library-$-list-$-cons (E2) (E)) (E1)) /\ ($ext__1__library-$-security-$-level (SG) (E1) (Sl));
$ext__1__library-$-security-$-level (SG) (library-$-list-$-null (E)) (Sl) := exists E1, ($trans__library-$-host-$-e (library-$-list-$-null (E)) (E1)) /\ ($ext__1__library-$-security-$-level (SG) (E1) (Sl));
$ext__1__library-$-security-$-level (SG) (library-$-list-$-head (E)) (Sl) := exists E1, ($trans__library-$-host-$-e (library-$-list-$-head (E)) (E1)) /\ ($ext__1__library-$-security-$-level (SG) (E1) (Sl));
$ext__1__library-$-security-$-level (SG) (library-$-list-$-tail (E)) (Sl) := exists E1, ($trans__library-$-host-$-e (library-$-list-$-tail (E)) (E1)) /\ ($ext__1__library-$-security-$-level (SG) (E1) (Sl)).
Define $ext__2__library-$-security-$-secure : (list ($lib__pair (list $char) ($ty__library-$-security-$-sl))) -> ($ty__library-$-security-$-sl) -> ($ty__library-$-host-$-s) -> (list ($lib__pair (list $char) ($ty__library-$-security-$-sl))) -> prop by
$ext__2__library-$-security-$-secure (SG) (Sl) (library-$-host-$-skipS) (SG);
$ext__2__library-$-security-$-secure (SG) (Sl) (library-$-host-$-seq (S1) (S2)) (SG2) := exists SG1, ($ext__2__library-$-security-$-secure (SG) (Sl) (S1) (SG1)) /\ ($ext__2__library-$-security-$-secure (SG1) (Sl) (S2) (SG2));
$ext__2__library-$-security-$-secure (SG) (library-$-security-$-public) (library-$-host-$-decl (N) (Ty) (E)) (($pair_c (N) (library-$-security-$-public))::(SG)) := ($ext__1__library-$-security-$-level (SG) (E) (library-$-security-$-public)) /\ ($fix__sterling-$-stdLib-$-no_lookup (SG) (N));
$ext__2__library-$-security-$-secure (SG) (Sl) (library-$-host-$-assign (N) (E)) (SG) := exists L, ($ext__1__library-$-security-$-level (SG) (E) (L)) /\ ($fix__sterling-$-stdLib-$-lookup (SG) (N) (library-$-security-$-private));
$ext__2__library-$-security-$-secure (SG) (library-$-security-$-public) (library-$-host-$-assign (N) (E)) (SG) := ($ext__1__library-$-security-$-level (SG) (E) (library-$-security-$-public)) /\ ($fix__sterling-$-stdLib-$-lookup (SG) (N) (library-$-security-$-public));
$ext__2__library-$-security-$-secure (SG) (Sl) (library-$-host-$-ifte (E) (S1) (S2)) (SG) := exists L Sl1 SG1 SG2, ($ext__1__library-$-security-$-level (SG) (E) (L)) /\ (($fix__library-$-security-$-join (L) (Sl) (Sl1)) /\ (($ext__2__library-$-security-$-secure (SG) (Sl1) (S1) (SG1)) /\ ($ext__2__library-$-security-$-secure (SG) (Sl1) (S2) (SG2))));
$ext__2__library-$-security-$-secure (SG) (Sl) (library-$-host-$-while (E) (S)) (SG) := exists L Sl1 SG1, ($ext__1__library-$-security-$-level (SG) (E) (L)) /\ (($fix__library-$-security-$-join (L) (Sl) (Sl1)) /\ ($ext__2__library-$-security-$-secure (SG) (Sl1) (S) (SG1)));
$ext__2__library-$-security-$-secure (SG) (Sl) (library-$-security-$-secdecl (N) (Ty) (library-$-security-$-private) (E)) (($pair_c (N) (library-$-security-$-private))::(SG)) := exists L, ($ext__1__library-$-security-$-level (SG) (E) (L)) /\ ($fix__sterling-$-stdLib-$-no_lookup (SG) (N));
$ext__2__library-$-security-$-secure (SG) (library-$-security-$-public) (library-$-security-$-secdecl (N) (Ty) (library-$-security-$-public) (E)) (($pair_c (N) (library-$-security-$-public))::(SG)) := ($ext__1__library-$-security-$-level (SG) (E) (library-$-security-$-public)) /\ ($fix__sterling-$-stdLib-$-no_lookup (SG) (N));
$ext__2__library-$-security-$-secure (SG) (Sl) (library-$-list-$-splitlist (S2) (S) (E)) (SG1) := exists S1, ($trans__library-$-host-$-s (library-$-list-$-splitlist (S2) (S) (E)) (S1)) /\ ($ext__2__library-$-security-$-secure (SG) (Sl) (S1) (SG1)).
Define $trans__library-$-security-$-sl : ($ty__library-$-security-$-sl) -> ($ty__library-$-security-$-sl) -> prop by
$trans__library-$-security-$-sl (X513) (X514) := false.



<span class="comment">/********************************************************************
 Proof-Level Definitions
 ********************************************************************/</span>
Define library-$-security-$-public_equiv : (list ($lib__pair (list $char) $ty__library-$-security-$-sl)) -> (list ($lib__pair (list $char) $ty__library-$-host-$-e)) -> (list ($lib__pair (list $char) $ty__library-$-host-$-e)) -> prop by library-$-security-$-public_equiv (S) (G1) (G2) := (forall X V, ($fix__sterling-$-stdLib-$-lookup (S) (X) (library-$-security-$-public)) -> ($fix__sterling-$-stdLib-$-lookup (G1) (X) (V)) -> $fix__sterling-$-stdLib-$-lookup (G2) (X) (V)) /\ (forall X V, ($fix__sterling-$-stdLib-$-lookup (S) (X) (library-$-security-$-public)) -> ($fix__sterling-$-stdLib-$-lookup (G2) (X) (V)) -> $fix__sterling-$-stdLib-$-lookup (G1) (X) (V)).

Define $extSize__library-$-host-$-is_e : $ty__library-$-host-$-e -> $lib__integer -> prop by $extSize__library-$-host-$-is_e ((library-$-host-$-var) (S)) (($posInt) ($zero))  := is_string (S);
$extSize__library-$-host-$-is_e ((library-$-host-$-intlit) (I)) (($posInt) ($zero))  := is_integer (I);
$extSize__library-$-host-$-is_e (library-$-host-$-trueE) (($posInt) ($zero)) ;
$extSize__library-$-host-$-is_e (library-$-host-$-falseE) (($posInt) ($zero)) ;
$extSize__library-$-host-$-is_e ((library-$-host-$-add) (E1) (E)) (N)  := exists N2 N1, ($plus_integer (N2) (N1) (N) ) /\ (($extSize__library-$-host-$-is_e (E1) (N2) ) /\ ($extSize__library-$-host-$-is_e (E) (N1) ));
$extSize__library-$-host-$-is_e ((library-$-host-$-eq) (E1) (E)) (N)  := exists N2 N1, ($plus_integer (N2) (N1) (N) ) /\ (($extSize__library-$-host-$-is_e (E1) (N2) ) /\ ($extSize__library-$-host-$-is_e (E) (N1) ));
$extSize__library-$-host-$-is_e ((library-$-host-$-gt) (E1) (E)) (N)  := exists N2 N1, ($plus_integer (N2) (N1) (N) ) /\ (($extSize__library-$-host-$-is_e (E1) (N2) ) /\ ($extSize__library-$-host-$-is_e (E) (N1) ));
$extSize__library-$-host-$-is_e ((library-$-host-$-not) (E)) (N)  := exists N1, (N1 = N) /\ ($extSize__library-$-host-$-is_e (E) (N1) );
$extSize__library-$-host-$-is_e (library-$-list-$-nil) (($posInt) (($succ) ($zero))) ;
$extSize__library-$-host-$-is_e ((library-$-list-$-cons) (E1) (E)) (N)  := exists N2 N1 N3, ($plus_integer (($posInt) (($succ) ($zero))) (N3) (N) ) /\ (($plus_integer (N2) (N1) (N3) ) /\ (($extSize__library-$-host-$-is_e (E1) (N2) ) /\ ($extSize__library-$-host-$-is_e (E) (N1) )));
$extSize__library-$-host-$-is_e ((library-$-list-$-null) (E)) (N)  := exists N1, ($plus_integer (($posInt) (($succ) ($zero))) (N1) (N) ) /\ ($extSize__library-$-host-$-is_e (E) (N1) );
$extSize__library-$-host-$-is_e ((library-$-list-$-head) (E)) (N)  := exists N1, ($plus_integer (($posInt) (($succ) ($zero))) (N1) (N) ) /\ ($extSize__library-$-host-$-is_e (E) (N1) );
$extSize__library-$-host-$-is_e ((library-$-list-$-tail) (E)) (N)  := exists N1, ($plus_integer (($posInt) (($succ) ($zero))) (N1) (N) ) /\ ($extSize__library-$-host-$-is_e (E) (N1) ).

Define $transRel__library-$-host-$-is_e : $ty__library-$-host-$-e -> prop by $transRel__library-$-host-$-is_e ((library-$-host-$-var) (S))  := is_string (S);
$transRel__library-$-host-$-is_e ((library-$-host-$-intlit) (I))  := is_integer (I);
$transRel__library-$-host-$-is_e (library-$-host-$-trueE) ;
$transRel__library-$-host-$-is_e (library-$-host-$-falseE) ;
$transRel__library-$-host-$-is_e ((library-$-host-$-add) (E1) (E))  := ($transRel__library-$-host-$-is_e (E1)) /\ ($transRel__library-$-host-$-is_e (E));
$transRel__library-$-host-$-is_e ((library-$-host-$-eq) (E1) (E))  := ($transRel__library-$-host-$-is_e (E1)) /\ ($transRel__library-$-host-$-is_e (E));
$transRel__library-$-host-$-is_e ((library-$-host-$-gt) (E1) (E))  := ($transRel__library-$-host-$-is_e (E1)) /\ ($transRel__library-$-host-$-is_e (E));
$transRel__library-$-host-$-is_e ((library-$-host-$-not) (E))  := $transRel__library-$-host-$-is_e (E);
$transRel__library-$-host-$-is_e (library-$-list-$-nil)  := exists T, ($transRel__library-$-host-$-is_e (T) ) /\ ($trans__library-$-host-$-e (library-$-list-$-nil) (T) );
$transRel__library-$-host-$-is_e ((library-$-list-$-cons) (E1) (E))  := exists T, ($transRel__library-$-host-$-is_e (T) ) /\ (($trans__library-$-host-$-e ((library-$-list-$-cons) (E1) (E)) (T) ) /\ (($transRel__library-$-host-$-is_e (E1)) /\ ($transRel__library-$-host-$-is_e (E))));
$transRel__library-$-host-$-is_e ((library-$-list-$-null) (E))  := exists T, ($transRel__library-$-host-$-is_e (T) ) /\ (($trans__library-$-host-$-e ((library-$-list-$-null) (E)) (T) ) /\ ($transRel__library-$-host-$-is_e (E)));
$transRel__library-$-host-$-is_e ((library-$-list-$-head) (E))  := exists T, ($transRel__library-$-host-$-is_e (T) ) /\ (($trans__library-$-host-$-e ((library-$-list-$-head) (E)) (T) ) /\ ($transRel__library-$-host-$-is_e (E)));
$transRel__library-$-host-$-is_e ((library-$-list-$-tail) (E))  := exists T, ($transRel__library-$-host-$-is_e (T) ) /\ (($trans__library-$-host-$-e ((library-$-list-$-tail) (E)) (T) ) /\ ($transRel__library-$-host-$-is_e (E))).

Define $extSize__library-$-host-$-eval_s : (list ($lib__pair (list $char) $ty__library-$-host-$-e)) -> $ty__library-$-host-$-s -> (list ($lib__pair (list $char) $ty__library-$-host-$-e)) -> $lib__integer -> prop by $extSize__library-$-host-$-eval_s (G) (library-$-host-$-skipS) (G) (($posInt) ($zero)) ;
$extSize__library-$-host-$-eval_s (G) ((library-$-host-$-decl) (N) (Ty) (E)) ((($pair_c) (N) (V))::(G)) (($posInt) ($zero))  := $ext__1__library-$-host-$-eval_e (G) (E) (V);
$extSize__library-$-host-$-eval_s (G) ((library-$-host-$-assign) (N) (E)) ((($pair_c) (N) (V))::(NewG)) (($posInt) ($zero))  := exists VOld, ($ext__1__library-$-host-$-eval_e (G) (E) (V)) /\ ($fix__sterling-$-stdLib-$-select (($pair_c) (N) (VOld)) (NewG) (G));
$extSize__library-$-host-$-eval_s (G) ((library-$-host-$-seq) (S1) (S2)) (G2) (N)  := exists N2 N1 G1, ($plus_integer (N2) (N1) (N) ) /\ (($extSize__library-$-host-$-eval_s (G) (S1) (G1) (N2) ) /\ ($extSize__library-$-host-$-eval_s (G1) (S2) (G2) (N1) ));
$extSize__library-$-host-$-eval_s (G) ((library-$-host-$-ifte) (E) (S1) (S2)) (G1) (N)  := exists N1, (N1 = N) /\ (($ext__1__library-$-host-$-eval_e (G) (E) (library-$-host-$-trueE)) /\ ($extSize__library-$-host-$-eval_s (G) (S1) (G1) (N1) ));
$extSize__library-$-host-$-eval_s (G) ((library-$-host-$-ifte) (E) (S1) (S2)) (G1) (N)  := exists N1, (N1 = N) /\ (($ext__1__library-$-host-$-eval_e (G) (E) (library-$-host-$-falseE)) /\ ($extSize__library-$-host-$-eval_s (G) (S2) (G1) (N1) ));
$extSize__library-$-host-$-eval_s (G) ((library-$-host-$-while) (E) (S)) (G2) (N)  := exists N2 N1 G1, ($plus_integer (N2) (N1) (N) ) /\ (($ext__1__library-$-host-$-eval_e (G) (E) (library-$-host-$-trueE)) /\ (($extSize__library-$-host-$-eval_s (G) (S) (G1) (N2) ) /\ ($extSize__library-$-host-$-eval_s (G1) ((library-$-host-$-while) (E) (S)) (G2) (N1) )));
$extSize__library-$-host-$-eval_s (G) ((library-$-host-$-while) (E) (S)) (G) (($posInt) ($zero))  := $ext__1__library-$-host-$-eval_e (G) (E) (library-$-host-$-falseE);
$extSize__library-$-host-$-eval_s (G) ((library-$-list-$-splitlist) (Hd) (Tl) (E)) ((($pair_c) (Hd) (V1))::((($pair_c) (Tl) (V2))::(GTl))) (($posInt) (($succ) ($zero)))  := exists VHd GHd VTl, ($ext__1__library-$-host-$-eval_e (G) (E) ((library-$-list-$-cons) (V1) (V2))) /\ (((Hd = Tl) -> false) /\ (($fix__sterling-$-stdLib-$-select (($pair_c) (Hd) (VHd)) (GHd) (G)) /\ ($fix__sterling-$-stdLib-$-select (($pair_c) (Tl) (VTl)) (GTl) (GHd))));
$extSize__library-$-host-$-eval_s (G) ((library-$-security-$-secdecl) (N) (Ty) (Sl) (E)) ((($pair_c) (N) (V))::(G)) (($posInt) (($succ) ($zero)))  := $ext__1__library-$-host-$-eval_e (G) (E) (V).

Define $transRel__library-$-host-$-eval_s : (list ($lib__pair (list $char) $ty__library-$-host-$-e)) -> $ty__library-$-host-$-s -> (list ($lib__pair (list $char) $ty__library-$-host-$-e)) -> prop by $transRel__library-$-host-$-eval_s (G) (library-$-host-$-skipS) (G) ;
$transRel__library-$-host-$-eval_s (G) ((library-$-host-$-decl) (N) (Ty) (E)) ((($pair_c) (N) (V))::(G))  := $ext__1__library-$-host-$-eval_e (G) (E) (V);
$transRel__library-$-host-$-eval_s (G) ((library-$-host-$-assign) (N) (E)) ((($pair_c) (N) (V))::(NewG))  := exists VOld, ($ext__1__library-$-host-$-eval_e (G) (E) (V)) /\ ($fix__sterling-$-stdLib-$-select (($pair_c) (N) (VOld)) (NewG) (G));
$transRel__library-$-host-$-eval_s (G) ((library-$-host-$-seq) (S1) (S2)) (G2)  := exists G1, ($transRel__library-$-host-$-eval_s (G) (S1) (G1)) /\ ($transRel__library-$-host-$-eval_s (G1) (S2) (G2));
$transRel__library-$-host-$-eval_s (G) ((library-$-host-$-ifte) (E) (S1) (S2)) (G1)  := ($ext__1__library-$-host-$-eval_e (G) (E) (library-$-host-$-trueE)) /\ ($transRel__library-$-host-$-eval_s (G) (S1) (G1));
$transRel__library-$-host-$-eval_s (G) ((library-$-host-$-ifte) (E) (S1) (S2)) (G1)  := ($ext__1__library-$-host-$-eval_e (G) (E) (library-$-host-$-falseE)) /\ ($transRel__library-$-host-$-eval_s (G) (S2) (G1));
$transRel__library-$-host-$-eval_s (G) ((library-$-host-$-while) (E) (S)) (G2)  := exists G1, ($ext__1__library-$-host-$-eval_e (G) (E) (library-$-host-$-trueE)) /\ (($transRel__library-$-host-$-eval_s (G) (S) (G1)) /\ ($transRel__library-$-host-$-eval_s (G1) ((library-$-host-$-while) (E) (S)) (G2)));
$transRel__library-$-host-$-eval_s (G) ((library-$-host-$-while) (E) (S)) (G)  := $ext__1__library-$-host-$-eval_e (G) (E) (library-$-host-$-falseE);
$transRel__library-$-host-$-eval_s (G) ((library-$-list-$-splitlist) (Hd) (Tl) (E)) ((($pair_c) (Hd) (V1))::((($pair_c) (Tl) (V2))::(GTl)))  := exists T VHd GHd VTl, ($transRel__library-$-host-$-eval_s (G) (T) ((($pair_c) (Hd) (V1))::((($pair_c) (Tl) (V2))::(GTl))) ) /\ (($trans__library-$-host-$-s ((library-$-list-$-splitlist) (Hd) (Tl) (E)) (T) ) /\ (($ext__1__library-$-host-$-eval_e (G) (E) ((library-$-list-$-cons) (V1) (V2))) /\ (((Hd = Tl) -> false) /\ (($fix__sterling-$-stdLib-$-select (($pair_c) (Hd) (VHd)) (GHd) (G)) /\ ($fix__sterling-$-stdLib-$-select (($pair_c) (Tl) (VTl)) (GTl) (GHd))))));
$transRel__library-$-host-$-eval_s (G) ((library-$-security-$-secdecl) (N) (Ty) (Sl) (E)) ((($pair_c) (N) (V))::(G))  := exists T, ($transRel__library-$-host-$-eval_s (G) (T) ((($pair_c) (N) (V))::(G)) ) /\ (($trans__library-$-host-$-s ((library-$-security-$-secdecl) (N) (Ty) (Sl) (E)) (T) ) /\ ($ext__1__library-$-host-$-eval_e (G) (E) (V))).



<span class="comment">/********************************************************************
 Properties and Proofs
 ********************************************************************/</span>
Theorem sterling-$-stdLib-$-lookup_unique[Key, Value] : forall L (Key : Key) (Value2 : Value) (Value1 : Value), ($fix__sterling-$-stdLib-$-lookup (L) (Key) (Value1)) -> ($fix__sterling-$-stdLib-$-lookup (L) (Key) (Value2)) -> Value1 = Value2.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(91);" id="toggleproof91">[Show Proof]</a>
<div class="proof" id="proof91" style="display: none;">
induction on 1.  intros Lkp1' Lkp2'.  Lkp1: case Lkp1'.  Lkp2: case Lkp2'.  search.  apply Lkp2 to _.  Lkp2: case Lkp2'.  apply Lkp1 to _.  backchain IH.  </div>

Theorem sterling-$-stdLib-$-no_lookup[Key, Value] : forall L (Key : Key) (Value : Value), ($fix__sterling-$-stdLib-$-no_lookup (L) (Key)) -> ($fix__sterling-$-stdLib-$-lookup (L) (Key) (Value)) -> false.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(92);" id="toggleproof92">[Show Proof]</a>
<div class="proof" id="proof92" style="display: none;">
induction on 1.  intros NLkp' Lkp'.  NLkp: case NLkp'.  Lkp: case Lkp'.  Lkp: case Lkp'.  backchain NLkp.  backchain IH.  </div>

Theorem sterling-$-stdLib-$-lookup_eq_or_not[Key, Value] : forall L (A : Key) (B : Key) (VB : Value) (VA : Value), ($fix__sterling-$-stdLib-$-lookup (L) (A) (VA)) -> ($fix__sterling-$-stdLib-$-lookup (L) (B) (VB)) -> (A = B) \/ ((A = B) -> false).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(93);" id="toggleproof93">[Show Proof]</a>
<div class="proof" id="proof93" style="display: none;">
induction on 1.  intros LkpA LkpB.  LkpA: case LkpA.  LkpB: case LkpB.  search.  search.  LkpB: case LkpB.  right.  intros Eq.  case Eq.  backchain LkpA.  apply IH to LkpA1 LkpB1.  search.  </div>

Theorem sterling-$-stdLib-$-lookup_mem[Key, Value] : forall L (Key : Key) (Value : Value), ($fix__sterling-$-stdLib-$-lookup (L) (Key) (Value)) -> $fix__sterling-$-stdLib-$-mem (($pair_c) (Key) (Value)) (L).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(94);" id="toggleproof94">[Show Proof]</a>
<div class="proof" id="proof94" style="display: none;">
induction on 1.  intros Lkp'.  Lkp: case Lkp'.  search.  apply IH to Lkp1.  search.  </div>

Theorem sterling-$-stdLib-$-no_lookup_mem[Key, Value] : forall L (Key : Key) (Value : Value), ($fix__sterling-$-stdLib-$-no_lookup (L) (Key)) -> ($fix__sterling-$-stdLib-$-mem (($pair_c) (Key) (Value)) (L)) -> false.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(95);" id="toggleproof95">[Show Proof]</a>
<div class="proof" id="proof95" style="display: none;">
induction on 1.  intros Lkp Mem.  Lkp: case Lkp.  case Mem.  Mem: case Mem.  apply Lkp to _.  apply IH to Lkp1 Mem.  </div>

Theorem sterling-$-stdLib-$-no_lookup_mem_pair[Key, Value] : forall L (P : $lib__pair Key Value) K, ($fix__sterling-$-stdLib-$-no_lookup (L) (K)) -> ($fix__sterling-$-stdLib-$-mem (P) (L)) -> exists X Y, P = ($pair_c) (X) (Y).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(96);" id="toggleproof96">[Show Proof]</a>
<div class="proof" id="proof96" style="display: none;">
induction on 2.  intros NLkp Mem.  Mem: case Mem.  case NLkp.  search.  NLkp: case NLkp.  apply IH to _ Mem.  search.  </div>

Theorem sterling-$-stdLib-$-lookup_select[Key, Value] : forall L (Key : Key) (Value : Value), ($fix__sterling-$-stdLib-$-lookup (L) (Key) (Value)) -> exists L', $fix__sterling-$-stdLib-$-select (($pair_c) (Key) (Value)) (L') (L).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(97);" id="toggleproof97">[Show Proof]</a>
<div class="proof" id="proof97" style="display: none;">
induction on 1.  intros Lkp'.  Lkp: case Lkp'.  search.  apply IH to Lkp1.  search.  </div>

Theorem sterling-$-stdLib-$-no_lookup_select[Key, Value] : forall L (Key : Key) (Value : Value) R, ($fix__sterling-$-stdLib-$-no_lookup (L) (Key)) -> ($fix__sterling-$-stdLib-$-select (($pair_c) (Key) (Value)) (R) (L)) -> false.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(98);" id="toggleproof98">[Show Proof]</a>
<div class="proof" id="proof98" style="display: none;">
induction on 1.  intros NLkp Slct.  NLkp: case NLkp.  case Slct.  Slct: case Slct.  apply NLkp to _.  apply IH to NLkp1 Slct.  </div>

Theorem sterling-$-stdLib-$-select_lookup[Key, Value] : forall L (Key : Key) (K : Key) (Value : Value) (V : Value) R, ($fix__sterling-$-stdLib-$-lookup (L) (K) (V)) -> ($fix__sterling-$-stdLib-$-select (($pair_c) (Key) (Value)) (R) (L)) -> ((K = Key) -> false) -> $fix__sterling-$-stdLib-$-lookup (R) (K) (V).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(99);" id="toggleproof99">[Show Proof]</a>
<div class="proof" id="proof99" style="display: none;">
induction on 1.  intros Lkp Slct NEq.  Lkp: case Lkp.  Slct: case Slct.  apply NEq to _.  search.  Slct: case Slct.  search.  apply IH to Lkp1 Slct _.  search.  </div>

Theorem sterling-$-stdLib-$-no_lookup_after_select_before[Key, Value] : forall (Key : Key) (K : Key) (V : Value) Rest L, ($fix__sterling-$-stdLib-$-no_lookup (Rest) (Key)) -> ($fix__sterling-$-stdLib-$-select (($pair_c) (K) (V)) (Rest) (L)) -> ((K = Key) -> false) -> $fix__sterling-$-stdLib-$-no_lookup (L) (Key).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(100);" id="toggleproof100">[Show Proof]</a>
<div class="proof" id="proof100" style="display: none;">
induction on 1.  intros NLkp Slct NEq.  NLkp: case NLkp.  case Slct.  search.  Slct: case Slct.  search.  apply IH to NLkp1 Slct _.  search.  </div>

Theorem sterling-$-stdLib-$-no_lookup_before_select_after[Key, Value] : forall (Key : Key) (P : $lib__pair Key Value) Rest L, ($fix__sterling-$-stdLib-$-no_lookup (L) (Key)) -> ($fix__sterling-$-stdLib-$-select (P) (Rest) (L)) -> $fix__sterling-$-stdLib-$-no_lookup (Rest) (Key).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(101);" id="toggleproof101">[Show Proof]</a>
<div class="proof" id="proof101" style="display: none;">
induction on 2.  intros NLkp Slct.  Slct: case Slct.  case NLkp.  search.  NLkp: case NLkp.  apply IH to NLkp1 Slct.  search.  </div>

Theorem sterling-$-stdLib-$-lookup_after_select_before[Key, Value] : forall (K : Key) (Key : Key) (V : Value) (Value : Value) L R, ($fix__sterling-$-stdLib-$-lookup (R) (K) (V)) -> ($fix__sterling-$-stdLib-$-select (($pair_c) (Key) (Value)) (R) (L)) -> ((K = Key) -> false) -> $fix__sterling-$-stdLib-$-lookup (L) (K) (V).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(102);" id="toggleproof102">[Show Proof]</a>
<div class="proof" id="proof102" style="display: none;">
induction on 2.  intros Lkp Slct NEq.  Slct: case Slct.  unfold .
intros E.  case E.  backchain NEq.  search.  L: case Lkp.  search.  apply IH to L1 Slct NEq.  search.  </div>

Theorem sterling-$-stdLib-$-mem_select[Item] : forall L (X : Item), ($fix__sterling-$-stdLib-$-mem (X) (L)) -> exists L', $fix__sterling-$-stdLib-$-select (X) (L') (L).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(103);" id="toggleproof103">[Show Proof]</a>
<div class="proof" id="proof103" style="display: none;">
induction on 1.  intros Mem'.  Mem: case Mem'.  search.  apply IH to Mem.  search.  </div>

Theorem sterling-$-stdLib-$-select_mem[Item] : forall L (X : Item) L', ($fix__sterling-$-stdLib-$-select (X) (L') (L)) -> $fix__sterling-$-stdLib-$-mem (X) (L).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(104);" id="toggleproof104">[Show Proof]</a>
<div class="proof" id="proof104" style="display: none;">
induction on 1.  intros Slct'.  Slct: case Slct'.  search.  apply IH to Slct.  search.  </div>

Theorem sterling-$-stdLib-$-mem_after_select_before[Item] : forall L L' (Y : Item) (X : Item), ($fix__sterling-$-stdLib-$-select (X) (L') (L)) -> ($fix__sterling-$-stdLib-$-mem (Y) (L')) -> $fix__sterling-$-stdLib-$-mem (Y) (L).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(105);" id="toggleproof105">[Show Proof]</a>
<div class="proof" id="proof105" style="display: none;">
induction on 1.  intros Slct Mem.  Slct: case Slct.  search.  Mem: case Mem.  search.  apply IH to Slct Mem.  search.  </div>

Theorem sterling-$-stdLib-$-mem_before_select_after[Item] : forall L L' (Y : Item) (X : Item), ($fix__sterling-$-stdLib-$-select (X) (L') (L)) -> ($fix__sterling-$-stdLib-$-mem (Y) (L)) -> ((X = Y) -> false) -> $fix__sterling-$-stdLib-$-mem (Y) (L').<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(106);" id="toggleproof106">[Show Proof]</a>
<div class="proof" id="proof106" style="display: none;">
induction on 1.  intros Slct Mem Eq.  Slct: case Slct.  M: case Mem.  apply Eq to _.  search.  M: case Mem.  search.  apply IH to Slct M Eq.  search.  </div>

Theorem sterling-$-stdLib-$-select_comm[Item] : forall L Rest Rest' (Y : Item) (X : Item), ($fix__sterling-$-stdLib-$-select (X) (Rest) (L)) -> ($fix__sterling-$-stdLib-$-select (Y) (Rest') (Rest)) -> exists R, ($fix__sterling-$-stdLib-$-select (Y) (R) (L)) /\ ($fix__sterling-$-stdLib-$-select (X) (Rest') (R)).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(107);" id="toggleproof107">[Show Proof]</a>
<div class="proof" id="proof107" style="display: none;">
induction on 1.  intros SX SY.  SX: case SX.  search.  SY: case SY.  search.  apply IH to SX SY.  search.  </div>

Theorem sterling-$-stdLib-$-mem_append_left[A] : forall L1 L2 L (A : A), ($fix__sterling-$-stdLib-$-mem (A) (L1)) -> ($append (L1) (L2) (L)) -> $fix__sterling-$-stdLib-$-mem (A) (L).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(108);" id="toggleproof108">[Show Proof]</a>
<div class="proof" id="proof108" style="display: none;">
induction on 1.  intros Mem' App.  case Mem'.  case App.  search.  App: case App.  apply IH to H1 App.  search.  </div>

Theorem sterling-$-stdLib-$-mem_append_right[A] : forall L1 L2 L (A : A), ($fix__sterling-$-stdLib-$-mem (A) (L2)) -> ($append (L1) (L2) (L)) -> $fix__sterling-$-stdLib-$-mem (A) (L).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(109);" id="toggleproof109">[Show Proof]</a>
<div class="proof" id="proof109" style="display: none;">
induction on 2.  intros Mem App.  App: case App.  search.  apply IH to Mem App.  search.  </div>

Theorem sterling-$-stdLib-$-mem_append[A] : forall L1 L2 L (A : A), ($fix__sterling-$-stdLib-$-mem (A) (L)) -> ($append (L1) (L2) (L)) -> ($fix__sterling-$-stdLib-$-mem (A) (L1)) \/ ($fix__sterling-$-stdLib-$-mem (A) (L2)).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(110);" id="toggleproof110">[Show Proof]</a>
<div class="proof" id="proof110" style="display: none;">
induction on 1.  intros Mem' App'.  Mem: case Mem'.  App: case App'.  search.  search.  App: case App'.  search.  Or: apply IH to Mem App.  case Or.  search.  search.  </div>

Theorem sterling-$-stdLib-$-not_mem[A] : forall (A : A) L, ($fix__sterling-$-stdLib-$-not_mem (A) (L)) -> ($fix__sterling-$-stdLib-$-mem (A) (L)) -> false.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(111);" id="toggleproof111">[Show Proof]</a>
<div class="proof" id="proof111" style="display: none;">
induction on 1.  intros N M.  N: case N.  case M.  M: case M.  apply N to _.  apply IH to N1 M.  </div>

Theorem sterling-$-stdLib-$-not_mem_select[A] : forall L (A : A) L', ($fix__sterling-$-stdLib-$-not_mem (A) (L)) -> ($fix__sterling-$-stdLib-$-select (A) (L') (L)) -> false.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(112);" id="toggleproof112">[Show Proof]</a>
<div class="proof" id="proof112" style="display: none;">
intros N S.  M: apply sterling-$-stdLib-$-select_mem to S.  apply sterling-$-stdLib-$-not_mem to N M.  </div>

Theorem sterling-$-stdLib-$-not_mem_after_select_before[A] : forall L L' (Y : A) (X : A), ($fix__sterling-$-stdLib-$-select (X) (L') (L)) -> ($fix__sterling-$-stdLib-$-not_mem (Y) (L')) -> ((X = Y) -> false) -> $fix__sterling-$-stdLib-$-not_mem (Y) (L).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(113);" id="toggleproof113">[Show Proof]</a>
<div class="proof" id="proof113" style="display: none;">
induction on 1.  intros S N NEq.  S: case S.  search.  case N.  apply IH to S _ _.  search.  </div>

Theorem sterling-$-stdLib-$-not_mem_before_select_after[A] : forall L L' (Y : A) (X : A), ($fix__sterling-$-stdLib-$-select (X) (L') (L)) -> ($fix__sterling-$-stdLib-$-not_mem (Y) (L)) -> $fix__sterling-$-stdLib-$-not_mem (Y) (L').<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(114);" id="toggleproof114">[Show Proof]</a>
<div class="proof" id="proof114" style="display: none;">
induction on 1.  intros S N.  S: case S.  case N.  search.  case N.  apply IH to S _.  search.  </div>

Theorem sterling-$-stdLib-$-not_mem_append[A] : forall L1 L2 L (A : A), ($fix__sterling-$-stdLib-$-not_mem (A) (L1)) -> ($fix__sterling-$-stdLib-$-not_mem (A) (L2)) -> ($append (L1) (L2) (L)) -> $fix__sterling-$-stdLib-$-not_mem (A) (L).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(115);" id="toggleproof115">[Show Proof]</a>
<div class="proof" id="proof115" style="display: none;">
induction on 1.  intros NA NB App.  NA: case NA.  case App.  search.  case App.  apply IH to NA1 _ _.  search.  </div>

Theorem sterling-$-stdLib-$-not_mem_append_back[A] : forall L1 L2 L (A : A), ($fix__sterling-$-stdLib-$-not_mem (A) (L)) -> ($append (L1) (L2) (L)) -> ($fix__sterling-$-stdLib-$-not_mem (A) (L1)) /\ ($fix__sterling-$-stdLib-$-not_mem (A) (L2)).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(116);" id="toggleproof116">[Show Proof]</a>
<div class="proof" id="proof116" style="display: none;">
induction on 2.  intros N App.  App: case App.  search.  case N.  apply IH to _ App.  search.  </div>

Theorem sterling-$-stdLib-$-permutation_mem[Item] : forall (L : list Item) (M : list Item) I, ($fix__sterling-$-stdLib-$-permutation (L) (M)) -> ($fix__sterling-$-stdLib-$-mem (I) (L)) -> $fix__sterling-$-stdLib-$-mem (I) (M).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(117);" id="toggleproof117">[Show Proof]</a>
<div class="proof" id="proof117" style="display: none;">
induction on 2.  intros P M.  M: case M.  P: case P.  apply sterling-$-stdLib-$-select_mem to P.  search.  P: case P.  M': apply IH to P1 M.  apply sterling-$-stdLib-$-mem_after_select_before to _ M'.  search.  </div>

Theorem sterling-$-stdLib-$-perm_lemma[Item] : forall A B B' (X : Item), ($fix__sterling-$-stdLib-$-permutation (B') (A)) -> ($fix__sterling-$-stdLib-$-select (X) (B') (B)) -> $fix__sterling-$-stdLib-$-permutation (B) ((X)::(A)).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(118);" id="toggleproof118">[Show Proof]</a>
<div class="proof" id="proof118" style="display: none;">
induction on 2.  intros P S.  S: case S.  search.  P: case P.  apply IH to P1 S.  search.  </div>

Theorem sterling-$-stdLib-$-permutation_symmetric[Item] : forall (M : list Item) (L : list Item), ($fix__sterling-$-stdLib-$-permutation (L) (M)) -> $fix__sterling-$-stdLib-$-permutation (M) (L).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(119);" id="toggleproof119">[Show Proof]</a>
<div class="proof" id="proof119" style="display: none;">
induction on 1.  intros P.  P: case P.  search.  PSub: apply IH to P1.  apply sterling-$-stdLib-$-perm_lemma to PSub P.  search.  </div>

Theorem sterling-$-stdLib-$-no_lookup_permutation[Key, Value] : forall (L : list ($lib__pair Key Value)) (P : list ($lib__pair Key Value)) (Key : Key), ($fix__sterling-$-stdLib-$-no_lookup (L) (Key)) -> ($fix__sterling-$-stdLib-$-permutation (L) (P)) -> $fix__sterling-$-stdLib-$-no_lookup (P) (Key).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(120);" id="toggleproof120">[Show Proof]</a>
<div class="proof" id="proof120" style="display: none;">
induction on 1.  intros NLkp P.  NLkp: case NLkp.  case P.  search.  P: case P.  NLkp': apply IH to NLkp1 P1.  apply sterling-$-stdLib-$-no_lookup_after_select_before to NLkp' P NLkp.  search.  </div>

Theorem sterling-$-stdLib-$-count_is_integer[Item] : forall (I : Item) L N, ($fix__sterling-$-stdLib-$-count (I) (L) (N)) -> is_integer (N).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(121);" id="toggleproof121">[Show Proof]</a>
<div class="proof" id="proof121" style="display: none;">
induction on 1.  intros C.  C: case C.  search.  apply IH to C.  apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ C1.  search.  apply IH to C1.  search.  </div>

Theorem sterling-$-stdLib-$-count_geq_0[Item] : forall (I : Item) L N, ($fix__sterling-$-stdLib-$-count (I) (L) (N)) -> $greatereq_integer (N) (($posInt) ($zero)).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(122);" id="toggleproof122">[Show Proof]</a>
<div class="proof" id="proof122" style="display: none;">
induction on 1.  intros C.  C: case C.  search.  GEq: apply IH to C.  apply extensibella-$-stdLib-$-greatereq_integer__add_positive to _ GEq C1.  search.  apply IH to C1.  search.  </div>

Theorem sterling-$-stdLib-$-select_count[Item] : forall (I : Item) L Rest N N', ($fix__sterling-$-stdLib-$-count (I) (L) (N)) -> ($fix__sterling-$-stdLib-$-select (I) (Rest) (L)) -> ($minus_integer (N) (($posInt) (($succ) ($zero))) (N')) -> $fix__sterling-$-stdLib-$-count (I) (Rest) (N').<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(123);" id="toggleproof123">[Show Proof]</a>
<div class="proof" id="proof123" style="display: none;">
induction on 2.  intros C S Minus.  S: case S.  IsN: apply sterling-$-stdLib-$-count_is_integer to C.  C: case C.  IsN1: apply sterling-$-stdLib-$-count_is_integer to C.  P: apply extensibella-$-stdLib-$-plus_integer_comm to _ _ C1.  M2: apply extensibella-$-stdLib-$-plus_minus_same_integer to _ _ P.  apply extensibella-$-stdLib-$-minus_integer_unique to Minus M2.  search.  apply C to _.  IsN: apply sterling-$-stdLib-$-count_is_integer to C.  C: case C.  IsN1: apply sterling-$-stdLib-$-count_is_integer to C.  P: apply extensibella-$-stdLib-$-plus_integer_comm to _ _ C1.  M2: apply extensibella-$-stdLib-$-plus_minus_same_integer to _ _ P.  apply extensibella-$-stdLib-$-minus_integer_unique to Minus M2.  Sub: apply extensibella-$-stdLib-$-minus_integer_total to IsN1 _ with N2 = ($posInt) (($succ) ($zero)).  C': apply IH to C S Sub.  P': apply extensibella-$-stdLib-$-minus_plus_same_integer to _ _ Sub.  apply sterling-$-stdLib-$-count_is_integer to C'.  apply extensibella-$-stdLib-$-plus_integer_comm to _ _ P'.  search.  apply IH to C1 S _.  search.  </div>

Theorem sterling-$-stdLib-$-count_select[Item] : forall (I : Item) L Rest N' N, ($fix__sterling-$-stdLib-$-count (I) (Rest) (N')) -> ($fix__sterling-$-stdLib-$-select (I) (Rest) (L)) -> ($plus_integer (($posInt) (($succ) ($zero))) (N') (N)) -> $fix__sterling-$-stdLib-$-count (I) (L) (N).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(124);" id="toggleproof124">[Show Proof]</a>
<div class="proof" id="proof124" style="display: none;">
induction on 2.  intros C S P.  S: case S.  search.  C: case C.  apply IH to C S _.  search.  apply IH to C1 S _.  search.  </div>

Theorem sterling-$-stdLib-$-select_count_neq[Item] : forall (I : Item) (J : Item) L Rest N, ($fix__sterling-$-stdLib-$-count (I) (L) (N)) -> ($fix__sterling-$-stdLib-$-select (J) (Rest) (L)) -> ((I = J) -> false) -> $fix__sterling-$-stdLib-$-count (I) (Rest) (N).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(125);" id="toggleproof125">[Show Proof]</a>
<div class="proof" id="proof125" style="display: none;">
induction on 2.  intros C S NEq.  S: case S.  C: case C.  apply NEq to _.  search.  C: case C.  apply IH to C S _.  search.  apply IH to C1 S _.  search.  </div>

Theorem sterling-$-stdLib-$-count_select_neq[Item] : forall (I : Item) (J : Item) L Rest N, ($fix__sterling-$-stdLib-$-count (I) (Rest) (N)) -> ($fix__sterling-$-stdLib-$-select (J) (Rest) (L)) -> ((I = J) -> false) -> $fix__sterling-$-stdLib-$-count (I) (L) (N).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(126);" id="toggleproof126">[Show Proof]</a>
<div class="proof" id="proof126" style="display: none;">
induction on 2.  intros C S NEq.  S: case S.  search.  C: case C.  apply IH to C S _.  search.  apply IH to C1 S _.  search.  </div>

Theorem sterling-$-stdLib-$-count_unique[Item] : forall (I : Item) NA NB L, ($fix__sterling-$-stdLib-$-count (I) (L) (NA)) -> ($fix__sterling-$-stdLib-$-count (I) (L) (NB)) -> NA = NB.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(127);" id="toggleproof127">[Show Proof]</a>
<div class="proof" id="proof127" style="display: none;">
induction on 1.  intros CA CB.  CA: case CA.  case CB.  search.  CB: case CB.  apply IH to CA CB.  apply extensibella-$-stdLib-$-plus_integer_unique to CA1 CB1.  search.  apply CB to _.  CB: case CB.  apply CA to _.  apply IH to CA1 CB1.  search.  </div>

Theorem sterling-$-stdLib-$-count_mem[Item] : forall (I : Item) N L, ($fix__sterling-$-stdLib-$-count (I) (L) (N)) -> ($greater_integer (N) (($posInt) ($zero))) -> $fix__sterling-$-stdLib-$-mem (I) (L).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(128);" id="toggleproof128">[Show Proof]</a>
<div class="proof" id="proof128" style="display: none;">
induction on 1.  intros C G.  C: case C.  L: apply extensibella-$-stdLib-$-greater_integer_flip_less to G.  apply extensibella-$-stdLib-$-less_integer_not_eq to L.  search.  apply IH to C1 _.  search.  </div>

Theorem sterling-$-stdLib-$-count_not_mem[Item] : forall (I : Item) L, ($fix__sterling-$-stdLib-$-count (I) (L) (($posInt) ($zero))) -> ($fix__sterling-$-stdLib-$-mem (I) (L)) -> false.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(129);" id="toggleproof129">[Show Proof]</a>
<div class="proof" id="proof129" style="display: none;">
induction on 1.  intros C Mem.  C: case C.  case Mem.  G: apply sterling-$-stdLib-$-count_geq_0 to C.  IsN: apply sterling-$-stdLib-$-count_is_integer to C.  P: apply extensibella-$-stdLib-$-plus_integer_comm to _ _ C1.  Or: apply extensibella-$-stdLib-$-greatereq_integer_greater_or_eq to G.  G': case Or.  G'': apply extensibella-$-stdLib-$-greater_plus_positive to _ _ C1 _.  case G''.  case H1.  case P.  Mem: case Mem.  backchain C.  apply IH to C1 Mem.  </div>

Theorem sterling-$-stdLib-$-count_greater_0[Item] : forall (I : Item) L N, ($fix__sterling-$-stdLib-$-count (I) ((I)::(L)) (N)) -> $greater_integer (N) (($posInt) ($zero)).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(130);" id="toggleproof130">[Show Proof]</a>
<div class="proof" id="proof130" style="display: none;">
induction on 1.  intros C.  C: case C.  GEq: apply sterling-$-stdLib-$-count_geq_0 to C.  Or: apply extensibella-$-stdLib-$-greatereq_integer_greater_or_eq to GEq.  G: case Or.  IsN1: apply sterling-$-stdLib-$-count_is_integer to C.  P: apply extensibella-$-stdLib-$-plus_integer_comm to _ _ C1.  G': apply extensibella-$-stdLib-$-greater_plus_positive to _ _ P _.  apply extensibella-$-stdLib-$-greater_integer_transitive to G' G.  search.  P: apply extensibella-$-stdLib-$-plus_integer_comm to _ _ C1.  case P.  search.  apply C to _.  </div>

Theorem sterling-$-stdLib-$-subset_mem[A] : forall (Sub : list A) (Sup : list A) A, ($fix__sterling-$-stdLib-$-subset (Sub) (Sup)) -> ($fix__sterling-$-stdLib-$-mem (A) (Sub)) -> $fix__sterling-$-stdLib-$-mem (A) (Sup).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(131);" id="toggleproof131">[Show Proof]</a>
<div class="proof" id="proof131" style="display: none;">
induction on 1.  intros Sub Mem.  Sub: case Sub.  case Mem.  Mem: case Mem.  search.  apply IH to Sub1 Mem.  search.  </div>

Theorem sterling-$-stdLib-$-subset_trans[A] : forall (B : list A) (C : list A) (A : list A), ($fix__sterling-$-stdLib-$-subset (A) (B)) -> ($fix__sterling-$-stdLib-$-subset (B) (C)) -> $fix__sterling-$-stdLib-$-subset (A) (C).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(132);" id="toggleproof132">[Show Proof]</a>
<div class="proof" id="proof132" style="display: none;">
induction on 1.  intros SAB SBC.  SAB: case SAB.  search.  apply sterling-$-stdLib-$-subset_mem to SBC SAB.  apply IH to SAB1 SBC.  search.  </div>

Theorem sterling-$-stdLib-$-subset_add_right[A] : forall Sub Sup (A : A), ($fix__sterling-$-stdLib-$-subset (Sub) (Sup)) -> $fix__sterling-$-stdLib-$-subset (Sub) ((A)::(Sup)).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(133);" id="toggleproof133">[Show Proof]</a>
<div class="proof" id="proof133" style="display: none;">
induction on 1.  intros S.  S: case S.  search.  apply IH to S1 with A = A.  search.  </div>

Theorem sterling-$-stdLib-$-permutation_counts[Item] : forall L P (I : Item) NL NP, ($fix__sterling-$-stdLib-$-permutation (L) (P)) -> ($fix__sterling-$-stdLib-$-count (I) (L) (NL)) -> ($fix__sterling-$-stdLib-$-count (I) (P) (NP)) -> NL = NP.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(134);" id="toggleproof134">[Show Proof]</a>
<div class="proof" id="proof134" style="display: none;">
induction on 2.  intros P CL CP.  CL: case CL.  case P.  case CP.  search.  P: case P.  S: case P (keep).  CP: case CP.  apply IH to P1 CL CP.  apply extensibella-$-stdLib-$-plus_integer_unique to CL1 CP1.  search.  apply CP to _.  IsNP: apply sterling-$-stdLib-$-count_is_integer to CP.  Minus: apply extensibella-$-stdLib-$-minus_integer_total to IsNP _ with N2 = ($posInt) (($succ) ($zero)).  C': apply sterling-$-stdLib-$-select_count to CP P Minus.  P': apply extensibella-$-stdLib-$-minus_plus_same_integer to _ _ Minus.  IsN3: apply extensibella-$-stdLib-$-minus_integer_is_integer to _ _ Minus.  Plus: apply extensibella-$-stdLib-$-plus_integer_comm to _ _ P'.  apply IH to P1 CL _.  apply extensibella-$-stdLib-$-plus_integer_unique to CL1 Plus.  search.  P: case P.  C: apply sterling-$-stdLib-$-select_count_neq to CP P CL.  apply IH to P1 CL1 C.  search.  </div>

Theorem sterling-$-stdLib-$-domain_mem[A, B] : forall L (A : A) (B : B) D, ($fix__sterling-$-stdLib-$-mem (($pair_c) (A) (B)) (L)) -> ($fix__sterling-$-stdLib-$-domain (L) (D)) -> $fix__sterling-$-stdLib-$-mem (A) (D).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(135);" id="toggleproof135">[Show Proof]</a>
<div class="proof" id="proof135" style="display: none;">
induction on 1.  intros Mem Dmn.  Mem: case Mem.  case Dmn.  search.  Dmn: case Dmn.  apply IH to Mem Dmn.  search.  </div>

Theorem sterling-$-stdLib-$-mem_domain[A, B] : forall (L : list ($lib__pair A B)) A D, ($fix__sterling-$-stdLib-$-domain (L) (D)) -> ($fix__sterling-$-stdLib-$-mem (A) (D)) -> exists B, $fix__sterling-$-stdLib-$-mem (($pair_c) (A) (B)) (L).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(136);" id="toggleproof136">[Show Proof]</a>
<div class="proof" id="proof136" style="display: none;">
induction on 2.  intros D M.  M: case M.  case D.  search.  D: case D.  apply IH to D M.  search.  </div>

Theorem sterling-$-stdLib-$-domain_select[A, B] : forall (L : list ($lib__pair A B)) LRest A B D, ($fix__sterling-$-stdLib-$-domain (L) (D)) -> ($fix__sterling-$-stdLib-$-select (($pair_c) (A) (B)) (LRest) (L)) -> exists DRest, ($fix__sterling-$-stdLib-$-select (A) (DRest) (D)) /\ ($fix__sterling-$-stdLib-$-domain (LRest) (DRest)).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(137);" id="toggleproof137">[Show Proof]</a>
<div class="proof" id="proof137" style="display: none;">
induction on 2.  intros Dmn Slct.  Slct: case Slct.  case Dmn.  search.  Dmn: case Dmn.  apply IH to Dmn Slct.  search.  </div>

Theorem sterling-$-stdLib-$-domain_unique[A, B] : forall (L : list ($lib__pair A B)) DA DB, ($fix__sterling-$-stdLib-$-domain (L) (DA)) -> ($fix__sterling-$-stdLib-$-domain (L) (DB)) -> DA = DB.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(138);" id="toggleproof138">[Show Proof]</a>
<div class="proof" id="proof138" style="display: none;">
induction on 1.  intros DmnA DmnB.  DmnA: case DmnA.  case DmnB.  search.  DmnB: case DmnB.  apply IH to DmnA DmnB.  search.  </div>

Theorem sterling-$-stdLib-$-values_mem[A, B] : forall L (A : A) (B : B) V, ($fix__sterling-$-stdLib-$-mem (($pair_c) (A) (B)) (L)) -> ($fix__sterling-$-stdLib-$-values (L) (V)) -> $fix__sterling-$-stdLib-$-mem (B) (V).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(139);" id="toggleproof139">[Show Proof]</a>
<div class="proof" id="proof139" style="display: none;">
induction on 1.  intros Mem Vals.  Mem: case Mem.  case Vals.  search.  Vals: case Vals.  apply IH to Mem Vals.  search.  </div>

Theorem sterling-$-stdLib-$-values_select[A, B] : forall (L : list ($lib__pair A B)) LRest A B V, ($fix__sterling-$-stdLib-$-values (L) (V)) -> ($fix__sterling-$-stdLib-$-select (($pair_c) (A) (B)) (LRest) (L)) -> exists VRest, ($fix__sterling-$-stdLib-$-select (B) (VRest) (V)) /\ ($fix__sterling-$-stdLib-$-values (LRest) (VRest)).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(140);" id="toggleproof140">[Show Proof]</a>
<div class="proof" id="proof140" style="display: none;">
induction on 2.  intros Vals Slct.  Slct: case Slct.  case Vals.  search.  Vals: case Vals.  apply IH to Vals Slct.  search.  </div>

Theorem sterling-$-stdLib-$-values_unique[A, B] : forall (L : list ($lib__pair A B)) VA VB, ($fix__sterling-$-stdLib-$-values (L) (VA)) -> ($fix__sterling-$-stdLib-$-values (L) (VB)) -> VA = VB.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(141);" id="toggleproof141">[Show Proof]</a>
<div class="proof" id="proof141" style="display: none;">
induction on 1.  intros VA VB.  VA: case VA.  case VB.  search.  VB: case VB.  apply IH to VA VB.  search.  </div>

Theorem sterling-$-stdLib-$-zip_unique[A, B] : forall (L1 : list A) (L2 : list B) LA LB, ($fix__sterling-$-stdLib-$-zip (L1) (L2) (LA)) -> ($fix__sterling-$-stdLib-$-zip (L1) (L2) (LB)) -> LA = LB.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(142);" id="toggleproof142">[Show Proof]</a>
<div class="proof" id="proof142" style="display: none;">
induction on 1.  intros ZA ZB.  ZA: case ZA.  case ZB.  search.  ZB: case ZB.  apply IH to ZA ZB.  search.  </div>

Theorem sterling-$-stdLib-$-zip_mem_after[A, B] : forall LA LB (A : A) (B : B) Z, ($fix__sterling-$-stdLib-$-zip (LA) (LB) (Z)) -> ($fix__sterling-$-stdLib-$-mem (($pair_c) (A) (B)) (Z)) -> ($fix__sterling-$-stdLib-$-mem (A) (LA)) /\ ($fix__sterling-$-stdLib-$-mem (B) (LB)).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(143);" id="toggleproof143">[Show Proof]</a>
<div class="proof" id="proof143" style="display: none;">
induction on 1.  intros Zip Mem.  Zip: case Zip.  case Mem.  Mem: case Mem.  search.  apply IH to Zip Mem.  search.  </div>

Theorem sterling-$-stdLib-$-zip_mem_before1[A, B] : forall LA (LB : list B) (A : A) Z, ($fix__sterling-$-stdLib-$-zip (LA) (LB) (Z)) -> ($fix__sterling-$-stdLib-$-mem (A) (LA)) -> exists B, $fix__sterling-$-stdLib-$-mem (($pair_c) (A) (B)) (Z).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(144);" id="toggleproof144">[Show Proof]</a>
<div class="proof" id="proof144" style="display: none;">
induction on 1.  intros Zip Mem.  Zip: case Zip.  case Mem.  Mem: case Mem.  search.  apply IH to Zip Mem.  search.  </div>

Theorem sterling-$-stdLib-$-zip_mem_before2[A, B] : forall (LA : list A) LB (B : B) Z, ($fix__sterling-$-stdLib-$-zip (LA) (LB) (Z)) -> ($fix__sterling-$-stdLib-$-mem (B) (LB)) -> exists A, $fix__sterling-$-stdLib-$-mem (($pair_c) (A) (B)) (Z).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(145);" id="toggleproof145">[Show Proof]</a>
<div class="proof" id="proof145" style="display: none;">
induction on 1.  intros Zip Mem.  Zip: case Zip.  case Mem.  Mem: case Mem.  search.  apply IH to Zip Mem.  search.  </div>

Theorem sterling-$-stdLib-$-drop_is_integer[A] : forall N (R : list A) (L : list A), ($fix__sterling-$-stdLib-$-drop (N) (L) (R)) -> is_integer (N).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(146);" id="toggleproof146">[Show Proof]</a>
<div class="proof" id="proof146" style="display: none;">
induction on 1.  intros D.  D: case D.  search.  apply IH to D1.  apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ D.  search.  </div>

Theorem sterling-$-stdLib-$-drop_geq_0[A] : forall N (R : list A) (L : list A), ($fix__sterling-$-stdLib-$-drop (N) (L) (R)) -> $greatereq_integer (N) (($posInt) ($zero)).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(147);" id="toggleproof147">[Show Proof]</a>
<div class="proof" id="proof147" style="display: none;">
induction on 1.  intros D.  D: case D.  search.  GEq: apply IH to D1.  LEq: case GEq.  G: apply extensibella-$-stdLib-$-greater_integer__add_positive to _ _ D.  L: apply extensibella-$-stdLib-$-greater_integer_flip_less to G.  apply extensibella-$-stdLib-$-less_integer_lesseq to L.  search.  </div>

Theorem sterling-$-stdLib-$-drop_unique[A] : forall N (RA : list A) (RB : list A) (L : list A), ($fix__sterling-$-stdLib-$-drop (N) (L) (RA)) -> ($fix__sterling-$-stdLib-$-drop (N) (L) (RB)) -> RA = RB.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(148);" id="toggleproof148">[Show Proof]</a>
<div class="proof" id="proof148" style="display: none;">
induction on 1.  intros DA DB.  DA: case DA.  DB: case DB.  search.  apply sterling-$-stdLib-$-drop_is_integer to DB1.  L: apply extensibella-$-stdLib-$-lt_plus_one to DB _.  GEq: apply sterling-$-stdLib-$-drop_geq_0 to DB1.  apply extensibella-$-stdLib-$-greatereq_less_integer_false to GEq L.  DB: case DB.  apply sterling-$-stdLib-$-drop_is_integer to DA1.  L: apply extensibella-$-stdLib-$-lt_plus_one to DA _.  GEq: apply sterling-$-stdLib-$-drop_geq_0 to DA1.  apply extensibella-$-stdLib-$-greatereq_less_integer_false to GEq L.  apply sterling-$-stdLib-$-drop_is_integer to DA1.  apply sterling-$-stdLib-$-drop_is_integer to DB1.  apply extensibella-$-stdLib-$-plus_integer_unique_addend to _ _ _ DA DB.  apply IH to DA1 DB1.  search.  </div>

Theorem sterling-$-stdLib-$-append_drop[A] : forall N (L2 : list A) (L : list A) (L1 : list A), ($append (L1) (L2) (L)) -> (extensibella-$-stdLib-$-length (L1) (N)) -> $fix__sterling-$-stdLib-$-drop (N) (L) (L2).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(149);" id="toggleproof149">[Show Proof]</a>
<div class="proof" id="proof149" style="display: none;">
induction on 2.  intros App Len.  Len: case Len.  case App.  search.  App: case App.  apply IH to App Len.  search.  </div>

Theorem sterling-$-stdLib-$-take_is_integer[A] : forall N (F : list A) (L : list A), ($fix__sterling-$-stdLib-$-take (N) (L) (F)) -> is_integer (N).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(150);" id="toggleproof150">[Show Proof]</a>
<div class="proof" id="proof150" style="display: none;">
induction on 1.  intros T.  T: case T.  search.  apply IH to T1.  apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ T.  search.  </div>

Theorem sterling-$-stdLib-$-take_geq_0[A] : forall N (F : list A) (L : list A), ($fix__sterling-$-stdLib-$-take (N) (L) (F)) -> $greatereq_integer (N) (($posInt) ($zero)).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(151);" id="toggleproof151">[Show Proof]</a>
<div class="proof" id="proof151" style="display: none;">
induction on 1.  intros T.  T: case T.  search.  GEq: apply IH to T1.  LEq: case GEq.  G: apply extensibella-$-stdLib-$-greater_integer__add_positive to _ _ T.  L: apply extensibella-$-stdLib-$-greater_integer_flip_less to G.  apply extensibella-$-stdLib-$-less_integer_lesseq to L.  search.  </div>

Theorem sterling-$-stdLib-$-take_unique[A] : forall N (RA : list A) (RB : list A) (L : list A), ($fix__sterling-$-stdLib-$-take (N) (L) (RA)) -> ($fix__sterling-$-stdLib-$-take (N) (L) (RB)) -> RA = RB.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(152);" id="toggleproof152">[Show Proof]</a>
<div class="proof" id="proof152" style="display: none;">
induction on 1.  intros TA TB.  TA: case TA.  TB: case TB.  search.  apply sterling-$-stdLib-$-take_is_integer to TB1.  L: apply extensibella-$-stdLib-$-lt_plus_one to TB _.  GEq: apply sterling-$-stdLib-$-take_geq_0 to TB1.  apply extensibella-$-stdLib-$-greatereq_less_integer_false to GEq L.  TB: case TB.  apply sterling-$-stdLib-$-take_is_integer to TA1.  L: apply extensibella-$-stdLib-$-lt_plus_one to TA _.  GEq: apply sterling-$-stdLib-$-take_geq_0 to TA1.  apply extensibella-$-stdLib-$-greatereq_less_integer_false to GEq L.  apply sterling-$-stdLib-$-take_is_integer to TA1.  apply sterling-$-stdLib-$-take_is_integer to TB1.  apply extensibella-$-stdLib-$-plus_integer_unique_addend to _ _ _ TA TB.  apply IH to TA1 TB1.  search.  </div>

Theorem sterling-$-stdLib-$-take_length[A] : forall N (R : list A) (L : list A), ($fix__sterling-$-stdLib-$-take (N) (L) (R)) -> extensibella-$-stdLib-$-length (R) (N).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(153);" id="toggleproof153">[Show Proof]</a>
<div class="proof" id="proof153" style="display: none;">
induction on 1.  intros T.  T: case T.  search.  L: apply IH to T1.  search.  </div>

Theorem sterling-$-stdLib-$-append_take[A] : forall N (L2 : list A) (L : list A) (L1 : list A), ($append (L1) (L2) (L)) -> (extensibella-$-stdLib-$-length (L1) (N)) -> $fix__sterling-$-stdLib-$-take (N) (L) (L1).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(154);" id="toggleproof154">[Show Proof]</a>
<div class="proof" id="proof154" style="display: none;">
induction on 2.  intros App Len.  Len: case Len.  search.  App: case App.  apply IH to App Len.  search.  </div>

Theorem sterling-$-stdLib-$-range_is : forall Low High R, (is_integer (Low)) -> ($fix__sterling-$-stdLib-$-range (Low) (High) (R)) -> is_list (is_integer) (R).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(155);" id="toggleproof155">[Show Proof]</a>
<div class="proof" id="proof155" style="display: none;">
induction on 2.  intros IsLow R.  R: case R.  search.  IsPlusOne: apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ R1.  apply IH to IsPlusOne R2.  search.  </div>

Theorem sterling-$-stdLib-$-is_list_int_mem : forall L (X : $lib__integer), (is_list (is_integer) (L)) -> ($fix__sterling-$-stdLib-$-mem (X) (L)) -> is_integer (X).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(156);" id="toggleproof156">[Show Proof]</a>
<div class="proof" id="proof156" style="display: none;">
induction on 2.  intros IsL Mem.  Mem: case Mem.  case IsL.  search.  Is: case IsL.  apply IH to _ Mem.  search.  </div>

Theorem sterling-$-stdLib-$-range_low_lesseq : forall Low High R X, (is_integer (Low)) -> ($fix__sterling-$-stdLib-$-range (Low) (High) (R)) -> ($fix__sterling-$-stdLib-$-mem (X) (R)) -> $lesseq_integer (Low) (X).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(157);" id="toggleproof157">[Show Proof]</a>
<div class="proof" id="proof157" style="display: none;">
induction on 3.  intros IsLow Range Mem.  apply sterling-$-stdLib-$-range_is to IsLow Range.  IsX: apply sterling-$-stdLib-$-is_list_int_mem to _ Mem.  Mem: case Mem.  R: case Range.  apply extensibella-$-stdLib-$-is_integer_lesseq to IsX.  search.  R: case Range.  apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ R1.  LEq: apply IH to _ R2 Mem.  L: apply extensibella-$-stdLib-$-lt_plus_one to R1 _.  LEq': apply extensibella-$-stdLib-$-less_integer_lesseq to L.  apply extensibella-$-stdLib-$-lesseq_integer_transitive to LEq' LEq.  search.  </div>

Theorem sterling-$-stdLib-$-range_high_lesseq : forall Low High R X, (is_integer (Low)) -> ($fix__sterling-$-stdLib-$-range (Low) (High) (R)) -> ($fix__sterling-$-stdLib-$-mem (X) (R)) -> $lesseq_integer (X) (High).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(158);" id="toggleproof158">[Show Proof]</a>
<div class="proof" id="proof158" style="display: none;">
induction on 2.  intros IsLow Range Mem.  Range: case Range.  case Mem.  Mem: case Mem.  search.  apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ Range1.  apply IH to _ Range2 Mem.  search.  </div>

Theorem sterling-$-stdLib-$-in_range : forall Low High R X, (is_integer (Low)) -> (is_integer (X)) -> ($fix__sterling-$-stdLib-$-range (Low) (High) (R)) -> ($lesseq_integer (Low) (X)) -> ($lesseq_integer (X) (High)) -> $fix__sterling-$-stdLib-$-mem (X) (R).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(159);" id="toggleproof159">[Show Proof]</a>
<div class="proof" id="proof159" style="display: none;">
induction on 3.  intros IsLow IsX R LowX XHigh.  R: case R.  L: apply extensibella-$-stdLib-$-lesseq_integer_transitive to LowX XHigh.  apply extensibella-$-stdLib-$-greater_lesseq_integer_false to R L.  Or: apply extensibella-$-stdLib-$-lesseq_integer_less_or_eq to LowX.  L: case Or.  P: apply extensibella-$-stdLib-$-plus_integer_comm to _ _ R1.  IsPlusOne: apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ P.  apply extensibella-$-stdLib-$-less_lesseq_plus_one to _ _ L P.  apply IH to _ _ R2 _ _.  search.  search.  </div>

Theorem sterling-$-stdLib-$-range_unique : forall Low High R1 R2, ($fix__sterling-$-stdLib-$-range (Low) (High) (R1)) -> ($fix__sterling-$-stdLib-$-range (Low) (High) (R2)) -> R1 = R2.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(160);" id="toggleproof160">[Show Proof]</a>
<div class="proof" id="proof160" style="display: none;">
induction on 1.  intros RA RB.  RA: case RA.  RB: case RB.  search.  apply extensibella-$-stdLib-$-greater_lesseq_integer_false to RA RB.  RB: case RB.  apply extensibella-$-stdLib-$-greater_lesseq_integer_false to RB RA.  apply extensibella-$-stdLib-$-plus_integer_unique to RA1 RB1.  apply IH to RA2 RB2.  search.  </div>

Theorem sterling-$-stdLib-$-range_smaller_exists : forall Low High R Low', (is_integer (Low)) -> (is_integer (Low')) -> ($fix__sterling-$-stdLib-$-range (Low) (High) (R)) -> ($less_integer (Low) (Low')) -> exists R', $fix__sterling-$-stdLib-$-range (Low') (High) (R').<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(161);" id="toggleproof161">[Show Proof]</a>
<div class="proof" id="proof161" style="display: none;">
induction on 3.  intros IsLow IsLow' R L.  R: case R.  G: apply extensibella-$-stdLib-$-less_integer_flip_greater to L.  apply extensibella-$-stdLib-$-greater_integer_transitive to G R.  search.  IsPlusOne: apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ R1.  P: apply extensibella-$-stdLib-$-plus_integer_comm to _ _ R1.  LEq: apply extensibella-$-stdLib-$-less_lesseq_plus_one to _ _ L P.  Or: apply extensibella-$-stdLib-$-lesseq_integer_less_or_eq to LEq.  L: case Or.  apply IH to _ _ R2 L1.  search.  search.  </div>

Theorem sterling-$-stdLib-$-range_subset : forall Low Low' High R R', (is_integer (Low)) -> (is_integer (Low')) -> ($fix__sterling-$-stdLib-$-range (Low) (High) (R)) -> ($fix__sterling-$-stdLib-$-range (Low') (High) (R')) -> ($less_integer (Low) (Low')) -> $fix__sterling-$-stdLib-$-subset (R') (R).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(162);" id="toggleproof162">[Show Proof]</a>
<div class="proof" id="proof162" style="display: none;">
induction on 4.  intros IsLow IsLow' R R' L.  R': case R'.  search.  P: apply extensibella-$-stdLib-$-plus_integer_comm to _ _ R'1.  LEq: apply extensibella-$-stdLib-$-less_integer_lesseq to L.  M: apply sterling-$-stdLib-$-in_range to _ _ R _ R'.  L': apply extensibella-$-stdLib-$-lt_plus_one to R'1 _.  apply extensibella-$-stdLib-$-less_integer_transitive to L L'.  apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ R'1.  apply IH to _ _ R R'2 _.  search.  </div>

Theorem sterling-$-stdLib-$-range_select_unique : forall Low High R X Rest Rest', (is_integer (Low)) -> ($fix__sterling-$-stdLib-$-range (Low) (High) (R)) -> ($fix__sterling-$-stdLib-$-select (X) (Rest) (R)) -> ($fix__sterling-$-stdLib-$-select (X) (Rest') (R)) -> Rest = Rest'.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(163);" id="toggleproof163">[Show Proof]</a>
<div class="proof" id="proof163" style="display: none;">
induction on 2.  intros IsLow Range Slct Slct'.  Range: case Range.  case Slct.  Slct: case Slct.  Slct': case Slct'.  search.  L: apply extensibella-$-stdLib-$-lt_plus_one to Range1 _.  M: apply sterling-$-stdLib-$-select_mem to Slct'.  IsPlusOne: apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ Range1.  LEq: apply sterling-$-stdLib-$-range_low_lesseq to _ Range2 M.  G: apply extensibella-$-stdLib-$-less_integer_flip_greater to L.  apply extensibella-$-stdLib-$-greater_lesseq_integer_false to G LEq.  Slct': case Slct'.  L: apply extensibella-$-stdLib-$-lt_plus_one to Range1 _.  M: apply sterling-$-stdLib-$-select_mem to Slct.  IsPlusOne: apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ Range1.  LEq: apply sterling-$-stdLib-$-range_low_lesseq to _ Range2 M.  G: apply extensibella-$-stdLib-$-less_integer_flip_greater to L.  apply extensibella-$-stdLib-$-greater_lesseq_integer_false to G LEq.  apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ Range1.  apply IH to _ Range2 Slct Slct'.  search.  </div>

Theorem sterling-$-stdLib-$-range_exists : forall Low High, (is_integer (Low)) -> (is_integer (High)) -> exists R, $fix__sterling-$-stdLib-$-range (Low) (High) (R).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(164);" id="toggleproof164">[Show Proof]</a>
<div class="proof" id="proof164" style="display: none;">
assert forall Low High Diff, (is_integer (Low)) -> (is_integer (High)) -> ($minus_integer (High) (Low) (Diff)) -> (acc (Diff)) -> exists R, $fix__sterling-$-stdLib-$-range (Low) (High) (R).  induction on 4.  intros IsLow IsHigh Minus Acc.  Or: apply extensibella-$-stdLib-$-integer_compare_total to IsLow IsHigh.  Comp: case Or.  P: apply extensibella-$-stdLib-$-plus_integer_total to _ IsLow with N1 = ($posInt) (($succ) ($zero)).  IsN3: apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ P.  LowN3: apply extensibella-$-stdLib-$-lt_plus_one to P _.  Minus': apply extensibella-$-stdLib-$-minus_integer_total to IsHigh IsN3.  L: apply extensibella-$-stdLib-$-minus_larger to _ Minus Minus' LowN3.  Acc: case Acc.  Or: apply extensibella-$-stdLib-$-integer_compare_total to IsN3 IsHigh.  Comp: case Or.  Or: apply extensibella-$-stdLib-$-lesseq_integer_less_or_eq to Comp1.  L': case Or.  L0N1: apply extensibella-$-stdLib-$-minus_smaller_positive to Minus' L'.  LEq: apply extensibella-$-stdLib-$-less_integer_lesseq to L0N1.  A: apply Acc to LEq L.  apply IH to _ _ Minus' A.  search.  M: apply extensibella-$-stdLib-$-minus_integer_same to IsHigh.  apply extensibella-$-stdLib-$-minus_integer_unique to M Minus'.  A: apply Acc to _ L.  apply IH to _ _ Minus' A.  search.  search.  search.  intros IsLow IsHigh.  Minus: apply extensibella-$-stdLib-$-minus_integer_total to IsHigh IsLow.  IsN3: apply extensibella-$-stdLib-$-minus_integer_is_integer to _ _ Minus.  Or: apply extensibella-$-stdLib-$-integer_compare_total to _ IsN3 with A = ($posInt) ($zero).  Comp: case Or.  apply extensibella-$-stdLib-$-all_acc to IsN3 Comp.  apply H1 to _ _ Minus _.  search.  NegN3: apply extensibella-$-stdLib-$-greater_integer_flip_less to Comp.  apply extensibella-$-stdLib-$-minus_integer_diff_neg to NegN3 Minus.  search.  </div>

Theorem library-$-host-$-trans_e_unique  : forall E E1 E2, ($trans__library-$-host-$-e (E) (E1)) -> ($trans__library-$-host-$-e (E) (E2)) -> E1 = E2.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(165);" id="toggleproof165">[Show Proof]</a>
<div class="proof" id="proof165" style="display: none;">
intros Hyp Hyp1.  Hyp: case Hyp (keep).   case Hyp1.  search.  case Hyp1.  search.  case Hyp1.  search.  case Hyp1.  search.  case Hyp1.  search.  </div>

Theorem library-$-host-$-trans_e_is  : forall E E', ($trans__library-$-host-$-e (E) (E')) -> ($ext__0__library-$-host-$-is_e (E)) -> $ext__0__library-$-host-$-is_e (E').<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(166);" id="toggleproof166">[Show Proof]</a>
<div class="proof" id="proof166" style="display: none;">
intros Hyp Hyp1.  Hyp: case Hyp (keep).   case Hyp1.  search.  case Hyp1.  search.  case Hyp1.  search.  case Hyp1.  search.  case Hyp1.  search.  </div>

Theorem library-$-host-$-trans_s_unique  : forall S S1 S2, ($trans__library-$-host-$-s (S) (S1)) -> ($trans__library-$-host-$-s (S) (S2)) -> S1 = S2.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(167);" id="toggleproof167">[Show Proof]</a>
<div class="proof" id="proof167" style="display: none;">
intros Hyp Hyp1.  Hyp: case Hyp (keep).   case Hyp1.  search.  case Hyp1.  search.  </div>

Theorem library-$-host-$-trans_s_is  : forall S S', ($trans__library-$-host-$-s (S) (S')) -> ($ext__0__library-$-host-$-is_s (S)) -> $ext__0__library-$-host-$-is_s (S').<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(168);" id="toggleproof168">[Show Proof]</a>
<div class="proof" id="proof168" style="display: none;">
intros Hyp Hyp1.  Hyp: case Hyp (keep).   case Hyp1.  search.  case Hyp1.  search.  </div>

Theorem library-$-host-$-trans_ty_unique  : forall Ty Ty1 Ty2, ($trans__library-$-host-$-ty (Ty) (Ty1)) -> ($trans__library-$-host-$-ty (Ty) (Ty2)) -> Ty1 = Ty2.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(169);" id="toggleproof169">[Show Proof]</a>
<div class="proof" id="proof169" style="display: none;">
intros Hyp Hyp1.  Hyp: case Hyp (keep).   case Hyp1.  search.  </div>

Theorem library-$-host-$-trans_ty_is  : forall Ty Ty', ($trans__library-$-host-$-ty (Ty) (Ty')) -> ($ext__0__library-$-host-$-is_ty (Ty)) -> $ext__0__library-$-host-$-is_ty (Ty').<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(170);" id="toggleproof170">[Show Proof]</a>
<div class="proof" id="proof170" style="display: none;">
intros Hyp Hyp1.  Hyp: case Hyp (keep).   case Hyp1.  search.  </div>

Theorem library-$-host-$-ext_ind_pos_is_e : forall E N, ($extSize__library-$-host-$-is_e (E) (N) ) -> $lesseq_integer (($posInt) ($zero)) (N) .<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(171);" id="toggleproof171">[Show Proof]</a>
<div class="proof" id="proof171" style="display: none;">
induction on 1.
intros ES. ES1: case ES.
 search.
 search.
 search.
 search.
 apply IH to ES2. apply IH to ES3. apply extensibella-$-stdLib-$-lesseq_integer__add_positive to _ _ ES1. search.
 apply IH to ES2. apply IH to ES3. apply extensibella-$-stdLib-$-lesseq_integer__add_positive to _ _ ES1. search.
 apply IH to ES2. apply IH to ES3. apply extensibella-$-stdLib-$-lesseq_integer__add_positive to _ _ ES1. search.
 apply IH to ES1. search.
 search.
 apply IH to ES3. apply IH to ES4. apply extensibella-$-stdLib-$-lesseq_integer__add_positive to _ _ ES2. apply extensibella-$-stdLib-$-lesseq_integer__add_positive to _ _ ES1. search.
 apply IH to ES2. apply extensibella-$-stdLib-$-lesseq_integer__add_positive to _ _ ES1. search.
 apply IH to ES2. apply extensibella-$-stdLib-$-lesseq_integer__add_positive to _ _ ES1. search.
 apply IH to ES2. apply extensibella-$-stdLib-$-lesseq_integer__add_positive to _ _ ES1. search.</div>

Theorem library-$-host-$-ext_ind_is_int_is_e : forall E N, ($extSize__library-$-host-$-is_e (E) (N) ) -> is_integer (N) .<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(172);" id="toggleproof172">[Show Proof]</a>
<div class="proof" id="proof172" style="display: none;">
induction on 1.
intros ES. ES1: case ES.
 search.
 search.
 search.
 search.
 apply IH to ES2. apply IH to ES3. apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ ES1. search.
 apply IH to ES2. apply IH to ES3. apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ ES1. search.
 apply IH to ES2. apply IH to ES3. apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ ES1. search.
 apply IH to ES1. search.
 search.
 apply IH to ES3. apply IH to ES4. apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ ES2. apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ ES1. search.
 apply IH to ES2. apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ ES1. search.
 apply IH to ES2. apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ ES1. search.
 apply IH to ES2. apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ ES1. search.</div>

Theorem library-$-host-$-drop_ext_ind_is_e : forall E N, ($extSize__library-$-host-$-is_e (E) (N) ) -> $ext__0__library-$-host-$-is_e (E) .<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(173);" id="toggleproof173">[Show Proof]</a>
<div class="proof" id="proof173" style="display: none;">
induction on 1.
intros ES. ES1: case ES.
 search.
 search.
 search.
 search.
 apply IH to ES2. apply IH to ES3. search.
 apply IH to ES2. apply IH to ES3. search.
 apply IH to ES2. apply IH to ES3. search.
 apply IH to ES1. search.
 search.
 apply IH to ES3. apply IH to ES4. search.
 apply IH to ES2. search.
 apply IH to ES2. search.
 apply IH to ES2. search.</div>

Theorem $toExtSize__$ext__0__library-$-host-$-is_e : forall E, ($ext__0__library-$-host-$-is_e (E) ) -> exists N, $extSize__library-$-host-$-is_e (E) (N) .<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(174);" id="toggleproof174">[Show Proof]</a>
<div class="proof" id="proof174" style="display: none;">
induction on 1. rename IH to IH0.
 intros R. R1: case R.
  search.
  search.
  search.
  search.
  ES319: apply IH0 to R1. ES320: apply IH0 to R2. Is321: apply library-$-host-$-ext_ind_is_int_is_e to ES319. Is322: apply library-$-host-$-ext_ind_is_int_is_e to ES320.  Plus323: apply extensibella-$-stdLib-$-plus_integer_total to Is321 Is322. Is324: apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ Plus323. search.
  ES325: apply IH0 to R1. ES326: apply IH0 to R2. Is327: apply library-$-host-$-ext_ind_is_int_is_e to ES325. Is328: apply library-$-host-$-ext_ind_is_int_is_e to ES326.  Plus329: apply extensibella-$-stdLib-$-plus_integer_total to Is327 Is328. Is330: apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ Plus329. search.
  ES331: apply IH0 to R1. ES332: apply IH0 to R2. Is333: apply library-$-host-$-ext_ind_is_int_is_e to ES331. Is334: apply library-$-host-$-ext_ind_is_int_is_e to ES332.  Plus335: apply extensibella-$-stdLib-$-plus_integer_total to Is333 Is334. Is336: apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ Plus335. search.
  ES337: apply IH0 to R1. Is338: apply library-$-host-$-ext_ind_is_int_is_e to ES337.  search.
  search.
  ES339: apply IH0 to R1. ES340: apply IH0 to R2. Is341: apply library-$-host-$-ext_ind_is_int_is_e to ES339. Is342: apply library-$-host-$-ext_ind_is_int_is_e to ES340.  Plus343: apply extensibella-$-stdLib-$-plus_integer_total to Is341 Is342. Is344: apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ Plus343. apply extensibella-$-stdLib-$-plus_integer_total to _ Is344 with N1 = $posInt ($succ $zero). search.
  ES345: apply IH0 to R1. Is346: apply library-$-host-$-ext_ind_is_int_is_e to ES345.  apply extensibella-$-stdLib-$-plus_integer_total to _ Is346 with N1 = $posInt ($succ $zero). search.
  ES347: apply IH0 to R1. Is348: apply library-$-host-$-ext_ind_is_int_is_e to ES347.  apply extensibella-$-stdLib-$-plus_integer_total to _ Is348 with N1 = $posInt ($succ $zero). search.
  ES349: apply IH0 to R1. Is350: apply library-$-host-$-ext_ind_is_int_is_e to ES349.  apply extensibella-$-stdLib-$-plus_integer_total to _ Is350 with N1 = $posInt ($succ $zero). search.</div>

Theorem $toTransRel__$ext__0__library-$-host-$-is_e : forall N E, ($extSize__library-$-host-$-is_e (E) (N) ) -> (acc (N) ) -> $transRel__library-$-host-$-is_e (E) .<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(175);" id="toggleproof175">[Show Proof]</a>
<div class="proof" id="proof175" style="display: none;">
induction on 2. induction on 1.
 intros Rel Acc. Rel: case Rel (keep).
  search.
  search.
  search.
  search.
  apply library-$-host-$-ext_ind_pos_is_e to Rel2. apply library-$-host-$-ext_ind_is_int_is_e to Rel2. apply library-$-host-$-ext_ind_pos_is_e to Rel3. apply library-$-host-$-ext_ind_is_int_is_e to Rel3. apply extensibella-$-stdLib-$-lesseq_integer__add_positives to _ _ Rel1. apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ Rel1. LE_R351: apply extensibella-$-stdLib-$-lte_right to Rel1 _ _ _. LE_L352: apply extensibella-$-stdLib-$-lte_left to Rel1 _ _ _. A353: case Acc (keep). Or354: apply extensibella-$-stdLib-$-lesseq_integer_less_or_eq to LE_R351. L355: case Or354. A356: apply A353 to _ L355. apply IH1 to Rel3 A356. Or357: apply extensibella-$-stdLib-$-lesseq_integer_less_or_eq to LE_L352. L358: case Or357. A359: apply A353 to _ L358. apply IH1 to Rel2 A359. search. apply IH1 to Rel2 Acc. search. apply IH1 to Rel3 Acc. Or357: apply extensibella-$-stdLib-$-lesseq_integer_less_or_eq to LE_L352. L358: case Or357. A359: apply A353 to _ L358. apply IH1 to Rel2 A359. search. apply IH1 to Rel2 Acc. search.
  apply library-$-host-$-ext_ind_pos_is_e to Rel2. apply library-$-host-$-ext_ind_is_int_is_e to Rel2. apply library-$-host-$-ext_ind_pos_is_e to Rel3. apply library-$-host-$-ext_ind_is_int_is_e to Rel3. apply extensibella-$-stdLib-$-lesseq_integer__add_positives to _ _ Rel1. apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ Rel1. LE_R360: apply extensibella-$-stdLib-$-lte_right to Rel1 _ _ _. LE_L361: apply extensibella-$-stdLib-$-lte_left to Rel1 _ _ _. A362: case Acc (keep). Or363: apply extensibella-$-stdLib-$-lesseq_integer_less_or_eq to LE_R360. L364: case Or363. A365: apply A362 to _ L364. apply IH1 to Rel3 A365. Or366: apply extensibella-$-stdLib-$-lesseq_integer_less_or_eq to LE_L361. L367: case Or366. A368: apply A362 to _ L367. apply IH1 to Rel2 A368. search. apply IH1 to Rel2 Acc. search. apply IH1 to Rel3 Acc. Or366: apply extensibella-$-stdLib-$-lesseq_integer_less_or_eq to LE_L361. L367: case Or366. A368: apply A362 to _ L367. apply IH1 to Rel2 A368. search. apply IH1 to Rel2 Acc. search.
  apply library-$-host-$-ext_ind_pos_is_e to Rel2. apply library-$-host-$-ext_ind_is_int_is_e to Rel2. apply library-$-host-$-ext_ind_pos_is_e to Rel3. apply library-$-host-$-ext_ind_is_int_is_e to Rel3. apply extensibella-$-stdLib-$-lesseq_integer__add_positives to _ _ Rel1. apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ Rel1. LE_R369: apply extensibella-$-stdLib-$-lte_right to Rel1 _ _ _. LE_L370: apply extensibella-$-stdLib-$-lte_left to Rel1 _ _ _. A371: case Acc (keep). Or372: apply extensibella-$-stdLib-$-lesseq_integer_less_or_eq to LE_R369. L373: case Or372. A374: apply A371 to _ L373. apply IH1 to Rel3 A374. Or375: apply extensibella-$-stdLib-$-lesseq_integer_less_or_eq to LE_L370. L376: case Or375. A377: apply A371 to _ L376. apply IH1 to Rel2 A377. search. apply IH1 to Rel2 Acc. search. apply IH1 to Rel3 Acc. Or375: apply extensibella-$-stdLib-$-lesseq_integer_less_or_eq to LE_L370. L376: case Or375. A377: apply A371 to _ L376. apply IH1 to Rel2 A377. search. apply IH1 to Rel2 Acc. search.
  apply library-$-host-$-ext_ind_pos_is_e to Rel1. apply library-$-host-$-ext_ind_is_int_is_e to Rel1.   IS378: apply library-$-host-$-ext_ind_is_int_is_e to Rel1.LE379: apply extensibella-$-stdLib-$-is_integer_lesseq to IS378.A380: case Acc (keep). Or381: apply extensibella-$-stdLib-$-lesseq_integer_less_or_eq to LE379. L382: case Or381. A383: apply A380 to _ L382. apply IH1 to Rel1 A383. search. apply IH1 to Rel1 Acc. search.
search.   Trans: assert $trans__library-$-host-$-e ((library-$-list-$-cons) (E1) (E2)) ((library-$-host-$-eq) (E1) (E2)).   Acc: case Acc.   ESTrans: assert $extSize__library-$-host-$-is_e ((library-$-host-$-eq) (E1) (E2)) (N4).   IsN2: apply library-$-host-$-ext_ind_is_int_is_e to Rel3.   IsN3: apply library-$-host-$-ext_ind_is_int_is_e to Rel4.   IsN4: apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ Rel2.   L: apply extensibella-$-stdLib-$-lt_plus_one to Rel1 IsN4.   N2Pos: apply library-$-host-$-ext_ind_pos_is_e to Rel3.   N3Pos: apply library-$-host-$-ext_ind_pos_is_e to Rel4.   N4Pos: apply extensibella-$-stdLib-$-lesseq_integer__add_positive to N2Pos N3Pos Rel2.   A: apply Acc to _ L.   TTrans: apply IH to ESTrans A.   LN2: assert $less_integer (N2) (N).   Or: apply extensibella-$-stdLib-$-lt_left to Rel2 N2Pos N3Pos.   E: case Or.   apply extensibella-$-stdLib-$-less_integer_transitive to E L.   search.   search.   LN3: assert $less_integer (N3) (N).   Or: apply extensibella-$-stdLib-$-lt_right to Rel2 IsN3 N2Pos N3Pos.   E: case Or.   apply extensibella-$-stdLib-$-less_integer_transitive to E L.   search.   search.   AN2: apply Acc to N2Pos LN2.   AN3: apply Acc to N3Pos LN3.   apply IH to Rel3 AN2.   apply IH to Rel4 AN3.   search.   Trans: assert $trans__library-$-host-$-e ((library-$-list-$-null) (E1)) (E1).   IsN2: apply library-$-host-$-ext_ind_is_int_is_e to Rel2.   L: apply extensibella-$-stdLib-$-lt_plus_one to Rel1 IsN2.   Acc: case Acc.   N2Pos: apply library-$-host-$-ext_ind_pos_is_e to Rel2.   AN2: apply Acc to N2Pos L.   apply IH to Rel2 AN2.   search.   Trans: assert $trans__library-$-host-$-e ((library-$-list-$-head) (E1)) (E1).   IsN2: apply library-$-host-$-ext_ind_is_int_is_e to Rel2.   L: apply extensibella-$-stdLib-$-lt_plus_one to Rel1 IsN2.   Acc: case Acc.   N2Pos: apply library-$-host-$-ext_ind_pos_is_e to Rel2.   AN2: apply Acc to N2Pos L.   apply IH to Rel2 AN2.   search.   Trans: assert $trans__library-$-host-$-e ((library-$-list-$-tail) (E1)) (E1).   IsN2: apply library-$-host-$-ext_ind_is_int_is_e to Rel2.   L: apply extensibella-$-stdLib-$-lt_plus_one to Rel1 IsN2.   Acc: case Acc.   N2Pos: apply library-$-host-$-ext_ind_pos_is_e to Rel2.   AN2: apply Acc to N2Pos L.   apply IH to Rel2 AN2.   search.  </div>



Theorem $extInd_$ext__0__library-$-host-$-is_e : forall E, ($ext__0__library-$-host-$-is_e (E) ) -> $transRel__library-$-host-$-is_e (E) .<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(176);" id="toggleproof176">[Show Proof]</a>
<div class="proof" id="proof176" style="display: none;">
intros R. ES: apply $toExtSize__$ext__0__library-$-host-$-is_e to R.
P: apply library-$-host-$-ext_ind_pos_is_e to ES. Is: apply library-$-host-$-ext_ind_is_int_is_e to ES. A: apply extensibella-$-stdLib-$-all_acc to Is P.
apply $toTransRel__$ext__0__library-$-host-$-is_e to ES A. search.
Theorem $dropT_$ext__0__library-$-host-$-is_e : forall E, ($transRel__library-$-host-$-is_e (E) ) -> $ext__0__library-$-host-$-is_e (E) .
induction on 1.
intros R. R: case R (keep).
  search.
  search.
  search.
  search.
  apply IH to R1. apply IH to R2. search.
  apply IH to R1. apply IH to R2. search.
  apply IH to R1. apply IH to R2. search.
  apply IH to R1. search.
  search.
  apply IH to R3. apply IH to R4. search.
  apply IH to R3. search.
  apply IH to R3. search.
  apply IH to R3. search.</div>



Theorem library-$-host-$-is_e_var_or_not : forall E, ($ext__0__library-$-host-$-is_e (E)) -> (exists N, E = (library-$-host-$-var) (N)) \/ ((exists N, E = (library-$-host-$-var) (N)) -> false).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(177);" id="toggleproof177">[Show Proof]</a>
<div class="proof" id="proof177" style="display: none;">
induction on 1. 
 intros IsE. IsE: case IsE (keep).
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  </div>

Theorem library-$-host-$-is_e_intlit_or_not : forall E, ($ext__0__library-$-host-$-is_e (E)) -> (exists I, E = (library-$-host-$-intlit) (I)) \/ ((exists I, E = (library-$-host-$-intlit) (I)) -> false).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(178);" id="toggleproof178">[Show Proof]</a>
<div class="proof" id="proof178" style="display: none;">
induction on 1. 
 intros IsE. IsE: case IsE (keep).
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  </div>

Theorem library-$-host-$-is_e_trueE_or_not : forall E, ($ext__0__library-$-host-$-is_e (E)) -> (E = library-$-host-$-trueE) \/ ((E = library-$-host-$-trueE) -> false).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(179);" id="toggleproof179">[Show Proof]</a>
<div class="proof" id="proof179" style="display: none;">
induction on 1. 
 intros IsE. IsE: case IsE (keep).
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  </div>

Theorem library-$-host-$-is_e_falseE_or_not : forall E, ($ext__0__library-$-host-$-is_e (E)) -> (E = library-$-host-$-falseE) \/ ((E = library-$-host-$-falseE) -> false).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(180);" id="toggleproof180">[Show Proof]</a>
<div class="proof" id="proof180" style="display: none;">
induction on 1. 
 intros IsE. IsE: case IsE (keep).
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  </div>

Theorem library-$-host-$-is_e_add_or_not : forall E, ($ext__0__library-$-host-$-is_e (E)) -> (exists E1 E2, E = (library-$-host-$-add) (E1) (E2)) \/ ((exists E1 E2, E = (library-$-host-$-add) (E1) (E2)) -> false).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(181);" id="toggleproof181">[Show Proof]</a>
<div class="proof" id="proof181" style="display: none;">
induction on 1. 
 intros IsE. IsE: case IsE (keep).
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  </div>

Theorem library-$-host-$-is_e_eqC_or_not : forall E, ($ext__0__library-$-host-$-is_e (E)) -> (exists E1 E2, E = (library-$-host-$-eq) (E1) (E2)) \/ ((exists E1 E2, E = (library-$-host-$-eq) (E1) (E2)) -> false).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(182);" id="toggleproof182">[Show Proof]</a>
<div class="proof" id="proof182" style="display: none;">
induction on 1. 
 intros IsE. IsE: case IsE (keep).
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  </div>

Theorem library-$-host-$-is_e_gt_or_not : forall E, ($ext__0__library-$-host-$-is_e (E)) -> (exists E1 E2, E = (library-$-host-$-gt) (E1) (E2)) \/ ((exists E1 E2, E = (library-$-host-$-gt) (E1) (E2)) -> false).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(183);" id="toggleproof183">[Show Proof]</a>
<div class="proof" id="proof183" style="display: none;">
induction on 1. 
 intros IsE. IsE: case IsE (keep).
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  </div>

Theorem library-$-host-$-is_e_not_or_not : forall E, ($ext__0__library-$-host-$-is_e (E)) -> (exists E', E = (library-$-host-$-not) (E')) \/ ((exists E', E = (library-$-host-$-not) (E')) -> false).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(184);" id="toggleproof184">[Show Proof]</a>
<div class="proof" id="proof184" style="display: none;">
induction on 1. 
 intros IsE. IsE: case IsE (keep).
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  </div>

Theorem $extThm_318 : forall E, ($transRel__library-$-host-$-is_e (E)) -> (E = library-$-list-$-nil) \/ ((E = library-$-list-$-nil) -> false).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(185);" id="toggleproof185">[Show Proof]</a>
<div class="proof" id="proof185" style="display: none;">
induction on 1. 
 intros IsE. IsE: case IsE (keep).
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE2.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE2.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE2.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE3.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE4.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE3.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE3.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE3.   search.  </div>
Theorem library-$-list-$-is_e_nil_or_not : forall E, ($ext__0__library-$-host-$-is_e (E)) -> (E = library-$-list-$-nil) \/ ((E = library-$-list-$-nil) -> false).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(186);" id="toggleproof186">[Show Proof]</a>
<div class="proof" id="proof186" style="display: none;">
intros IsE. $R: apply $extInd_$ext__0__library-$-host-$-is_e to IsE. apply $extThm_318 to $R. search.</div>
Theorem $extThm_317 : forall E, ($transRel__library-$-host-$-is_e (E)) -> (exists E1 E2, E = (library-$-list-$-cons) (E1) (E2)) \/ ((exists E1 E2, E = (library-$-list-$-cons) (E1) (E2)) -> false).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(187);" id="toggleproof187">[Show Proof]</a>
<div class="proof" id="proof187" style="display: none;">
induction on 1. 
 intros IsE. IsE: case IsE (keep).
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE2.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE2.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE2.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE3.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE4.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE3.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE3.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE3.   search.  </div>
Theorem library-$-list-$-is_e_cons_or_not : forall E, ($ext__0__library-$-host-$-is_e (E)) -> (exists E1 E2, E = (library-$-list-$-cons) (E1) (E2)) \/ ((exists E1 E2, E = (library-$-list-$-cons) (E1) (E2)) -> false).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(188);" id="toggleproof188">[Show Proof]</a>
<div class="proof" id="proof188" style="display: none;">
intros IsE. $R: apply $extInd_$ext__0__library-$-host-$-is_e to IsE. apply $extThm_317 to $R. search.</div>
Theorem $extThm_316 : forall E, ($transRel__library-$-host-$-is_e (E)) -> (exists E', E = (library-$-list-$-null) (E')) \/ ((exists E', E = (library-$-list-$-null) (E')) -> false).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(189);" id="toggleproof189">[Show Proof]</a>
<div class="proof" id="proof189" style="display: none;">
induction on 1. 
 intros IsE. IsE: case IsE (keep).
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE2.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE2.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE2.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE3.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE4.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE3.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE3.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE3.   search.  </div>
Theorem library-$-list-$-is_e_null_or_not : forall E, ($ext__0__library-$-host-$-is_e (E)) -> (exists E', E = (library-$-list-$-null) (E')) \/ ((exists E', E = (library-$-list-$-null) (E')) -> false).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(190);" id="toggleproof190">[Show Proof]</a>
<div class="proof" id="proof190" style="display: none;">
intros IsE. $R: apply $extInd_$ext__0__library-$-host-$-is_e to IsE. apply $extThm_316 to $R. search.</div>
Theorem $extThm_315 : forall E, ($transRel__library-$-host-$-is_e (E)) -> (exists E', E = (library-$-list-$-head) (E')) \/ ((exists E', E = (library-$-list-$-head) (E')) -> false).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(191);" id="toggleproof191">[Show Proof]</a>
<div class="proof" id="proof191" style="display: none;">
induction on 1. 
 intros IsE. IsE: case IsE (keep).
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE2.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE2.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE2.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE3.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE4.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE3.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE3.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE3.   search.  </div>
Theorem library-$-list-$-is_e_head_or_not : forall E, ($ext__0__library-$-host-$-is_e (E)) -> (exists E', E = (library-$-list-$-head) (E')) \/ ((exists E', E = (library-$-list-$-head) (E')) -> false).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(192);" id="toggleproof192">[Show Proof]</a>
<div class="proof" id="proof192" style="display: none;">
intros IsE. $R: apply $extInd_$ext__0__library-$-host-$-is_e to IsE. apply $extThm_315 to $R. search.</div>
Theorem $extThm_314 : forall E, ($transRel__library-$-host-$-is_e (E)) -> (exists E', E = (library-$-list-$-tail) (E')) \/ ((exists E', E = (library-$-list-$-tail) (E')) -> false).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(193);" id="toggleproof193">[Show Proof]</a>
<div class="proof" id="proof193" style="display: none;">
induction on 1. 
 intros IsE. IsE: case IsE (keep).
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE2.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE2.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE2.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE3.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE4.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE3.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE3.   search.  
  apply $dropT_$ext__0__library-$-host-$-is_e to IsE.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE1.   apply $dropT_$ext__0__library-$-host-$-is_e to IsE3.   search.  </div>
Theorem library-$-list-$-is_e_tail_or_not : forall E, ($ext__0__library-$-host-$-is_e (E)) -> (exists E', E = (library-$-list-$-tail) (E')) \/ ((exists E', E = (library-$-list-$-tail) (E')) -> false).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(194);" id="toggleproof194">[Show Proof]</a>
<div class="proof" id="proof194" style="display: none;">
intros IsE. $R: apply $extInd_$ext__0__library-$-host-$-is_e to IsE. apply $extThm_314 to $R. search.</div>
Theorem library-$-host-$-is_e_eq_or_not : forall E1 E2, ($ext__0__library-$-host-$-is_e (E1)) -> ($ext__0__library-$-host-$-is_e (E2)) -> (E1 = E2) \/ ((E1 = E2) -> false).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(195);" id="toggleproof195">[Show Proof]</a>
<div class="proof" id="proof195" style="display: none;">
induction on 1. 
 intros IsE1 IsE2. IsE1: case IsE1 (keep).
  Or: apply library-$-host-$-is_e_var_or_not to IsE2.   E: case Or.   Is: case IsE2.   Or: apply extensibella-$-stdLib-$-is_string_eq_or_not to IsE3 Is.   E: case Or.   search.   right.   intros Eq.   case Eq.   backchain E.   right.   intros Eq.   backchain E.   case Eq.   search.  
  Or: apply library-$-host-$-is_e_intlit_or_not to IsE2.   E: case Or.   Is: case IsE2.   Or: apply extensibella-$-stdLib-$-is_integer_eq_or_not to IsE3 Is.   E: case Or.   search.   right.   intros Eq.   case Eq.   backchain E.   right.   intros Eq.   backchain E.   case Eq.   search.  
  Or: apply library-$-host-$-is_e_trueE_or_not to IsE2.   E: case Or.   search.   right.   intros Eq.   case Eq.   backchain E.  
  Or: apply library-$-host-$-is_e_falseE_or_not to IsE2.   E: case Or.   search.   right.   intros Eq.   case Eq.   backchain E.  
  Or: apply library-$-host-$-is_e_add_or_not to IsE2.   E: case Or.   Is: case IsE2.   Or: apply IH to IsE3 Is.   E: case Or.   Or: apply IH to IsE4 Is1.   E: case Or.   search.   right.   intros Eq.   case Eq.   backchain E.   right.   intros Eq.   case Eq.   backchain E.   right.   intros Eq.   backchain E.   case Eq.   search.  
  Or: apply library-$-host-$-is_e_eqC_or_not to IsE2.   E: case Or.   Is: case IsE2.   Or: apply IH to IsE3 Is.   E: case Or.   Or: apply IH to IsE4 Is1.   E: case Or.   search.   right.   intros Eq.   case Eq.   backchain E.   right.   intros Eq.   case Eq.   backchain E.   right.   intros Eq.   backchain E.   case Eq.   search.  
  Or: apply library-$-host-$-is_e_gt_or_not to IsE2.   E: case Or.   Is: case IsE2.   Or: apply IH to IsE3 Is.   E: case Or.   Or: apply IH to IsE4 Is1.   E: case Or.   search.   right.   intros Eq.   case Eq.   backchain E.   right.   intros Eq.   case Eq.   backchain E.   right.   intros Eq.   backchain E.   case Eq.   search.  
  Or: apply library-$-host-$-is_e_not_or_not to IsE2.   E: case Or.   Is: case IsE2.   Or: apply IH to IsE3 Is.   E: case Or.   search.   right.   intros Eq.   case Eq.   backchain E.   right.   intros Eq.   backchain E.   case Eq.   search.  
  Or: apply library-$-list-$-is_e_nil_or_not to IsE2.   E: case Or.   search.   right.   intros Eq.   case Eq.   backchain E.  
  Or: apply library-$-list-$-is_e_cons_or_not to IsE2.   E: case Or.   Is: case IsE2.   Or: apply IH to IsE3 Is.   E: case Or.   Or: apply IH to IsE4 Is1.   E: case Or.   search.   right.   intros Eq.   case Eq.   backchain E.   right.   intros Eq.   case Eq.   backchain E.   right.   intros Eq.   backchain E.   case Eq.   search.  
  Or: apply library-$-list-$-is_e_null_or_not to IsE2.   E: case Or.   Is: case IsE2.   Or: apply IH to IsE3 Is.   E: case Or.   search.   right.   intros Eq.   case Eq.   backchain E.   right.   intros Eq.   backchain E.   case Eq.   search.  
  Or: apply library-$-list-$-is_e_head_or_not to IsE2.   E: case Or.   Is: case IsE2.   Or: apply IH to IsE3 Is.   E: case Or.   search.   right.   intros Eq.   case Eq.   backchain E.   right.   intros Eq.   backchain E.   case Eq.   search.  
  Or: apply library-$-list-$-is_e_tail_or_not to IsE2.   E: case Or.   Is: case IsE2.   Or: apply IH to IsE3 Is.   E: case Or.   search.   right.   intros Eq.   case Eq.   backchain E.   right.   intros Eq.   backchain E.   case Eq.   search.  </div>

Theorem library-$-host-$-vars_unique : forall E V1 V2, ($ext__0__library-$-host-$-vars (E) (V1)) -> ($ext__0__library-$-host-$-vars (E) (V2)) -> V1 = V2.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(196);" id="toggleproof196">[Show Proof]</a>
<div class="proof" id="proof196" style="display: none;">
induction on 1. 
 intros Vars1 Vars2. Vars1: case Vars1 (keep).
  case Vars2.   search.  
  case Vars2.   search.  
  case Vars2.   search.  
  case Vars2.   search.  
  V: case Vars2.   apply IH to Vars3 V.   apply IH to Vars4 V1.   apply extensibella-$-stdLib-$-append_unique to Vars5 V2.   search.  
  V: case Vars2.   apply IH to Vars3 V.   apply IH to Vars4 V1.   apply extensibella-$-stdLib-$-append_unique to Vars5 V2.   search.  
  V: case Vars2.   apply IH to Vars3 V.   apply IH to Vars4 V1.   apply extensibella-$-stdLib-$-append_unique to Vars5 V2.   search.  
  V: case Vars2.   apply IH to Vars3 V.   search.  
  case Vars2.   search.  
  V: case Vars2.   apply IH to Vars3 V.   apply IH to Vars4 V1.   apply extensibella-$-stdLib-$-append_unique to Vars5 V2.   search.  
  V: case Vars2.   apply IH to Vars3 V.   search.  
  V: case Vars2.   apply IH to Vars3 V.   search.  
  V: case Vars2.   apply IH to Vars3 V.   search.  </div>

Theorem library-$-host-$-trans_e_vars_exist  : forall E E' V, ($trans__library-$-host-$-e (E) (E')) -> ($ext__0__library-$-host-$-vars (E) (V)) -> exists V', $ext__0__library-$-host-$-vars (E') (V').<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(197);" id="toggleproof197">[Show Proof]</a>
<div class="proof" id="proof197" style="display: none;">
intros Hyp Hyp1.  Hyp: case Hyp (keep).   case Hyp1.  search.  case Hyp1.  search.  case Hyp1.  search.  search.  case Hyp1.  search. </div> 

Theorem library-$-host-$-trans_e_vars  : forall E E' V V' X, ($trans__library-$-host-$-e (E) (E')) -> ($ext__0__library-$-host-$-vars (E) (V)) -> ($ext__0__library-$-host-$-vars (E') (V')) -> ($fix__sterling-$-stdLib-$-mem (X) (V)) -> $fix__sterling-$-stdLib-$-mem (X) (V').<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(198);" id="toggleproof198">[Show Proof]</a>
<div class="proof" id="proof198" style="display: none;">
intros Hyp Hyp1 Hyp2 Hyp3.  Hyp: case Hyp (keep).   V: case Hyp1.  apply library-$-host-$-vars_unique to V Hyp2.  search.  V: case Hyp1.  apply library-$-host-$-vars_unique to V Hyp2.  search.  V: case Hyp1.  apply library-$-host-$-vars_unique to V Hyp2.  search.  case Hyp1.  case Hyp2.  search.  V: case Hyp1.  V': case Hyp2.  apply library-$-host-$-vars_unique to V V'.  apply library-$-host-$-vars_unique to V1 V'1.  apply extensibella-$-stdLib-$-append_unique to V2 V'2.  search.  </div>

Theorem library-$-host-$-append__is_list__is_string : forall L1 L2 L, (is_list (is_string) (L1)) -> (is_list (is_string) (L2)) -> ($append (L1) (L2) (L)) -> is_list (is_string) (L).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(199);" id="toggleproof199">[Show Proof]</a>
<div class="proof" id="proof199" style="display: none;">
induction on 1.  intros IsL1 IsL2 App.  IsL1': case IsL1.  case App.  search.  App: case App.  apply IH to IsL1'1 _ _.  search.  </div>

Theorem library-$-host-$-vars_is : forall E V, ($ext__0__library-$-host-$-is_e (E)) -> ($ext__0__library-$-host-$-vars (E) (V)) -> is_list (is_string) (V).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(200);" id="toggleproof200">[Show Proof]</a>
<div class="proof" id="proof200" style="display: none;">
induction on 2. 
 intros IsE Vars. Vars: case Vars (keep).
  case IsE.   search.  
  search.  
  search.  
  search.  
  Is: case IsE.   IsA: apply IH to _ Vars1.   IsB: apply IH to _ Vars2.   apply library-$-host-$-append__is_list__is_string to _ _ Vars3.   search.  
  Is: case IsE.   IsA: apply IH to _ Vars1.   IsB: apply IH to _ Vars2.   apply library-$-host-$-append__is_list__is_string to _ _ Vars3.   search.  
  Is: case IsE.   IsA: apply IH to _ Vars1.   IsB: apply IH to _ Vars2.   apply library-$-host-$-append__is_list__is_string to _ _ Vars3.   search.  
  case IsE.   apply IH to _ Vars1.   search.  
  search.  
  Is: case IsE.   apply IH to Is Vars1.   apply IH to Is1 Vars2.   apply library-$-host-$-append__is_list__is_string to _ _ Vars3.   search.  
  Is: case IsE.   apply IH to Is Vars1.   search.  
  Is: case IsE.   apply IH to Is Vars1.   search.  
  Is: case IsE.   apply IH to Is Vars1.   search.  </div>

Theorem library-$-host-$-append__is_list__is_string__total : forall L1 L2, (is_list (is_string) (L1)) -> (is_list (is_string) (L2)) -> exists L, $append (L1) (L2) (L).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(201);" id="toggleproof201">[Show Proof]</a>
<div class="proof" id="proof201" style="display: none;">
induction on 1.  intros IsL1 IsL2.  IsL1': case IsL1.  search.  apply IH to IsL1'1 _.  search.  </div>

Theorem library-$-host-$-vars_exist : forall E, ($ext__0__library-$-host-$-is_e (E)) -> exists V, $ext__0__library-$-host-$-vars (E) (V).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(202);" id="toggleproof202">[Show Proof]</a>
<div class="proof" id="proof202" style="display: none;">
induction on 1. 
 intros IsE. IsE: case IsE (keep).
  search.  
  search.  
  search.  
  search.  
  V1: apply IH to IsE1.   V2: apply IH to IsE2.   Is1: apply library-$-host-$-vars_is to _ V1.   Is2: apply library-$-host-$-vars_is to _ V2.   apply library-$-host-$-append__is_list__is_string__total to Is1 Is2.   search.  
  V1: apply IH to IsE1.   V2: apply IH to IsE2.   Is1: apply library-$-host-$-vars_is to _ V1.   Is2: apply library-$-host-$-vars_is to _ V2.   apply library-$-host-$-append__is_list__is_string__total to Is1 Is2.   search.  
  V1: apply IH to IsE1.   V2: apply IH to IsE2.   Is1: apply library-$-host-$-vars_is to _ V1.   Is2: apply library-$-host-$-vars_is to _ V2.   apply library-$-host-$-append__is_list__is_string__total to Is1 Is2.   search.  
  apply IH to IsE1.   search.  
  search.  
  V1: apply IH to IsE1.   V2: apply IH to IsE2.   Is1: apply library-$-host-$-vars_is to IsE1 V1.   Is2: apply library-$-host-$-vars_is to IsE2 V2.   apply library-$-host-$-append__is_list__is_string__total to Is1 Is2.   search.  
  apply IH to IsE1.   search.  
  apply IH to IsE1.   search.  
  apply IH to IsE1.   search.  </div>

Theorem library-$-host-$-value_empty_typable : forall V G Ty, ($ext__0__library-$-host-$-value (V)) -> ($ext__1__library-$-host-$-ty_e (G) (V) (Ty)) -> $ext__1__library-$-host-$-ty_e (nil) (V) (Ty).
induction on 1. <span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(203);" id="toggleproof203">[Show Proof]</a>
<div class="proof" id="proof203" style="display: none;">
 intros Value Ty. Value: case Value (keep).
  case Ty.   search.  
  case Ty.   search.  
  case Ty.   search.  
  case Ty.   search.  
  Ty: case Ty.   apply IH to Value1 Ty.   apply IH to Value2 Ty1.   search.  </div>

Theorem library-$-host-$-lookup_is : forall G X V, (is_list ((is_pair) (is_string) ($ext__0__library-$-host-$-is_e)) (G)) -> ($fix__sterling-$-stdLib-$-lookup (G) (X) (V)) -> $ext__0__library-$-host-$-is_e (V).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(204);" id="toggleproof204">[Show Proof]</a>
<div class="proof" id="proof204" style="display: none;">
induction on 2.  intros Is L.  L: case L.  Is: case Is.  case Is.  search.  case Is.  apply IH to _ L1.  search.  </div>

Theorem library-$-host-$-eval_e_is : forall G E V, ($ext__0__library-$-host-$-is_e (E)) -> (is_list ((is_pair) (is_string) ($ext__0__library-$-host-$-is_e)) (G)) -> ($ext__1__library-$-host-$-eval_e (G) (E) (V)) -> $ext__0__library-$-host-$-is_e (V).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(205);" id="toggleproof205">[Show Proof]</a>
<div class="proof" id="proof205" style="display: none;">
induction on 3. 
 intros IsE IsCtx Ev. Ev: case Ev (keep).
  apply library-$-host-$-lookup_is to _ Ev1.   search.  
  search.  
  search.  
  search.  
  case IsE.   Is1: apply IH to _ _ Ev1.   Is2: apply IH to _ _ Ev2.   case Is1.   case Is2.   apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ Ev3.   search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  case IsE.   apply IH to _ _ Ev1.   apply IH to _ _ Ev2.   search.  
  search.  
  search.  
  case IsE.   IsV: apply IH to _ _ Ev1.   case IsV.   search.  
  case IsE.   IsV: apply IH to _ _ Ev1.   case IsV.   search.  </div>

Theorem library-$-host-$-type_preservation_e : forall TG EG E Ty V, ($ext__1__library-$-host-$-ty_e (TG) (E) (Ty)) -> ($ext__1__library-$-host-$-eval_e (EG) (E) (V)) -> (forall X Ty V, ($fix__sterling-$-stdLib-$-lookup (TG) (X) (Ty)) -> ($fix__sterling-$-stdLib-$-lookup (EG) (X) (V)) -> $ext__1__library-$-host-$-ty_e (nil) (V) (Ty)) -> $ext__1__library-$-host-$-ty_e (nil) (V) (Ty).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(206);" id="toggleproof206">[Show Proof]</a>
<div class="proof" id="proof206" style="display: none;">
induction on 2. 
 intros Ty Ev Rel. Ev: case Ev (keep).
  Ty: case Ty.   apply Rel to Ty Ev1.   search.  
  case Ty.   search.  
  case Ty.   search.  
  case Ty.   search.  
  case Ty.   search.  
  case Ty.   search.  
  case Ty.   search.  
  case Ty.   search.  
  case Ty.   search.  
  case Ty.   search.  
  case Ty.   search.  
  case Ty.   search.  
  Ty: case Ty.   apply IH to Ty Ev1 Rel.   apply IH to Ty1 Ev2 Rel.   search.  
  case Ty.   search.  
  case Ty.   search.  
  Ty: case Ty.   TV: apply IH to Ty Ev1 Rel.   case TV.   search.  
  Ty: case Ty.   TV: apply IH to Ty Ev1 Rel.   case TV.   search.  </div>

Theorem library-$-host-$-var_types_maintained : forall G S G' X Ty, ($ext__1__library-$-host-$-ty_s (G) (S) (G')) -> ($fix__sterling-$-stdLib-$-lookup (G) (X) (Ty)) -> $fix__sterling-$-stdLib-$-lookup (G') (X) (Ty).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(207);" id="toggleproof207">[Show Proof]</a>
<div class="proof" id="proof207" style="display: none;">
induction on 1. 
 intros Ty Lkp. Ty: case Ty (keep).
  search.  
  Lkp': apply IH to Ty1 Lkp.   apply IH to Ty2 Lkp'.   search.  
  NEq: assert (N = X) -> false.   intros E.   case E.   apply sterling-$-stdLib-$-no_lookup to Ty2 Lkp.   search.  
  search.  
  search.  
  search.  
  search.  
  assert (N = X) -> false.   intros E.   case E.   apply sterling-$-stdLib-$-no_lookup to Ty2 Lkp.   search.  </div>

Theorem library-$-host-$-type_preservation_s : forall TG EG S TG' EG' X Ty V, ($ext__1__library-$-host-$-ty_s (TG) (S) (TG')) -> ($ext__1__library-$-host-$-eval_s (EG) (S) (EG')) -> (forall X Ty V, ($fix__sterling-$-stdLib-$-lookup (TG) (X) (Ty)) -> ($fix__sterling-$-stdLib-$-lookup (EG) (X) (V)) -> $ext__1__library-$-host-$-ty_e (nil) (V) (Ty)) -> ($fix__sterling-$-stdLib-$-lookup (TG') (X) (Ty)) -> ($fix__sterling-$-stdLib-$-lookup (EG') (X) (V)) -> $ext__1__library-$-host-$-ty_e (nil) (V) (Ty).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(208);" id="toggleproof208">[Show Proof]</a>
<div class="proof" id="proof208" style="display: none;">
induction on 2. 
 intros Ty Ev Rel LkpTy LkpV. Ev: case Ev (keep).
  case Ty.   backchain Rel.  
  Ty: case Ty.   TE: apply library-$-host-$-type_preservation_e to Ty Ev1 Rel.   LT: case LkpTy.   LV: case LkpV.   search.   apply LV to _.   LV: case LkpV.   apply LT to _.   backchain Rel.  
  Ty: case Ty.   TE: apply library-$-host-$-type_preservation_e to Ty Ev1 Rel.   LV: case LkpV.   apply sterling-$-stdLib-$-lookup_unique to Ty1 LkpTy.   search.   assert (X = N) -> false.   intros E.   case E.   backchain LV.   apply sterling-$-stdLib-$-lookup_after_select_before to LV1 Ev2 _.   apply Rel to LkpTy _.   search.  
  Ty: case Ty.   Rel': assert forall X1 Ty1 V1, ($fix__sterling-$-stdLib-$-lookup (G2) (X1) (Ty1)) -> ($fix__sterling-$-stdLib-$-lookup (G1) (X1) (V1)) -> $ext__1__library-$-host-$-ty_e (nil) (V1) (Ty1).   intros LT LV.   apply IH to Ty Ev1 Rel LT LV.   search.   apply IH to Ty1 Ev2 Rel' LkpTy LkpV.   search.  
  Ty: case Ty.   L: apply library-$-host-$-var_types_maintained to Ty1 LkpTy.   apply IH to Ty1 Ev2 Rel L LkpV.   search.  
  Ty: case Ty.   L: apply library-$-host-$-var_types_maintained to Ty2 LkpTy.   apply IH to Ty2 Ev2 Rel L LkpV.   search.  
  Ty: case Ty (keep).   Rel': assert forall X1 Ty1 V1, ($fix__sterling-$-stdLib-$-lookup (TG') (X1) (Ty1)) -> ($fix__sterling-$-stdLib-$-lookup (G1) (X1) (V1)) -> $ext__1__library-$-host-$-ty_e (nil) (V1) (Ty1).   intros LT LV.   L: apply library-$-host-$-var_types_maintained to Ty2 LT.   apply IH to Ty2 Ev2 Rel L LV.   search.   apply IH to Ty Ev3 Rel' LkpTy LkpV.   search.  
  Ty: case Ty.   backchain Rel.  
  Ty: case Ty.   TyCons: apply library-$-host-$-type_preservation_e to Ty Ev1 Rel.   TyV: case TyCons.   LV: case LkpV.   apply sterling-$-stdLib-$-lookup_unique to LkpTy Ty1.   search.   LV: case LV1.   apply sterling-$-stdLib-$-lookup_unique to Ty2 LkpTy.   search.   assert (X = Tl) -> false.   intros E.   case E.   backchain LV1.   assert (X = Hd) -> false.   intros E.   case E.   backchain LV.   L: apply sterling-$-stdLib-$-lookup_after_select_before to LV2 Ev4 _.   L': apply sterling-$-stdLib-$-lookup_after_select_before to L Ev3 _.   apply Rel to _ L'.   search.  
  Ty: case Ty.   apply library-$-host-$-type_preservation_e to Ty Ev1 Rel.   LT: case LkpTy.   LV: case LkpV.   search.   apply LV to _.   LV: case LkpV.   apply LT to _.   backchain Rel.  </div>

Theorem library-$-host-$-trans_eval_e  : forall G E E' V, ($trans__library-$-host-$-e (E) (E')) -> ($ext__1__library-$-host-$-eval_e (G) (E) (V)) -> (is_list ((is_pair) (is_string) ($ext__0__library-$-host-$-is_e)) (G)) -> ($ext__0__library-$-host-$-is_e (E)) -> exists V', $ext__1__library-$-host-$-eval_e (G) (E') (V').<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(209);" id="toggleproof209">[Show Proof]</a>
<div class="proof" id="proof209" style="display: none;">
intros Hyp Hyp1 Hyp2 Hyp3.  Hyp: case Hyp (keep).   case Hyp1.  search.  search.  case Hyp1.  search.  case Hyp1.  search.  search.  case Hyp1.  case Hyp3.  Is1: apply library-$-host-$-eval_e_is to _ _ H1.  Is2: apply library-$-host-$-eval_e_is to _ _ H2.  Or: apply library-$-host-$-is_e_eq_or_not to Is1 Is2.  E: case Or.  search.  search.  </div>

Theorem library-$-host-$-eval_e_unique : forall G E V1 V2, ($ext__1__library-$-host-$-eval_e (G) (E) (V1)) -> ($ext__1__library-$-host-$-eval_e (G) (E) (V2)) -> V1 = V2.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(210);" id="toggleproof210">[Show Proof]</a>
<div class="proof" id="proof210" style="display: none;">
induction on 1. 
 intros Ev1 Ev2. Ev1: case Ev1 (keep).
  Ev2: case Ev2.   apply sterling-$-stdLib-$-lookup_unique to Ev3 Ev2.   search.  
  case Ev2.   search.  
  case Ev2.   search.  
  case Ev2.   search.  
  Ev2: case Ev2.   apply IH to Ev3 Ev2.   apply IH to Ev4 Ev6.   apply extensibella-$-stdLib-$-plus_integer_unique to Ev5 Ev7.   search.  
  Ev2: case Ev2.   search.   apply IH to Ev3 Ev2.   apply IH to Ev4 Ev5.   apply Ev6 to _.  
  Ev2: case Ev2.   apply IH to Ev3 Ev2.   apply IH to Ev4 Ev6.   apply Ev5 to _.   search.  
  Ev2: case Ev2.   search.   apply IH to Ev3 Ev2.   apply IH to Ev4 Ev6.   apply extensibella-$-stdLib-$-greater_lesseq_integer_false to Ev5 Ev7.  
  Ev2: case Ev2.   apply IH to Ev3 Ev2.   apply IH to Ev4 Ev6.   apply extensibella-$-stdLib-$-greater_lesseq_integer_false to Ev7 Ev5.   search.  
  Ev2: case Ev2.   search.   apply IH to Ev3 Ev2.  
  Ev2: case Ev2.   apply IH to Ev3 Ev2.   search.  
  case Ev2.   search.  
  Ev2: case Ev2.   apply IH to Ev3 Ev2.   apply IH to Ev4 Ev5.   search.  
  Ev2: case Ev2.   search.   apply IH to Ev3 Ev2.  
  Ev2: case Ev2.   apply IH to Ev3 Ev2.   search.  
  Ev2: case Ev2.   apply IH to Ev3 Ev2.   search.  
  Ev2: case Ev2.   apply IH to Ev3 Ev2.   search.  </div>

Theorem library-$-host-$-trans_s_eval  : forall S S' G G2, ($trans__library-$-host-$-s (S) (S')) -> ($ext__1__library-$-host-$-eval_s (G) (S) (G2)) -> exists G', $ext__1__library-$-host-$-eval_s (G) (S') (G').<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(211);" id="toggleproof211">[Show Proof]</a>
<div class="proof" id="proof211" style="display: none;">
intros Hyp Hyp1.  Hyp: case Hyp (keep).   Ev: case Hyp1.  exists (($pair_c) (Hd) (V1))::((($pair_c) (Tl) (V2))::(GTl)).  unfold .
exists (($pair_c) (Tl) (V2))::((($pair_c) (Hd) ((library-$-list-$-cons) (V1) (V2)))::(GTl)).  split.  unfold .
exists (($pair_c) (Hd) ((library-$-list-$-cons) (V1) (V2)))::(GHd).  split.  search.  search.  assert (Tl = Hd) -> false.  intros E.  case E.  backchain Ev1.  search.  case Hyp1.  search.  </div>

Theorem library-$-host-$-ext_ind_pos_eval_s : forall G S G1 N, ($extSize__library-$-host-$-eval_s (G) (S) (G1) (N) ) -> $lesseq_integer (($posInt) ($zero)) (N) .<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(212);" id="toggleproof212">[Show Proof]</a>
<div class="proof" id="proof212" style="display: none;">
induction on 1.
intros ES. ES1: case ES.
 search.
 search.
 search.
 apply IH to ES2. apply IH to ES3. apply extensibella-$-stdLib-$-lesseq_integer__add_positive to _ _ ES1. search.
 apply IH to ES2. search.
 apply IH to ES2. search.
 apply IH to ES3. apply IH to ES4. apply extensibella-$-stdLib-$-lesseq_integer__add_positive to _ _ ES1. search.
 search.
 search.
 search.</div>

Theorem library-$-host-$-ext_ind_is_int_eval_s : forall G S G1 N, ($extSize__library-$-host-$-eval_s (G) (S) (G1) (N) ) -> is_integer (N) .<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(213);" id="toggleproof213">[Show Proof]</a>
<div class="proof" id="proof213" style="display: none;">
induction on 1.
intros ES. ES1: case ES.
 search.
 search.
 search.
 apply IH to ES2. apply IH to ES3. apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ ES1. search.
 apply IH to ES2. search.
 apply IH to ES2. search.
 apply IH to ES3. apply IH to ES4. apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ ES1. search.
 search.
 search.
 search.</div>

Theorem library-$-host-$-drop_ext_ind_eval_s : forall G S G1 N, ($extSize__library-$-host-$-eval_s (G) (S) (G1) (N) ) -> $ext__1__library-$-host-$-eval_s (G) (S) (G1) .<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(214);" id="toggleproof214">[Show Proof]</a>
<div class="proof" id="proof214" style="display: none;">
induction on 1.
intros ES. ES1: case ES.
 search.
 search.
 search.
 apply IH to ES2. apply IH to ES3. search.
 apply IH to ES2. search.
 apply IH to ES2. search.
 apply IH to ES3. apply IH to ES4. search.
 search.
 search.
 search.</div>

Theorem $toExtSize__$ext__1__library-$-host-$-eval_s : forall G S G1, ($ext__1__library-$-host-$-eval_s (G) (S) (G1) ) -> exists N, $extSize__library-$-host-$-eval_s (G) (S) (G1) (N) .<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(215);" id="toggleproof215">[Show Proof]</a>
<div class="proof" id="proof215" style="display: none;">
induction on 1. rename IH to IH0.
 intros R. R1: case R.
  search.
  search.
  search.
  ES268: apply IH0 to R1. ES269: apply IH0 to R2. Is270: apply library-$-host-$-ext_ind_is_int_eval_s to ES268. Is271: apply library-$-host-$-ext_ind_is_int_eval_s to ES269.  Plus272: apply extensibella-$-stdLib-$-plus_integer_total to Is270 Is271. Is273: apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ Plus272. search.
  ES274: apply IH0 to R2. Is275: apply library-$-host-$-ext_ind_is_int_eval_s to ES274.  search.
  ES276: apply IH0 to R2. Is277: apply library-$-host-$-ext_ind_is_int_eval_s to ES276.  search.
  ES278: apply IH0 to R2. ES279: apply IH0 to R3. Is280: apply library-$-host-$-ext_ind_is_int_eval_s to ES278. Is281: apply library-$-host-$-ext_ind_is_int_eval_s to ES279.  Plus282: apply extensibella-$-stdLib-$-plus_integer_total to Is280 Is281. Is283: apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ Plus282. search.
  search.
  search.
  search.</div>

Theorem $toTransRel__$ext__1__library-$-host-$-eval_s : forall N G S G1, ($extSize__library-$-host-$-eval_s (G) (S) (G1) (N) ) -> (acc (N) ) -> $transRel__library-$-host-$-eval_s (G) (S) (G1) .<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(216);" id="toggleproof216">[Show Proof]</a>
<div class="proof" id="proof216" style="display: none;">
induction on 2. induction on 1.
 intros Rel Acc. Rel: case Rel (keep).
  search.
  search.
  search.
  apply library-$-host-$-ext_ind_pos_eval_s to Rel2. apply library-$-host-$-ext_ind_is_int_eval_s to Rel2. apply library-$-host-$-ext_ind_pos_eval_s to Rel3. apply library-$-host-$-ext_ind_is_int_eval_s to Rel3. apply extensibella-$-stdLib-$-lesseq_integer__add_positives to _ _ Rel1. apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ Rel1. LE_R284: apply extensibella-$-stdLib-$-lte_right to Rel1 _ _ _. LE_L285: apply extensibella-$-stdLib-$-lte_left to Rel1 _ _ _. A286: case Acc (keep). Or287: apply extensibella-$-stdLib-$-lesseq_integer_less_or_eq to LE_R284. L288: case Or287. A289: apply A286 to _ L288. apply IH1 to Rel3 A289. Or290: apply extensibella-$-stdLib-$-lesseq_integer_less_or_eq to LE_L285. L291: case Or290. A292: apply A286 to _ L291. apply IH1 to Rel2 A292. search. apply IH1 to Rel2 Acc. search. apply IH1 to Rel3 Acc. Or290: apply extensibella-$-stdLib-$-lesseq_integer_less_or_eq to LE_L285. L291: case Or290. A292: apply A286 to _ L291. apply IH1 to Rel2 A292. search. apply IH1 to Rel2 Acc. search.
  apply library-$-host-$-ext_ind_pos_eval_s to Rel2. apply library-$-host-$-ext_ind_is_int_eval_s to Rel2.   IS293: apply library-$-host-$-ext_ind_is_int_eval_s to Rel2.LE294: apply extensibella-$-stdLib-$-is_integer_lesseq to IS293.A295: case Acc (keep). Or296: apply extensibella-$-stdLib-$-lesseq_integer_less_or_eq to LE294. L297: case Or296. A298: apply A295 to _ L297. apply IH1 to Rel2 A298. search. apply IH1 to Rel2 Acc. search.
  apply library-$-host-$-ext_ind_pos_eval_s to Rel2. apply library-$-host-$-ext_ind_is_int_eval_s to Rel2.   IS299: apply library-$-host-$-ext_ind_is_int_eval_s to Rel2.LE300: apply extensibella-$-stdLib-$-is_integer_lesseq to IS299.A301: case Acc (keep). Or302: apply extensibella-$-stdLib-$-lesseq_integer_less_or_eq to LE300. L303: case Or302. A304: apply A301 to _ L303. apply IH1 to Rel2 A304. search. apply IH1 to Rel2 Acc. search.
  apply library-$-host-$-ext_ind_pos_eval_s to Rel3. apply library-$-host-$-ext_ind_is_int_eval_s to Rel3. apply library-$-host-$-ext_ind_pos_eval_s to Rel4. apply library-$-host-$-ext_ind_is_int_eval_s to Rel4. apply extensibella-$-stdLib-$-lesseq_integer__add_positives to _ _ Rel1. apply extensibella-$-stdLib-$-plus_integer_is_integer to _ _ Rel1. LE_R305: apply extensibella-$-stdLib-$-lte_right to Rel1 _ _ _. LE_L306: apply extensibella-$-stdLib-$-lte_left to Rel1 _ _ _. A307: case Acc (keep). Or308: apply extensibella-$-stdLib-$-lesseq_integer_less_or_eq to LE_R305. L309: case Or308. A310: apply A307 to _ L309. apply IH1 to Rel4 A310. Or311: apply extensibella-$-stdLib-$-lesseq_integer_less_or_eq to LE_L306. L312: case Or311. A313: apply A307 to _ L312. apply IH1 to Rel3 A313. search. apply IH1 to Rel3 Acc. search. apply IH1 to Rel4 Acc. Or311: apply extensibella-$-stdLib-$-lesseq_integer_less_or_eq to LE_L306. L312: case Or311. A313: apply A307 to _ L312. apply IH1 to Rel3 A313. search. apply IH1 to Rel3 Acc. search.
  search.
assert $trans__library-$-host-$-s ((library-$-list-$-splitlist) (Hd) (Tl) (E)) ((library-$-host-$-seq) ((library-$-host-$-seq) ((library-$-host-$-assign) (Hd) (E)) ((library-$-host-$-assign) (Tl) ((library-$-list-$-tail) ((library-$-host-$-var) (Hd))))) ((library-$-host-$-assign) (Hd) ((library-$-list-$-head) ((library-$-host-$-var) (Hd))))).   unfold .
 exists (library-$-host-$-seq) ((library-$-host-$-seq) ((library-$-host-$-assign) (Hd) (E)) ((library-$-host-$-assign) (Tl) ((library-$-list-$-tail) ((library-$-host-$-var) (Hd))))) ((library-$-host-$-assign) (Hd) ((library-$-list-$-head) ((library-$-host-$-var) (Hd)))), VHd, GHd, VTl.   split.   unfold .
 exists (($pair_c) (Tl) (V2))::((($pair_c) (Hd) ((library-$-list-$-cons) (V1) (V2)))::(GTl)).   split.   unfold .
 exists (($pair_c) (Hd) ((library-$-list-$-cons) (V1) (V2)))::(GHd).   split.   search.   search.   assert (Tl = Hd) -> false.   intros E.   case E.   backchain Rel2.   search.   search.   search.   search.   search.   search.  
search.  </div>



Theorem $extInd_$ext__1__library-$-host-$-eval_s : forall G S G1, ($ext__1__library-$-host-$-eval_s (G) (S) (G1) ) -> $transRel__library-$-host-$-eval_s (G) (S) (G1) .<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(217);" id="toggleproof217">[Show Proof]</a>
<div class="proof" id="proof217" style="display: none;">
intros R. ES: apply $toExtSize__$ext__1__library-$-host-$-eval_s to R.
P: apply library-$-host-$-ext_ind_pos_eval_s to ES. Is: apply library-$-host-$-ext_ind_is_int_eval_s to ES. A: apply extensibella-$-stdLib-$-all_acc to Is P.
apply $toTransRel__$ext__1__library-$-host-$-eval_s to ES A. search.
Theorem $dropT_$ext__1__library-$-host-$-eval_s : forall G S G1, ($transRel__library-$-host-$-eval_s (G) (S) (G1) ) -> $ext__1__library-$-host-$-eval_s (G) (S) (G1) .
induction on 1.
intros R. R: case R (keep).
  search.
  search.
  search.
  apply IH to R1. apply IH to R2. search.
  apply IH to R2. search.
  apply IH to R2. search.
  apply IH to R2. apply IH to R3. search.
  search.
  search.
  search.</div>



Theorem library-$-host-$-trans_s_eval_results  : forall S S' G G1 G2 X V, ($trans__library-$-host-$-s (S) (S')) -> ($ext__1__library-$-host-$-eval_s (G) (S) (G1)) -> ($ext__1__library-$-host-$-eval_s (G) (S') (G2)) -> ($fix__sterling-$-stdLib-$-lookup (G1) (X) (V)) -> $fix__sterling-$-stdLib-$-lookup (G2) (X) (V).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(218);" id="toggleproof218">[Show Proof]</a>
<div class="proof" id="proof218" style="display: none;">
intros Hyp Hyp1 Hyp2 Hyp3.  Hyp: case Hyp (keep).   EvTr: case Hyp2.  EvTr: case EvTr.  EvTr: case EvTr.  EvTr: case EvTr2.  EvTr: case EvTr2.  EvTr: case EvTr2.  case EvTr2.  EvTr: case EvTr1.  EvTr: case EvTr1.  EvTr: case EvTr1.  L: case EvTr1.  apply Hyp4 to _.  STl: case EvTr4.  apply L to _.  SHd: case EvTr2.  apply L to _.  EvSL: case Hyp1.  case L1.  apply library-$-host-$-eval_e_unique to EvTr EvSL.  LX: case Hyp3.  search.  LX: case LX1.  search.  assert (X = Tl) -> false.  intros E.  case E.  backchain LX1.  L2: apply sterling-$-stdLib-$-lookup_after_select_before to LX2 EvSL3 _.  assert (X = Hd) -> false.  intros E.  case E.  backchain LX.  L3: apply sterling-$-stdLib-$-lookup_after_select_before to L2 EvSL2 _.  L4: apply sterling-$-stdLib-$-select_lookup to L3 EvTr3 _.  L5: apply sterling-$-stdLib-$-select_lookup to L4 STl _.  L5': assert $fix__sterling-$-stdLib-$-lookup ((($pair_c) (Hd) ((library-$-list-$-cons) (V6) (V7)))::(L1)) (X) (V).  apply sterling-$-stdLib-$-select_lookup to L5' SHd _.  search.  apply H1 to _.  apply H1 to _.  VS: case Hyp1.  VD: case Hyp2.  apply library-$-host-$-eval_e_unique to VS VD.  search.  </div>

Theorem library-$-host-$-trans_s_eval_results_back  : forall S S' G G1 G2 X V, ($trans__library-$-host-$-s (S) (S')) -> ($ext__1__library-$-host-$-eval_s (G) (S) (G1)) -> ($ext__1__library-$-host-$-eval_s (G) (S') (G2)) -> ($fix__sterling-$-stdLib-$-lookup (G2) (X) (V)) -> $fix__sterling-$-stdLib-$-lookup (G1) (X) (V).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(219);" id="toggleproof219">[Show Proof]</a>
<div class="proof" id="proof219" style="display: none;">
intros Hyp Hyp1 Hyp2 Hyp3.  Hyp: case Hyp (keep).   EvSL: case Hyp1.  EvTr: case Hyp2.  EvTr: case EvTr.  EvTr: case EvTr1.  EvTr: case EvTr.  apply library-$-host-$-eval_e_unique to EvTr EvSL.  EvTr: case EvTr2.  EvTr: case EvTr1.  EvTr: case EvTr2.  EvTr: case EvTr1.  EvTr: case EvTr2.  LHd: case EvTr2.  EvTr: case EvTr3.  apply EvSL1 to _.  LX: case Hyp3.  STl: case EvTr5.  apply EvSL1 to _.  L: case EvTr1.  apply EvSL1 to _.  L': case L1.  search.  apply L' to _.  LX: case LX1.  search.  assert (X = Hd) -> false.  intros E.  case E.  backchain LX.  assert (X = Tl) -> false.  intros E.  case E.  backchain LX1.  L1: apply sterling-$-stdLib-$-lookup_after_select_before to LX2 EvTr2 _.  L2: apply sterling-$-stdLib-$-lookup_after_select_before to L1 EvTr5 _.  L': case L2.  apply LX to _.  L3: apply sterling-$-stdLib-$-lookup_after_select_before to L'1 EvTr4 _.  L4: apply sterling-$-stdLib-$-select_lookup to L3 EvSL2 _.  apply sterling-$-stdLib-$-select_lookup to L4 EvSL3 _.  search.  apply LHd to _.  VS: case Hyp1.  VD: case Hyp2.  apply library-$-host-$-eval_e_unique to VS VD.  search.  </div>

Theorem library-$-host-$-eval_e_value : forall G E V, ($ext__1__library-$-host-$-eval_e (G) (E) (V)) -> (forall X XV, ($fix__sterling-$-stdLib-$-mem (($pair_c) (X) (XV)) (G)) -> $ext__0__library-$-host-$-value (XV)) -> $ext__0__library-$-host-$-value (V).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(220);" id="toggleproof220">[Show Proof]</a>
<div class="proof" id="proof220" style="display: none;">
induction on 1. 
 intros Ev AllVal. Ev: case Ev (keep).
  M: apply sterling-$-stdLib-$-lookup_mem to Ev1.   apply AllVal to M.   search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  search.  
  apply IH to Ev1 AllVal.   apply IH to Ev2 AllVal.   search.  
  search.  
  search.  
  V: apply IH to Ev1 AllVal.   case V.   search.  
  V: apply IH to Ev1 AllVal.   case V.   search.  </div>

Theorem library-$-host-$-eval_s_value : forall G S G' Y YV, ($ext__1__library-$-host-$-eval_s (G) (S) (G')) -> (forall X XV, ($fix__sterling-$-stdLib-$-mem (($pair_c) (X) (XV)) (G)) -> $ext__0__library-$-host-$-value (XV)) -> ($fix__sterling-$-stdLib-$-mem (($pair_c) (Y) (YV)) (G')) -> $ext__0__library-$-host-$-value (YV).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(221);" id="toggleproof221">[Show Proof]</a>
<div class="proof" id="proof221" style="display: none;">
induction on 1. 
 intros Ev AllVal Mem. Ev: case Ev (keep).
  backchain AllVal.  
  V: apply library-$-host-$-eval_e_value to Ev1 AllVal.   M: case Mem.   search.   backchain AllVal.  
  V: apply library-$-host-$-eval_e_value to Ev1 AllVal.   M: case Mem.   search.   M': apply sterling-$-stdLib-$-mem_after_select_before to Ev2 M.   backchain AllVal.  
  AllVal': assert forall X XV, ($fix__sterling-$-stdLib-$-mem (($pair_c) (X) (XV)) (G3)) -> $ext__0__library-$-host-$-value (XV).   intros M.   apply IH to Ev1 AllVal M.   search.   apply IH to Ev2 AllVal' Mem.   search.  
  apply IH to Ev2 AllVal Mem.   search.  
  apply IH to Ev2 AllVal Mem.   search.  
  AllVal': assert forall X XV, ($fix__sterling-$-stdLib-$-mem (($pair_c) (X) (XV)) (G3)) -> $ext__0__library-$-host-$-value (XV).   intros M.   apply IH to Ev2 AllVal M.   search.   apply IH to Ev3 AllVal' Mem.   search.  
  backchain AllVal.  
  VCons: apply library-$-host-$-eval_e_value to Ev1 AllVal.   V: case VCons (keep).   M: case Mem.   search.   M: case M.   search.   MGHd: apply sterling-$-stdLib-$-mem_after_select_before to _ M.   apply sterling-$-stdLib-$-mem_after_select_before to _ MGHd.   backchain AllVal.  
  apply library-$-host-$-eval_e_value to Ev1 _.   case Mem.   search.   backchain AllVal.  </div>

Theorem library-$-host-$-vars_equiv_left : forall (G1 : list ($lib__pair (list $char) $ty__library-$-host-$-e)) G2 D D1 D2, (forall X U1 U2, ($fix__sterling-$-stdLib-$-mem (X) (D)) -> ($fix__sterling-$-stdLib-$-lookup (G1) (X) (U1)) -> ($fix__sterling-$-stdLib-$-lookup (G2) (X) (U2)) -> U1 = U2) -> ($append (D1) (D2) (D)) -> forall X U1 U2, ($fix__sterling-$-stdLib-$-mem (X) (D1)) -> ($fix__sterling-$-stdLib-$-lookup (G1) (X) (U1)) -> ($fix__sterling-$-stdLib-$-lookup (G2) (X) (U2)) -> U1 = U2.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(222);" id="toggleproof222">[Show Proof]</a>
<div class="proof" id="proof222" style="display: none;">
intros Equiv J Mem Lkp1 Lkp2.  backchain Equiv with X = X.  backchain sterling-$-stdLib-$-mem_append_left.  </div>

Theorem library-$-host-$-vars_equiv_right : forall (G1 : list ($lib__pair (list $char) $ty__library-$-host-$-e)) G2 D D1 D2, (forall X U1 U2, ($fix__sterling-$-stdLib-$-mem (X) (D)) -> ($fix__sterling-$-stdLib-$-lookup (G1) (X) (U1)) -> ($fix__sterling-$-stdLib-$-lookup (G2) (X) (U2)) -> U1 = U2) -> ($append (D1) (D2) (D)) -> forall X U1 U2, ($fix__sterling-$-stdLib-$-mem (X) (D2)) -> ($fix__sterling-$-stdLib-$-lookup (G1) (X) (U1)) -> ($fix__sterling-$-stdLib-$-lookup (G2) (X) (U2)) -> U1 = U2.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(223);" id="toggleproof223">[Show Proof]</a>
<div class="proof" id="proof223" style="display: none;">
intros Equiv J Mem Lkp1 Lkp2.  backchain Equiv with X = X.  backchain sterling-$-stdLib-$-mem_append_right.  </div>

Theorem library-$-host-$-vars_eval_same_result : forall G1 G2 E D V1 V2, (forall X U1 U2, ($fix__sterling-$-stdLib-$-mem (X) (D)) -> ($fix__sterling-$-stdLib-$-lookup (G1) (X) (U1)) -> ($fix__sterling-$-stdLib-$-lookup (G2) (X) (U2)) -> U1 = U2) -> ($ext__0__library-$-host-$-vars (E) (D)) -> ($ext__1__library-$-host-$-eval_e (G1) (E) (V1)) -> ($ext__1__library-$-host-$-eval_e (G2) (E) (V2)) -> V1 = V2.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(224);" id="toggleproof224">[Show Proof]</a>
<div class="proof" id="proof224" style="display: none;">
induction on 3. 
 intros Equiv Vars Ev1 Ev2. Ev1: case Ev1 (keep).
  Ev2: case Ev2.   case Vars.   apply Equiv to _ Ev3 Ev2.   search.  
  case Ev2.   search.  
  case Ev2.   search.  
  case Ev2.   search.  
  Ev2: case Ev2.   Vars: case Vars.   apply IH to _ Vars Ev3 Ev2.   backchain library-$-host-$-vars_equiv_left.   apply IH to _ Vars1 Ev4 Ev6.   backchain library-$-host-$-vars_equiv_right.   apply extensibella-$-stdLib-$-plus_integer_unique to Ev5 Ev7.   search.  
  Ev2: case Ev2.   search.   Vars: case Vars.   apply IH to _ Vars Ev3 Ev2.   backchain library-$-host-$-vars_equiv_left.   apply IH to _ Vars1 Ev4 Ev5.   backchain library-$-host-$-vars_equiv_right.   apply Ev6 to _.  
  Ev2: case Ev2.   Vars: case Vars.   apply IH to _ Vars Ev3 Ev2.   backchain library-$-host-$-vars_equiv_left.   apply IH to _ Vars1 Ev4 Ev6.   backchain library-$-host-$-vars_equiv_right.   apply Ev5 to _.   search.  
  Ev2: case Ev2.   search.   Vars: case Vars.   apply IH to _ Vars Ev3 Ev2.   backchain library-$-host-$-vars_equiv_left.   apply IH to _ Vars1 Ev4 Ev6.   backchain library-$-host-$-vars_equiv_right.   apply extensibella-$-stdLib-$-greater_lesseq_integer_false to Ev5 Ev7.  
  Ev2: case Ev2.   Vars: case Vars.   apply IH to _ Vars Ev3 Ev2.   backchain library-$-host-$-vars_equiv_left.   apply IH to _ Vars1 Ev4 Ev6.   backchain library-$-host-$-vars_equiv_right.   apply extensibella-$-stdLib-$-greater_lesseq_integer_false to Ev7 Ev5.   search.  
  Ev2: case Ev2.   search.   Vars: case Vars.   apply IH to _ _ Ev3 Ev2.  
  Ev2: case Ev2.   Vars: case Vars.   apply IH to _ _ Ev3 Ev2.   search.  
  case Ev2.   search.  
  Ev2: case Ev2.   Vars: case Vars.   apply IH to _ Vars Ev3 Ev2.   backchain library-$-host-$-vars_equiv_left.   apply IH to _ Vars1 Ev4 Ev5.   backchain library-$-host-$-vars_equiv_right.   search.  
  Ev2: case Ev2.   search.   Vars: case Vars.   apply IH to _ Vars Ev3 Ev2.  
  Ev2: case Ev2.   Vars: case Vars.   apply IH to _ Vars Ev3 Ev2.   search.  
  Ev2: case Ev2.   Vars: case Vars.   apply IH to _ _ Ev3 Ev2.   search.  
  Ev2: case Ev2.   Vars: case Vars.   apply IH to _ _ Ev3 Ev2.   search.  </div>

Theorem library-$-security-$-sl_form : forall SL, ($ext__0__library-$-security-$-is_sl (SL)) -> (SL = library-$-security-$-public) \/ (SL = library-$-security-$-private).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(225);" id="toggleproof225">[Show Proof]</a>
<div class="proof" id="proof225" style="display: none;">
induction on 1. 
 intros Is. Is: case Is (keep).
  search.  
  search.  </div>

Theorem library-$-security-$-join_unique : forall A B S1 S2, ($fix__library-$-security-$-join (A) (B) (S1)) -> ($fix__library-$-security-$-join (A) (B) (S2)) -> S1 = S2.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(226);" id="toggleproof226">[Show Proof]</a>
<div class="proof" id="proof226" style="display: none;">
intros J1 J2.  case J1.  case J2.  search.  case J2.  search.  search.  case J2.  search.  search.  </div>

Theorem library-$-security-$-join_public : forall A B, ($fix__library-$-security-$-join (A) (B) (library-$-security-$-public)) -> (A = library-$-security-$-public) /\ (B = library-$-security-$-public).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(227);" id="toggleproof227">[Show Proof]</a>
<div class="proof" id="proof227" style="display: none;">
intros J.  case J.  search.  </div>

Theorem library-$-security-$-level_public_vars : forall SG E V X, ($ext__1__library-$-security-$-level (SG) (E) (library-$-security-$-public)) -> ($ext__0__library-$-host-$-vars (E) (V)) -> ($fix__sterling-$-stdLib-$-mem (X) (V)) -> $fix__sterling-$-stdLib-$-lookup (SG) (X) (library-$-security-$-public).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(228);" id="toggleproof228">[Show Proof]</a>
<div class="proof" id="proof228" style="display: none;">
induction on 1. 
 intros Lev Vars Mem. Lev: case Lev (keep).
  case Vars.   case Mem.  
  case Vars.   case Mem.  
  case Vars.   case Mem.  
  case Vars.   M: case Mem.   search.   case M.  
  V: case Vars.   apply library-$-security-$-join_public to Lev3.   Or: apply sterling-$-stdLib-$-mem_append to Mem V2.   M: case Or.   apply IH to Lev1 V M.   search.   apply IH to Lev2 V1 M.   search.  
  V: case Vars.   apply library-$-security-$-join_public to Lev3.   Or: apply sterling-$-stdLib-$-mem_append to Mem V2.   M: case Or.   apply IH to Lev1 V M.   search.   apply IH to Lev2 V1 M.   search.  
  V: case Vars.   apply library-$-security-$-join_public to Lev3.   Or: apply sterling-$-stdLib-$-mem_append to Mem V2.   M: case Or.   apply IH to Lev1 V M.   search.   apply IH to Lev2 V1 M.   search.  
  V: case Vars.   apply IH to Lev1 V Mem.   search.  
  V: apply library-$-host-$-trans_e_vars_exist to Lev1 Vars.   M: apply library-$-host-$-trans_e_vars to Lev1 Vars V Mem.   apply IH to Lev2 V M.   search.  
  V: apply library-$-host-$-trans_e_vars_exist to Lev1 Vars.   M: apply library-$-host-$-trans_e_vars to Lev1 Vars V Mem.   apply IH to Lev2 V M.   search.  
  V: apply library-$-host-$-trans_e_vars_exist to Lev1 Vars.   M: apply library-$-host-$-trans_e_vars to Lev1 Vars V Mem.   apply IH to Lev2 V M.   search.  
  V: apply library-$-host-$-trans_e_vars_exist to Lev1 Vars.   M: apply library-$-host-$-trans_e_vars to Lev1 Vars V Mem.   apply IH to Lev2 V M.   search.  
  V: apply library-$-host-$-trans_e_vars_exist to Lev1 Vars.   M: apply library-$-host-$-trans_e_vars to Lev1 Vars V Mem.   apply IH to Lev2 V M.   search.  </div>

Theorem library-$-security-$-public_equiv_trans : forall SG GA GB GC, (library-$-security-$-public_equiv (SG) (GA) (GB)) -> (library-$-security-$-public_equiv (SG) (GB) (GC)) -> library-$-security-$-public_equiv (SG) (GA) (GC).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(229);" id="toggleproof229">[Show Proof]</a>
<div class="proof" id="proof229" style="display: none;">
intros PEAB PEBC.  PEAB: case PEAB.  PEBC: case PEBC.  unfold .
intros LkpSec LkpA.  LkpB: apply PEAB to LkpSec LkpA.  apply PEBC to LkpSec LkpB.  search.  intros LkpSec LkpC.  LkpB: apply PEBC1 to LkpSec LkpC.  apply PEAB1 to LkpSec LkpB.  search.  </div>

Theorem library-$-security-$-public_equiv_symm : forall SG GA GB, (library-$-security-$-public_equiv (SG) (GA) (GB)) -> library-$-security-$-public_equiv (SG) (GB) (GA).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(230);" id="toggleproof230">[Show Proof]</a>
<div class="proof" id="proof230" style="display: none;">
intros Rel.  Rel: case Rel.  unfold .
intros LkpSec LkpB.  apply Rel1 to LkpSec LkpB.  search.  intros LkpSec LkpA.  apply Rel to LkpSec LkpA.  search.  </div>

Theorem library-$-security-$-public_equiv_refl : forall SG G, library-$-security-$-public_equiv (SG) (G) (G).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(231);" id="toggleproof231">[Show Proof]</a>
<div class="proof" id="proof231" style="display: none;">
intros.  unfold .
intros.  search.  intros.  search.  </div>

Theorem library-$-security-$-level_secure : forall SG G1 G2 E V1 V2, ($ext__0__library-$-host-$-is_e (E)) -> ($ext__1__library-$-security-$-level (SG) (E) (library-$-security-$-public)) -> (library-$-security-$-public_equiv (SG) (G1) (G2)) -> ($ext__1__library-$-host-$-eval_e (G1) (E) (V1)) -> ($ext__1__library-$-host-$-eval_e (G2) (E) (V2)) -> V1 = V2.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(232);" id="toggleproof232">[Show Proof]</a>
<div class="proof" id="proof232" style="display: none;">
intros IsE Lev Equiv Ev1 Ev2.  Vars: apply library-$-host-$-vars_exist to IsE.  Equiv: case Equiv.  apply library-$-host-$-vars_eval_same_result to _ Vars Ev1 Ev2.  intros Mem Lkp1 Lkp2.  LkpS: apply library-$-security-$-level_public_vars to Lev Vars Mem.  L: apply Equiv to LkpS Lkp1.  apply sterling-$-stdLib-$-lookup_unique to L Lkp2.  search.  search.  </div>

Theorem library-$-security-$-level_unique : forall SG E S1 S2, ($ext__1__library-$-security-$-level (SG) (E) (S1)) -> ($ext__1__library-$-security-$-level (SG) (E) (S2)) -> S1 = S2.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(233);" id="toggleproof233">[Show Proof]</a>
<div class="proof" id="proof233" style="display: none;">
induction on 1. 
 intros LevA LevB. LevA: case LevA (keep).
  case LevB.   search.  
  case LevB.   search.  
  case LevB.   search.  
  L: case LevB.   apply sterling-$-stdLib-$-lookup_unique to LevA1 L.   search.  
  L: case LevB.   apply IH to LevA1 L.   apply IH to LevA2 L1.   apply library-$-security-$-join_unique to LevA3 L2.   search.  
  L: case LevB.   apply IH to LevA1 L.   apply IH to LevA2 L1.   apply library-$-security-$-join_unique to LevA3 L2.   search.  
  L: case LevB.   apply IH to LevA1 L.   apply IH to LevA2 L1.   apply library-$-security-$-join_unique to LevA3 L2.   search.  
  L: case LevB.   apply IH to LevA1 L.   search.  
  L: case LevB.   apply library-$-host-$-trans_e_unique to LevA1 L.   apply IH to LevA2 L1.   search.  
  L: case LevB.   apply library-$-host-$-trans_e_unique to LevA1 L.   apply IH to LevA2 L1.   search.  
  L: case LevB.   apply library-$-host-$-trans_e_unique to LevA1 L.   apply IH to LevA2 L1.   search.  
  L: case LevB.   apply library-$-host-$-trans_e_unique to LevA1 L.   apply IH to LevA2 L1.   search.  
  L: case LevB.   apply library-$-host-$-trans_e_unique to LevA1 L.   apply IH to LevA2 L1.   search.  </div>

Theorem library-$-security-$-level_not_public : forall SG G1 G2 E V1 V2, ($ext__0__library-$-host-$-is_e (E)) -> (library-$-security-$-public_equiv (SG) (G1) (G2)) -> ($ext__1__library-$-security-$-level (SG) (E) (library-$-security-$-public)) -> ($ext__1__library-$-host-$-eval_e (G1) (E) (V1)) -> ($ext__1__library-$-host-$-eval_e (G2) (E) (V2)) -> ((V1 = V2) -> false) -> false.<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(234);" id="toggleproof234">[Show Proof]</a>
<div class="proof" id="proof234" style="display: none;">
intros Is Equiv Lev Ev1 Ev2 NEq.  apply library-$-security-$-level_secure to Is Lev Equiv Ev1 Ev2.  backchain NEq.  </div>

Theorem library-$-security-$-stmt_public_branch : forall SG SL SG2 S X, ($ext__2__library-$-security-$-secure (SG) (SL) (S) (SG2)) -> ($fix__sterling-$-stdLib-$-lookup (SG) (X) (library-$-security-$-public)) -> $fix__sterling-$-stdLib-$-lookup (SG2) (X) (library-$-security-$-public).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(235);" id="toggleproof235">[Show Proof]</a>
<div class="proof" id="proof235" style="display: none;">
induction on 1. 
 intros Sec LkpSec. Sec: case Sec (keep).
  search.  
  L: apply IH to Sec1 LkpSec.   apply IH to Sec2 L.   search.  
  assert (N = X) -> false.   intros E.   case E.   apply sterling-$-stdLib-$-no_lookup to Sec2 LkpSec.   search.  
  search.  
  search.  
  search.  
  search.  
  assert (N = X) -> false.   intros E.   case E.   apply sterling-$-stdLib-$-no_lookup to Sec2 LkpSec.   search.  
  assert (N = X) -> false.   intros E.   case E.   apply sterling-$-stdLib-$-no_lookup to Sec2 LkpSec.   search.  
  apply IH to Sec2 LkpSec.   search.  </div>

Theorem library-$-security-$-public_equiv_swap : forall SG SG' GA GB, (forall X, ($fix__sterling-$-stdLib-$-lookup (SG) (X) (library-$-security-$-public)) -> $fix__sterling-$-stdLib-$-lookup (SG') (X) (library-$-security-$-public)) -> (library-$-security-$-public_equiv (SG') (GA) (GB)) -> library-$-security-$-public_equiv (SG) (GA) (GB).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(236);" id="toggleproof236">[Show Proof]</a>
<div class="proof" id="proof236" style="display: none;">
intros LkpEquiv Eq.  Eq: case Eq.  unfold .
intros LkpSec LkpA.  LkpSG': apply LkpEquiv to LkpSec.  apply Eq to LkpSG' LkpA.  search.  intros LkpSec LkpB.  LkpSG': apply LkpEquiv to LkpSec.  apply Eq1 to LkpSG' LkpB.  search.  </div>

Theorem $extThm_267 : forall S SG SL SG1 G G1, ($ext__2__library-$-security-$-secure (SG) (SL) (S) (SG1)) -> ((SL = library-$-security-$-public) -> false) -> ($transRel__library-$-host-$-eval_s (G) (S) (G1)) -> library-$-security-$-public_equiv (SG) (G) (G1).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(237);" id="toggleproof237">[Show Proof]</a>
<div class="proof" id="proof237" style="display: none;">
induction on 3. 
 intros Sec NEq Ev. Ev: case Ev (keep).
  case Sec.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   backchain library-$-security-$-public_equiv_refl.  
  Sec: case Sec.   apply NEq to _.  
  Sec: case Sec.   unfold .
 intros LS LA.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   N: assert (N = X) -> false.   intros E.   case E.   apply sterling-$-stdLib-$-lookup_unique to Sec1 LS.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   assert (X = N) -> false.   intros E.   case E.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   backchain N.   apply sterling-$-stdLib-$-select_lookup to LA Ev2 _.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   search.   intros LS LB.   L: case LB.   apply sterling-$-stdLib-$-lookup_unique to Sec1 LS.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   assert (X = N) -> false.   intros E.   case E.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   backchain L.   apply sterling-$-stdLib-$-lookup_after_select_before to L1 Ev2 _.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   search.   apply NEq to _.  
  Sec: case Sec.   PE1: apply IH to Sec _ Ev1.   PE2: apply IH to Sec1 _ Ev2.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev1.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev2.   E: assert forall X, ($fix__sterling-$-stdLib-$-lookup (SG) (X) (library-$-security-$-public)) -> $fix__sterling-$-stdLib-$-lookup (SG2) (X) (library-$-security-$-public).   intros L.   L': apply library-$-security-$-stmt_public_branch to Sec L.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev1.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev2.   search.   PE': apply library-$-security-$-public_equiv_swap to E PE2.   apply library-$-security-$-public_equiv_trans to PE1 PE'.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev1.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev2.   search.  
  Sec: case Sec.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev2.   assert (Sl1 = library-$-security-$-public) -> false.   intros E.   case E.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev2.   backchain NEq.   apply library-$-security-$-join_public to Sec1.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev2.   search.   apply IH to Sec2 _ Ev2.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev2.   search.  
  Sec: case Sec.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev2.   assert (Sl1 = library-$-security-$-public) -> false.   intros E.   case E.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev2.   backchain NEq.   apply library-$-security-$-join_public to Sec1.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev2.   search.   apply IH to Sec3 _ Ev2.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev2.   search.  
  Sec: case Sec (keep).   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev2.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev3.   assert (Sl1 = library-$-security-$-public) -> false.   intros E.   case E.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev2.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev3.   backchain NEq.   apply library-$-security-$-join_public to Sec2.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev2.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev3.   search.   EqGG2: apply IH to Sec3 _ Ev2.   EqG2G1: apply IH to _ _ Ev3.   apply library-$-security-$-public_equiv_trans to EqGG2 EqG2G1.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev2.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev3.   search.  
  unfold .
 intros LkpSec LkpG1.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   search.   intros LkpSec LkpG1.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   search.  
  Sec: case Sec.   apply library-$-host-$-trans_s_unique to Ev2 Sec.   apply IH to _ _ Ev1.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev1.   search.  
  Sec: case Sec.   unfold .
 intros LkpSec LkpG.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev1.   assert (N = X) -> false.   intros E.   case E.   apply sterling-$-stdLib-$-no_lookup to Sec1 LkpSec.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev1.   search.   intros LkpSec LkpG+.   Lkp: case LkpG+.   apply sterling-$-stdLib-$-no_lookup to Sec1 LkpSec.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev.   apply $dropT_$ext__1__library-$-host-$-eval_s to Ev1.   search.   apply NEq to _.  </div>
Theorem library-$-security-$-stmt_not_public_no_public_change : forall S SG SL SG1 G G1, ($ext__2__library-$-security-$-secure (SG) (SL) (S) (SG1)) -> ((SL = library-$-security-$-public) -> false) -> ($ext__1__library-$-host-$-eval_s (G) (S) (G1)) -> library-$-security-$-public_equiv (SG) (G) (G1).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(238);" id="toggleproof238">[Show Proof]</a>
<div class="proof" id="proof238" style="display: none;">
intros Sec NEq Ev. $R: apply $extInd_$ext__1__library-$-host-$-eval_s to Ev. apply $extThm_267 to Sec NEq $R. search.</div>
Theorem library-$-security-$-while_no_public_change : forall SG SL SG' Cond Body S G G2, ($ext__2__library-$-security-$-secure (SG) (SL) ((library-$-host-$-while) (Cond) (Body)) (SG')) -> ($ext__1__library-$-security-$-level (SG) (Cond) (S)) -> ((S = library-$-security-$-public) -> false) -> ($ext__1__library-$-host-$-eval_s (G) ((library-$-host-$-while) (Cond) (Body)) (G2)) -> library-$-security-$-public_equiv (SG) (G) (G2).<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(239);" id="toggleproof239">[Show Proof]</a>
<div class="proof" id="proof239" style="display: none;">
induction on 4.  intros Sec Lev NEq Ev.  Ev: case Ev.  EqG1G2: apply IH to Sec Lev NEq Ev2.  Sec: case Sec.  EqGG1: apply library-$-security-$-stmt_not_public_no_public_change to Sec2 _ Ev1.  intros Eq.  case Eq.  apply library-$-security-$-join_public to Sec1.  apply library-$-security-$-level_unique to Lev Sec.  backchain NEq.  apply library-$-security-$-public_equiv_trans to EqGG1 EqG1G2.  search.  backchain library-$-security-$-public_equiv_refl.  </div>

Theorem $extThm_266 : forall S SG SL SG1 GA GA' GB GB', ($ext__0__library-$-host-$-is_s (S)) -> ($ext__2__library-$-security-$-secure (SG) (SL) (S) (SG1)) -> (library-$-security-$-public_equiv (SG) (GA) (GB)) -> ($transRel__library-$-host-$-eval_s (GA) (S) (GA')) -> ($ext__1__library-$-host-$-eval_s (GB) (S) (GB')) -> library-$-security-$-public_equiv (SG1) (GA') (GB').<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(240);" id="toggleproof240">[Show Proof]</a>
<div class="proof" id="proof240" style="display: none;">
induction on 4. 
 intros Is Sec Rel EvA EvB. EvA: case EvA (keep).
  case EvB.   case Sec.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   search.  
  EvB: case EvB.   Sec: case Sec.   Is: case Is.   apply library-$-security-$-level_secure to _ _ Rel EvA1 EvB.   unfold .
 intros LkpSec LkpA.   LkpSec: case LkpSec.   LkpA: case LkpA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   search.   apply LkpA to _.   LkpA: case LkpA.   apply LkpSec to _.   Rel: case Rel.   apply Rel to LkpSec1 LkpA1.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   search.   intros LkpSec LkpB.   LkpSec: case LkpSec.   LkpB: case LkpB.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   search.   apply LkpB to _.   LkpB: case LkpB.   apply LkpSec to _.   Rel: case Rel.   apply Rel1 to LkpSec1 LkpB1.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   search.  
  EvB: case EvB.   Is: case Is.   Sec: case Sec.   unfold .
 intros LkpSec LkpA.   LkpA: case LkpA.   apply sterling-$-stdLib-$-lookup_unique to Sec1 LkpSec.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   assert (X = N) -> false.   intros E.   case E.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   backchain LkpA.   L: apply sterling-$-stdLib-$-lookup_after_select_before to LkpA1 EvA2 _.   R: case Rel.   LB: apply R to _ L.   apply sterling-$-stdLib-$-select_lookup to LB EvB1 _.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   search.   intros LkpSec LkpB.   LkpB: case LkpB.   apply sterling-$-stdLib-$-lookup_unique to Sec1 LkpSec.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   assert (X = N) -> false.   intros E.   case E.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   backchain LkpB.   L: apply sterling-$-stdLib-$-lookup_after_select_before to LkpB1 EvB1 _.   R: case Rel.   LA: apply R1 to _ L.   apply sterling-$-stdLib-$-select_lookup to LA EvA2 _.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   search.   apply library-$-security-$-level_secure to _ Sec Rel EvA1 EvB.   unfold .
 intros LkpSec LkpA.   LkpA: case LkpA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   search.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   assert (X = N) -> false.   intros E.   case E.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   backchain LkpA.   LGA: apply sterling-$-stdLib-$-lookup_after_select_before to LkpA1 EvA2 _.   R: case Rel.   LGB: apply R to LkpSec LGA.   apply sterling-$-stdLib-$-select_lookup to LGB EvB1 _.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   search.   intros LkpSec LkpB.   LkpB: case LkpB.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   search.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   assert (X = N) -> false.   intros E.   case E.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   backchain LkpB.   LGB: apply sterling-$-stdLib-$-lookup_after_select_before to LkpB1 EvB1 _.   R: case Rel.   LGA: apply R1 to LkpSec LGB.   apply sterling-$-stdLib-$-select_lookup to LGA EvA2 _.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   search.  
  EvB: case EvB.   Sec: case Sec.   Is: case Is.   apply IH to _ _ _ EvA1 EvB.   apply IH to _ _ _ EvA2 EvB1.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA1.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA2.   search.  
  Is: case Is.   Sec: case Sec.   EvB: case EvB.   EqGA'GB': apply IH to _ _ _ EvA2 EvB1.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA2.   LkpEq: assert forall X, ($fix__sterling-$-stdLib-$-lookup (SG1) (X) (library-$-security-$-public)) -> $fix__sterling-$-stdLib-$-lookup (SG2) (X) (library-$-security-$-public).   intros Lkp.   apply library-$-security-$-stmt_public_branch to Sec2 Lkp.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA2.   search.   apply library-$-security-$-public_equiv_swap to LkpEq EqGA'GB'.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA2.   search.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA2.   NEq: assert (L = library-$-security-$-public) -> false.   intros E.   case E.   apply library-$-security-$-level_not_public to Is _ Sec EvA1 EvB _.   $384: apply $dropT_$ext__1__library-$-host-$-eval_s to EvA2.   EqGAGA': apply library-$-security-$-stmt_not_public_no_public_change to Sec2 _ $384.   intros E.   case E.   apply library-$-security-$-join_public to Sec1.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA2.   backchain NEq.   EqGBGB': apply library-$-security-$-stmt_not_public_no_public_change to Sec3 _ EvB1.   intros E.   case E.   apply library-$-security-$-join_public to Sec1.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA2.   backchain NEq.   EqGAGB': apply library-$-security-$-public_equiv_trans to Rel EqGBGB'.   EqGA'GA: apply library-$-security-$-public_equiv_symm to EqGAGA'.   EqGA'GB: apply library-$-security-$-public_equiv_trans to EqGA'GA Rel.   apply library-$-security-$-public_equiv_trans to EqGA'GB EqGBGB'.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA2.   search.  
  Is: case Is.   Sec: case Sec.   EvB: case EvB.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA2.   NEq: assert (L = library-$-security-$-public) -> false.   intros E.   case E.   apply library-$-security-$-level_not_public to Is _ _ EvA1 EvB _.   $385: apply $dropT_$ext__1__library-$-host-$-eval_s to EvA2.   EqGAGA': apply library-$-security-$-stmt_not_public_no_public_change to Sec3 _ $385.   intros E.   case E.   apply library-$-security-$-join_public to Sec1.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA2.   backchain NEq.   EqGBGB': apply library-$-security-$-stmt_not_public_no_public_change to Sec2 _ EvB1.   intros E.   case E.   apply library-$-security-$-join_public to Sec1.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA2.   backchain NEq.   EqGAGB': apply library-$-security-$-public_equiv_trans to Rel EqGBGB'.   EqGA'GA: apply library-$-security-$-public_equiv_symm to EqGAGA'.   EqGA'GB: apply library-$-security-$-public_equiv_trans to EqGA'GA Rel.   apply library-$-security-$-public_equiv_trans to EqGA'GB EqGBGB'.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA2.   search.   EqGA'GB': apply IH to _ _ _ EvA2 EvB1.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA2.   LkpEq: assert forall X, ($fix__sterling-$-stdLib-$-lookup (SG1) (X) (library-$-security-$-public)) -> $fix__sterling-$-stdLib-$-lookup (SG3) (X) (library-$-security-$-public).   intros Lkp.   apply library-$-security-$-stmt_public_branch to Sec3 Lkp.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA2.   search.   apply library-$-security-$-public_equiv_swap to LkpEq EqGA'GB'.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA2.   search.  
  Is: case Is (keep).   Sec: case Sec (keep).   EvB: case EvB.   EqG1G3: apply IH to _ _ _ EvA2 EvB1.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA2.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA3.   LEq: assert forall X, ($fix__sterling-$-stdLib-$-lookup (SG1) (X) (library-$-security-$-public)) -> $fix__sterling-$-stdLib-$-lookup (SG2) (X) (library-$-security-$-public).   intros Lkp.   apply library-$-security-$-stmt_public_branch to Sec3 Lkp.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA2.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA3.   search.   apply library-$-security-$-public_equiv_swap to LEq EqG1G3.   EqG1GA': apply IH to Is Sec _ EvA3 EvB2.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA2.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA3.   search.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA2.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA3.   SNEq: assert (L = library-$-security-$-public) -> false.   intros E.   case E.   apply library-$-security-$-level_not_public to Is1 _ _ EvA1 EvB _.   $386: apply $dropT_$ext__1__library-$-host-$-eval_s to EvA2.   EqGAG1: apply library-$-security-$-stmt_not_public_no_public_change to Sec3 _ $386.   intros E.   case E.   apply library-$-security-$-join_public to Sec2.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA2.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA3.   backchain SNEq.   $387: apply $dropT_$ext__1__library-$-host-$-eval_s to EvA3.   EqG1GA': apply library-$-security-$-while_no_public_change to Sec Sec1 _ $387.   EqGAGA': apply library-$-security-$-public_equiv_trans to EqGAG1 EqG1GA'.   EqGA'GA: apply library-$-security-$-public_equiv_symm to EqGAGA'.   apply library-$-security-$-public_equiv_trans to EqGA'GA Rel.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA2.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA3.   search.  
  Is: case Is (keep).   Sec: case Sec (keep).   EvB: case EvB.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   SNEq: assert (L = library-$-security-$-public) -> false.   intros E.   case E.   apply library-$-security-$-level_not_public to Is1 _ _ EvA1 EvB _.   EqGBG2: apply library-$-security-$-stmt_not_public_no_public_change to Sec3 _ EvB1.   intros E.   case E.   apply library-$-security-$-join_public to Sec2.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   backchain SNEq.   EqGA'G2: apply library-$-security-$-public_equiv_trans to Rel EqGBG2.   EqG2GB': apply library-$-security-$-while_no_public_change to Sec Sec1 _ EvB2.   apply library-$-security-$-public_equiv_trans to EqGA'G2 EqG2GB'.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   search.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   search.  
  Sec: case Sec.   apply library-$-host-$-trans_s_unique to EvA2 Sec.   EvBTrans: apply library-$-host-$-trans_s_eval to EvA2 EvB.   IsCT: apply library-$-host-$-trans_s_is to Sec Is.   Equiv: apply IH to _ Sec1 Rel EvA1 EvBTrans.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA1.   LkpGB'G': assert forall X V, ($fix__sterling-$-stdLib-$-lookup (GB') (X) (V)) -> $fix__sterling-$-stdLib-$-lookup (G') (X) (V).   intros L.   apply library-$-host-$-trans_s_eval_results to EvA2 EvB EvBTrans L.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA1.   search.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA1.   EqG'GB': assert library-$-security-$-public_equiv (SG1) (G') (GB').   unfold .
 intros LkpSec LkpG'.   apply library-$-host-$-trans_s_eval_results_back to Sec EvB EvBTrans LkpG'.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA1.   search.   intros LkpSec LkpGB'.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA1.   backchain LkpGB'G'.   apply library-$-security-$-public_equiv_trans to Equiv EqG'GB'.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA1.   search.  
  EvB: case EvB.   Is: case Is.   Sec: case Sec.   unfold .
 intros LkpSec Lkp.   LkpSec: case LkpSec.   Lkp: case Lkp.   apply LkpSec to _.   Rel: case Rel.   apply Rel to LkpSec1 Lkp1.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA1.   search.   intros LkpSec Lkp.   LkpSec: case LkpSec.   Lkp: case Lkp.   apply LkpSec to _.   Rel: case Rel.   apply Rel1 to LkpSec1 Lkp1.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA1.   search.   apply library-$-security-$-level_secure to _ Sec Rel EvA3 EvB.   unfold .
 intros LkpSec Lkp.   LkpSec: case LkpSec.   Lkp: case Lkp.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA1.   search.   apply Lkp to _.   Lkp: case Lkp.   apply LkpSec to _.   Rel: case Rel.   apply Rel to LkpSec1 Lkp1.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA1.   search.   intros LkpSec Lkp.   LkpSec: case LkpSec.   Lkp: case Lkp.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA1.   search.   apply Lkp to _.   Lkp: case Lkp.   apply LkpSec to _.   Rel: case Rel.   apply Rel1 to LkpSec1 Lkp1.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA.   apply $dropT_$ext__1__library-$-host-$-eval_s to EvA1.   search.  </div>
Theorem library-$-security-$-stmt_secure : forall S SG SL SG1 GA GA' GB GB', ($ext__0__library-$-host-$-is_s (S)) -> ($ext__2__library-$-security-$-secure (SG) (SL) (S) (SG1)) -> (library-$-security-$-public_equiv (SG) (GA) (GB)) -> ($ext__1__library-$-host-$-eval_s (GA) (S) (GA')) -> ($ext__1__library-$-host-$-eval_s (GB) (S) (GB')) -> library-$-security-$-public_equiv (SG1) (GA') (GB').<span> </span><a class="fold-link" href="javascript:void" onclick="proofToggle(241);" id="toggleproof241">[Show Proof]</a>
<div class="proof" id="proof241" style="display: none;">
intros Is Sec Rel EvA EvB. $R: apply $extInd_$ext__1__library-$-host-$-eval_s to EvA. apply $extThm_266 to Is Sec Rel $R EvB. search.</div></pre>

  <p>
    We can verify the correctness of the modular proofs by checking
    the composed file:
  </p>
  <pre class="code">
abella out.thm</pre>
</div>
</body>
</html>
